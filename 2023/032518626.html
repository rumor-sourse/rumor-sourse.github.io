<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="GFS, charminghacker">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>GFS | charminghacker</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="charminghacker" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">charminghacker</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">charminghacker</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/rumor-sourse" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        <!-- 
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/rumor-sourse" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
         -->
    </nav>
     <!-- <div class="weather">
        
        <div id="tp-weather-widget"></div>
        <script>
            (function (a, h, g, f, e, d, c, b) { b = function () { d = h.createElement(g); c = h.getElementsByTagName(g)[0]; d.src = e; d.charset = "utf-8"; d.async = 1; c.parentNode.insertBefore(d, c) }; a["SeniverseWeatherWidgetObject"] = f; a[f] || (a[f] = function () { (a[f].q = a[f].q || []).push(arguments) }); a[f].l = +new Date(); if (a.attachEvent) { a.attachEvent("onload", b) } else { a.addEventListener("load", b, false) } }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
            window.SeniverseWeatherWidget('show', {
                flavor: "bubble",
                location: "WW92M43YCQG0",
                geolocation: true,
                language: "zh-Hans",
                unit: "c",
                theme: "auto",
                token: "2ee46d07-e99c-4227-925e-461574e6469c",
                hover: "enabled",
                container: "tp-weather-widget"
            })
        </script>
    </div>   -->
    
</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/20.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">GFS</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/GFS/">
                                <span class="chip bg-color">GFS</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/" class="post-category">
                                论文阅读
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-25
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-03-25
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    22.5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    78 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="1、GFS简介"><a href="#1、GFS简介" class="headerlink" title="1、GFS简介"></a>1、GFS简介</h1><p>Google文件系统(Google FIle Sysem)</p>
<p><strong>设计思路</strong></p>
<ol>
<li>组件失效被认为是常态事件，而不是意外事件。</li>
<li>以通常的标准衡量，我们的文件非常巨大。</li>
<li>绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</li>
<li>应用程序和文件系统API的协同设计提高了整个系统的灵活性。</li>
</ol>
<h1 id="2、设计概览"><a href="#2、设计概览" class="headerlink" title="2、设计概览"></a>2、设计概览</h1><h2 id="2-1、设计预期"><a href="#2-1、设计预期" class="headerlink" title="2.1、设计预期"></a>2.1、设计预期</h2><ol>
<li>系统由许多廉价的普通组件组成，组件失效是一种常态。</li>
<li>系统存储一定数量的大文件。</li>
<li>系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。</li>
<li>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。</li>
<li>系统必须高效的、行为定义明确的，实现多客户端并行追加数据到同一个文件里的语意。</li>
<li>高性能的稳定网络带宽远比低延迟重要。</li>
</ol>
<h2 id="2-2、接口"><a href="#2-2、接口" class="headerlink" title="2.2、接口"></a>2.2、接口</h2><p>GFS提供了一套类似传统文件系统的API接口函数，虽然并不是严格按照POSIX等标准API的形式实现的。</p>
<p>文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p>
<blockquote>
<p>POSIX：<em>可移植操作系统接口(Portable Operating System Interface)</em> 它是一个 IEEE 1003.1 标准，其定义了应用程序（以及命令行 Shell 和实用程序接口）和 UNIX 操作系统之间的语言接口。</p>
</blockquote>
<h2 id="2-3、架构"><a href="#2-3、架构" class="headerlink" title="2.3、架构"></a>2.3、架构</h2><p>​    一个GFS集群包含一个单独的<strong>Master节点</strong>（这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的<em>Master</em>组件。后面我们还会提到Master节点复制，因此，为了理解方便，我们把Master节点视为一个逻辑上的概念，一个逻辑的Master节点包括两台物理主机，即两台Master服务器）、多台<strong>Chunk服务器</strong>，并且同时被多个客户端访问。</p>
<p>​        GFS存储的文件都被分割成固定大小的<strong>Chunk</strong>。在Chunk创建的时候，Master服务器会给每个Chunk分配一个不变的、全球唯一的<strong>64位的Chunk标识</strong>。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据<strong>指定的Chunk标识和字节范围</strong>来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用<strong>3</strong>个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p>
<p>​        Master节点管理所有的文件系统<strong>元数据</strong>。这些元数据包括名字<strong>空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息</strong>。Master节点还管理着<strong>系统范围内的活动</strong>，比如，Chunk租用管理、孤儿Chunk的回收、以及Chunk在Chunk服务器之间的迁移。Master节点使用<strong>心跳信息</strong>周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p>
<p>​    GFS客户端代码以<strong>库</strong>的形式被链接到客户程序里。客户端代码实现了GFS文件系统的API接口函数、应用程序与Master节点和Chunk服务器通讯、以及对数据进行读写操作。客户端和Master节点的通信只获取<strong>元数据</strong>，所有的数据操作都是由客户端直接和Chunk服务器进行交互的。我们不提供POSIX标准的API的功能，因此，GFS API调用不需要深入到Linux vnode级别。</p>
<p>客户端和Chunk服务器都不需要缓存文件数据。</p>
<h2 id="2-4、单一Master节点"><a href="#2-4、单一Master节点" class="headerlink" title="2.4、单一Master节点"></a>2.4、单一Master节点</h2><p>单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。客户端并不通过Master节点读写文件数据。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241555591.png" alt="image-20230324155518538"></p>
<p>图1是简单读取的流程</p>
<ol>
<li>客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引</li>
<li>它把文件名和Chunk索引发送给Master节点。Master节点将相应的Chunk标识和副本的位置信息发还给客户端。客户端用文件名和Chunk索引作为key缓存这些信息。</li>
<li>后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了Chunk的标识和字节范围。</li>
</ol>
<blockquote>
<p>在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。</p>
</blockquote>
<h2 id="2-5、Chunk大小"><a href="#2-5、Chunk大小" class="headerlink" title="2.5、Chunk大小"></a>2.5、Chunk大小</h2><p>我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。</p>
<p><strong>优点</strong></p>
<ol>
<li>它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作</li>
<li>采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。</li>
<li>选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。</li>
</ol>
<h2 id="2-6、元数据"><a href="#2-6、元数据" class="headerlink" title="2.6、元数据"></a>2.6、元数据</h2><p>Master服务器存储3种主要类型的元数据，包括：<strong>文件和Chunk的命名空间、文件和Chunk的对应关系、每个Chunk副本的存放地点</strong>。</p>
<p>所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以<strong>记录变更日志</strong>的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被<strong>复制</strong>到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器<strong>轮询</strong>它们所存储的Chunk的信息。</p>
<h3 id="2-6-1、内存中的数据结构"><a href="#2-6-1、内存中的数据结构" class="headerlink" title="2.6.1、内存中的数据结构"></a>2.6.1、内存中的数据结构</h3><p>将元数据全部保存在内存中的方法有潜在问题：Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。</p>
<p>但是在实际应用中，这并不是一个严重的问题。</p>
<ul>
<li>Master服务器只需要不到64个字节的元数据就能够管理一个64MB的Chunk。由于大多数文件都包含多个Chunk，因此绝大多数Chunk都是满的，除了文件的最后一个Chunk是部分填充的。</li>
<li>同样的，每个文件的在命名空间中的数据大小通常在64字节以下，因为保存的文件名是用前缀压缩算法压缩过的。</li>
</ul>
<h3 id="2-6-2、Chunk位置信息"><a href="#2-6-2、Chunk位置信息" class="headerlink" title="2.6.2、Chunk位置信息"></a>2.6.2、Chunk位置信息</h3><p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。</p>
<p>这种设计简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步的问题。</p>
<h3 id="2-6-3、操作日志"><a href="#2-6-3、操作日志" class="headerlink" title="2.6.3、操作日志"></a>2.6.3、操作日志</h3><p>操作日志包含了<strong>关键的元数据变更历史记录</strong>。</p>
<p>操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线（通过逻辑日志的序号作为操作发生的逻辑时间）</p>
<p>我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。Master服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p>
<p>​    Master服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短Master启动的时间，我们必须使日志足够小（即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次<strong>Checkpoint</strong>(Checkpoint是一种行为，一种对数据库状态作一次快照的行为)，将所有的状态数据写入一个Checkpoint文件（并删除之前的日志文件）。在灾难恢复的时候，Master服务器就通过<strong>从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件</strong>就能够恢复系统。Checkpoint文件以压缩B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p>
<p>Master服务器使用独立的线程切换到新的日志文件和创建新的Checkpoint文件。</p>
<p>Master服务器恢复只需要最新的Checkpoint文件和后续的日志文件。旧的Checkpoint文件和日志文件可以被删除，但是为了应对灾难性的故障（<em>catastrophes</em>，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件），我们通常会多保存一些历史文件。</p>
<h2 id="2-7、一致性模型"><a href="#2-7、一致性模型" class="headerlink" title="2.7、一致性模型"></a>2.7、一致性模型</h2><p>宽松的一致性模型</p>
<h3 id="2-7-1、GFS一致性保障机制"><a href="#2-7-1、GFS一致性保障机制" class="headerlink" title="2.7.1、GFS一致性保障机制"></a>2.7.1、GFS一致性保障机制</h3><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由Master节点的控制：命名空间锁提供了原子性和正确性（4.1章）的保障；Master节点的操作日志定义了这些操作在全局的顺序（2.6.3章）。</p>
<p>数据修改后文件region（<em>region</em>这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）的状态取决于操作的类型、成功与否、以及是否同步修改。表1总结了各种操作的结果。</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241630130.png" alt="image-20230324163023055"></p>
<ul>
<li>如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件region是“<strong>一致的</strong>”</li>
<li>如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“<strong>已定义的</strong>”。</li>
</ul>
<p>当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的region就是<strong>已定义的</strong>（隐含了<strong>一致性</strong>）：所有的客户端都可以看到写入的内容。</p>
<p>并行修改操作成功完成之后，region处于<strong>一致的、未定义</strong>的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。</p>
<p>通常情况下，文件region内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个region处于不一致状态（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。</p>
<p>数据修改操作分为<strong>写入</strong>或者<strong>记录追加</strong>两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是<strong>偏移位置</strong>是由GFS选择的（3.3章）（这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由<em>GFS</em>自己计算）。（相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS返回给客户端一个偏移量，表示了包含了<strong>写入记录的、已定义的region的起点</strong>。另外，GFS可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件region被认定是不一致的，这些数据通常比用户数据小的多。</p>
<p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保上述行为：</p>
<p>（a） 对Chunk的所有副本的修改操作顺序一致（3.1章）</p>
<p>（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机（4.5章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。</p>
<p>​    即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS通过Master服务器和所有Chunk服务器的定期<strong>“握手”</strong>来找到失效的Chunk服务器，并且使用<strong>Checksum</strong>来校验数据是否损坏（5.2章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3章）。只有当一个Chunk的所有副本在GFS检测到错误并采取应对措施之前全部丢失，这个Chunk才会不可逆转的丢失。在一般情况下GFS的反应时间（指<em>Master</em>节点检测到错误并采取应对措施）是几分钟。即使在这种情况下，Chunk也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p>
<hr>
<h4 id="笔记1"><a href="#笔记1" class="headerlink" title="笔记1"></a>笔记1</h4><p><strong>串行Over-Write</strong></p>
<p>over-write由客户端指定文件更新offset。当客户端是串行更新时，客户端自己知道写入文件范围以及写入数据内容，且本次写入在数据服务器的多副本上均执行成功。因此，本次写结果对于客户端来说就是明确的，且多副本上数据一致，故而结果是defined。如下图：</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241745181.png" alt="image-20230324174551088"></p>
<p><strong>并行Over-Write</strong></p>
<p>并行写入时多个客户端由于写入范围可能交叉而形成交织写。这时候，由于单个客户端无法决定写入顺序（只有主副本才能决定谁先写谁后写），因此，即使写入成功，客户端仍无法确定在并发写入时交叉部分最终写入结果，但是因为写入成功，所以多副本数据必然一致。如下图：</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241746340.png" alt="image-20230324174611287"></p>
<p>图中红色部分代表并发追加的部分，这部分数据由于无法确定谁先谁后执行，因此结果不确定。但由于跟新成功，因此，副本间数据是一致的，这就是consistent but undefined。</p>
<p>无论是串行还是并行over-write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent。</p>
<p><strong>append</strong></p>
<p>客户端append操作无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端。因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。如下：</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241746215.png" alt="image-20230324174645164"></p>
<p><strong>append失败</strong></p>
<p>假设上面的append经历了一次重试，那可能实际chunk的布局如下：</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241747475.png" alt="image-20230324174705417"></p>
<p>由于第一次写失败（错误可能发生在任意一个副本），导致了多副本之间从50至80的数据可能不一致。但接下来重试成功，从80至110之间的数据一致，因此，其状态是interspersed with inconsistent。</p>
<h3 id="2-7-2、程序的实现"><a href="#2-7-2、程序的实现" class="headerlink" title="2.7.2、程序的实现"></a>2.7.2、程序的实现</h3><p>​    在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作Checkpoint，记录成功写入了多少数据。Checkpoint文件可以包含程序级别的校验和。Readers（即执行GFS读取的程序）仅校验并处理上个Checkpoint之后产生的文件region，这些文件region的状态一定是已定义的。</p>
<p>​    我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”的特性保证了Writer的输出。Readers使用下面的方法来处理偶然性的填充数据和重复内容。Writers在每条写入的记录中都包含了额外的信息，例如<strong>Checksum</strong>，用来验证它的有效性。Reader可以利用Checksum<strong>识别和抛弃额外的填充数据和记录片段</strong>。如果应用不能容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的<strong>唯一标识符</strong>来过滤它们，这些唯一标识符通常用于<strong>命名程序中处理的实体对象</strong>，例如web文档。这些记录I/O功能（These functionalities for record I/O）（除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于Google内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到Reader了。</p>
<h1 id="3、系统交互"><a href="#3、系统交互" class="headerlink" title="3、系统交互"></a>3、系统交互</h1><p>设计系统原则：<strong>最小化所有操作和Master节点的交互</strong></p>
<h2 id="3-1、租约及变更顺序"><a href="#3-1、租约及变更顺序" class="headerlink" title="3.1、租约及变更顺序"></a>3.1、租约及变更顺序</h2><p>​    变更是一个会改变Chunk内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在Chunk的所有副本上执行。我们使用租约（lease）机制来保持<strong>多个副本间变更顺序的一致性</strong>。Master节点为Chunk的一个副本建立一个租约，我们把这个副本叫做<strong>主Chunk</strong>。主Chunk对Chunk的所有更改操作进行<strong>序列化</strong>。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序<strong>首先由Master节点选择的租约的顺序决定，然后由租约中主Chunk分配的序列号决定。</strong></p>
<p>​    设计租约机制的目的是为了<strong>最小化Master节点的管理负担</strong>。租约的初始超时设置为60秒。不过，只要Chunk被修改了，主Chunk就可以申请<strong>更长的租期</strong>，通常会得到Master节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在Master节点和Chunk服务器之间的心跳消息中来传递。有时Master节点会试图<strong>提前取消租约</strong>（例如，Master节点想取消在一个已经被改名的文件上的修改操作）。即使Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。</p>
<p>图2：写入操作流程</p>
<img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251227081.png" alt="image-20230325122719920" style="zoom:67%;" />

<p><strong>step1</strong>：客户机向Master节点询问哪一个Chunk服务器持有当前的<strong>租约</strong>，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</p>
<p><strong>step2</strong>：Master节点将<strong>主Chunk的标识符以及其它副本</strong>（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</p>
<p><strong>step3</strong>： 客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的<strong>内部LRU缓存</strong>中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于<strong>网络拓扑情况</strong>对数据流进行规划，提高系统性能，而不用去理会哪个Chunk服务器保存了主Chunk。3.2章节会进一步讨论这点。</p>
<p><strong>step4</strong>: 当所有的副本都确认接收到了数据，客户机发送<strong>写请求</strong>到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所有操作分配<strong>连续的序列号</strong>，这些操作可能来自不同的客户机，<strong>序列号保证了操作顺序执行</strong>。它以序列号的顺序把操作应用到它自己的本地状态中（也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为<em>“</em>它顺序执行这些操作，并更新自己的状态”）。</p>
<p><strong>step5</strong>： 主Chunk把<strong>写请求</strong>传递到所有的<strong>二级副本</strong>。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</p>
<p><strong>step6</strong>： 所有的二级副本<strong>回复主Chunk</strong>，它们已经完成了操作。</p>
<p><strong>step7</strong>：主Chunk服务器（即主Chunk所在的Chunk服务器）<strong>回复</strong>客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</p>
<p>​    如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状态。</p>
<h4 id="笔记2"><a href="#笔记2" class="headerlink" title="笔记2"></a>笔记2</h4><ol>
<li>客户端向Master查询待写入的chunk的副本信息，</li>
<li>Master返回副本列表，第一项为主副本，即当前持有租约的副本；</li>
<li>客户端向多副本推送待写入数据，这里的推送是指将数据发送至chunk多副本，<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=chunkserver&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2228155582%22%7D">chunkserver</a>会缓存这些数据，此时数据并不落盘；</li>
<li>客户端向主副本发起Sync请求；</li>
<li>主副本将数据写入本地的同时通知其他副本将数据写入各自节点，此时数据方才落盘；</li>
<li>主副本等待所有从副本的sync响应；</li>
<li>主副本给客户端返回写入成功响应</li>
</ol>
<h2 id="3-2、数据流"><a href="#3-2、数据流" class="headerlink" title="3.2、数据流"></a>3.2、数据流</h2><p>​    为了提高网络效率，我们采取了把<strong>数据流和控制流</strong>分开的措施。在控制流从客户机到主Chunk、然后再到所有二级副本的同时，<strong>数据以管道的方式，顺序的沿着一个精心选择的Chunk服务器链推送</strong>。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p>
<p>​    为了充分利用每台机器的带宽，数据沿着一个Chunk服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，<strong>每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽</strong>。</p>
<p>​    为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch最有可能出现类似问题），<strong>每台机器都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据</strong>。假设客户机把数据从Chunk服务器S1推送到S4。它把数据推送到最近的Chunk服务器S1。S1把数据推送到S2，因为S2和S4中最接近的机器是S2。同样的，S2把数据传递给S3和S4之间更近的机器，依次类推推送下去。我们的网络拓扑非常简单，通过IP地址就可以计算出节点的“距离”。</p>
<p>​    最后，我们利用<strong>基于TCP连接的、管道式数据推送方式</strong>来最小化延迟。Chunk服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用<strong>全双工</strong>的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送B字节的数据到R个副本的理想时间是<strong>B/T+RL</strong> ，T是网络的吞吐量，L是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是100Mbps（T），L将远小于1ms。因此，1MB的数据在理想情况下80ms左右就能分发出去。</p>
<h2 id="3-3、原子的记录追加"><a href="#3-3、原子的记录追加" class="headerlink" title="3.3、原子的记录追加"></a>3.3、原子的记录追加</h2><p>​    GFS提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个region的并行写入操作不是串行的：region尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。<strong>GFS 会原子性至少一次在 GFS 选择的偏移量将数据写到文件中（比如，作为一个连续的字节序列）并将偏移位置返回给客户端</strong>。这类似于在Unix操作系统编程环境中，对以O_APPEND模式打开的文件，多个并发写操作在没有竞态条件时的行为。（<em>Unix文件系统中以O_APPEND模式调用write函数时，不会发生并发问题，文件指针在每一次调用时都会指向文件尾。在此处paper并未说明GFS具体是如何实现原子追加操作的。</em>）</p>
<p>​    记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的<strong>复杂、昂贵的同步机制</strong>，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列系统，或者是合并了来自多个客户机的数据的结果文件。</p>
<p>​    记录追加是一种修改操作，它也遵循3.1节描述的控制流程，除了在主Chunk有些额外的控制逻辑。客户机把数据推送给文件最后一个Chunk的所有副本，之后发送请求给主Chunk。主Chunk会检查这次记录追加操作是否会使Chunk超过最大尺寸（64MB）。如果超过了最大尺寸，主Chunk首先将当前Chunk填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个Chunk重新进行记录追加操作。（记录追加的数据大小严格控制在Chunk最大尺寸的1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）<strong>通常情况下追加的记录不超过Chunk的最大尺寸</strong>，主Chunk把数据追加到自己的副本内，然后通知二级副本把数据写在跟主Chunk一样的位置上，最后回复客户机操作成功。</p>
<p>​    如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个Chunk的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS并不保证Chunk的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到Chunk的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的Chunk上，即使其它的Chunk副本被Master节点选为了主Chunk。就我们的一致性保障模型而言，记录追加操作成功写入数据的region是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在2.7.2节讨论的，我们的程序可以处理不一致的区域。</p>
<h2 id="3-4、快照"><a href="#3-4、快照" class="headerlink" title="3.4、快照"></a>3.4、快照</h2><p>​    快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照迅速的<strong>创建一个巨大的数据集的分支拷贝</strong>（而且经常是递归的拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交或者回滚到备份时的状态。</p>
<p>​    就像AFS（<em>alex</em>注：<em>AFS</em>，即<em>Andrew File System</em>，一种分布式文件系统），我们用标准的<strong>copy-on-write技术</strong>实现快照。当Master节点收到一个快照请求，它首先取消作快照的文件的所有Chunk的租约。这个措施保证了后续对这些Chunk的写操作都必须与Master交互交互以找到租约持有者。这就给Master节点一个率先创建Chunk的新拷贝的机会。</p>
<p>​    租约取消或者过期之后，Master节点把这个操作以<strong>日志</strong>的方式记录到硬盘上。然后，Master节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的Chunk地址。</p>
<p>​    在快照操作之后，当客户机第一次想写入数据到Chunk C，它首先会发送一个请求到Master节点查询当前的租约持有者。Master节点注意到Chunke C的引用计数超过了1。Master节点不会马上回复客户机的请求，而是<strong>创建一个新名为C~的Chunk</strong>。之后，Master节点要求每个拥有Chunk C当前副本的Chunk服务器创建一个叫做C<del>的新Chunk。通过在源Chunk所在Chunk服务器上创建新的Chunk，我们确保<strong>数据在本地而不是通过网络复制</strong>（我们的硬盘比我们的100Mb以太网大约快3倍）。从这点来讲，请求的处理方式和任何其它Chunk没什么不同：Master节点确保新Chunk C</del>的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个Chunk，而不必理会它是从一个已存在的Chunk克隆出来的。</p>
<h4 id="笔记3"><a href="#笔记3" class="headerlink" title="笔记3"></a>笔记3</h4><p>COW原理是如果被Snapshot的文件有更新操作时，就将文件的要被更新的chunk复制一份，然后对复制的chunk进行更新，而原来的chunk作为快照数据被保留，以后要恢复到该快照时，直接将该chunk读出即可。</p>
<p>当GFS的Master节点收到Snapshot请求时：</p>
<ol>
<li>回收Snapshot请求覆盖的文件chunks上的租约，这样，接下来客户端要对文件修改时，就必须向Master申请，而此时master就可以对chunk进行复制；</li>
<li>Master在日志中记录本次Snapshot操作，然后在内存中执行Snapshot动作，具体是将被Snapshot的文件或目录的元数据复制一份，被复制出的文件与原始文件指向相同的chunk；</li>
<li>假如客户端申请更新被Snapshot的文件内容，那么找到需要更新的Chunk，向其多个副本发送拷贝命令，在其本地创建出Chunk的副本Chunk’，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；</li>
<li>客户端收到Master的响应后，表示该Chunk已经COW结束，接下来客户端的更新流程与正常的没有区别。</li>
</ol>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251720872.png" alt="image-20230325164122077"></p>
<h1 id="4、Matser节点的操作"><a href="#4、Matser节点的操作" class="headerlink" title="4、Matser节点的操作"></a>4、Matser节点的操作</h1><p>​    Master节点执行所有的名称空间操作。此外，它还管理着整个系统里所有Chunk的副本：它决定<strong>Chunk的存储位置</strong>，<strong>创建新Chunk</strong>和<strong>它的副本</strong>，协调各种各样的<strong>系统活动</strong>以保证Chunk被完全复制，在所有的Chunk服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述的主题。</p>
<h2 id="4-1、名称空间和锁"><a href="#4-1、名称空间和锁" class="headerlink" title="4.1、名称空间和锁"></a>4.1、名称空间和锁</h2><p>​    Master节点的很多操作会花费很长的时间：比如，快照操作必须取消Chunk服务器上快照所涉及的所有的Chunk的租约。我们不希望在这些操作的运行时，延缓了其它的Master节点的操作。因此，我们允许多个操作同时进行，使用名称空间的region上的锁来保证执行的正确顺序。</p>
<p>​    不同于许多传统文件系统，<strong>GFS没有针对每个目录实现能够列出目录下所有文件的数据结构</strong>。GFS也<strong>不支持文件或者目录的链接</strong>（Unix术语中的硬链接或者符号链接）。在逻辑上，GFS的名称空间就是一个<strong>全路径和元数据映射关系的查找表</strong>。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的<strong>读写锁</strong>。</p>
<p>​    每个Master节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/…/dn/leaf，那么操作首先要获得目录/d1，/d1/d2，…，/d1/d2/…/dn的读锁，以及/d1/d2/…/dn/leaf的读写锁。注意，根据操作的不同，leaf可以是一个文件，也可以是一个目录。</p>
<p>​    现在，我们演示一下在/home/user被快照到/save/user的时候，锁机制如何防止创建文件/home/user/foo。<strong>快照操作</strong>获取/home和/save的读取锁，以及/home/user和/save/user的写入锁。<strong>文件创建操作</strong>获得/home和/home/user的读取锁，以及/home/user/foo的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有”目录”，或者类似inode等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p>
<p>​    采用这种锁方案的优点是<strong>支持对同一目录的并行操作。</strong>比如，可以再同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的读取锁足以的防止目录被删除、改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。</p>
<p>​    因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p>
<h2 id="4-2、副本的位置"><a href="#4-2、副本的位置" class="headerlink" title="4.2、副本的位置"></a>4.2、副本的位置</h2><p>​    GFS集群是<strong>高度分布的多层布局结构</strong>，而不是平面结构。典型的拓扑结构是<strong>有数百个Chunk服务器安装在许多机架上</strong>。<strong>Chunk服务器被来自同一或者不同机架上的数百个客户机轮流访问</strong>。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p>
<p>​    Chunk副本位置选择的策略服务两大目标：<strong>最大化数据可靠性和可用性，最大化网络带宽利用率</strong>。为了实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在<strong>多个机架间分布储存Chunk的副本</strong>。这保证Chunk的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网络流量方面，尤其是针对Chunk的读操作，能够有效利用多个机架的整合带宽。另一方面，<strong>写操作必须和多个机架上的设备进行网络通信</strong>，但是这个代价是我们愿意付出的。</p>
<h2 id="4-3、创建、重新复制、重新负载均衡"><a href="#4-3、创建、重新复制、重新负载均衡" class="headerlink" title="4.3、创建、重新复制、重新负载均衡"></a>4.3、创建、重新复制、重新负载均衡</h2><p>Chunk的副本有三个用途：<strong>Chunk创建，重新复制和重新负载均衡</strong>。</p>
<p>​    当Master节点创建一个Chunk时，它会选择在哪里放置初始的空的副本。Master节点会考虑几个因素。（1）<strong>我们希望在低于平均硬盘使用率的Chunk服务器上存储新的副本。</strong>这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。（2）<strong>我们希望限制在每个Chunk服务器上”最近”的Chunk创建操作的次数。</strong>虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为Chunk在Writer真正写入数据的时候才被创建，而在我们的”追加一次，读取多次”的工作模式下，Chunk一旦写入成功之后就会变为只读的了。（3）如上所述，<strong>我们希望把Chunk的副本分布在多个机架之间。</strong></p>
<p>​    当Chunk的有效副本数量少于用户指定的复制因数的时候，Master节点会重新复制它。这可能是由几个原因引起的：<strong>一个Chunk服务器不可用了</strong>，Chunk服务器报告它所存储的一个副本损坏了，Chunk服务器的一个磁盘因为错误不可用了，或者Chunk副本的复制因数提高了。每个需要被重新复制的Chunk都会根据<strong>几个因素进行排序</strong>。一个因素是<strong>Chunk现有副本数量和复制因数相差多少</strong>。例如，丢失两个副本的Chunk比丢失一个副本的Chunk有更高的优先级。另外，我们<strong>优先重新复制活跃（live）文件的Chunk</strong>而不是最近刚被删除的文件的Chunk（查看4.4节）。最后，为了最小化失效的Chunk对正在运行的应用程序的影响，我们提高会阻塞客户机程序处理流程的Chunk的优先级。</p>
<p>​    Master节点选择<strong>优先级最高的Chunk</strong>，然后命令某个Chunk服务器直接从可用的副本”克隆”一个副本出来。选择新副本的位置的策略和创建时类似：<strong>平衡硬盘使用率、限制同一台Chunk服务器上的正在进行的克隆操作的数量、在机架间分布副本</strong>。为了防止克隆产生的网络流量大大超过客户机的流量，Master节点对整个集群和每个Chunk服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk服务器通过调节它对源Chunk服务器读请求的频率来限制它用于克隆操作的带宽。</p>
<p>​    最后，Master服务器周期性地对副本进行重新负载均衡：<strong>它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载均衡。</strong>而且在这个过程中，Master服务器逐渐的填满一个新的Chunk服务器，而不是在短时间内用新的Chunk填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相同。另外，Master节点必须选择哪个副本要被移走。通常情况，Master节点移走那些剩余空间低于平均值的Chunk服务器上的副本，从而平衡系统整体的硬盘使用率。</p>
<h4 id="笔记4"><a href="#笔记4" class="headerlink" title="笔记4"></a>笔记4</h4><p>创建chunk时副本位置的选择算法：</p>
<ol>
<li>选择存储空间利用率最低的节点和磁盘；</li>
<li>选择最近一段时间内新建chunk数量较少的节点和磁盘；</li>
<li>将多个副本分散在不同的rack上。</li>
</ol>
<h2 id="4-4、垃圾回收"><a href="#4-4、垃圾回收" class="headerlink" title="4.4、垃圾回收"></a>4.4、垃圾回收</h2><p>GFS在文件删除后不会立刻回收可用的物理空间。GFS空间回收采用惰性的策略，只在文件和Chunk级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p>
<h3 id="4-4-1、机制"><a href="#4-4-1、机制" class="headerlink" title="4.4.1、机制"></a>4.4.1、机制</h3><p>​    当一个文件被应用程序删除时，Master节点像对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master节点并不马上回收资源，而是把文件名改为一<strong>个包含删除时间戳的、隐藏的名字</strong>。当Master节点对文件系统命名空间做常规扫描的时候，它会<strong>删除所有三天前的隐藏文件</strong>（这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。<strong>当隐藏文件被从名称空间中删除，Master服务器内存中保存的这个文件的相关元数据才会被删除</strong>。这也有效的切断了文件和它包含的所有Chunk的连接。</p>
<p>​    在对Chunk名字空间做类似的常规扫描时，Master节点找到<strong>孤儿Chunk（不被任何文件包含的Chunk）并删除它们的元数据</strong>。Chunk服务器在和Master节点交互的心跳信息中，报告它拥有的Chunk子集的信息，Master节点回复Chunk服务器哪些Chunk在Master节点保存的元数据中已经不存在了。Chunk服务器可以任意删除这些Chunk的副本。</p>
<h3 id="4-4-2、讨论"><a href="#4-4-2、讨论" class="headerlink" title="4.4.2、讨论"></a>4.4.2、讨论</h3><p>​    虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在GFS系统中是非常简单的。<strong>我们可以轻易的得到Chunk的所有引用：它们都只存储在Master服务器上的文件到块的映射表中。我们也可以很轻易的得到所有Chunk的副本：它们都以Linux文件的形式存储在Chunk服务器的指定目录下</strong>。所有Master节点不能识别的副本都是”垃圾”。</p>
<p>​    垃圾回收在空间回收方面相比直接删除有几个优势。<strong>首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。</strong>Chunk可能在某些Chunk服务器创建成功，某些Chunk服务器上创建失败，失败的副本处于无法被Master节点识别的状态。副本删除消息可能丢失，Master节点必须重新发送失败的删除消息，包括自身的和Chunk服务器的（自身的指删除<em>metadata</em>的消息）。垃圾回收提供了一致的、可靠的清除无用副本的方法。<strong>第二，垃圾回收把存储空间的回收操作合并到Master节点规律性的后台活动中</strong>，比如，例行扫描和与Chunk服务器握手等。因此，操作被批量的执行，开销会被分散。<strong>另外，垃圾回收在Master节点相对空闲的时候完成。</strong>这样Master节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。<strong>第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</strong></p>
<p>​    根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p>
<h2 id="4-5、过期失效的副本检测"><a href="#4-5、过期失效的副本检测" class="headerlink" title="4.5、过期失效的副本检测"></a>4.5、过期失效的副本检测</h2><p>​    当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了<strong>每个Chunk的版本号</strong>，用来区分当前的副本和过期副本。</p>
<p>​    无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。Master节点和这些副本都把新的版本号记录在它们<strong>持久化存储的状态信息</strong>中。这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。<strong>Master节点在这个Chunk服务器重新启动，并且向Master节点报告它拥有的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk</strong>。如果Master节点看到一个比它记录的版本号更高的版本号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择<strong>更高的版本号作为当前的版本号。</strong></p>
<p>​    Master节点在例行的垃圾回收过程中<strong>移除所有的过期失效副本</strong>。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p>
<h1 id="5、容错和诊断"><a href="#5、容错和诊断" class="headerlink" title="5、容错和诊断"></a>5、容错和诊断</h1><p>​    我们在设计GFS时遇到的最大挑战之一是<strong>如何处理频繁发生的组件失效</strong>。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率：我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这些挑战，以及当组件失效不可避免的发生时，用GFS自带工具诊断系统故障。</p>
<h2 id="5-1、高可用性"><a href="#5-1、高可用性" class="headerlink" title="5.1、高可用性"></a>5.1、高可用性</h2><p>在GFS集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：<strong>快速恢复和复制。</strong></p>
<h3 id="5-1-1、快速复制"><a href="#5-1-1、快速复制" class="headerlink" title="5.1.1、快速复制"></a>5.1.1、快速复制</h3><p>​    ‘不管Master服务器和Chunk服务器是如何关闭的，它们都被设计为<strong>可以在数秒钟内恢复它们的状态并重新启动</strong>。事实上，我们并<strong>不区分正常关闭和异常关闭</strong>；通常，我们通过直接kill掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸*(*a minor hiccup)，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。6.6.2章节记录了实测的启动时间。</p>
<h3 id="5-1-2、Chunk复制"><a href="#5-1-2、Chunk复制" class="headerlink" title="5.1.2、Chunk复制"></a>5.1.2、Chunk复制</h3><p>​    正如之前讨论的，每个Chunk都被复制到不同机架上的不同的Chunk服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是3。当有Chunk服务器离线了，或者通过Checksum校验（参考5.2节）发现了已经损坏的数据，<strong>Master节点通过克隆已有的副本保证每个Chunk都被完整复制</strong>（即每个<em>Chunk</em>都有复制因子制定的个数个副本，缺省是<em>3</em>）。虽然Chunk复制策略对我们非常有效，但是我们也在寻找其<strong>它形式的跨服务器的冗余解决方案</strong>，比如使用奇偶校验、或者Erasure codes（<em>Erasure codes</em>用来解决链接层中不相关的错误，以及网络拥塞和<em>buffffer</em>限制造成的丢包错误）来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追<strong>加方式的写入和读取操作</strong>，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p>
<h3 id="5-1-3、Matser服务器的复制"><a href="#5-1-3、Matser服务器的复制" class="headerlink" title="5.1.3、Matser服务器的复制"></a>5.1.3、Matser服务器的复制</h3><p>​    为了保证Master服务器的可靠性，Master服务器的状态也要复制。Master服务器所有的操作日志和checkpoint文件都被复制到多台机器上。对Master服务器状态的修改操作能够提交成功的前提是，<strong>操作日志写入到Master服务器的备节点和本机的磁盘</strong>。简单说来，一个Master服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果Master进程所在的机器或者磁盘失效了，<strong>处于GFS系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的Master进程。</strong>客户端使用规范的名字访问Master（比如gfs-test）节点，这个名字类似DNS别名，因此也就可以在Master进程转到别的机器上执行时，通过更改别名的实际指向访问新的Master节点。</p>
<p>​    此外，GFS中还有些“影子”Master服务器，这些“影子”服务器在“主”Master服务器宕机的时候提供文件系统的<strong>只读访问</strong>。它们是影子，而不是镜像，所以<strong>它们的数据可能比“主”Master服务器更新要慢</strong>，通常是不到1秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子”Master服务器能够提高读取的效率。事实上，因为文件内容是从Chunk服务器上读取的，因此，应用程序不会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p>
<p>​    “影子”Master服务器为了保持自身状态是最新的，它会<strong>读取一份当前正在进行的操作的日志副本</strong>，并且<strong>依照和主Master服务器完全相同的顺序来更改内部的数据结构</strong>。和主Master服务器一样，“影子”Master服务器在启动的时候也会从Chunk服务器轮询数据（之后定期拉数据），数据中包括了Chunk副本的位置信息；“影子”Master服务器也会定期和Chunk服务器“握手”来确定它们的状态。<strong>在主Master服务器因创建和删除副本导致副本位置信息更新时，“影子”Master服务器才和主Master服务器通信来更新自身状态。</strong></p>
<h2 id="5-2、数据完整性"><a href="#5-2、数据完整性" class="headerlink" title="5.2、数据完整性"></a>5.2、数据完整性</h2><p>​    每个Chunk服务器都使用Checksum来检查保存的数据是否损坏。考虑到一个GFS集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的（第7节讲了一个原因）。我们可以通过别的Chunk副本来解决数据损坏问题，但是跨越Chunk服务器比较副本来检查数据是否损坏很不实际。另外，GFS允许有歧义的副本存在：<strong>GFS修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同</strong>(副本不是<em>byte-wise</em>完全一致的)。因此，每个Chunk服务器必须独立维护Checksum来校验自己的副本的完整性。</p>
<p>​    我们把每个Chunk都分成64KB大小的块。每个块都对应一个32位的Checksum。和其它元数据一样，Checksum与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p>
<p>​    对于读操作来说，在把数据返回给客户端或者其它的Chunk服务器之前，Chunk服务器会校验<strong>读取操作涉及的范围内的块的Checksum</strong>。因此Chunk服务器不会把错误数据传递到其它的机器上。如果发生某个块的Checksum不正确，<strong>Chunk服务器返回给请求者一个错误信息，并且通知Master服务器这个错误</strong>。作为回应，请求者应当从其它副本读取数据，Master服务器也会从其它副本克隆数据进行恢复。<strong>当一个新的副本就绪后，Master服务器通知副本错误的Chunk服务器删掉错误的副本</strong>。</p>
<p>​    Checksum对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS客户端代码通过每次把读取操作都对齐在Checksum block的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在Chunk服务器上，<strong>Checksum的查找和比较不需要I/O操作，Checksum的计算可以和I/O操作同时进行</strong>。</p>
<p>​    Checksum的计算针对在Chunk尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了很大比例。<strong>我们只增量更新最后一个不完整的块的Checksum，并且用所有的追加来的新Checksum块来计算新的Checksum</strong>。即使是最后一个不完整的Checksum块已经损坏了，而且我们不能够马上检查出来，由于新的Checksum和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。</p>
<p>​    相比之下，如果写操作覆盖已经存在的一个范围内的Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重新计算和写入新的Checksum。<strong>如果我们不校验第一个和最后一个被写的块，那么新的Checksum可能会隐藏没有被覆盖区域内的数据错误</strong>。</p>
<p>​    在Chunk服务器空闲的时候，它会<strong>扫描和校验每个不活动的Chunk的内容</strong>。这使得我们能够发现很少被读取的Chunk是否完整。一旦发现有Chunk的数据损坏，Master可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的Chunk欺骗Master节点，使Master节点认为它们已经有了足够多的副本了。</p>
<h2 id="5-3、诊断工具"><a href="#5-3、诊断工具" class="headerlink" title="5.3、诊断工具"></a>5.3、诊断工具</h2><p>​    详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。<strong>GFS的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk服务器启动和关闭）以及所有的RPC的请求和回复</strong>。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p>
<p>​    <strong>RPC日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据</strong>。通过匹配请求与回应，以及收集不同机器上的RPC日志记录，我们可以重演所有的消息交互来诊断问题。<strong>日志还用来跟踪负载测试和性能分析</strong>。</p>
<p>​    日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p>
<h1 id="6、度量"><a href="#6、度量" class="headerlink" title="6、度量"></a>6、度量</h1><p>本节中，我们将使用一些小规模基准测试来展现GFS系统架构和实现上的一些固有瓶颈，还有些来自Google内部使用的真实的GFS集群的基准数据。</p>
<h2 id="6-1、小规模基准测试"><a href="#6-1、小规模基准测试" class="headerlink" title="6.1、小规模基准测试"></a>6.1、小规模基准测试</h2><p>​    我们在一个包含1台Master服务器，2台Master服务器复制节点，16台Chunk服务器和16个客户机组成的GFS集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的GFS集群有数百个Chunk服务器和数百个客户机。</p>
<p>​    所有机器的配置都一样：两个PIII 1.4GHz处理器，2GB内存，两个80G/5400rpm的硬盘，以及100Mbps全双工以太网连接到一个HP2524交换机。GFS集群中所有的19台服务器都连接在一个交换机，所有16台客户机连接到另一个交换机上。两个交换机之间使用1Gbps的线路连接。</p>
<h3 id="6-1-1、读取"><a href="#6-1-1、读取" class="headerlink" title="6.1.1、读取"></a>6.1.1、读取</h3><p>​    N个客户机从GFS文件系统同步读取数据。每个客户机从320GB的文件集合中随机读取4MB region的内容。读取操作重复执行256次，因此，每个客户机最终都读取1GB的数据。所有的Chunk服务器加起来总共只有32GB的内存，因此，我们预期只有最多10%的读取请求命中Linux的文件系统缓冲。我们的测试结果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。</p>
<p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251720898.png" alt="image-20230325171652772"></p>
<p>图3（a）显示了N个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的1Gbps的链路饱和时，整体读取速度达到理论的极限值是125MB/S，或者说每个客户机配置的100Mbps网卡达到饱和时，每个客户机读取速度的理论极限值是12.5MB/s。实测结果是，当一个客户机读取的时候，读取的速度是10MB/s，也就是说达到客户机理论读取速度极限值的80%。对于16个客户机，整体的读取速度达到了94MB/s，大约是理论整体读取速度极限值的75%，也就是说每个客户机的读取速度是6MB/s。读取效率从80%降低到了75%，主要的原因是当读取的客户机增加时，多个客户机同时读取一个Chunk服务器的几率也增加了，导致整体的读取效率下降。</p>
<h3 id="6-1-2、写入"><a href="#6-1-2、写入" class="headerlink" title="6.1.2、写入"></a>6.1.2、写入</h3><p>​    N个客户机同时向N个不同的文件中写入数据。每个客户机以每次1MB的速度连续写入1GB的数据。图3（b）显示了整体的写入速度和它们理论上的极限值。理论上的极限值是67MB/s，因为我们需要把每一byte写入到16个Chunk服务器中的3个上，而每个Chunk服务器的输入连接速度是12.5MB/s。</p>
<p>​    一个客户机的写入速度是6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协议栈。它与我们推送数据到Chunk服务器时采用的管道模式不相适应。<strong>从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。</strong></p>
<p>​    16个客户机整体的写入速度达到了35MB/s（即每个客户机2.2MB/s），大约只是理论极限值的一半。和多个客户机读取的情形很类型，随着客户机数量的增加，多个客户机同时写入同一个Chunk服务器的几率也增加了。而且，16个客户机并行写入可能引起的冲突比16个客户机并行读取要大得多，因为每个写入都会涉及三个不同的副本。</p>
<p>​    写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响</p>
<h3 id="6-1-3、记录追加"><a href="#6-1-3、记录追加" class="headerlink" title="6.1.3、记录追加"></a>6.1.3、记录追加</h3><p>​    图3（c）显示了记录追加操作的性能。N个客户机同时追加数据到一个文件。记录追加操作的性能受限于保存文件最后一个Chunk的Chunk服务器的带宽，而与客户机的数量无关。记录追加的速度由一个客户机的6.0MB/s开始，下降到16个客户机的4.8MB/s为止，速度的下降主要是由于不同客户端的网络拥塞以及网络传输速度的不同而导致的。</p>
<p>​    我们的程序倾向于同时处理多个这样的文件。换句话说，即N个客户机同时追加数据到M个共享文件中，这里N和M都是数十或者数百以上。所以，在我们的实际应用中，Chunk服务器的网络拥塞并没有成为一个严重问题，如果Chunk服务器的某个文件正在写入，客户机会去写另外一个文件。</p>
<h2 id="6-2、实际应用中的集群"><a href="#6-2、实际应用中的集群" class="headerlink" title="6.2、实际应用中的集群"></a>6.2、实际应用中的集群</h2><p>​    我们现在来仔细评估一下Google内部正在使用的两个集群，它们具有一定的代表性。集群A通常被上百个工程师用于研究和开发。典<strong>型的任务是被人工初始化后连续运行数个小时。它通常读取数MB到数TB的数据，之后进行转化或者分析，最后把结果写回到集群中</strong>。<strong>集群B主要用于处理当前的生产数据</strong>。集群B的任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数TB的数据集。在这两个案例中，一个单独的”任务”都是指运行在多个机器上的多个进程，它们同时读取和写入多个文件。</p>
<img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251721795.png" alt="image-20230325172121663" style="zoom:67%;" />

<h3 id="6-2-1、存储"><a href="#6-2-1、存储" class="headerlink" title="6.2.1、存储"></a>6.2.1、存储</h3><p>​    如上表前五行所描述的，两个集群都由上百台Chunk服务器组成，支持数TB的硬盘空间；两个集群虽然都存储了大量的数据，但是还有剩余的空间。“已用空间”包含了所有的Chunk副本。实际上所有的文件都复制了三份。因此，集群实际上各存储了18TB和52TB的文件数据。</p>
<p>​    两个集群存储的文件数量都差不多，但是集群B上有大量的死文件。所谓“死文件”是指文件被删除了或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群B存储的文件较大，因此它的Chunk数量也比较多。</p>
<h3 id="6-2-2、元数据"><a href="#6-2-2、元数据" class="headerlink" title="6.2.2、元数据"></a>6.2.2、元数据</h3><p>​    Chunk服务器总共保存了十几GB的元数据，大多数是来自用户数据的、64KB大小的块的Checksum。保存在Chunk服务器上其它的元数据是Chunk的版本号信息，我们在4.5节描述过。</p>
<p>​    在Master服务器上保存的元数据就小的多了，大约只有数十MB，或者说平均每个文件100字节的元数据。这和我们设想的是一样的，Master服务器的内存大小在实际应用中并不会成为GFS系统容量的瓶颈。大多数文件的元数据都是以<strong>前缀压缩模式</strong>存放的文件名。Master服务器上存放的<strong>其它元数据包括了文件的所有者和权限、文件到Chunk的映射关系，以及每一个Chunk的当前版本号。</strong>此外，针对每一个Chunk，我们都保存<strong>了当前的副本位置以及对它的引用计数</strong>，这个引用计数用于实现<strong>写时拷贝</strong>（即<em>COW</em>，<em>copy-on-write</em>）。</p>
<p>​    对于每一个单独的服务器，无论是Chunk服务器还是Master服务器，都只保存了50MB到100MB的元数据。因此，恢复服务器是非常快速的：在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这些数据就可以了。不过，Master服务器会持续颠簸一段时间–通常是30到60秒–直到它完成轮询所有的Chunk服务器，并获取到所有Chunk的位置信息。</p>
<h3 id="6-2-3、读写速率"><a href="#6-2-3、读写速率" class="headerlink" title="6.2.3、读写速率"></a>6.2.3、读写速率</h3><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251735340.png" alt="image-20230325173508199" style="zoom:67%;" />

<p>​    表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。（这两个集群最近都因为升级新版本的GFS重新启动过了）。</p>
<p>​    集群重新启动后，平均写入速率小于30MB/s。当我们提取性能数据的时候，集群B正进行大量的写入操作，写入速度达到了100MB/s，并且因为每个Chunk都有三个副本的原因，网络负载达到了300MB/s。<strong>读取速率要比写入速率高的多</strong>。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比例。两个集群都进行着繁重的读取操作。特别是，集群A在一周时间内都维持了580MB/s的读取速度。集群A的网络配置可以支持750MB/s的速度，显然，它有效的利用了资源。集群B支持的峰值读取速度是1300MB/s，但是它的应用只用到了380MB/s。</p>
<h3 id="6-2-4、Master服务器的负载"><a href="#6-2-4、Master服务器的负载" class="headerlink" title="6.2.4、Master服务器的负载"></a>6.2.4、Master服务器的负载</h3><p>​    表3的数据显示了发送到Master服务器的操作请求大概是每秒钟200到500个。Master服务器可以轻松的应付这个请求速度，所以Master服务器的处理能力不是系统的瓶颈。</p>
<p>​    在早期版本的GFS中，Master服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录（包含数万个文件）去查找某个特定的文件。因此我们修改了Master服务器的数据结构，<strong>通过对名字空间进行二分查找来提高效率。</strong>现在Master服务器可以轻松的每秒钟进行数千次文件访问。如果有需要的话，<strong>我们可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。</strong></p>
<h3 id="6-2-5、恢复时间"><a href="#6-2-5、恢复时间" class="headerlink" title="6.2.5、恢复时间"></a>6.2.5、恢复时间</h3><p>​    <strong>当某个Chunk服务器失效了，一些Chunk副本的数量可能会低于复制因子指定的数量，我们必须通过克隆副本使Chunk副本数量达到复制因子指定的数量。</strong>恢复所有Chunk副本所花费的时间取决于资源的数量。在我们的试验中，我们把集群B上的一个Chunk服务器Kill掉。这个Chunk服务器上大约有15000个Chunk，共计600GB的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为GFS调度决策提供修正空间，我们缺省的把集群中并发克隆操作的数量设置为91个（Chunk服务器的数量的40%），每个克隆操作最多允许使用的带宽是6.25MB/s（50mbps）。所有的Chunk在23.2分钟内恢复了，复制的速度高达440MB/s。</p>
<p>​    在另外一个测试中，我们Kill掉了两个Chunk服务器，每个Chunk服务器大约有16000个Chunk，共计660GB的数据。这两个故障导致了266个Chunk只有单个副本。这266个Chunk被GFS优先调度进行复制，在2分钟内恢复到至少有两个副本；现在集群被带入到另外一个状态，在这个状态下，系统可以容忍另外一个Chunk服务器失效而不丢失数据。</p>
<h2 id="6-3、工作负荷分析"><a href="#6-3、工作负荷分析" class="headerlink" title="6.3、工作负荷分析"></a>6.3、工作负荷分析</h2><p>本节中，我们展示了对两个GFS集群工作负载情况的详细分析，这两个集群和6.2节中的类似，但是不完全相同。集群X用于研究和开发，集群Y用于生产数据处理。</p>
<h3 id="6-3-1、方法论和注意事项"><a href="#6-3-1、方法论和注意事项" class="headerlink" title="6.3.1、方法论和注意事项"></a>6.3.1、方法论和注意事项</h3><p>​    本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对GFS文件系统产生的全部工作负载。它们不包含那些为了实现客户端请求而在服务器间交互的请求，也不包含GFS内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。</p>
<p>​    <strong>我们从GFS服务器记录的真实的RPC请求日志中推导重建出关于IO操作的统计信息</strong>。例如，GFS客户程序可能会把一个读操作分成几个RPC请求来提高并行度，我们可以通过这些RPC请求推导出原始的读操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差<em>（</em>Since our*access patterns are highly stylized, we expect any error to be in the noise)*。应用程序如果能够记录更详尽的日志，就有可能提供更准确的诊断数据；但是为了这个目的去重新编译和重新启动数千个正在运行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。</p>
<p>​    <strong>应该避免从我们的工作负荷数据中过度的归纳出普遍的结论</strong><em>(alex</em>注：即不要把本节的数据作为基础的指导性数据*)*。因为Google完全控制着GFS和使用GFS的应用程序，所以，应用程序都针对GFS做了优化，同时，GFS也是为了这些应用程序而设计的。这样的相互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。</p>
<h3 id="6-3-2、Chunk服务器工作负荷"><a href="#6-3-2、Chunk服务器工作负荷" class="headerlink" title="6.3.2、Chunk服务器工作负荷"></a>6.3.2、Chunk服务器工作负荷</h3><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251748703.png" alt="image-20230325174828561" style="zoom:67%;" />

<p>​    表4显示了操作按涉及的数据量大小的分布情况。<strong>读取操作按操作涉及的数据量大小呈现了双峰分布</strong>。小的读取操作（小于64KB）一般是由查找操作的客户端发起的，目的在于<strong>从巨大的文件中查找小块的数据</strong>。大的读取操作（大于512KB）一般是<strong>从头到尾顺序的读取整个文件。</strong></p>
<p>​    在集群Y上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常使用文件作为生产者-消费者队列。生产者并行的向文件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群X通常用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群X很少出现这种情况。</p>
<p>​    写操作按数据量大小也同样呈现为<strong>双峰分布</strong>。大的写操作（超过256KB）通常是由于Writer使用了缓存机制导致的。Writer缓存较小的数据，通过频繁的Checkpoint或者同步操作，或者只是简单的统计小的写入（小于64KB）的数据量*(即汇集多次小的写入操作，当数据量达到一个阈值，一次写入*)，之后批量写入。</p>
<p>​    再来观察一下记录追加操作。<strong>我们可以看到集群Y中大的记录追加操作所占比例比集群X多的多，这是因为集群Y用于我们的生产系统，针对GFS做了更全面的调优。</strong></p>
<img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251751230.png" alt="image-20230325175154096" style="zoom:67%;" />

<p>表5显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作（超过256KB）占据了主要的传输量。小的读取（小于64KB）虽然传输的数据量比较少，但是在读取的数据量中仍占了相当的比例，这是因为在文件中<strong>随机Seek的工作负荷而导致的</strong>。</p>
<h3 id="6-3-3、记录追加vs写操作"><a href="#6-3-3、记录追加vs写操作" class="headerlink" title="6.3.3、记录追加vs写操作"></a>6.3.3、记录追加vs写操作</h3><p>​    记录追加操作在我们的生产系统中大量使用。对于集群X，记录追加操作和普通写操作的比例按照字节比是108:1，按照操作次数比是8:1。对于作为我们的生产系统的集群Y来说，这两个比例分别是3.7:1和2.5:1。更进一步，这一组数据说明在我们的两个集群上，<strong>记录追加操作所占比例都要比写操作要大</strong>。对于集群X，在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的buffffer的应用程序的影响。</p>
<p>​    如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第一个副本的数据覆盖写的情况。这近似于一个客户机故意覆盖刚刚写入的数据，而不是增加新的数据。对于集群X，覆盖写操作在写操作所占据字节上的比例小于0.0001%，在所占据操作数量上的比例小于0.0003%。对于集群Y，这两个比率都是0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。<strong>这是由于这些覆盖写的操作，大部分是由于客户端在发生错误或者超时以后重试的情况</strong>。这在本质上应该不算作工作负荷的一部分，而是重试机制产生的结果。</p>
<pre><code>### 6.3.4、Matser的工作负荷
</code></pre>
<img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251803831.png" alt="image-20230325180359715" style="zoom:67%;" />

<p>表6显示了Master服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询Chunk位置信息（FindLocation）、以及修改操作查询lease持有者的信息（FindLease-Locker）。</p>
<p>集群X和Y在删除请求的数量上有着明显的不同，因为<strong>集群Y存储了生产数据，一般会重新生成数据以及用新版本的数据替换旧有的数据</strong>。数量上的差异也被隐藏在了Open请求中，因为旧版本的文件可能在以重新写入的模式打开时，隐式的被删除了（类似UNIX的open函数中的“w”模式）。</p>
<p>FindMatchingFiles是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于Master服务器的其它请求，它可能会检索namespace的大部分内容，因此是非常昂贵的操作。<strong>集群Y的这类请求要多一些，因为自动化数据处理的任务进程需要检查文件系统的各个部分，以便从全局上了解应用程序的状态。与之不同的是，集群X的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的名称。</strong></p>
<h1 id="7、经验"><a href="#7、经验" class="headerlink" title="7、经验"></a>7、经验</h1><p>​    在构建和部署GFS的过程中，我们遇到了各种各样的问题，包括一些操作问题和一些技术问题。</p>
<p>​    最初，GFS被设想为我们生产系统的后端文件系统。随着时间的推移，其用途逐渐发展到包括研究和开发任务。在设计之初，它几乎不支持<strong>权限控制（permissions）和限额（quotas）</strong>。但现在，它包括了这些内容的初步形态。虽然生产系统有很好的纪律和控制，但用户有时却不一定。需要更多的基础设施来防止用户相互干扰。</p>
<p>​    我们最大的一些问题是与磁盘和Linux相关的。我们的许多磁盘都向Linux驱动程序声称，它们支持一系列IDE协议版本，但实际上只对最近的版本作出了可靠的响应。由于协议版本非常相似，这些驱动器大多可以工作，但偶尔不匹配会导致驱动器对自身的状态和内核对驱动器的状态之间存在分歧。这将由于内核中的问题而悄无声息地破坏数据。<strong>这个问题促使我们使用checksum来检测数据损坏，同时我们修改了内核来处理这些协议不匹配</strong>。（<em>GFS会提出数据校验的初衷，便是用来解决OS和磁盘之间状态不一致的问题的，否则磁盘本身是有错误校验的，理应无需OS自行判断</em>）</p>
<p>​    之前，由于fsync()的成本，我们在Linux2.2内核中遇到了一些问题。它的成本与文件的大小成正比，而不是修改部分的大小。这对于我们的大型操作日志来说是一个问题，特别是在我们实现checkpoint之前。我们通过使用同步写操作解决这个问题了一段时间，并最终迁移到Linux2.4。</p>
<p>​    另一个Linux问题是一个读写锁，当一个地址空间中的任何线程，从磁盘换入内存页（读锁）或在调用mmap()修改地址空间（写锁）时，都必须持有它。我们看到系统在轻负载下出现了瞬态超时，并努力寻找资源瓶颈或零星的硬件故障。最终，我们发现，当磁盘线程在以前映射的数据中分页时，这个锁阻止了<strong>主网络线程将新数据映射到内存</strong>中。由于我们主要受到网络接口的限制，而不是内存复制带宽，我们通过用pread()替换mmap()，代价是额外的副本。</p>
<p>​    尽管偶尔会出现问题，但Linux代码的可用性已经帮助我们不断地探索和理解系统行为。在适当的情况下，我们会改进内核，并与开源社区共享这些更改。</p>
<h1 id="8、相关工作"><a href="#8、相关工作" class="headerlink" title="8、相关工作"></a>8、相关工作</h1><p>​    与AFS[5]等其他大型分布式文件系统一样，GFS提供了一个位置独立的名称空间，<strong>允许数据透明地移动，以实现负载平衡或容错</strong>。与AFS不同，GFS以一种更类似于xFS[1]和Swift[3]的方式跨存储服务器传播文件的数据，以提供总体性能和更强的容错能力。</p>
<p>​    由于磁盘相对便宜，而且复制比更复杂的RAID[9]方法更简单，因此GFS目前只使用复制来进行冗余，因此比xFS或Swift消耗更多的原始存储。</p>
<p>​    与AFS、xFS、Frangipani[12]和Intermezzo[6]等系统相比，GFS不在文件系统接口下面提供任何缓存。我们的目标工作负载在单个应用程序运行中很少被重用，因为它们要么在大数据集上进行流式操作，要么在其中随机查找，每次读取少量数据。</p>
<p>​    一些分布式文件系统，如Frangipani、xFS、Minnesota的GFS[11]和GPFS[10]，删除了集中式服务器，并依赖于分布式算法来实现一致性和管理。我们选择集中式的方法是为了简化设计，增加其可靠性，并获得灵活性。特别是，集中式master使实现复杂的块放置和复制策略变得更加容易，因为master已经拥有了大部分相关信息并控制它如何更改。<strong>我们通过保持主状态较小并在其他机器上完全复制来解决容错问题</strong>。可伸缩性和高可用性（对读操作而言）目前是由我们的shadow master机制提供的（<em>即主备架构，热备</em>）。通过附加到预写日志（write-ahead log, WAL），使对主状态的更新持久化。因此，我们可以采用像Harp[7]中那样的primary-copy方案，以提供比我们当前的方案更强的高可用性和一致性保证。</p>
<p>​    我们正在解决一个类似于Lustre[8]的问题，即向大量客户提供总体性能。然而，我们通过<strong>关注应用程序的需求</strong>，而不是构建一个兼容POSIX的文件系统，从而大大简化了这个问题。此外，GFS假设有大量不可靠的组件，因此<strong>容错是我们设计的核心</strong>。</p>
<p>​    GFS最接近于NASD架构[4]。虽然NASD架构是基于网络连接的磁盘驱动器，但GFS使用商品机器作为chunkserver，就像在NASD原型中所做的那样。与NASD工作不同，我们的chunkserver使用延迟分配的固定大小的块，而不是可变长度的对象。此外，GFS还实现了生产环境中需要的再平衡、复制和恢复等特性。</p>
<p>​    与Minnesota的GFS和NASD不同，我们并不改变存储设备的模型。我们专注于解决包含既有商品组件的复杂分布式系统的日常数据处理需求。</p>
<p>​    由原子追加写操作（Atomic Record Appends, Section 3.3）实现的生产者-消费者队列，解决了与River[2]中的分布式队列类似的问题。<strong>River使用分布在机器上的基于内存的队列和细致的数据流控制，而GFS使用一个持久的文件，许多生产者可以并发地附加到该文件中</strong>。River模型支持m到n个分布式队列，但缺乏持久存储所附带的容错能力，而GFS只有效地支持m到1个队列。多个使用者可以读取同一个文件，但它们必须相互协调，以划分传入的负载。</p>
<h1 id="9、结束语"><a href="#9、结束语" class="headerlink" title="9、结束语"></a>9、结束语</h1><p>​    Google文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p>
<p>​    首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为<strong>组件失效是常态而不是异常</strong>，针对采用追加方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p>
<p>​    我们系统通过<strong>持续监控，复制关键数据，快速和自动恢复提供灾难冗余</strong>。Chunk复制使得我们可以对Chunk服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用<strong>Checksum</strong>在磁盘或者IDE子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。</p>
<p>​    我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过<strong>分离控制流和数据流</strong>来实现这个目标，<strong>控制流在Master服务器处理，而数据流在Chunk服务器和客户端处理</strong>。当一般的操作涉及到Master服务器时，由于GFS选择的Chunk尺寸较大*(从而减小了元数据的大小*)，以及通过Chunk Lease将控制权限移交给主副本，这些措施将Master服务器的负担降到最低。<strong>这得一个简单、中心的Master不会成为成为瓶颈</strong>。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p>
<p>​    GFS成功的实现了我们对存储的需求，在Google内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个WEB范围内的难题的一个重要工具。</p>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">wck</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/032518626.html">http://example.com/2023/032518626.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">wck</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/GFS/">
                                    <span class="chip bg-color">GFS</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'yohIdjiNFr5gi9AMV8TPhv90-gzGzoHsz',
        appKey: 'dpdaXreArfn9sbA5A5hGBlUG',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你想说的话吧~',
        enableQQ: true,
        emojiCDN: '//i0.hdslb.com/bfs/emote/', 
        // 表情title和图片映射
        emojiMaps: {
        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
        "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
        "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
        "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
        "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
        "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
        "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
        "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
        "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
        "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
        "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
        "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
        "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
        "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
        "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
        "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
        "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
        "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
        "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
        "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
        "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
        "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
        "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
        "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
        "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
        "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
        "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
        "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
        "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        },
        requiredFields: ['nick','mail'],
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/03289396.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/7.jpg" class="responsive-img" alt="算法（一）基础算法">
                        
                        <span class="card-title">算法（一）基础算法</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            y总算法基础课的第一章基础算法笔记，包括c++以及java版本的例题题解
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E8%AF%BE/" class="post-category">
                                    算法基础课
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/">
                        <span class="chip bg-color">基础算法</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/032336853.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/23.jpg" class="responsive-img" alt="krpc规范">
                        
                        <span class="card-title">krpc规范</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            在学习DHT的时候，了解到的krpc的传输规范
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-23
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="post-category">
                                    分布式系统
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/krpc-DHT/">
                        <span class="chip bg-color">krpc DHT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">wck</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">352.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rumor-sourse" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2560428298@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2560428298" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2560428298" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/7491101842/home" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/7491101842/home" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/chu-zi-hang-46-14" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/chu-zi-hang-46-14" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>





    <a href="https://space.bilibili.com/531340472" class="tooltipped" target="_blank" data-tooltip="在B站上关注我" " data-position="top" data-delay="50">
        <i class="fas fa-play-circle"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <!-- <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
    </script> -->
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

 
</body>

</html>
