<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="操作系统, charminghacker">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>操作系统 | charminghacker</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="charminghacker" type="application/atom+xml">
</head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">charminghacker</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">charminghacker</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/rumor-sourse" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        <!-- 
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/rumor-sourse" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
         -->
    </nav>
     <!-- <div class="weather">
        
        <div id="tp-weather-widget"></div>
        <script>
            (function (a, h, g, f, e, d, c, b) { b = function () { d = h.createElement(g); c = h.getElementsByTagName(g)[0]; d.src = e; d.charset = "utf-8"; d.async = 1; c.parentNode.insertBefore(d, c) }; a["SeniverseWeatherWidgetObject"] = f; a[f] || (a[f] = function () { (a[f].q = a[f].q || []).push(arguments) }); a[f].l = +new Date(); if (a.attachEvent) { a.attachEvent("onload", b) } else { a.addEventListener("load", b, false) } }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
            window.SeniverseWeatherWidget('show', {
                flavor: "bubble",
                location: "WW92M43YCQG0",
                geolocation: true,
                language: "zh-Hans",
                unit: "c",
                theme: "auto",
                token: "2ee46d07-e99c-4227-925e-461574e6469c",
                hover: "enabled",
                container: "tp-weather-widget"
            })
        </script>
    </div>   -->
    
</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/3.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">操作系统</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        padding: 35px 0 15px 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        padding-bottom: 30px;
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                <span class="chip bg-color">操作系统</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-category">
                                期末复习
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-02-28
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2023-03-01
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    25.8k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    90 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="Linux结构"><a href="#Linux结构" class="headerlink" title="Linux结构"></a>Linux结构</h1><img src="https://s2.loli.net/2022/04/10/f4bjWYcFtByv6eS.png" alt="image-20220410145624703" style="zoom:67%;" />

<p><strong>进程调度子系统</strong></p>
<p>功能：</p>
<ul>
<li>决定CPU的归属</li>
<li>处理中断，将其发送给合适的子系统</li>
<li>发送信号给用户进程</li>
<li>管理定时器</li>
<li>支持模块动态装入</li>
</ul>
<p><strong>内存管理子系统</strong></p>
<p>功能：</p>
<ul>
<li>扩大地址空间</li>
<li>进程保护</li>
<li>内存映射</li>
<li>实现虚存</li>
</ul>
<h1 id="一、操作系统引论"><a href="#一、操作系统引论" class="headerlink" title="一、操作系统引论"></a>一、操作系统引论</h1><img src="https://s2.loli.net/2022/04/10/xX2it5IvjpWhgHC.png" alt="image-20220410150944601" style="zoom:67%;" />

<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p><strong>特性：</strong>自动性、顺序性、单道性</p>
<p><strong>优点：</strong>减少人工操作，解决了作业的自动接续。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>资源利用率不高：CPU，内存</li>
<li>平均周转时间长</li>
<li>没有交互能力</li>
</ul>
<img src="https://s2.loli.net/2022/04/10/FoIlKp95S7dhRDj.png" alt="image-20220410152047886" style="zoom:67%;" />

<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p>同时驻留多个作业</p>
<p><strong>优点：</strong></p>
<ul>
<li>提高CPU利用率</li>
<li>提高内存和I/O设备的利用率</li>
<li>提高了系统吞吐量</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>资源利用率高</li>
<li>系统吞吐量大</li>
<li>平均周转时间长</li>
<li>无交互能力</li>
</ul>
<img src="https://s2.loli.net/2022/04/10/HFQ8DIWyMETR6Yh.png" alt="image-20220410152926183" style="zoom:67%;" />

<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p><strong>指一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户共享主机中的资源，各个用户都可通过自己的终端以交互方式使用计算机</strong></p>
<p>类型：</p>
<ul>
<li>单道分时系统</li>
<li>具有前、后台的分时系统</li>
<li>多道分时系统</li>
</ul>
<p>特征：</p>
<ul>
<li>多路性</li>
<li>独立性</li>
<li>及时性</li>
<li>交互性</li>
</ul>
<p>典型系统：MIT、<strong>UNIX</strong>、<strong>Linux</strong></p>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>及时处理</p>
<p>实时任务类型：</p>
<p>按程序运行是否呈现周期性：</p>
<ul>
<li>周期性</li>
<li>非周期性</li>
</ul>
<p>根据对截止时间的要求来划分：</p>
<ul>
<li>硬实时任务</li>
<li>软实时任务</li>
</ul>
<p><strong>实时 vs 分时</strong></p>
<ul>
<li>多路性：相同</li>
<li>独立性：相同</li>
<li>及时性：实时系统要求更高</li>
<li>交互性：分时系统要求更高</li>
<li>可靠性：实时系统要求更高</li>
</ul>
<h2 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h2><p>单用户单任务操作系统：CP/M，<strong>MS-DOS</strong></p>
<p>单用户多任务操作系统：Windows（不会Server版）</p>
<p>多用户多任务操作系统：<strong>Unix</strong>、Solaris、<strong>Linux</strong></p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul>
<li>并发性</li>
<li>共享性：互斥共享、同时访问</li>
<li>虚拟性：时分复用：虚拟处理机技术/虚拟设备技术、空分复用：虚拟存储</li>
<li>异步性</li>
</ul>
<p><strong>并发和共享是最基本的特征</strong></p>
<blockquote>
<p>并发：指两个或多个事件在<strong>同一时间间隔</strong>内发生</p>
<p>并行：指两个或多个事件在<strong>同一时刻</strong>发生</p>
</blockquote>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>处理机管理</li>
<li>存储器管理</li>
<li>设备管理</li>
<li>文件管理</li>
<li>方便用户使用的用户接口</li>
</ol>
<h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><p>1、整体式操作系统：Linux</p>
<p>2、模块化操作系统：</p>
<p>提升了<strong>易维护性、开发效率、适应性</strong>；没有提升运行效率</p>
<p>3、分层式操作系统</p>
<p>易于验证新开发功能的正确性</p>
<h2 id="微内核操作系统结构"><a href="#微内核操作系统结构" class="headerlink" title="微内核操作系统结构"></a>微内核操作系统结构</h2><p>优点：</p>
<ul>
<li>提高了<strong>可扩展性</strong></li>
<li>增强了<strong>可靠性</strong></li>
<li><strong>可移植性</strong>强</li>
<li>提供了对<strong>分布式</strong>系统的支持</li>
<li>融入了<strong>面向对象</strong>技术</li>
</ul>
<p>问题：</p>
<ul>
<li>性能代价</li>
</ul>
<h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>1、在OS中为实现多道程序设计需要有<strong>更大的内存</strong></p>
<p>2、推动微机OS发展的主要动力是<strong>计算机硬件的不断更新换代</strong></p>
<p>3、在多道批处理系统中，为了充分利用各种资源，系统总是优先选择<strong>计算型和I/O型均衡的</strong>的多个作业投入运行</p>
<p>4、在分时系统中，为使多个用户能够同时与系统交互，最关键的问题是<strong>能在一较短的时间内，使所有用户程序都得到运行</strong></p>
<p>5、分时系统和实时系统都具有交互性，实时系统的交互性允许用户访问<strong>专用服务程序</strong>，分时系统的交互性运行用户请求系统提供<strong>多方面的服务</strong></p>
<p>6、<strong>中断处理模块</strong>是必须包含在操作系统内核中的模块</p>
<h1 id="二、进程描述与控制"><a href="#二、进程描述与控制" class="headerlink" title="二、进程描述与控制"></a>二、进程描述与控制</h1><h2 id="1、前趋图"><a href="#1、前趋图" class="headerlink" title="1、前趋图"></a>1、前趋图</h2><p><strong>描述进程之间执行的前后关系</strong></p>
<img src="https://s2.loli.net/2022/04/10/7gPO8sYCDQeAyN2.png" alt="image-20220410161510200" style="zoom:67%;" />

<p><strong>顺序执行：</strong>顺序性、封闭性、可再现性</p>
<p><strong>并发执行：</strong>间断性、失去封闭性、不可再现性</p>
<h2 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h2><h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><p>为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念</p>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>进程映像：<strong>程序段、数据段和PCB</strong></p>
<p>PCB（Process Controll Block）:进程控制块，用与描述进程的基本情况和活动过程，进而控制和管理进程</p>
<blockquote>
<p>创建进程就是创建进程实体中的PCB</p>
<p>撤销进程就是撤销进程实体中的PCB</p>
</blockquote>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>动态性：最基本特征</li>
<li>并发性</li>
<li>独立性</li>
<li>异步性</li>
</ul>
<p>操作系统的<strong>并发性和异步性</strong>特征来自进程的特征</p>
<h3 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h3><p>就绪状态、执行状态、堵塞状态</p>
<img src="https://s2.loli.net/2022/04/10/enlkhKL3wHJA19C.png" alt="image-20220410163438759" style="zoom:67%;" />

<p>在单CPU的主机上，有N个进程</p>
<p>最大就绪进程数为N-1</p>
<p>最大运行进程数为1</p>
<p>最大阻塞进程数为N</p>
<h3 id="创建和终止状态"><a href="#创建和终止状态" class="headerlink" title="创建和终止状态"></a>创建和终止状态</h3><p>创建状态：未完成创建的进程不能被调度</p>
<p>终止状态：</p>
<ul>
<li>1、等待进程终止的善后处理；2、撤销进程的PCB</li>
<li>避免再被调度</li>
</ul>
<img src="https://s2.loli.net/2022/04/10/IzAMFj5evQkELXh.png" alt="image-20220410164039998" style="zoom:67%;" />

<h3 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h3><p>使执行的进程暂停执行，静止下来，使就绪状态的进程暂不接受调度</p>
<p>原因：</p>
<ul>
<li>终端用户的请求</li>
<li>父进程的请求</li>
<li>负荷调节的需要。当实时系统中的工作负荷较重，把一些不重要的进程挂起，以保证系统能正常运行。</li>
<li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li>
</ul>
<img src="https://s2.loli.net/2022/04/10/mdYkNwJ6gcXRKFM.png" alt="image-20220410164511250" style="zoom:67%;" />

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>1、用于管理控制的数据结构</p>
<p>四大表：内存表、设备表、文件表、进程表</p>
<p>2、PCB作用</p>
<p>提供进程<strong>管理和调度</strong>所需的信息，实现与其他进程的<strong>同步和通信</strong></p>
<p><strong>PCB是进程存在的唯一标志</strong></p>
<h3 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h3><p><strong>（1）进程标识符</strong></p>
<ul>
<li>内部标识符：唯一，系统使用</li>
<li>外部标识符：创建者提供，用户使用</li>
</ul>
<p><strong>（2）处理机状态</strong></p>
<ul>
<li>通用寄存器</li>
<li>指令计数器</li>
<li>程序状态字PSW</li>
<li>用户栈指针</li>
</ul>
<p><strong>中断和进程切换所需要保护的内容</strong></p>
<p><strong>（3）进程调度信息</strong></p>
<ul>
<li>进程状态</li>
<li>进程优先级</li>
<li>进程调度所需要的其他信息：如进程已等待CPU的时间总和</li>
<li>事件</li>
</ul>
<p><strong>（4）进程控制信息</strong></p>
<ul>
<li>程序和数据的地址</li>
<li>进程同步和通信机制</li>
<li>资源清单</li>
<li>链接指针</li>
</ul>
<h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul>
<li>线性</li>
<li>链接</li>
<li>索引</li>
</ul>
<h2 id="3、进程控制"><a href="#3、进程控制" class="headerlink" title="3、进程控制"></a>3、进程控制</h2><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><blockquote>
<p><strong>处理机的执行态</strong></p>
<ul>
<li>系统态/管态/内核态</li>
<li>用户态/目态</li>
</ul>
</blockquote>
<p><strong>内核功能：</strong></p>
<p>（1）支撑功能</p>
<ul>
<li>中断处理</li>
<li>时钟管理</li>
<li>原语操作</li>
</ul>
<p>（2）资源管理操作</p>
<ul>
<li>进程管理</li>
<li>存储器管理</li>
<li>设备管理</li>
</ul>
<blockquote>
<p><strong>原语：</strong>由若干条指令组成，用于完成一定功能的一个过程，并在执行中不可分割</p>
<p>操作系统内核的功能大都通过执行各种原语实现</p>
<p><strong>原子操作：</strong>在一个操作中的所有动作，要么全做，要么全不做</p>
<p>在单机系统中采用<strong>屏蔽中断</strong>的方式来保证操作的原子性</p>
</blockquote>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>进程的层次结构</p>
<ul>
<li>创建形成的父子进程关系</li>
<li>子进程继承父进程的资源</li>
<li>父进程终止会导致子进程终止</li>
<li>PCB中记录家族关系</li>
<li>Windows中没有进程层次关系</li>
</ul>
<p>进程图</p>
<img src="https://s2.loli.net/2022/04/10/NYH1DzUKTMS5R9a.png" alt="image-20220410174654636" style="zoom:67%;" />

<p><strong>创建进程的事件</strong></p>
<ol>
<li>用户登录</li>
<li>作业调度</li>
<li>提供服务</li>
<li>应用请求</li>
</ol>
<p>fork()：复制父进程全部资源</p>
<p>clone()：有选择的复制父进程资源</p>
<p>Vfork()：创建线程。复制除task_struct和系统空间堆栈外的所有资源</p>
<blockquote>
<p>fork()函数</p>
<p>失败返回负值</p>
<p>成功：</p>
<ul>
<li>父进程返回创建子进程的ID</li>
<li>子进程返回0</li>
</ul>
</blockquote>
<h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>引起进程终止的三类事件</p>
<ol>
<li><p>正常结束</p>
<p>return：结束函数的执行</p>
<p>exit：先进行清除工作，再进入内核</p>
<p>_exit：立刻进入内核</p>
</li>
<li><p>异常结束</p>
<p>调用abort函数</p>
<p>收到某个信号使程序终止</p>
</li>
<li><p>外界干预</p>
</li>
</ol>
<h3 id="进程阻塞和唤醒"><a href="#进程阻塞和唤醒" class="headerlink" title="进程阻塞和唤醒"></a>进程阻塞和唤醒</h3><p>引起阻塞和唤醒的事件</p>
<ol>
<li>请求系统服务而得不到满足</li>
<li>启动某种操作而需同步时</li>
<li>新数据尚未到达</li>
<li>无新工作可做</li>
</ol>
<p>唤醒原语流程：</p>
<p>首先把被阻塞的进程从该等待事件的阻塞队列中移出，将其PCB中的现行状态由<strong>阻塞改为就绪</strong></p>
<p>然后再将该PCB插入到<strong>就绪队列</strong>中</p>
<h3 id="进程挂起与激活"><a href="#进程挂起与激活" class="headerlink" title="进程挂起与激活"></a>进程挂起与激活</h3><p>挂起：</p>
<ul>
<li>活动就绪-&gt;静止就绪</li>
<li>活动阻塞-&gt;静止阻塞</li>
</ul>
<p>激活：</p>
<ul>
<li>静止就绪-&gt;活动就绪</li>
<li>静止阻塞-&gt;活动阻塞</li>
</ul>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>进程调度：把处理机分配给不同的进程占用执行</p>
<p>调度程序：实现分配处理机的程序</p>
<p>进程的上下文：进程切换时要保护执行现场</p>
<h2 id="4、进程同步"><a href="#4、进程同步" class="headerlink" title="4、进程同步"></a>4、进程同步</h2><ul>
<li><strong>硬件同步机制</strong></li>
<li><strong>信号量机制</strong></li>
<li><strong>管程机制</strong></li>
<li><strong>经典同步问题</strong></li>
</ul>
<p>资源的<strong>共享和协作</strong>导致相关进程间形成制约</p>
<p>例一：银行储蓄问题</p>
<p>例二：<strong>生产者消费者问题</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
     产生数据到临时变量nextp；
      ……<span class="token punctuation">.</span>
      <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span>
      buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>
      in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>
      counter<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>
         out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>n<span class="token punctuation">;</span>
         counter<span class="token operator">--</span><span class="token punctuation">;</span>
          消费取出的数据；
      <span class="token punctuation">&#125;</span>；
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>问题 ：</strong>没有对counter进行并发访问控制</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>各个进程要保证互斥的进入自己的临界区，从而实现临界资源的访问</p>
<h3 id="同步机制的准则（重要）"><a href="#同步机制的准则（重要）" class="headerlink" title="同步机制的准则（重要）"></a>同步机制的准则（重要）</h3><ol>
<li><strong>空闲让进</strong>：如果临界区空闲，则只要有进程申请就立即让其进入，以有效利用资源</li>
<li><strong>忙则等待</strong>：每次仅允许一个进程处于临界区，保证对临界资源的“互斥”访问</li>
<li><strong>有限等待</strong>：进程只能在临界区内逗留有限时间，不得让其他进程在临界区外陷入“死等”</li>
<li><strong>让权等待</strong>：进程不能进入临界区时，应立即释放处理机，以免陷入“忙等状态</li>
</ol>
<h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><blockquote>
<p>软件方法始终不能解决“忙等”现象，降低系统效率，同时很难控制多个进程的互斥</p>
</blockquote>
<p><strong>1、关中断</strong></p>
<ul>
<li>影响效率</li>
<li>不能保证互斥同步</li>
</ul>
<p><strong>2、Test-and-Set指令和Swap指令</strong></p>
<p>本质：确保对锁的检测和关锁操作的原子性</p>
<p>Test-and-Set</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">boolean <span class="token function">TS</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    boolean old <span class="token operator">=</span> <span class="token operator">*</span>lock<span class="token punctuation">;</span>
    lock <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> old<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">do</span><span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">while</span> <span class="token function">TS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区
    lock <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>
    其他区域
<span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Swap</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>
    boolean key<span class="token operator">=</span>TRUE<span class="token punctuation">;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>key<span class="token operator">!=</span>FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    临界区
    lock<span class="token operator">=</span>FALSE<span class="token punctuation">;</span>
    其他区域
<span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>本质：lock是真死循环，lock是否跳出循环，最后都要置lock为否</strong></p>
</blockquote>
<p>缺点：</p>
<ul>
<li>忙等</li>
<li>饥饿现象</li>
<li>死锁</li>
</ul>
<h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p><strong>P操作/Wait(s):</strong><code>while s&lt;=0; s=s-1</code></p>
<p><strong>V操作/Signal(s):</strong><code>s=s+1</code></p>
<p>未遵循让权等待原则</p>
<h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">process_controll_block</span> <span class="token operator">*</span>list<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>semaphore<span class="token punctuation">;</span>

<span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">-></span>vlaue<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    S<span class="token operator">-></span>value <span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>s.value初值：表示系统中某类资源的数目</p>
<p>s.value&lt;0：表示信号量链表中已阻塞进程的数目</p>
<ul>
<li><strong>资源信号量：</strong>用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数</li>
<li><strong>互斥信号量：</strong>用于申请或释放资源的使用权，常初始化为1</li>
</ul>
<p>资源信号量和互斥信号量使用相同的底层机制</p>
<h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>要么全分配，要么一个也不分配</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swait</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sn<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>Si<span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;&amp;</span> Sn<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> Si<span class="token operator">--</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">Ssignal</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sn<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
            Si<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="信号集量"><a href="#信号集量" class="headerlink" title="信号集量"></a>信号集量</h4><p>为提高效率而对AND信号的补充（略）</p>
<h3 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h3><ul>
<li>实现进程互斥</li>
<li>实现前趋关系</li>
</ul>
<h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p><strong>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据</strong></p>
<p>特点：</p>
<ol>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被挂起，以等待管程变成可用的。 从而实现进程互斥。</li>
</ol>
<p>同步工具：<strong>条件变量</strong></p>
<p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问 ，每个条件维护一个链表</p>
<p>①x.wait：调用进程的执行在条件x上挂起，插入x等待队列，并释放管程给另一个进程使用。</p>
<p>②x.signal：恢复在x条件挂起的进程的执行。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么也不做。</p>
<h2 id="5、经典进程同步问题"><a href="#5、经典进程同步问题" class="headerlink" title="5、经典进程同步问题"></a>5、经典进程同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><h4 id="（1）记录型信号量"><a href="#（1）记录型信号量" class="headerlink" title="（1）记录型信号量"></a>（1）记录型信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>empty<span class="token operator">=</span>n<span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        producer an item nextp<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//empty缓冲区为空的数量</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>
        in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//full缓冲区为满的数量</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>
        out <span class="token operator">=</span> <span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer the item in nextc<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>进程应该先申请资源信号量，再申请互斥信号量</li>
<li>对任何信号量的wait与signal操作必须配对。</li>
<li>对同一个资源信号量的wait与signal可以不在同一个进程中</li>
</ol>
<h4 id="（2）AND信号量"><a href="#（2）AND信号量" class="headerlink" title="（2）AND信号量"></a>（2）AND信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>empty<span class="token operator">=</span>n<span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        producer an item nextp<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">Swait</span><span class="token punctuation">(</span>empty<span class="token punctuation">,</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>
        in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>
        <span class="token function">Ssignal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        <span class="token function">Swait</span><span class="token punctuation">(</span>full<span class="token punctuation">,</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>
        out <span class="token operator">=</span> <span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>
        <span class="token function">Ssignal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>
        consumer the item in nextc<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="（3）管程"><a href="#（3）管程" class="headerlink" title="（3）管程"></a>（3）管程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Procedure entry <span class="token function">put</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
	begin
	  <span class="token keyword">if</span> count ≥n then notfull<span class="token punctuation">.</span>wait<span class="token punctuation">;</span>
	    <span class="token function">buffer</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">=</span>nextp<span class="token punctuation">;</span>
	    in<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod n
	    count<span class="token operator">:</span><span class="token operator">=</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>
	    <span class="token keyword">if</span> notempty<span class="token punctuation">.</span>queue then notempty<span class="token punctuation">.</span>signal<span class="token punctuation">;</span>
	end
Procedure entry <span class="token function">get</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
	begin
	  <span class="token keyword">if</span> count ≤ <span class="token number">0</span> then notempty<span class="token punctuation">.</span>wait<span class="token punctuation">;</span>
	    nextc<span class="token operator">:</span><span class="token operator">=</span><span class="token function">buffer</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    out<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod n
	    count<span class="token operator">:</span><span class="token operator">=</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	    <span class="token keyword">if</span> notfull<span class="token punctuation">.</span>queue then notfull<span class="token punctuation">.</span>signal<span class="token punctuation">;</span>
	end
Begin in<span class="token operator">:</span><span class="token operator">=</span>out<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> count<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span> end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>记录型信号量</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
   <span class="token comment">//eat</span>
    …
   <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
   <span class="token comment">//think;</span>
    …
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Q：死锁</p>
<p>A：仅当哲学家的左右两只筷子同时可以时才允许他拿起筷子</p>
<p><strong>AND信号量</strong></p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">Var chopstick<span class="token operator">:</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> …<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> of semaphore<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
processi
Repeat
   think<span class="token punctuation">;</span>
   <span class="token function">Sswait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    eat
    <span class="token function">Ssignal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Until false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">semphore rmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>wmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
nt readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//如果有人在读则说明绝对不在写，因此只有没人在读时需要判断是否在写</span>
            <span class="token function">wait</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//保证第一个读进程来，写进程就不能进行</span>
        readcount<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        perform read operation
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token function">signal</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>
        <span class="token function">wait</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        perform write operation<span class="token punctuation">;</span>
        <span class="token function">signal</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="6、进程的通信"><a href="#6、进程的通信" class="headerlink" title="6、进程的通信"></a>6、进程的通信</h2><h2 id="7、线程的基本概念"><a href="#7、线程的基本概念" class="headerlink" title="7、线程的基本概念"></a>7、线程的基本概念</h2><p><strong>线程是资源调度和分派的基本单位</strong></p>
<ul>
<li>进程的终止或挂起会导致进程中的所有线程的终止或线程</li>
<li>进程比线程有更好的独立性</li>
<li>进程中的所有线程共享该进程的状态和资源</li>
<li>线程阻塞不一定引起进程阻塞（系统调用进入核心态时，若线程阻塞则其所在进程也会被阻塞）</li>
<li>同一进程中的线程切换不会引起进程切换，在不同进程中的线程切换会引起进程切换</li>
</ul>
<p><strong>线程状态变化的4种基本操作：</strong></p>
<ol>
<li>派生</li>
<li>阻塞</li>
<li>解除阻塞</li>
<li>结束</li>
</ol>
<p><strong>线程控制块：</strong></p>
<p>线程标识符、一组寄存器、线程运行状态、优先级、专有存储区、用户栈、信号屏蔽</p>
<blockquote>
<p>线程运行状态不是线程的上下文</p>
</blockquote>
<h2 id="8、做题"><a href="#8、做题" class="headerlink" title="8、做题"></a>8、做题</h2><p>1、某进程所要求的一次打印输出结束，该进程被<strong>唤醒</strong>，其进程的状态将从<strong>阻塞到就绪</strong></p>
<p>2、在批处理系统中，导致进程创建的典型事件是<strong>作业调度</strong></p>
<p>3、由系统专门为运行中的应用进程创建新进程的事件是<strong>提供服务</strong></p>
<p>4、wait,signal操作可以解决一切互斥问题</p>
<h1 id="三、处理机调度和死锁"><a href="#三、处理机调度和死锁" class="headerlink" title="三、处理机调度和死锁"></a>三、处理机调度和死锁</h1><h2 id="1、一些基本概念"><a href="#1、一些基本概念" class="headerlink" title="1、一些基本概念"></a>1、一些基本概念</h2><table>
<thead>
<tr>
<th>层次</th>
<th>别名</th>
<th>对象</th>
<th>功能</th>
<th>频度</th>
<th>实现者</th>
<th>应用范围</th>
</tr>
</thead>
<tbody><tr>
<td>高级</td>
<td>作业调度、长程调度、接纳调度</td>
<td>作业</td>
<td>决定外存作业上处于后备队列中的哪几个作业调入内存，创建进程，分配资源，插入就绪队列</td>
<td>最低，分钟级</td>
<td>作业管理程序</td>
<td>批处理系统</td>
</tr>
<tr>
<td>中级</td>
<td>内存调度</td>
<td>挂起的进程</td>
<td>把外存上那些已经具备运行条件的就绪进程重新载入内存（从静止就绪到活动就绪），将暂时不能运行的进程调至外存等待</td>
<td>中等</td>
<td>内存管理中的对换进程</td>
<td>具有对换功能的操作系统</td>
</tr>
<tr>
<td>低级</td>
<td>进程调度、短程调度</td>
<td>就绪进程/内核进程</td>
<td>决定就绪队列中的哪个进程应获得处理机，并将处理机分配给选中的进程</td>
<td>最频繁，毫秒级</td>
<td>分派程序</td>
<td>都有</td>
</tr>
</tbody></table>
<p>CPU利用率 = CPU的有效工作时间/（CPU有效工作时间+ CPU空闲等待时间）</p>
<p><strong>周转时间：接纳等待、执行等待、执行时间、I/O时间</strong></p>
<p>面向用户的准则：<strong>平均周转时间</strong></p>
<p><strong>带权周转时间</strong>：作业的周转时间T与系统为它服务的时间（执行加IO）之比  （必定&gt;1）</p>
<p>吞吐量：单位时间内系统完成的作业数</p>
<p>响应时间：输入时间、处理时间、显示时间  </p>
<p>响应时间快：分时系统的重要准则</p>
<h2 id="2、作业与作业调度"><a href="#2、作业与作业调度" class="headerlink" title="2、作业与作业调度"></a>2、作业与作业调度</h2><p>作业管理系统用于管理和控制作业运行的数据结构</p>
<h3 id="先来先服务算法FCFS"><a href="#先来先服务算法FCFS" class="headerlink" title="先来先服务算法FCFS"></a>先来先服务算法FCFS</h3><p>first come fist serve</p>
<p>每次调度从就绪队列中选择一个最先进入该队列的进程</p>
<h3 id="短作业优先算法SJF"><a href="#短作业优先算法SJF" class="headerlink" title="短作业优先算法SJF"></a>短作业优先算法SJF</h3><p>shortest job first</p>
<p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p>
<h3 id="优先级调度算法PSA"><a href="#优先级调度算法PSA" class="headerlink" title="优先级调度算法PSA"></a>优先级调度算法PSA</h3><p>Priority-scheduling algorithm</p>
<p>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级</p>
<h3 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h3><p>Highest   Response   Ratio   Next</p>
<p>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。</p>
<p>优先权=（等待时间+要求服务时间）/要求服务时间</p>
<p>在作业完成时以及新作业到达时计算响应比</p>
<p><strong>不用于进程</strong></p>
<h2 id="3、进程调度"><a href="#3、进程调度" class="headerlink" title="3、进程调度"></a>3、进程调度</h2><p>抢占式</p>
<p>非抢占式</p>
<h3 id="轮转调度算法（抢占式）"><a href="#轮转调度算法（抢占式）" class="headerlink" title="轮转调度算法（抢占式）"></a>轮转调度算法（抢占式）</h3><ul>
<li>每个进程仅运行一个时间片即被强占CPU</li>
<li>原理：FCFS策略+时钟中断+时间片原则</li>
<li>切换时机：时间片内进程结束，进程结束事件激活进程调度，新进程可运行一个时间片；时间片用完，时钟中断激活调度，旧进程到就绪队列尾，队头进程投入运行一个时间片</li>
</ul>
<p>时间片大小默认为100ms</p>
<h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>静态优先权</p>
<p>动态优先权：响应比Rp = （等待时间+服务时间）/服务时间</p>
<h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><ul>
<li>设置多个就绪队列，并为各个队列赋予不同的优先级。</li>
<li>优先级愈高的队列的进程的执行时间片就愈小。</li>
<li>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾。最低优先权队列中的进程则按RR方式运行。</li>
<li>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。</li>
</ul>
<p><strong>未执行完时间片的进程被抢占后应不降级，到队列末尾</strong></p>
<h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol>
<li>保证调度算法：如N个进程平均分配时间</li>
<li>公平分享调度算法：按照用户数量平均分配时间</li>
</ol>
<h2 id="4、实时系统与实时任务调度"><a href="#4、实时系统与实时任务调度" class="headerlink" title="4、实时系统与实时任务调度"></a>4、实时系统与实时任务调度</h2><p><img src="https://s2.loli.net/2022/04/14/vaCTKStoruB7JZ5.png" alt="image-20220414212457224"></p>
<h3 id="最早截止时间优先算法（EDF）"><a href="#最早截止时间优先算法（EDF）" class="headerlink" title="最早截止时间优先算法（EDF）"></a>最早截止时间优先算法（EDF）</h3><p>Earliest Deadline First</p>
<p>具有最早截止时间的任务排在队列的最前面</p>
<h3 id="最低松弛度优先算法（LLF）"><a href="#最低松弛度优先算法（LLF）" class="headerlink" title="最低松弛度优先算法（LLF）"></a>最低松弛度优先算法（LLF）</h3><p>Least Laxity First</p>
<p>松弛度=完成截止时间-剩余运行时间-当前时间</p>
<p>松弛度最小的任务排在队列最前面</p>
<h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>存在高中低三个优先级的进程，高和低共享同一个临界资源，低优先级进程先进入临界区，阻止高优先级进程进入临界区，中优先级进程抢占低优先级进程的CPU，使得低优先级进程无法从临界区退出，从而间接阻止更高优先级进程运行。</p>
<p>解决办法：优先级继承</p>
<h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>死锁：多个进程在运行过程中因争夺资源而造成的一种僵局</p>
<p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</p>
<h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol>
<li>竞争资源</li>
<li>进程间推进顺序非法</li>
</ol>
<h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ol>
<li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用 。</li>
<li><strong>请求和保持条件</strong>：指进程已经保持了至少一个资源，但又提出了新的资源请求 。 </li>
<li><strong>不剥夺条件</strong>：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链 。（充要条件）</li>
</ol>
<h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><ol>
<li>预防死锁：预防2,3,4条件</li>
<li>避免死锁</li>
<li>检测死锁</li>
<li>解除死锁</li>
</ol>
<p>请求保持：资源的预分配</p>
<p>不剥夺条件：死锁时把保持的资源释放</p>
<p>循环等待：资源有序分配</p>
<h2 id="6、避免死锁"><a href="#6、避免死锁" class="headerlink" title="6、避免死锁"></a>6、避免死锁</h2><p>安全状态：没有死锁的状态</p>
<p>非安全状态：可能有死锁的状态</p>
<h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p>
<p>避免死锁的限制条件：</p>
<ul>
<li>预先必须声明每个进程需要的资源总量</li>
<li>进程之间相互独立，其执行顺序取决于系统安全，而非进程间的同步要求</li>
<li>系统必须提供固定数量的资源供进程使用</li>
</ul>
<blockquote>
<p>n个进程共享m个同种资源，若每个进程都需要该类资源，而且各进程对该类资源的最大需求量之和小于m+n，说明该系统不会因竞争该类资源而死锁</p>
</blockquote>
<h3 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h3><p><strong>资源分配图：</strong></p>
<p><img src="https://s2.loli.net/2022/04/14/1TLuN4AEnVP6Hsd.png" alt="image-20220414222643886"></p>
<p>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称该图是可完全简化图；若不能使该图完全简化，则称该图是不可完全化简图。</p>
<h3 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h3><p>（1）剥夺资源</p>
<p>（2）撤销进程（最简单常用）</p>
<h2 id="7、做题"><a href="#7、做题" class="headerlink" title="7、做题"></a>7、做题</h2><p>1、<strong>截止时间的保证</strong>是选择实时调度算法的重要准则，<strong>响应时间快</strong>是选择分时系统中进程调度算法的重要准则</p>
<p>2、<strong>FCFS</strong>只能采用非抢占式调度，<strong>时间片轮转</strong>只能采用抢占调度</p>
<p>3、为了实现人机交互采用<strong>时间片轮转法</strong>，为了兼顾短作业和长时间等待作业，采用<strong>高响应比优先</strong>，为了使作业的平均周转时间最短，应采用<strong>短作业优先算法</strong></p>
<p>4、最容易引起进程长期等待的是<strong>抢占式静态优先权优先算法</strong></p>
<p>5、<strong>有新进程进入就绪队列</strong>不是引起操作系统选择新进程的直接原因</p>
<p>6、产生死锁的基本原因是<strong>系统资源不足</strong>和<strong>进程推进顺序不当</strong></p>
<p>7、在多道程序的环境中，不会因竞争<strong>可被抢占的资源</strong>而产生死锁</p>
<h1 id="四、存储器管理"><a href="#四、存储器管理" class="headerlink" title="四、存储器管理"></a>四、存储器管理</h1><h2 id="1、存储系统结构"><a href="#1、存储系统结构" class="headerlink" title="1、存储系统结构"></a>1、存储系统结构</h2><p><img src="https://s2.loli.net/2022/06/02/KG2rnXfhN7SEspu.png" alt="image-20220602185202370"></p>
<ul>
<li>寄存器、高速缓存、主存储器、磁盘缓存：属于操作系统存储管理的管辖范畴，掉电后存储信息不再存在</li>
<li>磁盘、可移动存储介质：设备管理和文件系统的管辖范畴，存储信息长期保存</li>
</ul>
<blockquote>
<p>高速缓存能有效提升指令访问内存的原因：<strong>程序执行的局部性原理</strong></p>
<p>参与指令执行的存储器：<strong>寄存器、高速缓存、内存</strong></p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li>逻辑地址（相对地址、虚地址）</li>
<li>物理地址（绝对地址、实地址）</li>
<li>名空间： 一个用高级语言编制的源程序，我们说它存在于由程序员建立的符号名字空间（简称名空间）</li>
<li>地址空间：程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。</li>
<li>存储空间：主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/02/KiVhbq6vLTm1FoW.png" alt="image-20220602190927329"></p>
<ul>
<li>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。</li>
<li>一个作业在编译、装入前后存在于不同的空间。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/02/67f8rDHbLMGzJcK.png" alt="image-20220602191156473"></p>
<p>编辑—编译—链接—装入—运行</p>
<h2 id="2、程序的装入和链接"><a href="#2、程序的装入和链接" class="headerlink" title="2、程序的装入和链接"></a>2、程序的装入和链接</h2><h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>编译时即产生实际存储地址的目标代码，程序中的逻辑地址与实际内存地址完全相同</p>
<p>通常采用符号地址，编译或汇编时再将符号地址转换为绝对地址（转换在链接时候进行）  </p>
<p>缺点：只能将目标模块装入到内存中实现指定的位置，这只适用于单道程序环境</p>
<h4 id="可重定位装入方式"><a href="#可重定位装入方式" class="headerlink" title="可重定位装入方式"></a>可重定位装入方式</h4><p>装入内存时，相对地址需要做出修改得到正确的物理地址</p>
<p>静态重定位：物理地址=相对地址+内存中的起始地址，地址变换在装入内存时一次完成，且以后不能移动</p>
<h4 id="动态运行时的装入方式"><a href="#动态运行时的装入方式" class="headerlink" title="动态运行时的装入方式"></a>动态运行时的装入方式</h4><p>动态重定位：装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。即在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换</p>
<p>利用<strong>重定位寄存器</strong>实现：值由进程调度根据作业分配到的存储空间起始地址来设定的，将有效地址与重定位寄存器中的内容相加后得到的值作为访问主存的地址</p>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p>
<p>根据<strong>链接时间的不同</strong>，可把链接分成三种</p>
<h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。</p>
<p>解决问题：</p>
<ul>
<li>修改相对地址</li>
<li>变换外部调用符号</li>
</ul>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>在装入内存时再链接需要的其他模块</p>
<p>优点：</p>
<ul>
<li>便于对目标模块进行修改和更新</li>
<li>实现了对目标模块共享</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/02/b6FsKGw5vE4ByPV.png" alt="image-20220602212609976"></p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>在执行过程中，若发现一个被调用的模块尚未装入内存时，由操作系统去找到该模块，将它装入内存，并链接到调用模块上</p>
<p>优点：</p>
<p>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p>
<blockquote>
<p>当程序经过编译或者汇编后，形成了一种由机器指令组成的集合，被称为目标程序</p>
<p>若调用指令LOAD A Data，经动态重新定位后，其对应指令代码保持不变</p>
</blockquote>
<h2 id="3、连续分配存储管理方式"><a href="#3、连续分配存储管理方式" class="headerlink" title="3、连续分配存储管理方式"></a>3、连续分配存储管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存分为系统区和用户区，系统区仅提供给OS使用，用户区仅装有一道用户程序，整个内存的用户空间由该程序独占</p>
<p>只适用于单用户、单任务</p>
<h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>有n个分区，则可同时装入n个作业/任务。</p>
<p><strong>1、分区大小</strong></p>
<ul>
<li>相等：缺乏灵活性</li>
<li>不相等：利用率高</li>
</ul>
<p><strong>2、内存分配</strong></p>
<p>将分区按大小排序，并将其地址、分配标识作记录</p>
<p><strong>3、特点</strong></p>
<p>简单，有碎片（内零头）</p>
<blockquote>
<p>内零头：分配给进程没用到的空间</p>
<p>外零头：不能分配给任何一个进程的空间</p>
</blockquote>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ol>
<li>空闲分区表</li>
<li>空闲分区链</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/02/rFcSmMQEXjY97bx.png" alt="image-20220602222126659"></p>
<h4 id="顺序分配算法"><a href="#顺序分配算法" class="headerlink" title="顺序分配算法"></a>顺序分配算法</h4><p><strong>1、首次适应算法（First Fit / FF）</strong></p>
<ul>
<li><p>要求：分区按地址递增排序</p>
</li>
<li><p>方法：每次链首开始，直到找到满足大小的空闲分区，分割该分区</p>
</li>
<li><p>特点：有外零头，低址内存使用频繁，查找慢。高地址区保留大分区</p>
</li>
</ul>
<p><strong>2、循环首次适应算法（next fit / NF）</strong></p>
<ul>
<li>方法：从上次找到的空闲分区的下一个开始查找，直到找到满足大小的空闲分区，分割该分区。</li>
<li>特点：空闲分区分布均匀，提高了查找速度；缺乏大的空闲分区</li>
</ul>
<p><strong>3、最佳适应算法（best fit / BF）</strong></p>
<ul>
<li>要求：分区按大小递增排序；分区释放时需插入到适当位置。</li>
<li>方法：从小分区开始，找大小满足要求，但空余最小的分区。</li>
<li>特点：单次分配看似最优，但存在许多难以利用的碎片。总体未必最优。</li>
</ul>
<p><strong>4、最坏适应算法 （worst fit / WF）</strong></p>
<ul>
<li><p>要求：分区按大小递减排序</p>
</li>
<li><p>方法：总是选择最大的分区来分割分配。</p>
</li>
<li><p>特点：缺乏大的空闲分区。对中小作业有利。查找效率高。</p>
</li>
</ul>
<h4 id="分区合并"><a href="#分区合并" class="headerlink" title="分区合并"></a>分区合并</h4><p>（1）上邻空闲区：合并，改大小</p>
<p>（2）下邻空闲区：合并，改大小，首址。</p>
<p>（3）上、下邻空闲区：合并，改大小。</p>
<p>（4）不邻接，则建立一新表项。</p>
<h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><h5 id="1、快速适应算法（分类搜索法）（quick-fit）"><a href="#1、快速适应算法（分类搜索法）（quick-fit）" class="headerlink" title="1、快速适应算法（分类搜索法）（quick fit）"></a>1、快速适应算法（分类搜索法）（quick fit）</h5><p>对于每一类相同容量的空闲分区单独设立一个空闲分区链表；设置管理索引表，每个表项对应一种空闲分区类型，并记录该类空闲分区链表表头指针。</p>
<p>优点：</p>
<ul>
<li>查找效率高</li>
<li>不会对任何分区产生分割，能保留大的分区，也不会产生碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>分区归还主存时算法复杂，系统开销较大</li>
<li>内零头</li>
</ul>
<h5 id="2、伙伴系统（buddy-system）"><a href="#2、伙伴系统（buddy-system）" class="headerlink" title="2、伙伴系统（buddy system）"></a>2、伙伴系统（buddy system）</h5><p>在伙伴系统中，可用内存块的大小为2k(1≤k≤m)</p>
<p>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成k（0 ≤k≤m）个链表。</p>
<p>$$<br>buddy_{k}(x)=\left{\begin{matrix}x+2^{k}(若xMOD~~~2^{k+1}=0)<br> \x-2^{k}(若xMOD~~~2^{k+1}=2^{k})<br>\end{matrix}\right.<br>$$<br><img src="https://s2.loli.net/2022/06/02/zxlQNnPgiKGwVLc.png" alt="image-20220602225047117"></p>
<ul>
<li>优点：分配和回收内存速度快，且不会产生很多小碎片</li>
<li>缺点：内存利用率不高，分配的内存大小为2的幂</li>
</ul>
<h5 id="3、哈希算法"><a href="#3、哈希算法" class="headerlink" title="3、哈希算法"></a>3、哈希算法</h5><p>按照分区链表的大小建立哈希数组，从而快速找到需要大小的空闲分区链表。</p>
<h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><p>引入原因：连续式分配中，总量大于作业大小的多个小分区不能容纳作业。</p>
<p><strong>紧凑</strong></p>
<ul>
<li>通过作业移动将原来分散的小分区拼接成一个大分区</li>
<li>作业的移动需重定位。是动态（因作业已经装入）</li>
</ul>
<p>引入重定位寄存器</p>
<blockquote>
<p>当程序执行时，由相对地址与重定位寄存器中的<strong>起始地址</strong>相加得到物理地址访问内存</p>
</blockquote>
<h2 id="4、对换"><a href="#4、对换" class="headerlink" title="4、对换"></a>4、对换</h2><ul>
<li>以整个进程为单位：整体对换/进程对换</li>
<li>以“页”和“段”为单位：页面对换/分段对换/部分兑换</li>
</ul>
<h3 id="对换空间管理"><a href="#对换空间管理" class="headerlink" title="对换空间管理"></a>对换空间管理</h3><p>外存：</p>
<ul>
<li>文件区：为提高存储空间利用率，采用离散分配方式</li>
<li>对换区：为提高进程换入换出的速度，采用连续分配方式</li>
</ul>
<p>分配算法、对换空间的分配与回收与内存动态分区雷同。</p>
<h3 id="进程换出"><a href="#进程换出" class="headerlink" title="进程换出"></a>进程换出</h3><p>进程选择：</p>
<ul>
<li>先阻塞状态的，后选择就绪的挂起状态优先被换出，但不是一定被换出）</li>
<li>尽量选择优先级低的</li>
<li>考虑内存驻留时间长短</li>
</ul>
<p>换出进程：</p>
<ul>
<li>只能换出<strong>非共享的程序和数据段</strong>，共享段有其他进程使用时不能换出</li>
<li>先申请对换空间，然后启动磁盘将要换出的内容写出，最后才回收内存空间，并修改进程控制块和内存分配表等数据结构</li>
</ul>
<h3 id="进程换入"><a href="#进程换入" class="headerlink" title="进程换入"></a>进程换入</h3><ul>
<li>系统定时地查看所有进程的状态，从中找出就绪状态但已换出的进程；</li>
<li>将其中换出时间最久的进程作为换入进程；</li>
<li>有能满足进程需要的内存时可将之换入。</li>
</ul>
<blockquote>
<p>进程被换出时，非共享的程序段和数据段将被换出到外存</p>
</blockquote>
<h2 id="5、分页存储方式"><a href="#5、分页存储方式" class="headerlink" title="5、分页存储方式"></a>5、分页存储方式</h2><p>离散分配：程序在内存中不一定连续存放</p>
<p>引入原因</p>
<ul>
<li>连续分配会产生内外零头</li>
<li>为解决零头问题要进行紧凑等高开销活动</li>
</ul>
<p>根据基本单位不同：</p>
<ul>
<li>分页存储管理</li>
<li>分段存储管理</li>
<li>段页式存储管理</li>
</ul>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>页面/页 ： 将一个进程的逻辑地址空间分为若干大小相等的片</li>
<li>（物理）块/页框 ： 将内存空间分成与页面相同大小的若干个存储块</li>
<li>为进程分配内存时，以块为单位将进程中的若干个页装入到多个可以不相邻接的物理块中</li>
<li>最后一页不满一块会产生“内零头”（页内碎片）</li>
</ul>
<h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><ul>
<li>页面小：页表长，页面换入换出效率低</li>
<li>页面大：页内碎片增大</li>
<li>应为2的幂，通常为512B~8KB</li>
</ul>
<h3 id="空间组织"><a href="#空间组织" class="headerlink" title="空间组织"></a>空间组织</h3><p><img src="https://s2.loli.net/2022/06/03/ksU7OgEj1PwhlAZ.png" alt="image-20220603112036852"></p>
<p>若逻辑地址空间地址为A，页面大小为L，则页号P和页内地址d：<br>$$<br>P=INT[\frac{A}{L}]<br>\d=[A]MOD~L<br>$$</p>
<h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>页表：每个进程对应一个页表，描述该进程的各页面在内存中的物理块号（还可能有存取控制字段）</li>
<li>作业表：整个系统一张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息</li>
<li>空闲块表：整个系统一张，记录主存当前空闲块</li>
</ul>
<blockquote>
<p>全部页表集中存放在<strong>主存</strong>的系统专用区中，只有系统有权访问页表，保证安全。</p>
</blockquote>
<p><img src="https://s2.loli.net/2022/06/03/2JsyvTUrkxNWIK5.png" alt="image-20220603113510282"></p>
<h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p><strong>硬件机制：实现逻辑地址到物理地址的转换</strong></p>
<p>页表寄存器PTR：存放当前运行的进程的页表在内存中的起始地址，和此进程的页表长度</p>
<p><img src="https://s2.loli.net/2022/06/03/PRFi8umj3OzKGpZ.png" alt="image-20220603114700882"></p>
<p>执行检索前比较页号与页表长度，若页号大于页表长度，则表示本次所访问的地址已超越进程的地址空间，即产生越界中断，未出现则将页表始址与页号和页表项长度的乘积相加，得到物理块号</p>
<h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>分页系统：处理机每次存取指令或数据至少需要访问两次物理内存：</p>
<p><strong>第一次访问页表，第二次存取指令或数据</strong></p>
<p>为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表、TLB(Translation Lookaside Buffer)或联想存储器(Associative Memory)</p>
<p>工作原理：专门保存当前进程最近访问过的一组页表项（类似于高速缓存），根据逻辑地址中的页号，查找快表中是否存在对应的页表项</p>
<ul>
<li>若存在，称为命中(hit)，取出页框号，加上页内偏移量，计算出物理地址</li>
<li>若不存在，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中，并计算物理地址。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/03/wReVMvkObrxWzTF.png" alt="image-20220603144839827"></p>
<p>内存有效访问时间EAT(Effective Access Time)：</p>
<ul>
<li>无快表：EAT = 2t</li>
<li>有快表：EAT=a * λ + ( t + λ )(1-a) + t = 2t + λ – t x a</li>
</ul>
<p>其中，t为一次内存访问需要时间，λ 为查找快表所需时间，a为命中率</p>
<h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>大逻辑地址空间，页表非常大，需要占用相当大的内存空间</p>
<ol>
<li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题（即引入两级页表）</li>
<li>只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入</li>
</ol>
<p>对于4GB的进程，若采用二级页表，则对应的二级页表结构如图：</p>
<p><img src="https://s2.loli.net/2022/06/03/Qlo8FU9YgT5mz4w.png" alt="image-20220603150128825"></p>
<p>增设外层页表寄存器，用于存放外层页表的始址</p>
<p>利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，再利用指定页表分页的索引，找到指定的页表项，即该页在内存的物理块号</p>
<p><img src="https://s2.loli.net/2022/06/03/VaQb6E1neIwrFtS.png" alt="image-20220603153130046"></p>
<p>对于64位的机器就需采用多级页表</p>
<h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>现代计算机系统中通常允许一个进程的逻辑地址空间非常大</p>
<p>反置页表为每一个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所属进程的标志符。</p>
<p>地址变换：根据进程标志符和页号检索反置页表，如果找到则页表项中的序号就是该页所在的物理块号。如果检索未找到则失败或者必须请求调页。</p>
<p>虽然反置页表占用内存空间可以更小，但是仍然需要为每个进程保存完整的页表，以便实现请求调页。这样无法真正节约内存。</p>
<blockquote>
<p>反置页表不适用于大物理内存</p>
</blockquote>
<h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul>
<li>彻底消除了外零头，仅存在很少的内零头，提高了内存利用率</li>
<li>分页操作由系统自动进行，一个页面不能实现某种逻辑功能。用户看到的逻辑地址是一维的，无法调试执行其中的某个子程序或子函数。</li>
<li>采用分页技术不易于实现存储共享，也不便于程序的动态链接。</li>
</ul>
<h2 id="6、分段存储管理方式"><a href="#6、分段存储管理方式" class="headerlink" title="6、分段存储管理方式"></a>6、分段存储管理方式</h2><h3 id="引入原因-1"><a href="#引入原因-1" class="headerlink" title="引入原因"></a>引入原因</h3><ul>
<li>方便编程</li>
<li>信息共享</li>
<li>信息保护</li>
<li>动态增长</li>
<li>动态链接</li>
</ul>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>作业地址空间按逻辑信息的完整性被划分为若干个段，每段有段名/段号，从0开始编址，段内的地址空间是连续的</p>
<p>地址空间的访问：段名+段内地址</p>
<p><img src="https://s2.loli.net/2022/06/03/TK1BW7uJVjd8Exv.png" alt="image-20220603160918810"></p>
<h3 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h3><p>实现分段管理的关键：保证分段（二维）地址空间中的一个作业在线性（一维）的存储空间中正常运行</p>
<p>建立段映射表（段表）—每个段在表中占有一个表项，记录了该段在内存中的起始地址（基址）和段的长度</p>
<p>作用：实现从逻辑段到物理内存区的映射</p>
<h3 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h3><ol>
<li>根据段表寄存器的内容找到该作业的段表地址</li>
<li>利用有效地址中的段号作为检索段表的索引，得到该段在主存的起始地址</li>
<li>将段的主存起始地址和位移量W相加，即得访问主存的物理地址</li>
</ol>
<h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>优点：</p>
<ul>
<li>没有内碎片，外碎片可以通过内存紧凑来消除</li>
<li>便于改变进程占用空间大小</li>
</ul>
<p>缺点：</p>
<ul>
<li>进程全部装入内存</li>
</ul>
<h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p><strong>分页系统中：</strong></p>
<p>对于数据页面，实现起来比较简单。因为这个数据页面可以安排在诸作业地址空间中的任何一页面上。</p>
<p>对于代码页面，它必须把共享的代码安排到所有共享它的作业地址空间中相同页号的页面中。即共享代码所在的地址空间必须重叠</p>
<p>之所以有这种要求，是因为一个作业在运行前必须链接好，而链接后，一个例程的所占页号就确定了。如果其它作业要共享该例程，则必须使它具有相同的页号，才能正确运行。</p>
<p><strong>分段系统中：</strong></p>
<p>分段的共享是通过两个作业段表的相应表目都指向COS过程的同一物理副本来实现的。</p>
<p>说明：段号是在动态链接过程中分配的，而且，系统不可能事先知道某个过程将为哪些作业所调用，因此，一个公共过程不一定也无需赋相同的段号</p>
<h2 id="7、段页式存储管理方式"><a href="#7、段页式存储管理方式" class="headerlink" title="7、段页式存储管理方式"></a>7、段页式存储管理方式</h2><p><img src="https://s2.loli.net/2022/06/03/7EKgYUmfCwcb2FJ.png" alt="image-20220603162444264"></p>
<p> 先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。</p>
<p>地址空间由段号S、段内页号P和页内相对地址（位移量）W构成</p>
<ul>
<li>首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表。</li>
<li>然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址。</li>
<li>再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号。</li>
<li>最后，用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址。 </li>
</ul>
<p><img src="https://s2.loli.net/2022/06/03/gKsBP16AXwCyrND.png" alt="image-20220603163053657"></p>
<p>每访问一次数据，需访问三次内存：</p>
<ol>
<li>访问内存中的段表</li>
<li>访问内存中的页表</li>
<li>访问相应数据</li>
</ol>
<p>可以设置快表，表项包括段号，页号，物理块号</p>
<blockquote>
<p>引入分段存储管理的原因不包括提升内存利用率</p>
</blockquote>
<h2 id="8、分页分段区别"><a href="#8、分页分段区别" class="headerlink" title="8、分页分段区别"></a>8、分页分段区别</h2><p>（1）</p>
<p>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。</p>
<p>段则是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 </p>
<p>（2）</p>
<p>页的大小固定且由系统决定，因而在系统中只能有一种大小的页面</p>
<p>段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p>
<p>（3）</p>
<p>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；</p>
<p>分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。   </p>
<p>段页式的虚拟空间地址也是二维的</p>
<p>（4）</p>
<p>分页不利于实现程序的共享和保护，分段利于实现</p>
<h2 id="9、连续分配vs离散分配"><a href="#9、连续分配vs离散分配" class="headerlink" title="9、连续分配vs离散分配"></a>9、连续分配vs离散分配</h2><table>
<thead>
<tr>
<th>技术性能</th>
<th>连续分配</th>
<th>离散分配</th>
</tr>
</thead>
<tbody><tr>
<td>大批量数据的存取速度</td>
<td>较快</td>
<td>较慢</td>
</tr>
<tr>
<td>机制的复杂性</td>
<td>较简单</td>
<td>较复杂</td>
</tr>
<tr>
<td>内存碎片</td>
<td>较大</td>
<td>较小</td>
</tr>
<tr>
<td>实现虚拟技术</td>
<td>较难</td>
<td>较易</td>
</tr>
<tr>
<td>实现动态链接</td>
<td>较难</td>
<td>较易</td>
</tr>
</tbody></table>
<h1 id="五、虚拟存储器"><a href="#五、虚拟存储器" class="headerlink" title="五、虚拟存储器"></a>五、虚拟存储器</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>常规存储管理方式的特征：</p>
<ul>
<li>“一次性”：要求将一个作业全部装入内存中才能运行</li>
<li>“驻留性”：作业装入后一直驻留内存直到作业完成</li>
</ul>
<p>一次性和驻留性严重降低内存利用率，减少系统吞吐量。</p>
<p>解决方法：</p>
<ul>
<li>物理扩充</li>
<li>逻辑扩充<ul>
<li>覆盖：应用程序手动把需要的指令和数据保存在内存中</li>
<li>对换：操作系统自动把暂时不能执行的程序保存到外存中</li>
<li>虚拟存储</li>
</ul>
</li>
</ul>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序执行的局部性原理：程序的执行总是呈现局部性。即，在一个较短的时间段内，程序的执行仅限于某个部分；相应的，它所访问的存储空间也局限于某个区域。</p>
<p>因此，只要保证进程执行所需的部分程序和数据驻留在内存，一段时间内进程都能顺利执行。</p>
<ul>
<li>时间局限性：存在大量循环操作</li>
<li>空间局限性：访问地址集中在一定的范围内</li>
</ul>
<h3 id="虚拟存储器定义与特征"><a href="#虚拟存储器定义与特征" class="headerlink" title="虚拟存储器定义与特征"></a>虚拟存储器定义与特征</h3><p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p>
<ul>
<li>逻辑容量由内存容量和外存容量之和所决定</li>
<li>运行速度接近于内存速度，而每位的成本却又接近于外存</li>
</ul>
<p>特征</p>
<ol>
<li>多次性</li>
<li>对换性</li>
<li>虚拟性</li>
</ol>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>（1）<strong>请求分页存储管理方式</strong></p>
<ol>
<li>硬件支持<ul>
<li>请求分页的页表机制上增加若干项，作为请求分页的数据结构</li>
<li>缺页中断机构：当要访问的页面尚未调入内存时，便产生缺页中断，请求调页</li>
<li>地址变换机构：虚地址到物理地址转换</li>
</ul>
</li>
<li>软件<ul>
<li>实现请求调页的软件</li>
<li>实现页面置换的软件</li>
</ul>
</li>
</ol>
<p>（2）<strong>请求分段系统</strong></p>
<ul>
<li>请求分段的段表机制，这是在纯分段的段表机制基础上增加若干项而形成的</li>
<li>缺段中断机构</li>
<li>地址变换机构</li>
<li>相应软件支持</li>
</ul>
<p>（3）<strong>段页式虚拟存储系统</strong></p>
<h2 id="2、请求分页存储管理方式"><a href="#2、请求分页存储管理方式" class="headerlink" title="2、请求分页存储管理方式"></a>2、请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>建立在基本分页基础上</p>
<p>主要数据结构是页表</p>
<p>页表项：</p>
<p><img src="https://s2.loli.net/2022/06/03/EtF2Gl3sp7HuMQR.png" alt="image-20220603202056830"></p>
<ul>
<li><strong>状态位</strong>：也称存在位，标志该页是否驻留内存。 </li>
<li><strong>访问位</strong>：记录一段时间内该页被访问的情况，如一段时间内该页被访问的次数或者多长时间未被访问。</li>
<li><strong>修改位</strong>：标记该页是否被修改过。注：为减少置换开销，通常选择未被修改过的页面置换。 </li>
<li><strong>外存地址</strong>：用于记录该页在外存上的存储地址。</li>
</ul>
<h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存。 </p>
<p>地址转换时，检查页面的页表项中的存在位，如果为0，则产生一个缺页中断。</p>
<p>由于缺页中断的独特性，系统中需要提供硬件寄存器或其它机构，在出现页面故障时，保存部分完成的指令的状态。此外，还需要使用一条特殊的返回指令，确保在出现缺页中断处恢复该指令的处理。</p>
<h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><img src="https://s2.loli.net/2022/06/03/JpjcdMFHGEwKSQ4.png" alt="image-20220603204521684"></p>
<h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol>
<li>最小物理块数：保证进程正常运行所需的最小物理块数</li>
<li>物理块的分配策略<ul>
<li>固定分配局部置换</li>
<li>可变分配全局置换</li>
<li>可变分配局部置换</li>
</ul>
</li>
</ol>
<p>（1）<strong>固定分配局部置换</strong></p>
<p>为每个进程分配一定数目的物理块，在整个运行期间都不再改变</p>
<p>困难：应为每个进程分配多少物理块难以确定</p>
<p>（2）<strong>可变分配全局置换</strong>（常用）</p>
<p>在采用这种策略时，先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个空闲物理块队列。</p>
<p>当某进程发现缺页时，由系统从空闲物理块队列中，取出一个物理块分配给该进程，并将欲调入的（缺）页装入其中</p>
<blockquote>
<p>可能引起抖动问题</p>
</blockquote>
<p>（3）<strong>可变分配局部置换</strong></p>
<p>为每个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其它进程运行</p>
<p>在进程运行过程中统计进程的缺页率，如果缺页率高，则为其增加一定的内存页，否则适当减少其内存的页面数</p>
<p>困难：对进程的缺页情况统计需要额外开销</p>
<h3 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h3><p>（1）平均分配算法</p>
<p>（2）按比例分配</p>
<p>按进程的页面数占页面数总和的比例进行分配</p>
<p>（3）考虑优先权的分配算法</p>
<p>将内存中可供分配的所有物理块分为两部分，一部分按比例分配，另一部分根据各进程的优先权，适当增加其相应份额后，分配给各进程</p>
<h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><p>1、何时调入</p>
<ul>
<li>预调页：当进程创建时，预先为进程装入多个页面。 缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。</li>
<li>请求调页：仅当进程执行过程中，通过检查页表发现相应页面不在内存时，才装入该页面。</li>
</ul>
<blockquote>
<p>预调页总比请求调页高效</p>
</blockquote>
<p>2、何处调入</p>
<p>外存分为两部分：</p>
<ul>
<li>用于存放文件的文件区</li>
<li>用于存放对换页面的对换区</li>
</ul>
<p>三种情况</p>
<ul>
<li>系统拥有足够的对换区空间：进程运行前需将全部有关文件从文件区拷贝到对换区。</li>
<li>系统缺少足够的对换区空间：这时凡是不会被修改的文件，都直接从文件区调入； 而当换出这些页面时，若未被修改则直接丢弃，以后再调入时，仍从文件区调入。 但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li>
<li>UNIX方式：由于与进程有关的文件都放在文件区，应从文件区调入。 凡是未运行过的页面，都应从文件区调入。 而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。  允许页面共享</li>
</ul>
<h3 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h3><p><img src="https://s2.loli.net/2022/06/03/E2FQTIrxg86ap7j.png" alt="image-20220603204521684"></p>
<blockquote>
<p>整个页面的调入过程对用户是透明的</p>
</blockquote>
<h2 id="3、页面置换算法"><a href="#3、页面置换算法" class="headerlink" title="3、页面置换算法"></a>3、页面置换算法</h2><h3 id="最佳置换算法（Optimal）"><a href="#最佳置换算法（Optimal）" class="headerlink" title="最佳置换算法（Optimal）"></a>最佳置换算法（Optimal）</h3><p>所选择的被淘汰页面，将是以后永不使用的，或是在最长(未来)时间内不再被访问的页面</p>
<p>理想化的算法，具有最好的性能，但很难实现</p>
<h3 id="先进先出算法（FIFO"><a href="#先进先出算法（FIFO" class="headerlink" title="先进先出算法（FIFO)"></a>先进先出算法（FIFO)</h3><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰 </p>
<h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p>选择最近最久未使用的页面予以淘汰（Least Recently Used）</p>
<p>该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</p>
<p>要求有硬件支持：寄存器/栈</p>
<p><strong>寄存器实现：</strong></p>
<p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：                 </p>
<p>R=Rn-1Rn-2Rn-3···R2R1RO    </p>
<p>当进程访问某物理块时，要将相应寄存器的最高位Rn-1位置成1。</p>
<p>系统每隔一定时间（例如100  ms）将寄存器右移一位。     </p>
<p>如果我们把n位寄存器的数看作是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。 </p>
<p><img src="https://s2.loli.net/2022/06/03/kjvtlNuZsLwOba2.png" alt="image-20220603213919654"></p>
<p>此时应置换第3个页面</p>
<p><strong>栈实现：</strong></p>
<p>利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。 </p>
<p>栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。 </p>
<h3 id="最少使用算法（LFU-算法"><a href="#最少使用算法（LFU-算法" class="headerlink" title="最少使用算法（LFU)算法"></a>最少使用算法（LFU)算法</h3><p>选择自某时刻开始以来，访问次数最少的页面予以淘汰</p>
<h3 id="Clock置换算法（NRU）"><a href="#Clock置换算法（NRU）" class="headerlink" title="Clock置换算法（NRU）"></a>Clock置换算法（NRU）</h3><h4 id="简单Clock置换算法"><a href="#简单Clock置换算法" class="headerlink" title="简单Clock置换算法"></a>简单Clock置换算法</h4><p>循环地检查各页面的使用情况，又称为<strong>最近未使用算法NRU</strong>（Not Recently Used）</p>
<p>为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。 </p>
<p>当某页被访问时，其访问位被置1。</p>
<p> 置换程序从上次停止位置开始检查页面的访问位。 </p>
<ul>
<li>如果是0，就选择该页换出；</li>
<li>若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会。</li>
</ul>
<h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>在置换范围内首选在最近没有被使用过、在驻留内存期间没有被修改过的页面作为被置换页面</p>
<p>由访问位A和修改位M可以组合成下面四种类型的页面：   </p>
<ul>
<li> 1类（A=0，M=0：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。    </li>
<li> 2类（A=0，M=1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。    </li>
<li> 3类（A=1，M=0）：最近已被访问，但未被修改：该页有可能再被访问。   </li>
<li> 4类（A=1，M=1）：最近已被访问且被修改，该页可能再被访问。 </li>
</ul>
<p>执行过程：</p>
<p>（1）从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。    </p>
<p>（2）如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找A=0且M＝1的第二类页面，将所遇到的第一个这类页面作为淘汰页。<strong>在第二轮扫描期间，将所有扫描过的页面的访问位都置0</strong>。     </p>
<p>（3）如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步，如果仍失败，必要时再重复第二步，此时就一定能找到被淘汰的页 </p>
<h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p>最少使用（LFU： Least Frequently Used）算法</p>
<p>页面缓冲算法（PBA: Page Buffering Algorithm)</p>
<h3 id="访问内存有效时间"><a href="#访问内存有效时间" class="headerlink" title="访问内存有效时间"></a>访问内存有效时间</h3><p>三种情况：</p>
<p>（1）被访问页在内存中，且对应页表项在快表中</p>
<p>​    EAT = λ + t     </p>
<p> λ 是查找快表时间，t为访问实际物理内存需要的时间</p>
<p> (2) 被访问页在内存，但对应的页表项不在快表中：</p>
<p>查找快表，查找页表，修改快表，修改页表</p>
<p> EAT = 2 * (λ + t) </p>
<p>(3) 被访问页不在内存中 ：    EAT = ε + 2 * (λ + t)        </p>
<p>ε 为缺页中断的处理时间</p>
<p>再考虑快表命中率a，访问缺页率f</p>
<p>EAT=查找快表时间+a * 根据物理地址访存时间+（1-a）* [查找页表时间+f * (处理缺页时间+查找快表时间+根据物理地址访存时间)+（1-f）* (修改快表时间+根据物理地址访存时间)]      </p>
<p>EAT = λ + a<em>t + (1-a)</em>[ t + f * (ε + λ  + t) + (1-f) * (λ  + t) ]</p>
<p>若没有快表，λ和a都为0</p>
<p>EAT = t + f * (ε  +t)  + (1 – f) * t</p>
<h3 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h3><p>如果成功访问的次数为S，访问页面发生缺页的次数为F，则缺页率为：f = F / （S + F）</p>
<p>影响因素：</p>
<ul>
<li>页面大小，页面越大越小；</li>
<li>进程所分配的物理页数，越多越少； </li>
<li>页面置换算法；</li>
<li>程序的访问局部性。</li>
</ul>
<h2 id="4、抖动与工作集"><a href="#4、抖动与工作集" class="headerlink" title="4、抖动与工作集"></a>4、抖动与工作集</h2><p>抖动：如果运行进程的大部分时间都用于页面的换入/换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸。</p>
<p>分为：</p>
<ul>
<li>局部抖动</li>
<li>全局抖动</li>
</ul>
<p>产生原因：</p>
<ul>
<li>进程分配的物理块太少</li>
<li>置换算法选择不当</li>
<li>全局置换使抖动传播</li>
</ul>
<p>工作集略·</p>
<h2 id="5、请求分段存储管理方式"><a href="#5、请求分段存储管理方式" class="headerlink" title="5、请求分段存储管理方式"></a>5、请求分段存储管理方式</h2><h3 id="段表机制"><a href="#段表机制" class="headerlink" title="段表机制"></a>段表机制</h3><p>在请求分段式管理中所需的主要数据结构是段表，段表项有新的扩展。</p>
<p><img src="https://s2.loli.net/2022/06/03/Wltv6QOq91aoHId.png" alt="image-20220603221508144"></p>
<h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p><img src="https://s2.loli.net/2022/06/03/Akv6GxpElayjQcm.png" alt="image-20220603221544218"></p>
<h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><img src="https://s2.loli.net/2022/06/03/bcqKT6PUGznMBpW.png" alt="image-20220603221616752"></p>
<h3 id="共享段的分配与回收"><a href="#共享段的分配与回收" class="headerlink" title="共享段的分配与回收"></a>共享段的分配与回收</h3><p>简单来说就是分配的时候count+1，回收的时候count-1</p>
<h3 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h3><p>（1）越界检查</p>
<p>（2）存取控制检查</p>
<p>（3）环保护机构</p>
<p>低编号的环具有高优先权。OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序在外环上。</p>
<p>基本原则：</p>
<ul>
<li>一个程序可以访问驻留在相同环或较低特权环中的数据； </li>
<li>一个程序可以调用驻留在相同环或较高特权环中的服务。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/03/kfeV1iPUSL4vqMl.png" alt="image-20220603222232692"></p>
<h2 id="6、做题"><a href="#6、做题" class="headerlink" title="6、做题"></a>6、做题</h2><p>1、由于有了虚拟存储器，于是允许用户使用比内存更大的地址空间</p>
<p>2、状态位-&gt;程序访问；修改位-&gt;换出页面；访问位-&gt;置换算法;外存始址-&gt;调入页面</p>
<p>3、Belady现象：当分配到的内存块数增加时，缺页中断的次数有可能反而增加；-&gt;FIFO</p>
<p>4、凡未装入过内存的页都应从<strong>文件区</strong>调入，已运行过的页主要从<strong>对换区</strong>调入，有时也从<strong>页面缓冲区</strong>调入</p>
<p>5、虚拟存储器的功能由<strong>软硬件结合</strong>完成。在虚拟存储器系统中，采用<strong>高速缓冲存储器</strong>提高<strong>动态地址翻译</strong>的速度</p>
<p>6、Linux采用<strong>请求分页</strong>的存储管理方式，采用<strong>伙伴系统算法</strong>进行页框的分配和回收</p>
<h1 id="六、输入输出系统"><a href="#六、输入输出系统" class="headerlink" title="六、输入输出系统"></a>六、输入输出系统</h1><h2 id="1、I-O系统简介"><a href="#1、I-O系统简介" class="headerlink" title="1、I/O系统简介"></a>1、I/O系统简介</h2><ul>
<li><p>设备管理的对象：主要是I/O设备。 </p>
</li>
<li><p>设备管理的基本任务：完成用户提出的I/O请求，提高I/O速率以及改善I/O设备的利用率。  </p>
</li>
<li><p>设备管理的主要功能有：缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。 </p>
</li>
<li><p>I/O系统基本功能：</p>
<ul>
<li>设备管理</li>
<li>设备映射</li>
<li>设备驱动</li>
<li>I/O缓冲区的管理</li>
</ul>
</li>
<li><p>通用设备管理分层模型</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/04/4p6n7fSOvUGFs9R.png" alt="image-20220604145914720"></p>
<p>设备通常通过数据信号线、状态信号线、控制信号线与设备控制器连接</p>
<p><strong>设备控制器</strong></p>
<ul>
<li>设备控制器是CPU与I/O设备之间的接口，它接收从CPU发来的命令，并去控制I/O设备工作，以使处理机从繁杂的设备控制事务中解脱出来。</li>
<li>设备控制器主要职责是控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。 </li>
<li>若控制器可连接多个设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。 </li>
</ul>
<p><strong>I/O通道</strong></p>
<p> I/O通道设备的引入目的是使一些原来由CPU处理的I/O任务转由通道来承担，从而把CPU从繁杂的I/O任务中解脱出来。  </p>
<p>采用通道有以下特点：</p>
<ol>
<li> DMA（直接存储器存取）方式显著地减少了CPU的干预。</li>
<li> 只需向I/O通道发送一条I/O指令，即可完成一组相关的读（或写）操作及有关控制。</li>
<li> 可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</li>
</ol>
<h2 id="2、中断处理程序"><a href="#2、中断处理程序" class="headerlink" title="2、中断处理程序"></a>2、中断处理程序</h2><p>中断和陷入—CPU外部事件和内部事件导致</p>
<p>基本概念：</p>
<ul>
<li>中断源</li>
<li>中断请求</li>
<li>中断响应</li>
<li>关中断/开中断</li>
<li>中断屏蔽</li>
</ul>
<p>中断处理层主要工作：</p>
<ul>
<li>进行进程上下文的切换</li>
<li>对处理中断信号源进行测试</li>
<li>读取设备状态和修改进程状态等</li>
</ul>
<p>中断处理程序的过程</p>
<ul>
<li>测定是否有未响应的中断信号</li>
<li>保护被中断进程的CPU环境</li>
<li>转入相应的设备处理程序</li>
<li>中断处理</li>
<li>恢复被中断进程的现场</li>
</ul>
<h2 id="3、设备驱动程序"><a href="#3、设备驱动程序" class="headerlink" title="3、设备驱动程序"></a>3、设备驱动程序</h2><p>对I/O设备的控制方式</p>
<h3 id="使用轮询的可编程I-O方式"><a href="#使用轮询的可编程I-O方式" class="headerlink" title="使用轮询的可编程I/O方式"></a>使用轮询的可编程I/O方式</h3><ul>
<li>程序I/O（Programmed  I/O）方式，或称为忙 – 等待方式。处理机向控制器发出一条I/O指令启动输入设备输入数据时，同时把busy置为1，再不断循环测试busy。 </li>
<li>Busy=0，完成输入，处理机读取数据，送入指定单元，完成一次I/O。</li>
<li>对状态寄存器中的忙/闲标志busy的检查实现控制。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/04/9IhUSMDtqlZrgYz.png" alt="image-20220604152035857"></p>
<p>CPU的绝大部分时间都处在等待I/O设备完成数据I/O的循环测试中，会造成对CPU的极大浪费</p>
<h3 id="使用中断的可编程I-O方式"><a href="#使用中断的可编程I-O方式" class="headerlink" title="使用中断的可编程I/O方式"></a>使用中断的可编程I/O方式</h3><p><img src="https://s2.loli.net/2022/06/04/pJvhkPnxaFiyNVf.png" alt="image-20220604152046148"></p>
<p>效率高</p>
<h3 id="直接存储器访问方式"><a href="#直接存储器访问方式" class="headerlink" title="直接存储器访问方式"></a>直接存储器访问方式</h3><p>（1）DMA控制方式</p>
<p>减少了CPU对I/O的干预</p>
<p>特点：</p>
<ol>
<li>数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；</li>
<li>所传送的数据是从设备直接送入内存的，或者相反； </li>
<li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</li>
</ol>
<p>提高了CPU与I/O设备的并行操作程度</p>
<p><img src="https://s2.loli.net/2022/06/04/sfCBdySHANT9O4P.png" alt="image-20220604152308659"></p>
<h3 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h3><ul>
<li>I/O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。 </li>
<li>可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。 </li>
</ul>
<p><img src="https://s2.loli.net/2022/06/04/5qOX3NgfWHozByC.png" alt="image-20220604152516703"></p>
<p><strong>中断vsDMA</strong></p>
<p>1、中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理；</p>
<p>   DMA方式则是以数据块为单位传输的，在所要求传送的数据块全部传送开始或结束时需要CPU的干预，这样大大减少CPU进行中断处理的次数。</p>
<p>   DMA方式不需CPU干预传送操作，不占用CPU任何资源，中断方式是程序切换，每次操作需要保护和恢复现场，中断次数多，CPU需要花较多的时间处理中断，中断次数多也会导致数据丢失。</p>
<p>2、中断方式的数据传送方向是由设备到CPU再到内存，或者相反。</p>
<p>   DMA方式的数据传送则是将所传输的数据由设备直接送入内存，或是由内存直接送到设备。</p>
<h2 id="4、与设备无关的I-O软件"><a href="#4、与设备无关的I-O软件" class="headerlink" title="4、与设备无关的I/O软件"></a>4、与设备无关的I/O软件</h2><p>为了实现<strong>设备独立性</strong>而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>这两个概念。</p>
<p>在应用程序中，使用逻辑设备名称来请求使用某类设备；</p>
<p>而系统在实际执行时，还必须使用物理设备名称。</p>
<p>设备独立性好处：</p>
<ol>
<li>设备分配时的灵活性</li>
<li>易于实现I/O重定向</li>
</ol>
<p>由于驱动程序与硬件紧密相关，为了实现设备独立性，必须在驱动程序之上设置一层软件，称为设备独立性软件</p>
<p>主要功能：</p>
<ol>
<li>公有操作<ul>
<li>对独立设备的分配与回收</li>
<li>将逻辑设备名映射为物理设备名，进一步可以找到相应物理设备的驱动程序；</li>
<li>对设备进行保护，禁止用户直接访问设备；</li>
<li>缓冲管理</li>
<li>差错控制</li>
<li>提供独立于设备的逻辑块</li>
</ul>
</li>
<li>向用户层（或文件层）软件提供统一接口</li>
</ol>
<h2 id="5、虚拟设备域SPOOLing技术"><a href="#5、虚拟设备域SPOOLing技术" class="headerlink" title="5、虚拟设备域SPOOLing技术"></a>5、虚拟设备域SPOOLing技术</h2><p>虚拟设备技术是指把每次仅允许一个进程使用的物理设备，改造为能同时供多个进程共享的虚拟设备的技术，或者说将一个物理设备变为多个对应的逻辑设备。</p>
<p><strong>SPOOLing技术也称假脱机操作，是指在多道程序的环境下，利用多道程序中的一道或两道程序来模拟外围控制机。从而在联机的条件下实现脱机I/O的功能。</strong></p>
<p><strong>SPOOLing系统的组成</strong></p>
<ol>
<li>输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</li>
<li>输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</li>
<li>输入进程SPi和输出进程SP0。这里利用两个进程来模拟脱机I/O时的外围控制机。其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备上。</li>
<li>井管理程序。用于控制作业与磁盘井之间信息的交换</li>
</ol>
<p><strong>SPOOLing系统的特点</strong></p>
<ol>
<li>提高了I/O的速度</li>
<li>将独占设备改造为共享设备</li>
<li>实现了虚拟设备功能</li>
</ol>
<p><strong>假脱机打印机系统</strong></p>
<ol>
<li>磁盘缓冲区</li>
<li>打印缓冲区</li>
<li>假脱机管理进程和假脱机打印进程</li>
</ol>
<p>两件事：</p>
<ul>
<li>在输出井中为之申请一个空闲的磁盘块区，并将要打印的数据送入其中</li>
<li>为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，然后将表挂到假脱机文件队列上</li>
</ul>
<h2 id="6、缓冲区管理"><a href="#6、缓冲区管理" class="headerlink" title="6、缓冲区管理"></a>6、缓冲区管理</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><ol>
<li>缓和CPU与I/O设备速度不匹配的矛盾</li>
<li>减少对CPU的中断频率</li>
<li>提高CPU和I/O设备之间的并行性</li>
</ol>
<h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul>
<li>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</li>
<li>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</li>
<li>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。</li>
</ul>
<h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><ul>
<li>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</li>
<li>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</li>
<li>处理一块数据平均耗时Max(C,T)+M</li>
</ul>
<blockquote>
<p>从磁盘把一块数据输入到缓冲区的时间为T</p>
<p>OS将该缓冲区的数据传送到用户区的时间为M</p>
<p>CPU对这一块数据的处理时间为C</p>
</blockquote>
<p>缺点：</p>
<ol>
<li>生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未取出缓冲区的数据，即使生产者又生产出了新的数据，也无法将它送到缓冲区</li>
<li>若两台机器之间只有单缓冲，则它们之间在任一时刻只能实现单方向的数据传输</li>
</ol>
<h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><ul>
<li>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</li>
<li>对一块数据的处理时间max(T,M+C)</li>
</ul>
<h3 id="环形缓存"><a href="#环形缓存" class="headerlink" title="环形缓存"></a>环形缓存</h3><ul>
<li>将多个<strong>大小相等</strong>的缓冲区链接成一个<strong>循环队列</strong>。</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/05/ya3kOQ8NT5SIRKD.png" alt="image-20220605204212300"></p>
<p>使用：</p>
<ol>
<li>Getbuf过程</li>
<li>Releasebuf过程</li>
</ol>
<p><img src="https://s2.loli.net/2022/06/05/KVhpD4qutiRNbol.png" alt="image-20220605204700423"></p>
<p>两种特殊情况：</p>
<ol>
<li>Nexti指针追上Nextg指针，无缓冲区使用，输入进程应阻塞</li>
<li>Nextg指针追上Nexti指针，无装有数据的缓冲区供计算进程使用，计算进程阻塞</li>
</ol>
<h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>系统较大时，循环缓冲要消耗大量内存空间，利用率不高，为了提高缓冲区的利用率，引入了缓冲池</p>
<p>公有缓冲池即可用于输入又可用于输出，在池中设置了多个可供若干个进程共享的缓冲区</p>
<p><strong>与缓冲区区别：</strong></p>
<ul>
<li>缓冲区仅仅是一组内存块的链表</li>
<li>缓冲池是包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区</li>
</ul>
<p><strong>组成：</strong></p>
<ol>
<li>空白缓冲队列emq</li>
<li>输入队列inq</li>
<li>输出队列outq</li>
<li>四种工作缓冲区<ul>
<li>用于收容输入数据的工作缓冲区</li>
<li>用于提取输入数据的工作缓冲区</li>
<li>用于收容输出数据的工作缓冲区</li>
<li>用于提取输出数据的工作缓冲区</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">:</span>互斥信号量</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">:</span>资源信号量</span></span>
<span class="token keyword">void</span> <span class="token function">Getbuf</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> type<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">B</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Takebuf</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">void</span> <span class="token function">Putbuf</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> number<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Addbuf</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="https://s2.loli.net/2022/06/05/OrIgF7NzsfWdBYQ.png" alt="image-20220605204828680">    </p>
<ol>
<li><strong>收容输入</strong>。输入进程可调用Getbuf(emg)过程，从空缓冲队列emq 的队首摘下一空缓冲区，把它作为收容输入工作缓冲区 hin。然后，把数据输入其中，装满后再调用 Putbuf(inq,hin)过程，将它挂在输入队列 inq 队列上。</li>
<li><strong>提取输入</strong>。计算进程可调用 Getbuf(inq)过程，从输入队列 inq 的队首取得一缓冲区，作为提取输入工作缓冲区(sin)，计算进程从中提取数据。计算进程用完该数据后，再调用 Putbuf(emq,sin)过程，将它挂到空缓冲队列emq 上。</li>
<li><strong>收容输出</strong>。计算进程可调用 Getbuf(emq)，从空缓冲队列 emq 的队首取得一空缓冲，作为收容输出工作缓冲区hout。当其中装满输出数据后，又调用 Putbuf(outq,hout)过程，将它挂在outq末尾。 **</li>
<li><strong>提取输出</strong>。输出进程可调用 Getbuf(outq)过程，从输出队列的队首取得一装满输出数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完后，再调用 Putbuf(emq,sout) 过程，将它挂在空缓冲队列末尾。</li>
</ol>
<h2 id="7、磁盘系统与磁盘调度"><a href="#7、磁盘系统与磁盘调度" class="headerlink" title="7、磁盘系统与磁盘调度"></a>7、磁盘系统与磁盘调度</h2><h3 id="磁盘系统"><a href="#磁盘系统" class="headerlink" title="磁盘系统"></a>磁盘系统</h3><p>提高磁盘I/O速度的主要途径： </p>
<p>（1）选择性能好的磁盘</p>
<p>（2）采用好的<strong>磁盘调度算法</strong> </p>
<p>（3）设置<strong>磁盘高速缓存</strong>（Disk Cache） </p>
<p>（4）其它方法 </p>
<p>（5）采用高度可靠、快速的容量磁盘系统–<strong>磁盘冗余阵列</strong></p>
<p>数据的组织与格式</p>
<ul>
<li>存储面</li>
<li>磁道</li>
<li>柱面</li>
<li>扇区</li>
</ul>
<p>磁道访问时间：</p>
<p><strong>（1）寻道时间Ts：</strong></p>
<p>指把磁臂（磁头）移动到指定磁道上所经历的时间<br>$$<br>T_{s} = m * n+s<br>$$<br>s：启动磁臂时间</p>
<p>n：磁头移动n条磁道</p>
<p>m：移动每一条磁道所花费时间</p>
<p><strong>（2）旋转延迟时间Tτ：</strong></p>
<p>指定扇区移动到磁头下面所经历的时间</p>
<p><strong>（3）传输时间Tt</strong></p>
<p>指把数据从磁盘读出或向磁盘写入数据所经历的时间</p>
<p>Tt 的大小与每次所读/写的字节数b 和旋转速度有关：<br>$$<br>T_{t}=\frac{b}{rN}<br>$$<br>r为磁盘每秒钟转数；N为一条磁道上的字节数</p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>根据进程请求访问磁盘的先后次序进行调度</p>
<p><img src="https://s2.loli.net/2022/06/04/9Ne1ncmasEfCRkv.png" alt="image-20220604155225269"></p>
<h4 id="最短寻道优先SSTF"><a href="#最短寻道优先SSTF" class="headerlink" title="最短寻道优先SSTF"></a>最短寻道优先SSTF</h4><p>选择这样的进程，其要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短</p>
<p><img src="https://s2.loli.net/2022/06/04/pceVwCd5ga9UnAk.png" alt="image-20220604155535144"></p>
<p>可能会导致某个进程发生“饥饿”现象</p>
<h4 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h4><p>优先考虑的是磁头当前的移动方向。</p>
<p>例如，磁头自里向外移动, 并同时自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向自外向里移动。（又常称之为<strong>电梯调度算法</strong>）</p>
<p><img src="https://s2.loli.net/2022/06/04/RjUJm3I1rbTy2QF.png" alt="image-20220604155748969"></p>
<p>当磁头刚从里向外（或刚从外向里）移动而越过了某一磁道时，恰好又有一进程请求访问此磁道，那它必须等待磁头到达磁盘的另一端，反向回来后，才能得到处理。</p>
<h4 id="循环扫描算法（CSCAN"><a href="#循环扫描算法（CSCAN" class="headerlink" title="循环扫描算法（CSCAN)"></a>循环扫描算法（CSCAN)</h4><p>磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。 </p>
<p><img src="https://s2.loli.net/2022/06/04/8tyIcrw7GkW5Mle.png" alt="image-20220604155849604"></p>
<blockquote>
<p>磁道由外向里编号</p>
</blockquote>
<h2 id="8、做题-1"><a href="#8、做题-1" class="headerlink" title="8、做题"></a>8、做题</h2><p>1、通道控制控制器，设备在控制器控制下工作</p>
<p>2、共享设备必须是可寻址的和可随机访问的设备</p>
<p>3、通道是一种特殊的<strong>处理机</strong>，具有<strong>执行I/O指令集</strong>的能力。主机的CPU和通道可以并行工作，并通过<strong>I/O指令和I/O中断</strong>实现彼此的通信和同步</p>
<p>4、在I/O控制方式的发展过程中，最重要的推动因素是<strong>减少主机对I/O控制的干预</strong>。提高I/O速度和设备利用率，在OS中主要依靠<strong>缓冲管理</strong>功能</p>
<p>5、打印机的I/O控制主要采取<strong>程序中断</strong>的方式</p>
<p>6、在程序I/O方式中，对于输出设备，准备就绪是指<strong>输出缓冲区已空</strong></p>
<p>7、在单用户系统中可为<strong>整个系统</strong>设置一张<strong>逻辑设备表</strong>，在多用户系统中应为<strong>每个用户</strong>设置一张<strong>逻辑设备表</strong></p>
<p>8、为实现设备分配，应为每个设备设置一张<strong>设备控制表</strong>，在系统中设置一张<strong>系统设备表</strong>，为实现设备独立性，系统中应设置一张<strong>逻辑设备表</strong></p>
<p>9、SPOOLing系统实现了对I/O设备的虚拟，只要输入设备空闲，SPOOLing可预先将输入数据从设备传送到输入井中供用户程序随时读取</p>
<p>在SPOOLing系统中，用户程序可随时将输出数据送到输出井中，待输出设备空闲时再执行数据输出操作</p>
<p>10、同一用户所使用的I/O设备也可以并行操作</p>
<h1 id="七、文件管理"><a href="#七、文件管理" class="headerlink" title="七、文件管理"></a>七、文件管理</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>文件是存储和管理数据的容器</p>
<p>文件时指由创建者所定义的，具有文件名的一组相关元素的集合</p>
<ul>
<li>有结构的文件：文件由若干个相关记录组成</li>
<li>无结构文件：看成一个字符流</li>
</ul>
<p>文件在文件系统是一个基本的管理单元，这个管理单元必然有一组属性</p>
<p><strong>属性：</strong></p>
<ul>
<li>文件类型</li>
<li>文件长度</li>
<li>文件的物理位置</li>
<li>文件的建立时间</li>
</ul>
<p><strong>文件类型</strong></p>
<p>按用途：</p>
<ol>
<li>系统文件：可调用，不可读，不允许修改</li>
<li>用户文件</li>
<li>库文件</li>
</ol>
<p>按文件中的数据形式：</p>
<ol>
<li>源文件</li>
<li>目标文件</li>
<li>可执行文件</li>
</ol>
<p>按存取控制属性：</p>
<ol>
<li>只执行文件</li>
<li>只读文件</li>
<li>读写文件</li>
</ol>
<p>按组织形式和处理方式：</p>
<ol>
<li>普通文件</li>
<li>目录文件</li>
<li>特殊文件：特指系统中的各类I/O设备</li>
</ol>
<p><strong>文件系统：</strong></p>
<p>操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合</p>
<p>功能：</p>
<ul>
<li>有效地管理文件的存储空间；</li>
<li>管理文件目录； </li>
<li>完成文件的读/写操作； </li>
<li>实现文件共享与保护； </li>
<li>为用户提供交互式命令接口和程序调用接口</li>
</ul>
<h3 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h3><p><img src="https://s2.loli.net/2022/06/04/KqxC1c4yHIi8XPk.png" alt="image-20220604180023179"></p>
<p>不完整，一般为下图</p>
<p><img src="https://s2.loli.net/2022/06/04/pD1OUBluiwrJgA4.png" alt="image-20220604180002609"></p>
<p><strong>（1）对象及其属性</strong></p>
<ul>
<li>文件</li>
<li>目录</li>
<li>磁盘（磁带）存储空间</li>
</ul>
<blockquote>
<p>对目录的组织和管理是方便用户和提高对文件存取速度的关键</p>
</blockquote>
<p><strong>（2）对对象操纵和管理的软件集合</strong></p>
<p>核心部分</p>
<ul>
<li>对文件存储空间的管理</li>
<li>对文件目录的管理</li>
<li>用于将文件的逻辑地址转换为物理地址的机制</li>
<li>对文件读和写的管理</li>
<li>以及对文件的共享与保护等功能。</li>
</ul>
<p><strong>（3）文件系统接口</strong></p>
<ul>
<li>命令接口：用户与文件系统交互</li>
<li>程序接口：用户程序与文件系统交互</li>
</ul>
<h2 id="2、文件基本操作"><a href="#2、文件基本操作" class="headerlink" title="2、文件基本操作"></a>2、文件基本操作</h2><ol>
<li>最基本：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置</li>
<li>文件的“打开”和“关闭”操作</li>
<li>其他文件操作：对文件属性的操作，改变文件名、改变文件的拥有者，查询文件的状态等</li>
</ol>
<h2 id="3、文件系统目录管理"><a href="#3、文件系统目录管理" class="headerlink" title="3、文件系统目录管理"></a>3、文件系统目录管理</h2><p>管理要求：</p>
<ol>
<li>实现“按名存取”</li>
<li>提高对目录的检索速度</li>
<li>文件共享</li>
<li>允许文件重名</li>
</ol>
<p><strong>文件控制块</strong>（FCB）：用于描述和控制文件的数据结构</p>
<p><strong>文件目录</strong>：文件控制块的有序集合</p>
<p>通常，一个文件目录也被看做是一个文件，称为目录文件。</p>
<p>FCB内容：</p>
<ul>
<li>基本信息：文件名、文件类型等；</li>
<li>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。</li>
<li>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等；</li>
<li>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</li>
</ul>
<p><strong>目录项的两种组织方式：</strong></p>
<ol>
<li>FCB存储全部目录内容</li>
<li>存储部分目录信息，如文件名、索引节点指针等，其余部分保存在索引节点（i节点）。打开文件时将索引节点从磁盘读到内存中。</li>
</ol>
<p>索引节点：文件描述信息单独形成一个数据结构。文件名与索引节点分开。</p>
<p>文件目录保存：文件名和对应的文件索引节点</p>
<p>每个文件都在磁盘上保存一个磁盘索引节点，当文件被打开时，文件的索引节点从磁盘读入内存，称为内存索引节点。</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项</p>
<p><img src="https://s2.loli.net/2022/06/04/Ku41gQFpja7Gdy9.png" alt="image-20220604200725593"></p>
<p>实现目录管理的基本功能—按名存取</p>
<p>缺点：</p>
<ul>
<li>查找速度慢</li>
<li>不允许重名</li>
<li>不便于实现文件共享</li>
</ul>
<h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p><img src="https://s2.loli.net/2022/06/04/QsLUfG4lY9TepEy.png" alt="image-20220604200857875"></p>
<ul>
<li>一定程度解决了重名问题</li>
<li>提高了文件目录检索效率</li>
<li>简单的文件共享</li>
</ul>
<blockquote>
<p>在文件系统中，用户以<strong>虚拟地址</strong>方式使用外存</p>
</blockquote>
<h4 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h4><p>多级目录结构</p>
<p>主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。</p>
<p><img src="https://s2.loli.net/2022/06/04/1wTuGhQUm72AXYq.png" alt="image-20220604201510504"></p>
<blockquote>
<p>用户的<strong>主目录</strong>就是用户注册进入系统时的初始基本目录</p>
<p>UNIX的文件目录系统采用<strong>可装卸式多级树型目录</strong></p>
</blockquote>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol>
<li>创建目录</li>
<li>删除目录：不删除非空目录、可删除非空目录</li>
<li>改变目录</li>
<li>移动目录</li>
<li>查找</li>
</ol>
<h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><h4 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h4><p>顺序检索法</p>
<ul>
<li>在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。</li>
<li>在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。</li>
</ul>
<blockquote>
<p>在操作系统中，将文件名转换为文件存储地址，对文件实施控制管理都是通过文件目录来实现的</p>
</blockquote>
<h4 id="Hash法"><a href="#Hash法" class="headerlink" title="Hash法"></a>Hash法</h4><p>略</p>
<h2 id="4、文件系统外存管理"><a href="#4、文件系统外存管理" class="headerlink" title="4、文件系统外存管理"></a>4、文件系统外存管理</h2><p>磁盘管理的主要任务和目标是；</p>
<ul>
<li>有效地利用外存空间</li>
<li>提高对文件的访问速度</li>
<li>提高磁盘系统的可靠性</li>
</ul>
<p>目前，常见的文件磁盘块的组织方法有:</p>
<ul>
<li>连续组织</li>
<li>链接组织</li>
<li>索引组织</li>
</ul>
<h3 id="连续组织"><a href="#连续组织" class="headerlink" title="连续组织"></a>连续组织</h3><p>连续分配(Continuous Allocation)要求为每一个文件分配一组相邻接的盘块。一组盘块的地址定义了磁盘上的一段线性地址。</p>
<p>把逻辑文件中的数据顺序地存储到物理上邻接的各个数据块中，这样形成的物理文件可以进行顺序存取。</p>
<p>文件目录中为每个文件建立一个表项，其中记载文件的<strong>第一个数据块地址</strong>及<strong>文件长度</strong>。</p>
<p>对于顺序文件，连续读/写多个数据块内容时，性能较好。</p>
<p><img src="https://s2.loli.net/2022/06/04/udTYHp81j35zacZ.png" alt="image-20220604202723614"></p>
<p>优点：</p>
<ol>
<li>顺序访问容易</li>
<li>顺序访问速度快</li>
</ol>
<p>缺点：</p>
<ol>
<li>要求有连续的存储空间</li>
<li>必须事先知道文件的长度</li>
</ol>
<h3 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h3><p>链接文件：采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，把这样形成的物理文件称为链接文件。</p>
<p>优点：</p>
<ul>
<li>消除磁盘外部碎片，提高了利用率</li>
<li>对插入、删除和修改记录都非常容易；</li>
<li>能适应文件的动态增长，无需事先知道文件的大小。</li>
</ul>
<h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。</p>
<p><img src="https://s2.loli.net/2022/06/04/N8doAvIRGFQ4O9k.png" alt="image-20220604203144371"></p>
<p>缺点：只适合于顺序访问，它对随机访问是极其低效的。</p>
<p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇(cluster)</p>
<p>比如，一个簇可包含4 个盘块，在进行盘块分配时，是以簇为单位进行的。在链接文件中的每个元素也是以簇为单位的。</p>
<p>减少查找时间和指针所占空间，但增大了内部碎片</p>
<h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p>指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。</p>
<p>整个磁盘仅设置一张文件分配表（FAT File Allocation Table）</p>
<p>缺点：FAT需要占用较大的内存空间</p>
<h3 id="索引组织"><a href="#索引组织" class="headerlink" title="索引组织"></a>索引组织</h3><h4 id="单级索引"><a href="#单级索引" class="headerlink" title="单级索引"></a>单级索引</h4><p>为每个文件分配一个索引块(表)，再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多盘块号的数组</p>
<p>优点：</p>
<ul>
<li>支持直接访问</li>
<li>基于数据块的分区能消除外部碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>大文件索引项较多</li>
<li>索引块可能要花费较多的外存空间</li>
</ul>
<h4 id="两级索引"><a href="#两级索引" class="headerlink" title="两级索引"></a>两级索引</h4><p>当文件太大，其一级索引块太多时，这种方法是低效的。此时，应为这些索引块再建立一级索引，形成两级索引分配方式。</p>
<p><img src="https://s2.loli.net/2022/06/04/okJi8scdqaQP9NG.png" alt="image-20220604210210538"></p>
<h4 id="增量式索引"><a href="#增量式索引" class="headerlink" title="增量式索引"></a>增量式索引</h4><p>全面照顾小、中、大及特大文件的组织需求。</p>
<p>同时采用：</p>
<ul>
<li>直接寻址：10个块号</li>
<li>一级索引，一次间址：一个索引块</li>
<li>二级索引，二次间址</li>
<li>三级索引，三次间址</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/04/u1WdyPmIMKncC5S.png" alt="image-20220604210437093"></p>
<h2 id="5、磁盘空闲空间管理"><a href="#5、磁盘空闲空间管理" class="headerlink" title="5、磁盘空闲空间管理"></a>5、磁盘空闲空间管理</h2><p>存储空间的基本分配单位是<strong>磁盘块</strong>。</p>
<p>系统应为分配存储空间而设置相应的数据结构；其次，系统应提供对存储空间进行分配和回收的手段。</p>
<h3 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h3><p>空闲表法属于连续分配方式，它为每个文件分配一块连续的存储空间，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息</p>
<p><img src="https://s2.loli.net/2022/06/04/nBiohVres12AO95.png" alt="image-20220604211556454"></p>
<p>适合于可变大小分区的连续分配方式</p>
<p>为文件分配存储空间时，首先顺序查找空闲分区表中的各个表项，直至找到第一个大小适合的空闲分区。</p>
<p>可以采用首次适应分配算法、最佳适应分配算法等。然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项。</p>
<p>当删除文件释放出空间时，系统回收其存储空间，合并相邻空闲分区.</p>
<ul>
<li>优点：实现简单</li>
<li>缺点：当存储空间中的空闲分区分布较分散且数量较多时，空闲分区表将会很大。需要很大的内存空间，会降低空闲分区表的检索速度。</li>
</ul>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲链表法是将所有空闲盘区拉成一条空闲链。</p>
<p>根据构成链所用基本元素的不同，可把链表分成两种形式：</p>
<ul>
<li>空闲盘块链</li>
<li>空闲盘区链</li>
</ul>
<h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p>将磁盘上的所有空闲空间，以盘块为单位拉成一条链。</p>
<ul>
<li>当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。</li>
<li>当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。</li>
</ul>
<p>优点：用于分配和回收一个盘块的过程非常简单.</p>
<h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p>将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)拉成一条链。</p>
<p>在每个盘区上含有用于指示<strong>下一个空闲盘区的指针</strong>和能**指明本盘区大小(盘块数)**的信息。</p>
<p>通常采用首次适应算法</p>
<p>回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并</p>
<p>问题：</p>
<ul>
<li>一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。</li>
<li>删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。</li>
<li>若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。</li>
</ul>
<p>适用于非连续存储文件</p>
<h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><p>利用二进制位0、1表示存储空间中存储块的使用状态。空闲分区:0，已分配分区:1（或者相反）</p>
<p>通常可用m × n 个位数来构成位示图，并使m × n等于磁盘的总块数。</p>
<p><strong>盘块分配：</strong></p>
<p>(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲时)。</p>
<p>(2) 将所找到的一个或一组二进制位转换成与之相应的盘块号。</p>
<p>假定找到的其值为“0”的二进制位位于位示图的第i 行、第j列，则其相应的盘块号应按下式计算：<br>$$<br>b=n(i-1)+j<br>$$<br>(3)修改位示图，令map[i,j]=1</p>
<p><strong>盘块回收</strong></p>
<p>（1）将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：<br>$$<br>i=(b-1)DIV<del>n+1<br>\j=(b-1)MOD</del>n+1<br>\DIV ~~~~取整<br>$$<br>（2）修改位示图。令map[i,j] =0</p>
<p><strong>优点：</strong>可以很容易的找到一个或一组连续的空闲分区</p>
<p>一个位示图需要占用的存储空间：磁盘容量（字节数）/ （8 * 数据块大小）</p>
<p><strong>缺点：</strong>很难一次性将该位示图全部装入内存。即使内存足够大，可以存放全部或绝大部分位示图数据，搜索一个很大的位示图将会降低文件系统的性能。</p>
<p>尤其当磁盘空间快用完，剩下的空闲磁盘块很少时，文件系统的性能将严重降低。</p>
<h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><ul>
<li>将磁盘空闲块分成若干组，如将100个盘块作为一组，用索引表表示；</li>
<li>该组空闲块总数和各空闲块块号存入下一组的第一个空闲块中（从后往前分组），各组通过链接指针连在一起形成链表；</li>
<li>最后不满100块的那组空闲块总数和各空闲块块号计入磁盘区专用管理块（超级块）的空闲盘块号栈的s_nfree和s_free[100]中</li>
</ul>
<p><img src="https://s2.loli.net/2022/06/04/DmMdoUBv7JaHGiz.png" alt="image-20220604220630073"></p>
<p><strong>分配：</strong></p>
<ul>
<li>未到栈底：出栈，将栈顶盘块分配给用户</li>
<li>已到栈底盘块：调用磁盘读过程将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把原栈底对应的盘块分配出去（其中的有用数据已读入栈中）。然后，再分配一相应的缓冲区作为该盘块的缓冲区。最后，把栈中的空闲盘块数-1并返回</li>
</ul>
<p><strong>回收：</strong></p>
<ul>
<li>栈未满：进栈，依次将回收盘块号压入栈中</li>
<li>栈已满：将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底</li>
</ul>
<p>仅适用于离散分配形式，无法用于连续分配</p>
<p>优点：</p>
<ul>
<li>无需占用额外的磁盘空间</li>
<li>分配回收速度快</li>
<li>大小磁盘均可采用</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适用于连续分配</li>
</ul>
<h2 id="6、文件共享与保护"><a href="#6、文件共享与保护" class="headerlink" title="6、文件共享与保护"></a>6、文件共享与保护</h2><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ol>
<li>同时存取</li>
<li>存取权限</li>
</ol>
<p><strong>同时存取</strong></p>
<ul>
<li>允许多个用户同时读文件内容，但不允许同时修改，或同时读且修改文件内容。</li>
<li>共享用户之一修改文件内容时，可以将整个文件作为临界资源，锁定整个文件，不允许其他共享用户同时读或写文件。</li>
<li>也可以仅仅锁定指定的一条记录，允许其他共享用户读/写该文件的其它记录。后者的并发性能更好。</li>
<li>涉及进程的同步与互斥</li>
</ul>
<p><strong>存取权限</strong></p>
<ul>
<li>无（None） — 用户不知道文件的存在。用户无法获知该文件的目录信息，当然更不会知道文件的内容。</li>
<li>探知（Knowledge） — 用户可以检测文件的存在和文件的文件主，还可以向文件主申请增加对该文件的存取权限。</li>
<li>执行（Execution） —  用户可以装载并执行程序，但不允许拷贝程序内容。</li>
<li>读（Reading）— 允许用户读文件内容，包括拷贝和执行文件。某些系统严格地将浏览文件内容和拷贝权限分开，可以控制文件只能被浏览（显示），不能被拷贝。</li>
<li>追加（Appending）— 允许用户向文件添加数据，通常只能将数据添加到文件尾。但是，不能修改或删除文件内容。例如，超市收银员只能将新结帐的数据添加到文件中，不允许其修改或删除已有的数据。</li>
<li>更新（Updating）— 允许用户修改、删除、增加文件内容。包括创建文件、重写文件的全部或部分内容、移动文件的全部或部分数据等操作。</li>
<li>更改权限 (Changing protection) — 一般只有文件主才能更改共享该文件的其他用户对该文件的存取权限。有的系统允许文件主将更改文件存取权限赋予其他某个用户，但必须限制授权用户更改的权限范围。</li>
<li>删除 (Deletion) — 允许用户删除文件</li>
</ul>
<p>后一种权限包含前一种及前面各种存取权限</p>
<p>实现文件共享的实质就是<strong>可以从不同地方打开同一个文件</strong></p>
<p>打开文件的首要步骤就是<strong>找到文件的目录项</strong>，读取文件在外存的起始地址</p>
<h4 id="链接目录项实现法"><a href="#链接目录项实现法" class="headerlink" title="链接目录项实现法"></a>链接目录项实现法</h4><p>文件目录项中设置一个链接指针，用于指向共享文件的目录项。</p>
<p>访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。</p>
<p>每当有用户（进程）共享文件时，共享文件目录项中的“共享计数”加1；当用户不再共享该文件，撤消链接指针时，“共享计数”减1。</p>
<p>只有当共享文件用户数为1时，才能删除共享文件。</p>
<h4 id="索引节点实现法"><a href="#索引节点实现法" class="headerlink" title="索引节点实现法"></a>索引节点实现法</h4><p>文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。</p>
<p>由任何用户对文件进行Append 操作或修改，所引起的相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，都是其他用户可见的，从而也就能提供给其他用户来共享。</p>
<p>可以通过共享文件索引节点来共享文件，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名(也可用原名)，并将索引节点指针指向共享文件的索引节点。</p>
<p>在索引结点中还应有一个链接计数count，用于表示链接到本索引结点(亦即文件)上的用户目录项的数目。</p>
<ul>
<li>当用户C创建一个新文件时，他便是该文件的所有者，此时将count 置1。</li>
<li>当有用户B要共享此文件时，在用户B 的目录中增加一目录项，并设置一指针指向该文件的索引结点，此时，文件主仍然是C，count=2。</li>
</ul>
<h4 id="符号链实现法"><a href="#符号链实现法" class="headerlink" title="符号链实现法"></a>符号链实现法</h4><p>为使B能共享C的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F并将F写入B的目录中，以实现B的目录与文件F的链接；在新文件中只包含被创文件F的路径名。这样的链接方法被称为符号链接.</p>
<p>新文件中的路径名，则只被看作是<strong>符号链</strong>。当B要访问被链接的文件F且正要读LINK类新文件时，将被OS截获，  OS根据新文件中的路径名去读该文件，于是就实现了用户B对文件F的共享。</p>
<p>（快捷方式？？？！！！）</p>
<p>在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。</p>
<p>优点：能连接任何机器上的文件</p>
<p>缺点：</p>
<ul>
<li>访问共享文件时要多次读盘，开销大</li>
<li>建立符号链时仍需要配置索引节点，耗费一定的磁盘空间</li>
</ul>
<h4 id="利用URL"><a href="#利用URL" class="headerlink" title="利用URL"></a>利用URL</h4><p>统一资源定位器URL (Uniform Resource Locator)是Internet上用来链接超文本文件的一种方法。</p>
<p>（在线文档呗）</p>
<h2 id="7、做题-1"><a href="#7、做题-1" class="headerlink" title="7、做题"></a>7、做题</h2><p>1、文件系统最基本的目标是<strong>按名存取</strong>，它主要是通过<strong>文件共享</strong>功能实现的，文件系统所追求的最重要的目标就是<strong>文件安全性管理</strong></p>
<p>2、FC通常存放在<strong>该文件的上级目录的数据盘块</strong>中</p>
<p>3、Windows FAT32的目录项中不会包含<strong>文件控制块的物理位置</strong>，而Unix的磁盘索引节点中不会包含<strong>文件名信息</strong></p>
<p>4、在执行close的过程时，若系统打开文件表项引用技术f.count=0不成立，应置<strong>用户文件描述符表项为空</strong>；若f.count=0但内存索引节点引用计数i.count=0不成立，应使<strong>用户文件描述符和文件表项皆为空</strong>，若i.count=0，则关闭文件</p>
<h1 id="八、操作系统接口"><a href="#八、操作系统接口" class="headerlink" title="八、操作系统接口"></a>八、操作系统接口</h1><h2 id="1、操作系统与用户接口"><a href="#1、操作系统与用户接口" class="headerlink" title="1、操作系统与用户接口"></a>1、操作系统与用户接口</h2><ol>
<li><strong>命令接口</strong>：用户在终端输入命令与系统交互或者是用户通过提交作业控制说明书来控制系统运行。这种方式要求用户记忆所提交的命令。分为：联机用户接口（交互式方式运行的命令）与脱机用户接口（批处理用户接口）；<ul>
<li>联机命令</li>
<li>终端处理程序</li>
<li>命令解释程序</li>
</ul>
</li>
<li><strong>程序接口</strong>：通过系统调用实现，这种接口主要提供给程序员使用，在OS的外层软件或用户程序中，凡是与资源有关的操作都必须通过该接口向操作系统提出服务请求，并由OS完成</li>
<li><strong>图形接口</strong>：采用了图形化的操作界面，直观，方便，易学，更适合于普通用户使用</li>
</ol>
<h2 id="2、系统调用"><a href="#2、系统调用" class="headerlink" title="2、系统调用"></a>2、系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层，该层的主要作用有两个:</p>
<p>为用户空间提供了一种硬件的抽象界面，例如，当需要读文件时，应用程序可以不管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型；</p>
<p>系统调用保证了系统的稳定和安全。</p>
<p>各种版本的UNIX系统都提供了定义明确、数量有限、可直接进入内核的入口点，这些入口点被称为系统调用</p>
<p><strong>系统调用和普通调用的区别：</strong></p>
<p>系统调用本质上是一种过程调用，但它是一种特殊的过程调用，与一般用户程序中的过程调用有明显区别</p>
<table>
<thead>
<tr>
<th></th>
<th>系统调用</th>
<th>一般过程调用</th>
</tr>
</thead>
<tbody><tr>
<td>运行状态</td>
<td>主调程序：用户态<br>被调程序：系统态</td>
<td>主调程序和被调程序<br>同在用户态或系统态</td>
</tr>
<tr>
<td>状态切换</td>
<td>通过软中断进行状态切换</td>
<td>不切换</td>
</tr>
<tr>
<td>返回问题</td>
<td>可能引起调度<br>（与调度算法有关）</td>
<td>不调度</td>
</tr>
<tr>
<td>嵌套调用</td>
<td>有深度限制</td>
<td>不限制调度</td>
</tr>
</tbody></table>
<ol>
<li>运行在不同的系统状态。一般的过程调用，其调用程序和被调用程序都运行在相同的状态——系统态或用户态；而系统调用与一般调用的最大区别就在于：调用程序是运行在用户态，而被调用程序是运行在系统态</li>
<li>通过软中断进入。由于一般过程调用不涉及到系统状态的转换，故可直接由调用过程转向被调用过程。但在运行系统调用时，由于调用和被调用过程是工作在不同的系统状态，因而不允许由调用过程直接转向被调用过程，通常都是通过软中断机制，先由用户态转换为系统态，经核心分析后，才能转向相应的系统调用处理子程序</li>
<li>返回问题。一般的过程调用在被调用过程执行完后，将直接返回到调用过程继续执行。但对系统调用，如果系统采用抢占调度方式，则在被调用过程执行完后，必须对系统中所有要求运行的进程做优先权分析。只有当调用进程仍具有最高优先权时，才返回到调用进程继续执行；否则，将引起重新调度</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">wck</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2023/02281079.html">http://example.com/2023/02281079.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">wck</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">
                                    <span class="chip bg-color">操作系统</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }

    #vcomments textarea {
        box-sizing: border-box;
        background: url("/medias/comment_bg.png") 100% 100% no-repeat;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #4cbf30;
        font-weight: 500;
        text-decoration: none;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; padding-left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="vcomments" class="card-content" style="display: grid">
    </div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<script>
    new Valine({
        el: '#vcomments',
        appId: 'yohIdjiNFr5gi9AMV8TPhv90-gzGzoHsz',
        appKey: 'dpdaXreArfn9sbA5A5hGBlUG',
        notify: 'false' === 'true',
        verify: 'false' === 'true',
        visitor: 'true' === 'true',
        avatar: 'monsterid',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: '留下你想说的话吧~',
        enableQQ: true,
        emojiCDN: '//i0.hdslb.com/bfs/emote/', 
        // 表情title和图片映射
        emojiMaps: {
        "tv_doge": "6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png",
        "tv_亲亲": "a8111ad55953ef5e3be3327ef94eb4a39d535d06.png",
        "tv_偷笑": "bb690d4107620f1c15cff29509db529a73aee261.png",
        "tv_再见": "180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png",
        "tv_冷漠": "b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png",
        "tv_发怒": "34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png",
        "tv_发财": "34db290afd2963723c6eb3c4560667db7253a21a.png",
        "tv_可爱": "9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png",
        "tv_吐血": "09dd16a7aa59b77baa1155d47484409624470c77.png",
        "tv_呆": "fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png",
        "tv_呕吐": "9f996894a39e282ccf5e66856af49483f81870f3.png",
        "tv_困": "241ee304e44c0af029adceb294399391e4737ef2.png",
        "tv_坏笑": "1f0b87f731a671079842116e0991c91c2c88645a.png",
        "tv_大佬": "093c1e2c490161aca397afc45573c877cdead616.png",
        "tv_大哭": "23269aeb35f99daee28dda129676f6e9ea87934f.png",
        "tv_委屈": "d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png",
        "tv_害羞": "a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png",
        "tv_尴尬": "7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png",
        "tv_微笑": "70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png",
        "tv_思考": "90cf159733e558137ed20aa04d09964436f618a1.png",
        "tv_惊吓": "0d15c7e2ee58e935adc6a7193ee042388adc22af.png",
        "tv_打脸": "56ab10b624063e966bfcb76ea5dc4794d87dfd47.png",
        "tv_抓狂": "fe31c08edad661d63762b04e17b8d5ae3c71a757.png",
        "tv_抠鼻": "c666f55e88d471e51bbd9fab9bb308110824a6eb.png",
        "tv_斜眼笑": "911f987aa8bc1bee12d52aafe62bc41ef4474e6c.png",
        "tv_无奈": "ea8ed89ee9878f2fece2dda0ea8a5dbfe21b5751.png",
        "tv_晕": "5443c22b4d07fb1907ccc610c8e6db254f2461b7.png",
        "tv_流汗": "cead1c351ab8d79e9f369605beb90148db0fbed3.png",
        "tv_流泪": "7e71cde7858f0cd50d74b0264aa26db612a8a167.png",
        "tv_流鼻血": "c32d39db2737f89b904ca32700d140a9241b0767.png",
        "tv_点赞": "f85c354995bd99e28fc76c869bfe42ba6438eff4.png",
        "tv_生气": "26702dcafdab5e8225b43ffd23c94ac1ff932654.png",
        "tv_生病": "8b0ec90e6b86771092a498c54f09fc94621c1900.png",
        "tv_疑问": "0793d949b18d7be716078349c202c15ff166f314.png",
        "tv_白眼": "c1d59f439e379ee50eef488bcb5e5378e5044ea4.png",
        "tv_皱眉": "72ccad6679fea0d14cce648b4d818e09b8ffea2d.png",
        "tv_目瞪口呆": "0b8cb81a68de5d5365212c99375e7ace3e7891b7.png",
        "tv_睡着": "8b196675b53af58264f383c50ad0945048290b33.png",
        "tv_笑哭": "1abc628f6d4f4caf9d0e7800878f4697abbc8273.png",
        "tv_腼腆": "89712c0d4af73e67f89e35cbc518420380a7f6f4.png",
        "tv_色": "61822c7e9aae5da76475e7892534545336b23a6f.png",
        "tv_调侃": "4bc022533ef31544ca0d72c12c808cf4a1cce3e3.png",
        "tv_调皮": "b9c41de8e82dd7a8515ae5e3cb63e898bf245186.png",
        "tv_鄙视": "6e72339f346a692a495b123174b49e4e8e781303.png",
        "tv_闭嘴": "c9e990da7f6e93975e25fd8b70e2e290aa4086ef.png",
        "tv_难过": "87f46748d3f142ebc6586ff58860d0e2fc8263ba.png",
        "tv_馋": "fc7e829b845c43c623c8b490ee3602b7f0e76a31.png",
        "tv_鬼脸": "0ffbbddf8a94d124ca2f54b360bbc04feb6bbfea.png",
        "tv_黑人问号": "45821a01f51bc867da9edbaa2e070410819a95b2.png",
        "tv_鼓掌": "1d21793f96ef4e6f48b23e53e3b9e42da833a0f6.png"
        },
        requiredFields: ['nick','mail'],
    });
</script>

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2023/022863394.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/21.jpg" class="responsive-img" alt="数据库">
                        
                        <span class="card-title">数据库</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            数据库期末复习
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-28
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-category">
                                    期末复习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">
                        <span class="chip bg-color">数据库</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/022828758.html">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="计算机网络">
                        
                        <span class="card-title">计算机网络</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            计算机网络期末复习
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-02-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/" class="post-category">
                                    期末复习
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
                        <span class="chip bg-color">计算机网络</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2021-2023</span>
            
            <span id="year">2021</span>
            <a href="/about" target="_blank">wck</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">380.3k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/rumor-sourse" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2560428298@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2560428298" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2560428298" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>



    <a href="https://weibo.com/u/7491101842/home" class="tooltipped" target="_blank" data-tooltip="关注我的微博: https://weibo.com/u/7491101842/home" data-position="top" data-delay="50">
        <i class="fab fa-weibo"></i>
    </a>



    <a href="https://www.zhihu.com/people/chu-zi-hang-46-14" class="tooltipped" target="_blank" data-tooltip="关注我的知乎: https://www.zhihu.com/people/chu-zi-hang-46-14" data-position="top" data-delay="50">
        <i class="fab fa-zhihu1">知</i>
    </a>





    <a href="https://space.bilibili.com/531340472" class="tooltipped" target="_blank" data-tooltip="在B站上关注我" " data-position="top" data-delay="50">
        <i class="fas fa-play-circle"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <!-- <script type="text/javascript">
        //只在桌面版网页启用特效
        var windowWidth = $(window).width();
        if (windowWidth > 768) {
            document.write('<script type="text/javascript" src="/js/sakura.js"><\/script>');
        }
    </script> -->
    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

	
    
    <script type="text/javascript" color="0,0,255"
        pointColor="0,0,255" opacity='0.7'
        zIndex="-1" count="99"
        src="/libs/background/canvas-nest.js"></script>
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

 
</body>

</html>
