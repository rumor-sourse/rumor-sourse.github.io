<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spark</title>
      <link href="/2023/051023978.html"/>
      <url>/2023/051023978.html</url>
      
        <content type="html"><![CDATA[<p>弹性分布式数据集：基于内存集群计算的容错抽象</p><h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>我们提出的弹性分布式数据集（RDDs），是一个让程序员在大型集群上以容错的方式执行基于内存计算的分布式内存抽象。RDDs受启发于两类使用当前计算框架处理不高效的应用：迭代算法和交互式数据挖掘工具。这二者在内存中保存数据性能能够提高一个数量级。为了有效容错，RDDs提供一种受限的共享内存，基于粗粒度转换（transformations）而非细粒度地更新共享状态。尽管如此，RDDs仍足以表达许多类型的计算，包括最近专门用于迭代作业的编程模型（如Pregel）以及这些模型无法表示的新应用。我们在一个名为Spark的系统中实现了RDDs，我们通过各种用户应用程序和基准测试来评估该系统。</p><h1 id="1、介绍（Introduction）"><a href="#1、介绍（Introduction）" class="headerlink" title="1、介绍（Introduction）"></a>1、介绍（Introduction）</h1><p>像MapReduce和Dryad这样的集群计算框架已经广泛应用于大规模数据分析。这些系统让用户使用一系列高级算子编写并行计算，而不用担心工作分配和容错。</p><blockquote><p>Cluster computing frameworks是一种分布式计算框架，它允许在大规模数据分析中使用并行计算。这些系统让用户使用一组高级操作符编写并行计算，而无需担心工作分配和容错</p></blockquote><p>虽然现有框架为访问集群计算资源提供了大量抽象，但是他们缺少利用分布式内存的抽象。这使得它们对那些跨多个计算重用中间结果的新兴应用效率不高。数据重用普遍存在于很多迭代的机器学习和图像算法中，包括PageRank，K-means聚类和logistic回归。另一个引人注目的用例是交互式数据挖掘，即用户在同样的数据子集上运行多个即时查询。不幸的是，大多数现有框架中，在计算之间（比如在两个MapReduce作业之间）重用数据的唯一方式是把它写到外部稳定存储系统（如分布式文件系统）。这种方式会因为数据复制，磁盘I/O和序列化而带来巨大开销，这直接影响了应用的执行时间。</p><p>由于认识到这个问题，研究人员为一些需要数据重用的应用开发出了专门的框架。例如，Pregel是为迭代的图像计算而在内存中保存中间数据的系统；而HaLoop则提供一个迭代的MapReduce接口。但这些框架只提供了特定的计算模型，并对这些模式隐式地进行数据共享。它们没有为更普遍的重用提供抽象，如让用户把几个数据集加载到内存中，在它们上运行即时查询。</p><p>这篇论文中，我们提出一个新的抽象，叫弹性分布式数据集（RDDs），它让数据重用在广泛的应用上都是高效的。RDDs是容错的并行数据结构，它让用户显示地在内存中保存中间结果，控制它们的分区以优化数据布局，用丰富的算子去操作它们。</p><p> 在设计RDDs时主要的挑战是：设计一个能有效提供容错性的编程接口。现有的对集群上基于内存存储的抽象（如分布式共享内存、key-value stores、数据库、Piccolo）提供了基于细粒度更新可变状态（比如表中的元素）的接口。这个接口提供容错的仅有的方式是跨机器复制数据或跨机器记录更新。这两个方法对数据密集型工作负载代价很大，因为它们需要在集群网络上拷贝大量数据，它的带宽远比RAM的要小，并且导致严重的存储开销。</p><p>和这些系统对比，RDDs提供基于粗粒度转换（map、filter和join等）的接口。这允许它们通过记录用于构建数据集（它的<em>lineage</em>）的转换（<em>transformations</em>）去有效地提供容错性。如果RDD的分区丢失了，那个RDD会有足够的信息从其他RDDs衍生去重新计算刚才那个分区。从而，丢失的数据通常可以很快被恢复，且不需要花销很大的复制。</p><blockquote><p>粗粒度是应用于整个数据集，如上述map、filter；细粒度是指应用于单行，如get(index)和set(index)。</p></blockquote><p>即便是基于粗粒度转换的接口在最初也会受限，RDDs很适合很多并行化应用，因为这些应用天然适合在多个数据项上应用相同的操作。RDDs能高效地表示很多已经提出的作为独立系统的集群编程模型，包括MapReduce、Haloop等，也包括这些系统不能很好地应用的新应用程序，如交互式数据挖掘。<br>    我们已经在Spark的系统中实现了RDDs，Spark系统在UC Berkeley和个别公司被用于研究、生产应用。Spark提供一个方便语言集成的编程接口，接口是Scala语言编写的。另外，Spark可以用来从Scala解释器上交互式地查询大数据集。Spark允许通用编程语言以交互式速度用于集群上基于内存的数据挖掘，我们相信Spark是第一个这样的系统。<br>    我们通过微基准和用户应用程序的测试评估RDDs。发现，对于迭代应用，Spark比Hadoop快20倍；实际数据分析类报表速度提升40倍；Spark用于交互式查询1TB的数据集只有5至7秒的延迟。为了说明RDDs的普适性，我们已经在Spark之上实现了Pregel和HaLoop编程模型，包括以相对较小的库的形式提供了它们使用的位置优化策略（每个200行代码）。<br>    本文先分别在2和3节概述RDDs和Spark。然后，在第4节讨论RDDs的内部表示，第5节是RDDs内部的实现，第6节是实验结果。最后，在第7节讨论RDDs是怎样引起几个现有的集群编程模型兴趣的，第8节研究相关工作，最后是结论。</p><h1 id="2、弹性分布式数据集（Resilient-Distributed-Datasets-RDDs）"><a href="#2、弹性分布式数据集（Resilient-Distributed-Datasets-RDDs）" class="headerlink" title="2、弹性分布式数据集（Resilient Distributed Datasets RDDs）"></a>2、弹性分布式数据集（Resilient Distributed Datasets RDDs）</h1><p>这节对RDDs进行概述。先在2.1节给RDDs下定义，2.2节阐述Spark中RDDs的编程接口，然后在2.3节比较RDDs和细粒度共享内存抽象，最后在2.4节讨论RDD模型的局限性。</p><h2 id="2-1、RDD抽象（RDD-Abstraction）"><a href="#2-1、RDD抽象（RDD-Abstraction）" class="headerlink" title="2.1、RDD抽象（RDD Abstraction）"></a>2.1、RDD抽象（RDD Abstraction）</h2><p>RDD是一个只读的、分区记录的集合。RDDs能通过通过以下两种方式创建：（1）稳定存储中的数据 （2）其他RDDs</p><p>我们称这些操作为转换（<em>transformations</em>），以把它们和其他RDDs上的操作（<em>actions</em>）区分开。map、filter、join都属于transformations。</p><p>RDDs任何时候都不需要物化（<em>真正执行操作后存入稳定存储</em>）。相反，一个RDD有足够多的关于它是怎样从其他数据集衍生出（它的Lineage）的信息，据此从稳定存储中的数据计算出它的分区。这是一个强有力的特性：从本质上说，如果故障后无法重建RDD，程序就不能引用该RDD。（<em>有点绕，其实就是说<strong>RDD能够被重建是个很重要的特性，RDD有很强大的容错机制</strong></em>）</p><p> 最终，用户能控制RDDs的两个其他方面：持久化和分区。用户可以表明他们将重用那个RDDs并为它们选择存储策略（如in-memory 存储）。他们也可以让一个RDD的元素基于每个记录的key跨机器分区。这对位置优化是有用的，如确定两个将要join的数据集是以相同方式进行哈希分区的。</p><h2 id="2-2、Spark编程接口（Spark-Programming-Interface）"><a href="#2-2、Spark编程接口（Spark-Programming-Interface）" class="headerlink" title="2.2、Spark编程接口（Spark Programming Interface）"></a>2.2、Spark编程接口（Spark Programming Interface）</h2><p>Spark通过一个语言集成API暴露RDD，API中每个数据集被表示为一个对象，在这些对象上transformations被使用方法调用。<br>    程序员编程的第一步是通过在稳定存储中的数据调用transformations来定义RDDs（如map和filter）。然后他们可以对这些RDDs调用actions，actions是给应用程序返回值或者把数据导出到存储系统的操作。count、collect、save都属于actions。Spark只有在第一次调用action时才会真正计算RDDs，在此之前进行的transformations都是惰性计算，这样能对transformations进行并行流水线化（<em>pipeline</em>）。<br>    另外，程序员可以调用persist方法表明在以后的操作中他们想用哪个RDDs。Spark默认在内存中持久化RDDs，但是如果没有足够的RAM将会把多余的存入磁盘。用户也可以请求其它的持久化策略，如只在磁盘上存储RDD，或跨集群复制RDD，通过flags进行persist。最后，用户可以在每个RDD上设置持久化优先级去指定哪些内存的数据应该优先被存入磁盘。</p><h3 id="2-2-1、示例：控制台日志挖掘（Example-Console-Log-Mining）"><a href="#2-2-1、示例：控制台日志挖掘（Example-Console-Log-Mining）" class="headerlink" title="2.2.1、示例：控制台日志挖掘（Example: Console Log Mining）"></a>2.2.1、示例：控制台日志挖掘（Example: Console Log Mining）</h3><p>假设有一个web服务出错了，操作员想从保存在HDFS中的TB级的日志中找出原因。通过使用Spark，操作员只需从日志中把刚才那个错误的信息加载到一组节点的RAM，并交互式地查询它们。她将先写出下面的Scala代码：</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">lines <span class="token operator">=</span>spark<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token string">"hdfs://..."</span><span class="token punctuation">)</span>errors <span class="token operator">=</span> lines<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>startWith<span class="token punctuation">(</span><span class="token string">"ERROR"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>errors<span class="token punctuation">.</span>persist<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第一行通过HDFS文件定义了一个RDD（即是文本形式的lines的集合），第二行对lines进行过滤得到一个过滤后的RDD，第三行将errors存入内存以便查询中共享。值得注意的是，在Scala语法中<em>filter</em>的参数是一个闭包。<br>    此时，集群上并没有执行任何工作。但是，用户可以对该RDD执行动作（<em>actions</em>），如统计信息条数：</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala">errors<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 用户也可以在该RDD上进一步执行transformations，并使用转换后的结果，如下：</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token comment">//统计errors中涉及MySQL的行数:</span>errors<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">"MySQL"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">//以数组的形式返回errors中涉及HDFS的时间字段</span><span class="token comment">//（假设时间是'\t'分隔的number为3的字段）</span>errors<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>contains<span class="token punctuation">(</span><span class="token string">"HDFS"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span>map<span class="token punctuation">(</span>_split<span class="token punctuation">(</span><span class="token string">'\t'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在errors的第一个action运行后，Spark将在内存中保存errors的分区，极大地加速了后续计算。值得注意的是，最初的RDD（<em>lines</em>）没有被缓存。这很合理，因为错误信息可能只是数据的一小部分（小到足以存入内存）。</p><p>最后，为了说明我们的模型怎样容错，我们在图1中展示了第三次查询中的RDDs的血缘（lineage）图。这次查询，在lines上进行filter得到errors，然后在errors上进一步应用filter和map，之后是<em>collect</em>。Spark调度器将并行流水线化后两个transformations，给拥有errors的分区缓存的节点发送任务集去计算。另外，如果errors的一个分区丢失了，Spark可以仅在lines相应的分区上应用过滤器来重建该分区。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101011145.png"></p><h2 id="2-3、RDD模型的优势（Advantages-of-the-RDD-Model）"><a href="#2-3、RDD模型的优势（Advantages-of-the-RDD-Model）" class="headerlink" title="2.3、RDD模型的优势（Advantages of the RDD Model）"></a>2.3、RDD模型的优势（Advantages of the RDD Model）</h2><p>为了明白RDDs作为分布式内存抽象的好处，我们在表1中列出了RDDs与分布式共享内存（DSM）的对比。DSM系统中，应用在全局地址空间任意位置读写。值得注意的是，在这种定义下，DSM不仅包括传统的共享内存系统，还包括其他采用细粒度写共享状态的系统，提供共享的DHT的Piccolo和分布式数据库。DSM是非常通用的抽象，这种通用性使它难以在商业集群上实现高效率和容错性。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101017761.png" alt="image-20230510101717901"></p><table><thead><tr><th>方面</th><th>RDDs</th><th>分布式共享内存</th></tr></thead><tbody><tr><td>读</td><td>粗/细粒度</td><td>细粒度</td></tr><tr><td>写</td><td>粗粒度</td><td>细粒度</td></tr><tr><td>一致性</td><td>不重要（不可变）</td><td>取决于app/运行时</td></tr><tr><td>故障恢复</td><td>细粒度，使用Lineage的的开销</td><td>需要检查点和程序回滚</td></tr><tr><td>落后任务降灾</td><td>可以使用任务备份</td><td>难以实现</td></tr><tr><td>任务安排</td><td>基于数据本地化自动分配</td><td>取决于app（运行时实现透明性）</td></tr><tr><td>内存不足时行为</td><td>类似于已有数据流系统</td><td>性能差（交换？）</td></tr></tbody></table><p>表1：RDDs与DSM的对比</p><p>RDDs和DSM主要的区别在于RDDs只能通过粗粒度transformations创建（“written”），而DSM允许读写每个存储单元。这虽然限制了RDDs只读，但允许RDDs有更高效的容错。尤其，RDDs不需要检查点的开销，因为它们可以使用lineage恢复。此外，只有RDD丢失的分区才需要重新计算，并且它们可以在不同节点上并行计算，而不用回滚整个程序。<br>    RDDs的第二个好处是它们的不可变性使系统能够运行类似MapReduce的备份任务来缓和慢节点。用DSM难以实现备份任务，因为一个任务的两个副本将访问相同的内存位置，相互干扰更新。<br>    RDDs相比于DSM还提供了另外两个好处。第一， 在对RDDs的批量操作中，运行时会基于数据本地化去调度任务以提高性能。第二，仅仅当它们用于基于扫描的操作时，RDDs在内存不足以存储它们时会优雅降级，内存存不下的分区会存在磁盘中，此时与现有的数据并行系统性能相当。</p><h2 id="2-4、不适合RDDs的应用（Applications-Not-Suitable-for-RDDs）"><a href="#2-4、不适合RDDs的应用（Applications-Not-Suitable-for-RDDs）" class="headerlink" title="2.4、不适合RDDs的应用（Applications Not Suitable for RDDs）"></a>2.4、不适合RDDs的应用（Applications Not Suitable for RDDs）</h2><p>就像引言中讨论的，RDDs最适合批处理应用，批处理应用就是对一个数据集的所有元素运行相同的操作。这种情况下，RDDs能够有效地记住每个transformation，每个transformation是lineage图中的一个步骤，并且，不需要记录大量数据就能够恢复丢失分区。RDDs不太适合那些对共享状态进行异步的细粒度的更新，如web应用的存储系统或web爬虫增量抓取器。对于这些应用，执行传统的更新日志和数据检查点操作更加高效，例如数据库等。我们的目标是给批处理分析提供高效编程模型，把这些异步应用程序留给专门的系统。</p><h1 id="3、Spark编程接口（Spark-Programming-Interface）"><a href="#3、Spark编程接口（Spark-Programming-Interface）" class="headerlink" title="3、Spark编程接口（Spark Programming Interface）"></a>3、Spark编程接口（Spark Programming Interface）</h1><p>Spark给RDD抽象提供了一个用Scala编写了语言集成API。Scala是在JVM上的静态类型函数式编程语言。我们选择Scala是因为它简洁的组合（便于交互式使用）和效率（由于静态类型）。然而，RDD抽象并不是一定要用函数式语言。<br>    为了使用Spark，开发者写一个驱动程序（<em>driver program</em>）连接wokers集群，如图2所示。driver定义一或多个RDDs，并在RDDs上调用action。在driver上的Spark代码还会追踪这些RDDs的lineage。wokers是长期运行的进程，能在内存中存储RDD分区。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101023972.png" alt="image-20230510102301902"></p><p>Figure2：Spark运行态。用户的驱动程序启动多个worker，worker从分布式文件系统读取数据块，并在内存中保存已计算的RDD分区</p><p>就像在2.2.1节日志挖掘实例中所展现的，用户给RDD操作（如map）传参是传递闭包（字面函数）。Scala用一个java对象代表每个闭包，这些对象可以被序列化，可以通过网络中传递闭包加载到另一个节点上。Scala也把闭包中的变量约束保存为Java对象中的字段。例如，一个人可以写下面的代码去对RDD中每个元素加5。</p><pre class="line-numbers language-none"><code class="language-none">var x &#x3D; 5rdd.map(_ + x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> RDDs本身是元素类型参数化的静态类型对象。例如，RDD[Int]是整数的RDD。由于Scala支持类型推断，所以大多数例子中都省略了类型。<br>    虽然用Scala实现RDDs在概念上很简单，但是我们必须使用反射解决Scala闭包对象的问题。通过Scala解释器去使用用Spark，我们还需要做很多的工作，我们将在5.2节讨论。但我们并不需要去修改Scala编译器。</p><h2 id="3-1、Spark中的RDD操作（RDD-Operations-in-Spark）"><a href="#3-1、Spark中的RDD操作（RDD-Operations-in-Spark）" class="headerlink" title="3.1、Spark中的RDD操作（RDD Operations in Spark）"></a>3.1、Spark中的RDD操作（RDD Operations in Spark）</h2><p>表2列出了Spark中主要的RDD的transformations和actions操作。每个操作都给出了表示，中括号表示类型参数。前面说过<em>transformations</em>是定义新RDD的惰性操作，而<em>actions</em>开始真正的计算并返回一个值给程序或是把数据写到外部存储。</p><p>请注意，一些操作（例如join）仅在键值对的 RDD 上可用。此外，我们选择我们的功能名称来匹配 Scala 和其他功能语言中的其他 API；例如，map 是一个一对一的映射，而 flatMap 将每个输入值映射到一个或多个输出（类似于 MapReduce 中的映射）。</p><p>除了这些运算符之外，用户可以要求 RDD 持久化存储。此外，用户可以获得 RDD 的分区顺序，由分区类表示，并根据其划分另一个数据集。groupByKey、reduceByKey等操作自动排序导致哈希或范围分区RDD。</p><h2 id="3-2、应用实例（Example-Applications"><a href="#3-2、应用实例（Example-Applications" class="headerlink" title="3.2、应用实例（Example Applications)"></a>3.2、应用实例（Example Applications)</h2><p> 我们对2.2.1节中的数据挖掘示例补充两个迭代应用：logistic回归和网页排名。之后说明怎样控制RDDs的分区能提高性能。</p><h3 id="3-2-1、logistic回归"><a href="#3-2-1、logistic回归" class="headerlink" title="3.2.1、logistic回归"></a>3.2.1、logistic回归</h3><p>很多机器学习算法都具有迭代特性，因为他们需要运行迭代优化程序去最大化一个函数，如梯度下降法。它们的数据保存在内存中会让它们运行更快。<br>    下面的程序实现了logistic回归。logistic回归是一个常见的用于寻找一个能最佳分割两组点（如垃圾邮件和非垃圾邮件）的超平面w的经典算法。算法使用梯度下降法：w开始时是随机值，每一次迭代，对w的函数求和，使w朝着优化的方向移动。</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> points <span class="token operator">=</span> spark<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                  <span class="token punctuation">.</span>map<span class="token punctuation">(</span>parsePoint<span class="token punctuation">)</span><span class="token punctuation">.</span>persist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> w <span class="token operator">=</span> <span class="token comment">//随机初始向量</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span>to ITERATIONS<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>  <span class="token keyword">val</span> gradient <span class="token operator">=</span> points<span class="token punctuation">.</span>map<span class="token punctuation">&#123;</span>p <span class="token keyword">=></span>    p<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span>exp<span class="token punctuation">(</span><span class="token operator">-</span>p<span class="token punctuation">.</span>y<span class="token operator">*</span><span class="token punctuation">(</span>w dot p<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>p<span class="token punctuation">.</span>y  <span class="token punctuation">&#125;</span><span class="token punctuation">.</span>reduce<span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token keyword">=></span> a<span class="token operator">+</span>b<span class="token punctuation">)</span>  w <span class="token operator">-=</span> gradient<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们一开始定义了一个缓存RDD——points，作为在一个文本文件上调用map转换的结果，即把文本的每行都解析为Point对象。然后在points上运行<em>map</em>和<em>reduce</em>来计算梯度，在每一步对当前w的函数求和。把points保存在内存中迭代能提高20倍的速度，我们将在6.1节可以看到。</p><h3 id="3-2-2、网页排名（PageRank）"><a href="#3-2-2、网页排名（PageRank）" class="headerlink" title="3.2.2、网页排名（PageRank）"></a>3.2.2、网页排名（PageRank）</h3><p>在网页排名中会出现更加复杂的数据共享模式。算法通过把链向每个页面的所有页面的贡献值（<em>contributions</em>）加起来，迭代地更新每个页面的<em>rank</em>。在每次迭代过程中，每个页面给周围页面发送r/n个contribution，这里r是它的排名，n是周围文件的个数。接下来，它把它的排名更新为$\alpha/N+(1-\alpha)\sum{c_{i}}$，其中求和是对它接收到的贡献值，N是页面个数。在Spark中我们可以把网页排名写成如下代码：</p><pre class="line-numbers language-scala" data-language="scala"><code class="language-scala"><span class="token keyword">val</span> links <span class="token operator">=</span> spark<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span>persist<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> ranks <span class="token operator">=</span> <span class="token comment">//(URL, rank)对的RDD</span><span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">1</span> to ITERATIONS<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token comment">//根据每个页面发送过来的贡献值创建(targetURL, float)对的RDD，</span><span class="token keyword">val</span> contibs <span class="token operator">=</span> links<span class="token punctuation">.</span>join<span class="token punctuation">(</span>ranks<span class="token punctuation">)</span><span class="token punctuation">.</span>flatMap<span class="token punctuation">&#123;</span>  <span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span>links<span class="token punctuation">,</span> rank<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">=></span>  links<span class="token punctuation">.</span>map<span class="token punctuation">(</span>dest <span class="token keyword">=></span> <span class="token punctuation">(</span>dest<span class="token punctuation">,</span> rank<span class="token operator">/</span>links<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token punctuation">&#125;</span>  <span class="token comment">//根据URL对贡献值求和，并获取新的排名</span>  ranks <span class="token operator">=</span> contibs<span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token keyword">=></span> x<span class="token operator">+</span>y<span class="token punctuation">)</span>                 <span class="token punctuation">.</span>mapValues<span class="token punctuation">(</span>sum <span class="token keyword">=></span> a<span class="token operator">/</span>N<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>a<span class="token punctuation">)</span><span class="token operator">*</span>sum<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101040376.png"></p><p>这个程序会生成如图3中的RDD血缘图。每一步迭代过程，我们都会基于上一个迭代器的contribs、ranks和静态的links集合创建一个新排名集合（排名更新了）。这个图有一个特征：随着迭代次数的增加，图会变得越来越长。因此，在一个拥有很多迭代步骤的作业中，有必要可靠复制ranks的一些版本以减少故障恢复次数。用户可以调用带可靠标识的 <em>persist</em>来达到目的。值得注意的是，links集合不需要被复制，因为它的分区可以通过在输入文件块上重新运行 <em>map</em>操作来重建。这个数据集将比ranks大，因为每个文件有很多链接但只有一定数量会作为它的排名，以致于在系统上使用lineage比检查点检查程序整个内存状态来恢复要更快。</p><p> 最后，我们可以通过控制RDDs的分区来优化网页排名中的通信。如果我们为links指定一个分区方式（如根据URL对link列表跨节点哈希分区），我们则可以以相同的方式对ranks分区，并确保links和ranks的join操作不需要通信（因为每个URL的排名将会与它的link列表在相同的机器上）。我们也可以写一个Partitioner类把相互连接的页面聚在一起（比如按域名对URL分区）。这两种优化可以表示为在定义links时调用partitionBy：</p><pre class="line-numbers language-none"><code class="language-none">links &#x3D; spark.textFile(...).map(...)             .partitionBy(myPartFunc).persist()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>该初始化调用后，links和ranks的join操作将自动把每个URL的贡献值聚合到它link列表所在的机器上，在那计算它的新排名，并join它和它的links。这类多次迭代的一致性分区是指定框架（Pregel）中主要优化方式之一。RDDs让用户直接表达他的目的。</p><h1 id="4、表示RDDs（Representing-RDDs）"><a href="#4、表示RDDs（Representing-RDDs）" class="headerlink" title="4、表示RDDs（Representing RDDs）"></a>4、表示RDDs（Representing RDDs）</h1><p>把RDDs作为一个抽象会有一个问题：为它们选择一个代表在广泛的transformations中能追踪血缘。理想情况下，一个实现RDDs的系统应该提供尽可能丰富的转换算子，并让用户以任意方式组合它们。我们为RDDs提出一个简单的基于图的代表以达到这些目的。我们已经在Spark中使用这个代表去支持广泛的transformations，而且不会为任何transformation去给调度器添加特殊逻辑，这极大地简化了系统设计。<br>    简而言之，我们了一个通用接口去代表每个RDD，该接口表达五种信息:</p><ul><li>一组分区（<em>partitons</em>），数据集的原子组成</li><li>一组父RDDs上的依赖（<em>dependencies</em>）</li><li>一个基于父数据集计算的函数</li><li>分区策略的元数据</li><li>数据位置策略</li></ul><p>例如，一个RDD表示一个HDFS文件的每个块都有一个分区，并且知道每个块在哪台机器上。同时，在这个RDD上执行<em>map</em>操作后的结果分区不变。我们把这个接口总结在表3中。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101044377.png"></p><table><thead><tr><th>操作</th><th>含义</th></tr></thead><tbody><tr><td>partitions()</td><td>返回Partiton对象的列表</td></tr><tr><td>preferredLocations(<em>p</em>)</td><td>列出<em>p</em>分区由于数据局部性可以被快速访问的节点</td></tr><tr><td>dependencies()</td><td>返回依赖列表</td></tr><tr><td>iterator(<em>p, parentIters</em>)</td><td>根据为父分区指定的迭代器，逐个计算<em>p</em>分区的元素</td></tr><tr><td>partitioner()</td><td>返回RDD是否是hash/range分区的元数据信息</td></tr></tbody></table><p>表3：Spark中用于表示RDDs的接口</p><p>在设计这个接口时最有趣的问题是怎样在RDDs间表示依赖。我们发现把依赖分成两类足够了，并且很有用。</p><ul><li>一类是窄依赖。父RDD的每个分区被子RDD的至多一个分区使用。</li><li>一类是宽依赖。多个子分区依赖于一个父分区。</li></ul><p>例如，<em>map</em>操作会发生窄依赖，<em>join</em>操作发生宽依赖（除非父RDD是哈希分区）。图4显示了其他例子。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101045133.png"></p><p>Figure4：宽窄依赖的例子。每个空心框代表一个RDD，里面的阴影矩阵代表分区。</p><p> 这个区别是有用的，有两个原因。第一，窄依赖考虑到了一个节点上的流水线执行。例如，在一个个元素上先应用filter然后map。相反，宽依赖需要父分区的所有数据可用，并用一个类似于MapReduce的操作在节点间重排（shuffle）。第二，窄依赖使节点故障后恢复更有效，因为只有丢失的父分区需要被重新计算，并且可能在不同节点上并行计算。相反，在宽依赖的血缘图中，单一的故障节点可能导致一个RDD所有祖先的一些分区丢失，需要一个完全的重新执行。<br>    这个RDDs通用接口在Spark中实现的大部分transformations都少于20行代码。甚至Spark新用户在不知道调度器的细节的情况下都能够实现新的transformations（如sampling和各种join）。下面写了一些RDD实现。</p><p><strong>HDFS files</strong>：我们采样的输入RDDs都是来自于HDFS中的文件。对于这些RDDs，<em>partitions</em>返回文件每个块的分区（块的偏移量存在于每个Partition对象中）。<em>preferredLocations</em>给出块所在节点和读块的迭代器。</p><p><em><strong>map</strong></em>：在任何RDD上调用<em>map</em>都会返回MappedRDD对象。这个对象和它的父RDD有相同的分区和首选位置。<em>map</em>的参数是一个函数，对于父RDD中的所有记录，将以<em>iterator</em>方法的方式执行这个函数。</p><p><em><strong>union</strong>：对两个RDD调用</em>union会返回一个分区为父RDD分区的联合的RDD。每个子分区都是在相应的父分区上进行窄依赖计算得到的。</p><p><em><strong>sample</strong></em>：采样类似于映射，除了RDD会为每个分区保存一个随机数生成种子以确定性地采样父分区记录。</p><p><em><strong>join</strong></em>：join两个RDD可能会产生两个窄依赖（如果他们具有相同的hash/range分区），可能是两个宽依赖，也可能都有（如果一个父RDD有分区，另一个没有）。</p><h1 id="5、实现（Implementation）"><a href="#5、实现（Implementation）" class="headerlink" title="5、实现（Implementation）"></a>5、实现（Implementation）</h1><p>我们用大约14000行Scala代码实现了Spark。系统运行在Mesos集群管理器上，使其能够与Hadoop、MPI和其他应用程序共享资源。每个Spark程序都作为独立的Mesos应用运行，它有自己驱动程序（master）和workers，并且在这些被Mesos处理的应用中共享资源。<br>    Spark可以从任何Hadoop输入源读取数据（比如HDFS、HBase），只需要使用Hadoop已存在的插件的API，在Scala的未修改版本上运行。<br>    我们大致说几个该系统技术上比较有趣的部分：任务调度（5.1节），Spark解释器允许交互式使用（5.2节），内存管理（5.3节），支持检查点（5.4节）。</p><h2 id="5-1、任务调度（Job-Scheduling）"><a href="#5-1、任务调度（Job-Scheduling）" class="headerlink" title="5.1、任务调度（Job Scheduling）"></a>5.1、任务调度（Job Scheduling）</h2><p>Spark的调度器使用了RDDs的表示，在第4节已经描述过了。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101056213.png"></p><p>​    总而言之，我们的调度器与Dryad的类似，但它另外还考虑了持久化的RDDs的哪些分区在内存中可用。无论何时用户运行在RDD上运行action，调度器都会检查RDD的血缘图，建立由stages组成的DAG，然后执行，如图5的插图。每个阶段（stage）包含尽可能多的窄依赖流水线转换（transformations）。stages的边界是宽依赖shuffle操作，或者任何已经计算过的分区，它可以截断父RDD的计算。然后，调度器在每个stage中运行任务去计算丢失的分区，知道计算出想要的RDD。</p><blockquote><p>DAG是指有向无环图（Directed Acyclic Graph），它是一种数据结构，用于表示计算任务之间的依赖关系。在RDD中，每个RDD都可以被看作是一个DAG中的一个节点。DAG的每个边表示一个转换操作，例如map或reduce。由于DAG是无环的，因此可以保证计算任务按正确的顺序执行，避免了循环依赖和死锁等问题。RDD使用DAG来跟踪数据集之间的依赖关系，并在需要时重新计算丢失的数据分区。这种机制使得RDD具有容错性和高效性。</p></blockquote><p>​    调度器基于数据存放位置使用延迟调度给机器指派任务。如果一个任务需要处理节点内存中可用的分区，我们就把它发送给那个节点。但是，如果处理的分区位于多个可能的位置（如HDFS文件），则把任务发送给这些节点。</p><p>​    对于宽依赖（即shuffle依赖），我们一般把中间结果具体化在持有父分区的节点上，以简化故障恢复，很像MapReduce物化map的输出结果。</p><p>​    如果一个任务失败，只要它的stage的父分区还可用，我们将在另一个节点上重新运行它。如果一些stages已经不可用（例如，由于一个shuffle的map输出结果丢失了），我们会重新提交任务去并行地计算丢失分区。我们还不能对调度器故障容错，但是复制RDD血缘图是直截了当的做法。</p><p>​    最后，虽然Spark中所有当前运行的计算都对驱动程序中调用的actions响应，我们也会试验让集群上的任务（如maps）调用<em>lookup</em>操作，该操作允许按关键字随机访问哈希分区的RDDs的元素。在这种情况下，任务需要告诉调度器去计算哪些丢失的分区。</p><h2 id="5-2、解释器的集成（Interpreter-Integration）"><a href="#5-2、解释器的集成（Interpreter-Integration）" class="headerlink" title="5.2、解释器的集成（Interpreter Integration）"></a>5.2、解释器的集成（Interpreter Integration）</h2><p> Scala包含一个类似于Ruby和Python的交互式shell。考虑到实现内存中数据带来的低延迟，我们希望让用户在解释器上交互式地运行Spark，查询大数据集。<br>    Scala解释器通常把用户输入的代码行编译成一个类，然后加载到JVM，之后调用类的函数。这个类包括一个单例对象（单例对象包含那行代码的变量或方法），并且在一个初始化函数中运行那行代码。例如，如果用户写入<code>var x = 5</code>，接下来<code>println(x)</code>，解释器会定义包含x的Line1类，并让第二行编译成<code>println(Line1.getInstance().x)</code>。<br>    我们对Spark中的编译器做了两点改变：</p><ul><li>类传输：为了让工作节点获取每行代码上创建的类的字节码，我们使解释器基于HTTP传输这些类。</li><li>改进的代码生成逻辑：一般地，每行代码生成的单例对象是通过相应的类上的一个静态方法去访问的。这意味着当我们序列化一个引用了前一行定义的变量的闭包时（如上面例子中的<code>Line1.x</code>），Java将不会通过对象图跟踪而传输包装<code>x</code>的<code>Line1</code>实例。因此，工作节点将不接受<code>x</code>。我们把代码生成逻辑改成了直接引用每行对象的实例。</li></ul><p> 图6显示在做了上面两个改变后，解释器怎样把用户写的一系列代码行翻译成Java对象。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101106530.png"></p><p>Figure6：显示解释器怎样把用户输入的两行代码翻译成Java对象</p><p>我们发现Spark解释器便于处理大量跟踪关系，也便于研究HDFS中保存的数据集。我们也计划交互式地运行更高级的查询语言，如SQL。</p><h2 id="5-3、内存管理（Memory-Management"><a href="#5-3、内存管理（Memory-Management" class="headerlink" title="5.3、内存管理（Memory Management)"></a>5.3、内存管理（Memory Management)</h2><p>Spark对于持久化RDDs提供了三个选项：</p><ul><li>序列化成Java对象存储在内存中</li><li>作为序列化数据存储在内存中</li><li>存储在磁盘上</li></ul><p>第一个选项性能最快，因为JVM能在本机访问每个RDD元素。第二个选项让用户在内存空间有限时，选择比Java对象图更加有效的存储方式，性能会差一点。第三个选项对于那些太大而无法存入内存的RDDs是有用的，但是每次使用都需要重新计算，这很耗时。<br>    为了管理有限的可用内存，我们基于RDDs的级别使用LRU淘汰策略。当计算一个新的RDD分区，而又没有足够的空间存储它时，我们淘汰一个最近最少访问RDD的分区，除非这个RDD和新分区的一样。在这种情况下，我们把旧分区存入内存以防止相同RDD的分区循环读入和写出。这很重要，因为大多数操作将在整个RDD上运行任务，所以很可能以后会需要用到一直在内存中的分区。我们发现，目前为止这个默认的策略在我们的应用中很好地工作，我们通过每个RDD的“持久化优先级“，让用户进一步控制RDD。<br>    目前，集群上Spark的每个实例都有自己独立的内存空间。未来，我们打算研究通过统一的内存管理实现在Spark实例间共享RDDs。</p><h2 id="5-4、支持检查点（Checkpointing）"><a href="#5-4、支持检查点（Checkpointing）" class="headerlink" title="5.4、支持检查点（Checkpointing）"></a>5.4、支持检查点（Checkpointing）</h2><p> 虽然血缘图总是被用于在故障后恢复RDDs，但这样的恢复在血lineage链很长的时候会很耗时。因此，把一些RDD执行检查点操作存入稳定内存十分有用。<br>    一般地，检查点对于Lineage图长、宽依赖的RDDs很有用，如3.2.2节中PageRank例子中的rank集合。在这些情况下，集群中节点故障可能导致会每个父RDD的一些数据分片丢失，这就需要完全重新计算，<strong>检查点操作在这里就可以避免完全重新计算</strong>。相反，对于稳定存储数据上的窄依赖RDDs，检查点没什么价值。如果节点故障，这些RDDs丢失的分区可以并行地在其他节点上计算，成本比复制整个RDD要少得多。<br>    Spark目前为检查点提供了一个API（给<em>persist</em>传入REPLICATE标识），把checkpoint哪个数据的决定权留给了用户。然而，我们也研究了怎样实现自动的检查点。因为我们的调度器知道每个数据集的大小，也知道第一次计算花费的时间，所以它应该能选择一个优化的RDDs集合执行检查点操作，最小化系统恢复时间。<br>    最后，值得注意的是RDDs的只读属性使检查点操作比常见的共享内存更简单。因为不需要关注一致性，RDDs可以在不需要程序中断或分布式快照方案的情况下在后台写出。</p><h1 id="6、测评（Evaluation）"><a href="#6、测评（Evaluation）" class="headerlink" title="6、测评（Evaluation）"></a>6、测评（Evaluation）</h1><p>我们再Amazon EC2上做了一系列实验，以此来评估Spark和RDDs，并与其他用户应用程序的基准做了对比。总之，我们的结果如下：</p><ul><li>Spark在迭代机器学习和图像应用方面性能比Hadoop高20倍。速度的提升的原因是，把数据作为Java对象存入内存中避免了I/O和反序列化的成本。</li><li>用户所写应用执行效果好。我们使用Spark对原来在Hadoop上运行的分析报告提升了40倍。</li><li>当节点故障，Spark可以通过只重建丢失的RDD分区来快速恢复。</li><li>Spark用于交互式地查询1TB数据集，只有5-7s的延迟。</li></ul><p> 我们将在6.1节呈现与Hadoop对比的迭代机器学习应用的基准，6.2节呈现对比后的PageRank。然后，6.3节评估Spark中故障恢复，6.4节呈现数据集在内存不足时的行为。最后，6.5节讨论用户应用程序的结果，6.6节交互式数据挖掘。<br>    除非另有说明，我们的测试使用m1.xlarge EC2节点，4核，15G内存。我们使用HDFS存储，块大小256M。在每个测试之前，为了准确地测量IO成本，我们清理了操作系统缓存。</p><h2 id="6-1、迭代机器学习应用（Iterative-Machine-Learning-Applications）"><a href="#6-1、迭代机器学习应用（Iterative-Machine-Learning-Applications）" class="headerlink" title="6.1、迭代机器学习应用（Iterative Machine Learning Applications）"></a>6.1、迭代机器学习应用（Iterative Machine Learning Applications）</h2><p>我们实现了两个迭代机器学习应用，逻辑回归和k-means，为了比较下面系统的性能：</p><ul><li><em>Hadoop</em>：Hadoop 0.20.0稳定版本</li><li><em>HadoopBinMem</em>：一个Hadoop部署。第一次迭代时，把输入数据转换成低开销二进制格式，以消除在之后迭代过程的文本解析，并把它存入内存中的HDFS实例。</li><li><em>Spark</em>：RDDs的实现。</li></ul><p>我们用25-100台机器在100GB的数据集上对这两个算法进行了10次迭代。两个应用程序的主要区别在于他们执行数据每个字节的计算的数量。k-means的迭代时间主要取决于计算，但逻辑回归不是计算密集型的，因此时间更多地花费在反序列化和I/O上。<br>    由于经典的学习算法需要几十次迭代才能收敛，所以我们在报告时间时，把首轮迭代的时间与后续迭代的时间分开。我们发现经RDDs共享数据极大地加快了后面的迭代。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101117076.png"></p><p>Figure7：图表示了逻辑回归和k-means两种算法分别在Hadoop、HadoopBinMem和Spark三种集群中的首轮迭代和后续迭代的时长。实验是在有100个节点的集群上对100GB数据进行的。<br>Figure：Hadoop、HadoopBinMem和Spark上后续迭代的运行时间。</p><p><strong>首轮迭代</strong> 三个系统在首轮迭代时都从HDFS中读取文本输入。如图7中的浅色长方形所示，实验中Spark比Hadoop更快。这个不同是因为在Hadoop的master和workers之间的心跳协议中的通信开销。HadoopBinMem是最慢的，因为它运行了一个额外的MapReduce工作去把数据转成二进制的，它必须通过网络把这个数据写向一个复制的内存HDFS实例。</p><p><strong>后续迭代</strong> 图7也显示了后续迭代的平均运行时间，图8显示了随着集群大小的变化是运行时间的分布情况。对于logistic回归，在100台机器上，Spark比Hadoop快25.3倍，比HadoopBinMem快20.7倍。对于更加计算密集型的k-means应用，Spark有1.9到3.2倍的提速。</p><p><strong>理解速度</strong> 我们惊讶地发现，Spark甚至都超过了基于内存存储二进制数据的Hadoop（HadoopBinMem）20多倍。在HadoopBinMem中，我们使用了Hadoop的标准二进制格式（SequenceFile）和256MB大的块，我们还强制HDFS的数据直接存放在内存文件系统。然而Hadoop仍然运行缓慢，有以下几个因素：</p><ol><li>Hadoop软件栈的最小开销</li><li>提供数据时HDFS的开销</li><li>把二进制记录转换成可用的内存Java对象的反序列化成本</li></ol><p>我们来依次研究这几个因素。为了衡量（1），我们运行没有操作的Hadoop作业，然后发现，仅仅完成作业设置，启动任何和清理工作的最小需求就需要花费至少25s的开销。对于（2），我们发现HDFS为每个块提供多次内存拷贝和计算校验和的操作。</p><p>最后，为了测量（3），我们在单机上运行微基准程序，在256MB多种格式的输入上运行逻辑回归计算。尤其，我们比较了来源于HDFS（这里将体现出HDFS栈的开销）和内存本地文件（内核能够非常有效地把数据传递给程序）的文本输入和二进制输入的处理时间。</p><p>我们在图9中展示了这些实验的结果。内存中的HDFS和本地文件的区别显示，从HDFS读取数据会多花费2s的开销，甚至数据就在本地机器的内存中。文本输入和二进制输入的区别表明，解析的开销相差7s。甚至当从内存文件读取数据时，把预解析的二进制数据转成Java对象都要花费3s，这几乎和逻辑回归本身的成本一样。而Spark通过在内存中把RDD元素直接存成Java对象，避免了以上所有开销。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101121293.png"></p><h2 id="6-2、网页排名（PageRank）"><a href="#6-2、网页排名（PageRank）" class="headerlink" title="6.2、网页排名（PageRank）"></a>6.2、网页排名（PageRank）</h2><p>我们使用了54GB维基百科数据，比较分别在Spark和Hadoop上实现PageRank的性能。我们运行10轮PageRank算法去处理大约4百万文章的链接图。图10显示在30台节点上，只基于内存存储时，Spark比Hadoop快2.4倍。另外，控制RDDs的分区方式使整个迭代过程保持一致，如3.2.2节所讨论的，提升速度至7.4倍。扩展到60台机器，结果也随之近于线性地减少。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101128569.png"></p><p>Figure10： 在Hadoop和Spark上PageRank的性能</p><p>我们也评估了PageRank的两一个版本——用Pregel在Spark上实现，我们再7.1节进行描述。迭代时间与图10类似，但是长了4s，因为Pregel会在每次迭代额外运行一个操作，这个操作让顶点“投票”是否结束作业。</p><h2 id="6-3、故障恢复（Fault-Recovery）"><a href="#6-3、故障恢复（Fault-Recovery）" class="headerlink" title="6.3、故障恢复（Fault Recovery）"></a>6.3、故障恢复（Fault Recovery）</h2><p>我们对k-means应用评估了其在单点故障后，使用lineage重建RDD分区的成本。图11比较了在75个节点的集群上k-means10轮迭代在正常情况下和一个节点在第六轮迭代的开始时故障的情况下的运行时间。没有任何故障，每轮迭代会运行400各任务处理100GB数据。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101129802.png"></p><p>Figure11：k-means存在故障时的迭代时间。在第六轮迭代开始时kill掉一台机器导致使用lineage部分重构RDD</p><p>直到第五轮迭代结束，迭代时间都是大约58s。在第六轮迭代，一台机器被kill掉，导致运行在该机器上的任务和存储该机器上的RDD分区的丢失。Spark在其他机器上并行地重新运行这些任务，他们在这些机器上重新读取相应的输入数据并通过lineage重构RDDs，这会让迭代时间增至80s。一旦丢失的RDD分区被重建，迭代时间将降回到58s。<br>    值得注意的是，基于检查点的故障恢复机制，恢复将可能需要运行至少几轮迭代，取决于检查点操作的频率。更进一步说，系统将需要通过网络复制应用的100GB工作集（文本输入数据转成二进制），要么消费两次Spark内存去复制它到内存中，要么将不得不等到100GB写入磁盘。相反地，我们例子中RDDs的血缘图都是小于10KB的。</p><h2 id="6-4、内存不足时的行为（Behavior-with-Insufficient-Memory）"><a href="#6-4、内存不足时的行为（Behavior-with-Insufficient-Memory）" class="headerlink" title="6.4、内存不足时的行为（Behavior with Insufficient Memory）"></a>6.4、内存不足时的行为（Behavior with Insufficient Memory）</h2><p>目前为止，我们确保每个集群中每台机器有足够内存存储迭代中所有的RDDs。一个自然的问题是，如果没有足够的内存去存储作业的数据时Spark怎样运行。在这个实验中，我们配置Spark在每台机器上不是用超过一定百分比的内存去存储RDDs。我们在图12中展示逻辑回归在多种百分比内存空间下的运行结果。我们看见随着空间变小性能缓慢下降。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101131292.png"></p><h2 id="6-5、基于Spark建立的用户应用（User-Applications-Built-with-Spark）"><a href="#6-5、基于Spark建立的用户应用（User-Applications-Built-with-Spark）" class="headerlink" title="6.5、基于Spark建立的用户应用（User Applications Built with Spark）"></a>6.5、基于Spark建立的用户应用（User Applications Built with Spark）</h2><p><strong>内存分析（In-Memory Analytics）</strong> Conviva Inc（一家视频发行公司）使用Spark加快了数据分析报告的数据，以前是基于Hadoop上运行的。举个例子，一个报告被作为一系列Hive查询运行为客户计算多种统计。这些查询全都是基于数据的相同子集（记录匹配用户提供的过滤器），但在不同分组的字段上执行聚合（averages, precentiles和COUNT DISTINCT）操作需要独立的MapReduce作业。在Spark中实现上述查询，并把数据子集一次加载到RDD中，该公司能够对报告提速40倍。一个基于200G压缩数据的报告在Hadoop集群上运行要花费20小时，现在仅仅只需要2台Spark机器就可以运行在30分钟以内。更进一步，Spark程序只需要96GB的RAM，因为它只把匹配用户过滤器的行和列存入RDD，而不是所有解压文件。<br><strong>交通建模（Traffic Modeling）</strong> 在Berkeley的Mobile Millennium项目中，研究人员基于分散的汽车GPS测量，并行化一个学习算法去预测道路交通阻塞情况。源数据是城市的10000个互联的道路网，还有600,000由装备GPS的汽车采集到的点到点的行驶时间的样本（每条路线的形式时间可能包括多条互联的道路）。使用交通模型，系统可以估计跨交通网花费的时间。研究人员用一个期望最大化算法训练这个模型，这个算法迭代地重复两次<em>map</em>和<em>reduceByKey</em>步骤。这个应用近乎线性地从20个节点扩展到80个节点，每个节点4核，如图13(a)所示。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101132533.png"></p><p>图13：用Spark实现的两个用户应用程序每次运行时间。错误条显示标准差。</p><p><strong>Twitter垃圾分类（Twitter Spam Classification）</strong> 伯克利的Monarch项目用Spark识别Twitter信息中的垃圾链接。他们在Spark之上实现了一个逻辑回归分类器，和6.1节中例子类似，但他们使用分布式的 <em>reduceByKey</em>对并行的梯度向量求和。在图13(b)中，我们展示了在超过50GB数据上训练一个分类器的扩展结果，数据包括250000URLs和10^7与网络相关的特征/维度和在每个URL的页面的内容属性。缩放不是接近线性的原因是每次迭代都会有更高的固定通信成本。</p><h2 id="6-6、交互式数据挖掘（Interactive-Data-Mining）"><a href="#6-6、交互式数据挖掘（Interactive-Data-Mining）" class="headerlink" title="6.6、交互式数据挖掘（Interactive Data Mining）"></a>6.6、交互式数据挖掘（Interactive Data Mining）</h2><p>为了证明Spark在交互查询大数据集方面的能力，我们用它去分析1TB的维基百科页面访问日志（2年的数据）。这个实验，我们用8核、68GB内存的100m2.3xlarge EC2实例。我们运行查询以获得以下内容总访问次数（1）所有页面，（2）标题能精确匹配给定关键字的页面，（3）标题部分匹配关键字的页面。每个查询会扫描整个输入数据。<br>    图14显示的是在整个数据集、一半数据和十分之一数据的查询响应时间。甚至在1TB的数据上，Spark上的查询只需要花费5-7s。这比查询磁盘上的数据的速度快一个数量级以上。例如，从磁盘上查询1TB的文件花费了170s。这证明了RDDs使Spark更适用于交互式数据挖掘。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305101138110.png"></p><p>Figure14：在Spark上交互式查询的响应时间，在100台机器上扫描持续增大的输入数据集</p><h1 id="7、讨论（Discussion）"><a href="#7、讨论（Discussion）" class="headerlink" title="7、讨论（Discussion）"></a>7、讨论（Discussion）</h1><p>虽然，由于RDDs的不可变的性质和粗粒度转换，它们提供了一个限制的编程接口，但我们发现它们适用于广泛类别的应用。尤其，RDDs可以表达的集群编程模型数量惊人，这些集群编程模型目前为止都被作为独立框架提出，允许用户在一个项目（例如，运行一个MapReduce操作图建立一个图，然后在其上运行Pregel）中<em>compose</em>这些模型，并在他们之间分享数据。在这一节，我们将在7.1小节讨论RDDs可以表达哪些编程模型和为什么它们应用这么广泛。另外，我们在7.2小节讨论RDDs中lineage信息的另一个好处，即为了方便在这些模型上调试。</p><h2 id="7-1、表达已有的编程模型（Expressing-Existing-Programming-Models）"><a href="#7-1、表达已有的编程模型（Expressing-Existing-Programming-Models）" class="headerlink" title="7.1、表达已有的编程模型（Expressing Existing Programming Models）"></a>7.1、表达已有的编程模型（Expressing Existing Programming Models）</h2><p>RDDs可以<em>有效地</em>表达一些目前已经独立提出的集群编程模型。这里说<em>有效地</em>，我们的意思是RDDs不仅可以产生和这些模型相同的结果，还可以捕获这些框架执行的优化，如把指定的数据保存在内存中，对它进行分区以最小化通信并且高效地从故障中恢复。可以使用RDDs表达的模型包括：</p><p><strong>MapReduce</strong>：这个模型可以通过在Spark使用<em>flatMap</em>和<em>groupByKey</em>操作，或者在有结合器时使用<em>reduceByKey</em>操作来表达。</p><p><strong>DryadLINQ</strong>：DryadLINQ系统提供了比在更普通的Dryad运行时的MapReduce更广泛的算子。但是这些是直接对应于Spark中可用的RDD转换的所有大型算子（如map, groupByKey,join,etc）。</p><p><strong>SQL</strong>：类似于DryadLINQ表达式，SQL需要在记录集上执行数据并行化操作。</p><p><strong>Pregel</strong>：Google 的 Pregel [22] 是专门用于迭代图像应用的模型，它最初与其他系统中的面向集合的编程模型有很大不同。在Pregel中，程序运行为一系列协调的“superstep”。在每个superstep中，图中的每个顶点运行一个用户函数，可以更新与顶点相关的状态，改变图拓扑，并将消息发送给其他顶点，以便在下一个superstep中使用。该模型可以表达许多图算法，包括最短路径、二部匹配和PageRank。</p><p>让我们用 RDD 实现这个模型的关键观察是 Pregel 在每次迭代中将相同的用户函数应用于所有顶点。因此，我们可以在 RDD 中存储每次迭代的顶点状态并执行批量转换 (flatMap) 来应用该函数并生成消息的 RDD。然后，我们可以将这个 RDD 与顶点状态连接起来以执行消息交换。同样重要的是，RDD 允许我们像 Pregel 那样在内存中保留顶点状态，通过控制它们的分区来最小化通信，并支持对故障的部分恢复。我们在Spark之上实现了Pregel作为200行库，并请读者参考[33]了解更多细节。</p><p><strong>Iterative MapReduce</strong>：最近提出的几个系统，包括 HaLoop [7] 和 Twister [11]，提供了一个迭代 MapReduce 模型，其中用户向系统提供一系列 MapReduce 作业以循环。系统保持数据在迭代之间始终分区，Twister 还可以将其保存在内存中。这两个优化都很容易用 RDD 表达，我们能够使用 Spark 将 HaLoop 实现为 200 行库。</p><p><strong>批处理流处理（Batched Stream Processing）</strong>：研究人员最近提出了几种增量处理系统，用于周期性地用新数据更新结果[21,15,4]。例如，每15分钟更新一次广告点击统计信息的应用程序应该能够将前15分钟窗口的中间状态与来自新日志的数据结合起来。这些系统执行与Dryad类似的批量操作，但将应用程序状态存储在分布式文件系统中。将中间状态放在RDD中可以加快它们的处理速度。</p><p><strong>解释RDD的表达能力（Explaining the Expressivity of RDDs）</strong>：</p><p>为什么 RDD 能够表达这些不同的编程模型？原因是 RDD 的限制在许多并行应用程序中几乎没有影响。特别是，虽然 RDD 只能通过批量转换创建，但许多并行程序自然会对许多记录应用相同的操作，这使得它们易于表达。类似地，RDD 的不变性不是障碍，因为人们可以创建多个 RDD 来表示相同数据集的版本。事实上，今天的许多MapReduce应用程序运行在不允许更新文件的文件系统上，如HDFS。</p><p>最后一个问题是为什么以前的框架没有提供相同的通用性水平。我们认为这是因为这些系统探索了 MapReduce 和 Dryad 不能很好地处理的特定问题，例如迭代，而不观察这些问题的共同原因是缺乏数据共享抽象。</p><h2 id="7-2、利用RDDs进行调试（Leveraging-RDDs-for-Debugging）"><a href="#7-2、利用RDDs进行调试（Leveraging-RDDs-for-Debugging）" class="headerlink" title="7.2、利用RDDs进行调试（Leveraging RDDs for Debugging）"></a>7.2、利用RDDs进行调试（Leveraging RDDs for Debugging）</h2><p>虽然我们最初将rdd设计为可确定性地重新计算以实现容错性，但该属性也有助于调试。特别是，通过记录作业期间创建的RDD的沿行，可以(1)稍后重建这些RDD，并让用户以交互方式查询它们;(2)通过重新计算作业所依赖的RDD分区，在单进程调试器中重新运行作业中的任何任务。与传统的用于一般分布式系统的重播调试器[13]不同，它必须捕获或推断跨多个节点的事件顺序，这种方法实际上增加了零记录开销，因为只需要记录RDD血缘图。我们目前正在基于这些想法开发一个Spark调试器[33]。</p><h1 id="8、相关工作（Related-Work）"><a href="#8、相关工作（Related-Work）" class="headerlink" title="8、相关工作（Related Work）"></a>8、相关工作（Related Work）</h1><p><strong>集群编程模型</strong>：集群编程模型相关工作主要有几类。</p><p> 第一，数据流模型，如MapReduce、Drayad和Ciel，支持丰富的算子去处理数据，但通过稳定外部系统共享数据。RDDs表示的是一个比稳定存储更高效的数据共享抽象，因为它们避免了数据复制、I/O和序列化的成本。<br>    第二，数据流系统的高级别编程接口，包括DryadLINQ和FlumeJava，提供语言集成APIs，它们可以让用户通过像<em>map</em>和<em>join</em>的算子操作“并行的集合”。然而，在这些系统，并行的集合要么代表磁盘上的文件，要么代表用来表达查询计划的临时数据集。即使，系统将在相同的查询中的算子间流水线化数据（如一个<em>map</em>接着另一个<em>map</em>），它们不能在查询间高效地共享数据。我们把Spark的API基于并行集合模型是因为它的便利，并且不主张新奇的语言集成接口，但是通过这个接口的背后提供RDDs作为存储抽象，我们允许它支持更广泛类型的应用。<br>    第三类系统为需要数据共享的特别类型的应用提供高级别接口。例如，Pregel支持迭代图像应用，而Twister和HaLoop支持迭代MapReduce的运行。然而，这些框架对它们支持的计算类型隐式地执行数据共享，也不提供一个普遍地抽象让用户可以在他选择的操作间去共享他们选择的数据。例如，一个用户不能用Pregel或者Twister去把数据集加载到内存中，然后决定在它上面运行去查询什么。RDDs显示地提供一个分布式存储抽象，并可以支持这些特定系统不包括的应用，如交互式数据挖掘。</p><p>最后，一些系统暴露出共享可变状态以允许用户执行内存中的计算。例如，Picco让用户运行变形的函数读和更新分布式哈希表中的单元分布式共享。分布式共享内存系统和键值存储提供相似的模型。RDDs以两种方式区别这些系统。第一：RDDs提供一个高级别编程接口，接口基于如map/sort这些算子。而Piccolo和DSM中的接口仅仅是读和更新到表的单元中。第二，Piccolo和DSM系统通过检查点和回滚实现恢复，这比RDDs基于lineage的策略更耗费性能。最终，如2.3节所讨论的，RDDs也提供其他优点。</p><p><strong>缓存系统</strong>：Nectar能够通过识别带有程序分析的子表达式，在DryadLINQ作业间重用中间结果。把这种功能添加到基于RDD的系统将是引人入胜的。然而，Nectar不提供内存缓存（它把数据存放在分布是文件系统中），也不让用户显示地控制持久化哪些数据集和怎样对数据集分区。Ciel和FlumeJava同样可以缓存任务结果，但是却不提供内存缓存和显示控制缓存数据。<br>    Ananthanarayanan et al.提出给分布式文件系统添加一个内存缓存，以利用数据访问的时空本地化。虽然这个解决方案能够更快地访问在文件系统中的数据，但是它不像RDDs那样可以高效地在应用中共享中间结果，因为在stage间它仍然需要应用去把这些结果写到文件系统。</p><p><strong>Lineage</strong> ：对于一些应用，如需要说明结果的、允许其他应用复制的、如果在工作流中发现bug或者数据及丢失而导致的重新计算数据的，获取数据的血缘或出处信息一直都是科学计算和数据库的研究主题。RDDs提供了并行化编程模型，它的细粒度血缘较容易获取，所以它可以被用于故障恢复。<br>    我们的基于lineage恢复机制类似于MapReduce和Dryad中计算（作业）内使用的恢复机制，它在任务的DAG中追踪依赖。但在这些系统中，血缘信息在作业结束时被丢弃，需要使用备份存储系统跨计算分享数据。相反，RDDs把血缘应用于跨计算持久化内存中的数据，没有复制和磁盘I/O的开销。<br><strong>关系型数据库</strong>：RDDs概念上类似于数据库中的试图，持久化RDDs类似于物化试图。但，像DSM系统，数据库一般允许对所有的记录进行细粒度的读写访问，需要记录操作和数据来容错，并需要保持一致性的额外开销。</p><h1 id="9、结语"><a href="#9、结语" class="headerlink" title="9、结语"></a>9、结语</h1><p>我们已经介绍了RDDs，一个用于在集群应用中共享数据的高效的、普遍用途的、容错的抽象。RDDs能表达广发的并行应用，包括很多特殊的编程模型，已经提出用于迭代计算和这些模型不包含的新应用。已存在的集群存储抽象需要为容错而复制数据，而RDDs与此不同，RDDs提供一个基于粗粒度转换的API，让它们用lineage高效地恢复数据。我们已经在Spark中实现RDDs，运行迭代应用速度提升20X，可以用于交互式查询几百GB数据。我们已经开源Spark。</p>]]></content>
      
      
      <categories>
          
          <category> 论文翻译 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FaRM</title>
      <link href="/2023/051050105.html"/>
      <url>/2023/051050105.html</url>
      
        <content type="html"><![CDATA[<p>毫不妥协:具有一致性、可用性和性能的分布式事务</p><h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>具有强一致性和高可用性的事务简化了分布式系统的构建和推理。然而，以前的实现表现不佳。这迫使系统设计者完全避免事务，削弱一致性保证，或者提供要求程序员对其数据进行分区的单机事务。在本文中，我们展示了在现代数据中心中没有必要妥协。我们展示了一个名为FaRM的<strong>主内存分布式计算平台</strong>可以提供具有<strong>严格序列化性、高性能、持久性和高可用性的分布式事务</strong>。FaRM在拥有4.9 TB数据库的90台机器上实现了每秒1.4亿次TATP事务的峰值吞吐量，并且在不到50毫秒的时间内从故障中恢复。实现这些结果的关键是<strong>设计新的事务、复制和恢复协议</strong>，从第一原则出发，利用具有RDMA的商用网络和提供非易失性DRAM的新的廉价方法。</p><h1 id="1、介绍（Introduction）"><a href="#1、介绍（Introduction）" class="headerlink" title="1、介绍（Introduction）"></a>1、介绍（Introduction）</h1><p>具有高可用性和严格序列化性的事务[35]通过提供简单、强大的抽象简化了分布式系统的编程和逻辑:一台永远不会宕机的机器，以与实时一致的顺序执行一个事务。然而，之前在分布式系统中实现这种抽象的尝试导致了较差的性能。因此，Dynamo[13]或Memcached[1]之类的系统通过不支持事务或实现弱一致性保证来提高性能。其他(例如，[3 - 6,9,28])仅在所有数据驻留在单个机器内时才提供事务，这迫使程序员对数据进行分区，并使关于正确性的推理复杂化。</p><p>本文证明了现代数据中心的新软件可以消除妥协。它介绍了FaRM [16] (一个主内存分布式计算平台)中的事务、复制和恢复协议。FaRM提供分布式ACID事务，具有严格的序列化性、高可用性、高吞吐量和低延迟。这些协议的设计初衷是利用数据中心中出现的两种硬件趋势:<strong>使用RDMA的快速商用网络和提供非易失性DRAM的廉价方法</strong>。非易失性是通过将电池连接到电源单元，并在电源故障时将DRAM的内容写入SSD来实现的。这些趋势消除了存储和网络瓶颈，但也暴露了CPU瓶颈，限制了它们的性能优势。FaRM协议遵循三个原则来解决这些CPU瓶颈:<strong>减少消息计数</strong>，<strong>使用单侧RDMA读写而不是消息</strong>，以及有<strong>效地利用并行性</strong>。</p><p>FaRM通过在数据中心的机器上分布对象进行扩展，同时允许事务跨越任意数量的机器。FaRM不是使用Paxos复制协调器和数据分区(例如[11])，而是通过使用带主备份复制的垂直(vertical)Paxos[25] 和直接与primaries和replicas通信的非复制协调器来减少消息计数。FaRM使用乐观并发控制和四阶段提交协议(锁(lock)、验证(validation)、提交备份(commit back-up)，和提交主机(commit primary))[16]，但我们通过去除了锁定阶段的发送到backups的消息进而改进了原始协议。</p><p>FaRM通过使用单侧RDMA操作进一步降低了CPU开销。单侧RDMA不使用远程CPU，避免了大部分本地CPU开销。FaRM事务在事务执行和验证期间使用单侧RDMA读取。因此，它们在远程只读参与者上不使用CPU。此外，协调器在将log记录到事务中修改的replicas中的对象的非易失性预写日志时使用单侧RDMA。例如，协调器使用单个单侧RDMA将提交记录写入远程备份。因此，事务在备份时不使用前台CPU。稍后在后台延迟截断日志以就地更新对象时使用CPU。</p><p>使用单侧RDMA需要新的故障恢复协议。例如，FaRM不能依赖服务器在它们的租约[18]到期时拒绝传入的请求，因为请求是由网卡服务的，而网卡不支持租约。我们通过使用精确的precise membership[10]来解决这个问题，以确保机器同意当前的配置成员资格，并仅向作为成员的机器发送单边操作。FaRM也不能依赖传统机制来确保参与者在准备阶段拥有提交事务所需的资源，因为事务记录被写入参与者日志不涉及远程CPU。作为替代的，FaRM使用reservation来确保日志中有空间用于提交所需的所有记录，并在开始提交之前截断事务。</p><p>FaRM中的故障恢复协议速度很快，因为它有效地利用了并行性。它在整个集群中均匀地分配每个状态位的恢复，并在每台机器的核心之间并行地进行恢复。此外，它还使用了两种优化来允许事务执行与恢复并行进行。首先，事务在锁恢复阶段(只需几十毫秒即可完成)之后开始访问受故障影响的数据，而不是等待几秒钟进行其余的恢复。其次，不受故障影响的事务继续执行而不阻塞。FaRM还通过利用快速网络交换频繁的心跳来提供快速故障检测，并使用优先级和预分配来避免误报。</p><p>我们的实验结果表明，您可以同时拥有这一切:一致性、高可用性和性能。FaRM可以在不到50毫秒的时间内从单台机器故障中恢复，并且它的性能优于仅使用几台机器的最先进的单台内存事务系统。例如，仅在三台机器上运行时，它比Hekaton[14,26]实现了更好的吞吐量，并且比Silo[39,40]具有更好的吞吐量和延迟。</p><h1 id="2、硬件的发展趋势（Hardware-trends）"><a href="#2、硬件的发展趋势（Hardware-trends）" class="headerlink" title="2、硬件的发展趋势（Hardware trends）"></a>2、硬件的发展趋势（Hardware trends）</h1><p>FaRM的设计灵感来自于数据中心机器中大量廉价的DRAM。典型的数据中心配置每台2插槽机器[29]有128-512 GB的DRAM，而DRAM的成本低于12美元/GB1。这意味着一个pb的DRAM只需要2000台机器，这足以容纳许多需要的应用程序的数据集。此外，FaRM利用两种硬件趋势来消除存储和网络瓶颈:非易失性DRAM和具有RDMA的快速商用网络。</p><h2 id="2-1、非易失性DRAM（Non-volatile-DRAM）"><a href="#2-1、非易失性DRAM（Non-volatile-DRAM）" class="headerlink" title="2.1、非易失性DRAM（Non-volatile DRAM）"></a>2.1、非易失性DRAM（Non-volatile DRAM）</h2><p>“分布式不间断电源(UPS)”利用锂离子电池的广泛可用性来降低数据中心UPS的成本，而不是使用铅酸电池的传统集中式方法。例如，微软的开放云服务器(OCS)规范包括本地能量存储(LES)[30,36]，它将锂电池与电源单元集成在机架内的每个24机机箱中。估计LES UPS的成本低于每焦耳0.005美元。这种方法比传统的UPS更可靠:锂离子电池有多个独立的电池单元，任何电池故障只影响机架的一部分。</p><p>分布式UPS有效地提高了DRAM的耐用性。当电源发生故障时，分布式UPS利用电池提供的能量将内存中的内容保存到商用SSD上。这不仅通过避免对SSD进行同步写操作来提高一般情况下的性能，而且还通过仅在发生故障时才对SSD进行写操作来保持SSD的生命周期。另一种方法是使用非易失性dimm (nvdimm)，它包含自己的专用闪存、控制器和超级电容器(例如[2])。不幸的是，这些设备是专门的，昂贵的，笨重的。相反，分布式UPS使用商品内存，并利用商品ssd。唯一的额外成本是SSD的预留容量和UPS电池本身。</p><p>电池配置成本取决于将内存保存到ssd所需的能量。我们在标准的2插座机器上测量了一个未优化的原型。在出现故障时，它关闭HDDs和NIC，并将内存中的数据保存到单个M.2 (PCIe) SSD，每保存1GB数据消耗110焦耳。大约90焦耳用于在保存期间为机器上的两个CPU插座供电。额外的ssd减少了保存数据的时间，从而减少了能耗(图1)。优化，如将cpu置于低功耗状态，将进一步降低能耗。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081553094.png"></p><p>在最坏情况下，(单个SSD，未优化)每焦耳0.005美元，非易失性的能源成本为0.55美元/GB，保留SSD容量的存储成本为0.90美元/GB3。合并后的额外成本不到基本DRAM成本的15%，与成本为DRAM 3 - 5倍的nvdimm相比，这是一个显著的改进。因此，将所有机器内存视为非易失性RAM (NVRAM)是可行且实惠的。FaRM将所有数据存储在内存中，并且在多个副本上将数据写入NVRAM时认为它是持久的。</p><h2 id="2-2、RDMA网络（RDMA-networking）"><a href="#2-2、RDMA网络（RDMA-networking）" class="headerlink" title="2.2、RDMA网络（RDMA networking）"></a>2.2、RDMA网络（RDMA networking）</h2><p>FaRM在可能的情况下使用单侧RDMA操作，因为它们不使用远程CPU。我们的这个决定是基于我们之前的工作和额外的测量。在[16]中，我们展示了在20台机器的RoCE[22]集群上，当所有机器从集群中的其他机器随机选择小对象时，RDMA读取的性能比基于RDMA的可靠RPC高2倍。瓶颈是NIC消息速率，我们的RPC实现需要的消息数量是单侧读取的两倍。我们在一个90台机器的集群上复制了这个实验，其中每台机器有两个Infiniband FDR (56 Gbps)网卡。与[16]相比，这使每台机器的消息速率增加了一倍以上，并消除了NIC消息速率瓶颈。RDMA和RPC现在都受CPU限制，性能差距增加到4倍，如图2所示。这说明了减少CPU开销以实现新硬件潜力的重要性。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081603378.png"></p><h1 id="3、编程模型和体系结构（Programming-model-and-architecture）"><a href="#3、编程模型和体系结构（Programming-model-and-architecture）" class="headerlink" title="3、编程模型和体系结构（Programming model and architecture）"></a>3、编程模型和体系结构（Programming model and architecture）</h1><p>FaRM为应用程序提供了跨集群中机器的全局地址空间的抽象。每台机器运行应用程序线程并在地址空间中存储对象。FaRM API[16]提供了对事务中的本地和远程对象的透明访问。应用程序线程可以在任何时候启动事务，并成为事务的协调器。在事务执行期间，线程可以执行任意逻辑以及读、写、分配和释放对象。在执行结束时，线程调用FaRM来提交事务。</p><p>FaRM事务使用乐观并发控制。更新在执行期间被本地缓冲，只有在成功提交时才对其他事务可见。提交可能由于与并发事务的冲突或失败而失败。FaRM为所有成功提交的事务提供严格的可序列化性[35]。在事务执行期间，FaRM保证单个对象的读取是原子性的，它们只读取已提交的数据，对同一对象的连续读取返回相同的数据，并且对由事务写入的对象的读取返回最近写入的值。它不保证跨不同对象读的原子性，但在这种情况下，它保证事务不提交，确保提交的事务是严格可序列化的。这允许我们将一致性检查推迟到提交时间，而不是重新检查每个读取对象的一致性。然而，它增加了一些编程复杂性:FaRM应用程序必须在执行[20]期间处理这些临时不一致。自动处理这些不一致是可能的[12]。</p><p>FaRM API还提供无锁读取(这是优化的单对象只读事务)和位置提示(这使程序员能够在同一组机器上共同定位相关对象)。应用程序可以使用这些特性来改进性能，如[16]中所述。</p><p>图3显示了一个包含四台机器的FaRM实例。该图还显示了机器a的内部组件。每台机器在一个用户进程中运行FaRM，每个硬件线程都有一个内核线程。每个内核线程运行一个事件循环，该事件循环执行应用程序代码并轮询RDMA完成队列。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081618932.png"></p><p>随着时间的推移，当机器出现故障或添加新机器时，FaRM实例会经历一系列配置。一个配置是一个&lt; i, S, F, CM &gt;的元组，其中i是唯一的、单调递增的64位配置标识符，S是配置中的机器集合，F是从机器到预计会独立故障的故障域的映射(例如，不同的机架)，CM∈si是配置管理器。FaRM使用Zookeeper[21]协调服务来确保机器同意当前配置并存储它，就像Vertical Paxos[25]一样。但它不像通常那样依赖Zookeeper来管理租约、检测故障或协调恢复。CM使用一种利用RDMA快速恢复的高效实现来完成这些工作。每次配置更改时，CM都会调用Zookeeper一次，以更新配置。</p><p>FaRM中的全局地址空间由2 GB区域组成，每个区域在一个主机和6个备份上复制，这是所需的容错性。每台机器在非易失性DRAM中存储几个区域，这些区域可以由使用RDMA的其他机器读取。对象总是从包含区域的主副本中读取，如果区域在本地机器上，则使用本地内存访问，如果是远程的，则使用单侧RDMA读取。每个对象都有一个64位版本，用于并发控制和复制。区域标识符到主区域和备份的映射由CM维护，并随区域复制。这些映射由其他机器根据需要获取，并由线程与向主服务器发出单侧RDMA读取所需的RDMA引用一起缓存。</p><p>机器与CM交互以分配新区域。CM从单调递增的计数器中分配一个区域标识符，并为该区域选择副本。副本选择平衡存储在每台机器上的区域数量，以满足以下约束:有足够的容量，每个副本位于不同的故障域中，当应用程序指定局域性约束时，该区域被放置在目标区域。然后，它向带有区域标识符的选定副本发送一条准备消息。如果所有副本报告分配区域成功，CM将向所有副本发送提交消息。这个两阶段协议确保映射是有效的，并在使用之前在所有区域副本上进行复制。</p><p>与之前基于一致哈希[16]的方法相比，这种集中式方法在满足故障独立性和局域性约束方面提供了更大的灵活性。它还可以更容易地在机器之间平衡负载并接近容量运行。对于2 GB的区域，我们预计一台典型机器上最多有250个区域，因此单个CM可以处理数千台机器的区域分配。</p><p>每台机器还存储实现FIFO队列[16]的环缓冲区。它们可用作事务日志或消息队列。每个发送方-接收方都有自己的日志和消息队列，它们物理上位于接收方上。发送方使用单侧RDMA写入其尾部将记录追加到日志中。这些写操作由NIC确认，而不涉及接收器的CPU。接收器定期轮询日志的头部以处理记录。它在截断日志时惰性地更新发送方，从而允许发送方重用环缓冲区中的空间。</p><h1 id="4、分布式事务和复制（Distributed-transactions-and-replication）"><a href="#4、分布式事务和复制（Distributed-transactions-and-replication）" class="headerlink" title="4、分布式事务和复制（Distributed transactions and replication）"></a>4、分布式事务和复制（Distributed transactions and replication）</h1><p>FaRM集成了事务和复制协议，以提高性能。它比传统协议使用更少的消息，并利用单侧RDMA读写来提高CPU效率和低延迟。FaRM在非易失性DRAM中对数据和事务日志使用主备份复制，并使用非复制事务协调器直接与主机和备份通信。它使用带有读验证的乐观并发控制，就像在一些软件事务性内存系统(例如tl2[15])中一样。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081634414.png" alt="image-20230508163438396"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081634865.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305081635925.png"></p><p>图4显示了FaRM事务的时间轴，表1和表2列出了事务协议中使用的所有日志记录和消息类型。在执行阶段，事务使用单侧RDMA读取对象，并在本地缓冲写操作。协调器还记录访问的所有对象的地址和版本。对于与协调器在同一台机器上的主服务器和备份，对象读取和写入日志使用本地内存访问而不是RDMA。在执行结束时，FaRM尝试通过执行以下步骤提交事务:</p><p><strong>1、锁（Lock）</strong></p><p>协调器向每台机器的日志中写入一条LOCK记录，该记录是任何写入对象的主记录。它包含该主节点上所有写入对象的版本和新值，以及包含写入对象的所有区域的列表。主节点通过尝试使用compare-and-swap将对象锁定在指定的版本来处理这些记录，并返回一条消息，报告是否已成功获取所有锁。如果对象的版本在被事务读取后发生了变化，或者对象当前被另一个事务锁定，则锁定可能会失败。在这种情况下，协调器终止事务。它向所有主程序写入一个中止记录，并向应用程序返回一个错误。</p><p><strong>2、验证（Validate）</strong></p><p>协调器通过从它们的主节点读取所有已读取但还未被事务写入的对象的版本来执行读验证。如果任何对象发生了更改，则验证失败并终止事务。默认情况下，验证使用单侧RDMA读取。对于拥有超过$t_{r}$个对象的primary，验证是通过RPC完成的。阈值$t_{r}$(目前为4)反映了RPC相对于RDMA读取的CPU开销。</p><p><strong>3、提交备份（Commit backups）</strong></p><p>协调器在每次备份时将COMMIT-BACKUP记录写入非易失性日志，然后等待来自NIC硬件的回复，而不会中断备份的CPU。COMMIT-BACKUP日志记录与LOCK记录具有相同的负载。</p><p><strong>4、提交主机（Commit primaries）</strong></p><p>在所有COMMIT-BACKUP写操作都被打包之后，协调器将一条COMMIT-PRIMARY记录写入每个主服务器的日志。如果至少接收到一个这样的记录的硬件应答，或者它在本地写了一个，它就会向应用程序报告完成情况。primary通过更新对象、增加其版本和解锁来处理这些记录，这暴露了事务提交的写操作。</p><p><strong>5、截断（Truncate）</strong></p><p>主机和备份将记录保存在其日志中，直到它们被截断。协调器在主节点截断日志，并在接收到来自所有主节点的回复后进行惰性备份。它通过在其他日志记录中附带截断事务的标识符来实现这一点。备份在截断时将更新应用于它们的对象副本。</p><p><strong>正确性（Correctness）</strong></p><p>提交的读写事务在获得所有写锁时是可序列化的，而提交的只读事务在最后一次读取时是可序列化的。这是因为在序列化点读取和写入的所有对象的版本与在执行期间看到的版本相同。锁定确保写入的对象是这样，验证确保只读取的对象是这样。在没有故障的情况下，这相当于在序列化点自动执行和提交整个事务。FaRM中的可序列化性也是严格的:序列化点总是在开始执行和向应用程序报告完成之间。</p><p>为了确保跨故障的可序列化性，有必要在写入commit - primary之前等待来自所有备份的硬件ack。假设协调器没有收到来自某个区域r的备份b的回复。那么主服务器可能会公开事务修改，然后在没有接收到COMMIT-BACKUP记录的情况下，与协调器和其他副本一起失败。这将导致丢失对r的更新。</p><p>由于读集仅存储在协调器中，因此如果协调器失败并且没有提交记录存活以证明验证成功，则事务将被中止。因此，协调器有必要在向应用程序报告提交成功之前，等待其中一个主节点上的提交成功。这确保至少有一个提交记录在报告提交给应用程序的事务失败时仍然存在。否则，如果协调器和所有备份在写入任何COMMIT-PRIMARY记录之前都失败了，这样的事务仍然可能中止，因为只有LOCK记录会保存下来，并且不会有验证成功的记录。</p><p>在传统的两阶段提交协议中，参与者可以在处理准备消息时保留资源以提交事务，或者在没有足够的资源时拒绝准备事务。然而，由于我们的协议避免在提交期间涉及备份的cpu，协调器必须为所有参与者保留日志空间以保证进度。协调器在启动提交协议之前为所有提交协议记录保留空间，包括主日志和备份日志中的截断记录。日志保留是协调器上的本地操作，因为协调器将记录写入它在每个参与者上拥有的日志。当相应的记录被写入时，保留将被释放。如果截断被附加在另一条消息上，也会释放截断记录保留。如果日志已满，协调器将使用保留来写入显式截断记录，以释放日志中的空间。这种情况很少见，但却是确保存活的必要条件。</p><p><strong>性能（Performance）</strong></p><p>对于我们的目标硬件，该协议比传统的分布式提交协议有几个优点。考虑一个带复制的两阶段提交协议，比如Spanner[11]。Spanner使用Paxos[24]来复制事务协调器及其参与者，这些参与者是存储事务读取或写入数据的机器。每个Paxos状态机在传统的两阶段提交协议[19]中扮演单个机器的角色。这需要2f + 1个副本来容忍f个故障，并且由于每个状态机操作至少需要2f + 1个往返消息，因此它需要4P (2f + 1)个消息(其中P是事务中参与者的数量)。</p><p>FaRM使用主备份复制而不是Paxos状态机复制。这将数据副本的数量减少到f + 1，并且还减少了事务期间传输的消息数量。不复制协调器状态，并且协调器直接与主要和备份通信，从而进一步减少延迟和消息计数。FaRM由于复制而产生的开销很小:对每台远程机器进行一次RDMA写入，并备份任何写入对象。协议中根本不涉及只读参与者的备份。此外，RDMA上的读验证确保只读参与者的主节点不做CPU工作，并且使用单向RDMA写commit - primary和COMMIT-BACKUP记录减少了对远程CPU的等待，还允许远程CPU工作延迟和批处理。</p><p>FaRM提交阶段使用$P_{w}(f+3)$个单侧RDMA写操作和$P_{r}$个单侧RDMA读操作，其中$P_{w}$是事务写入对象的主机器数量，$P_{r}$是从远程主服务器读取但未写入的对象数量。读验证为关键路径增加了两个单侧RDMA延迟，但这是一个很好的权衡:在没有负载的情况下，增加的延迟只有几微秒，CPU开销的减少会带来更高的吞吐量和更低的负载下延迟。</p><h1 id="5、故障恢复（Failure-recovery）"><a href="#5、故障恢复（Failure-recovery）" class="headerlink" title="5、故障恢复（Failure recovery）"></a>5、故障恢复（Failure recovery）</h1><p>FaRM通过复制提供持久性和高可用性。我们假设机器可能因崩溃而失败，但可以在不丢失非易失性DRAM内容的情况下恢复。我们依靠有限的时钟漂移来保证安全性，最终依靠有限的消息延迟来保证活跃性。</p><p>即使整个集群发生故障或断电，我们也为所有提交的事务提供持久性:所有提交的状态都可以从存储在非易失性DRAM中的区域和日志中恢复。即使每个对象最多有f个副本丢失了非易失性DRAM的内容，我们也能确保持久性。FaRM还可以维护故障和网络分区的可用性，前提是存在一个分区，该分区包含大多数保持相互连接的机器和Zookeeper服务中的大多数副本，并且该分区至少包含每个对象的一个副本。</p><p>FaRM中的故障恢复有以下五个阶段:故障检测、重新配置、事务状态恢复、批量数据恢复和分配器状态恢复。</p><h2 id="5-1、故障检测（Failure-detection）"><a href="#5-1、故障检测（Failure-detection）" class="headerlink" title="5.1、故障检测（Failure detection）"></a>5.1、故障检测（Failure detection）</h2><p>FaRM使用租约[18]来检测故障。每台机器(CM除外)在CM上持有一个租约，CM在其他每台机器上持有一个租约。任何租约到期都会触发失败恢复。租约是通过三次握手授予的。每台机器向CM发送一个租约请求，并使用一条消息进行响应，该消息既是对机器的租约授予，又是来自CM的租约请求。然后，机器向CM返回一个租约授权。</p><p>FaRM租约非常短，这是高可用性的关键。在高负载下，FaRM可以为一个90台机器的集群使用5毫秒的租约，没有误报。更大的集群可能需要两级层次结构，在最坏的情况下，这将使故障检测时间加倍。</p><p>在负荷下实现短期租赁需要仔细执行。FaRM为租约使用专用pair队列，以避免租约消息在其他消息类型后面的共享队列中延迟。使用可靠的传输需要在CM上为每台机器增加一个队列pair。由于NIC的队列对缓存[16]中的容量丢失，这将导致性能不佳。相反，租约管理器使用Infiniband发送和接收谓词以及无连接的不可靠数据报传输，这在NIC上只需要一个额外队列对的空间。默认情况下，每隔1/5的租约到期尝试一次租约更新，以考虑潜在的消息丢失。</p><p>租期续订还必须在CPU上及时安排。FaRM使用一个专用的租约管理器线程，该线程以最高的用户空间优先级运行(在Windows上为31)。租约管理器线程没有绑定任何硬件线程，它使用中断而不是轮询，以避免使每个必须在硬件线程上定期运行的关键操作系统任务饿死。这会使消息延迟增加几微秒，这对于租约来说不是问题。</p><blockquote><p>“starving”指的是关键的操作系统任务没有足够的CPU时间来正常运行，因为另一个进程或线程正在使用过多的CPU时间。</p></blockquote><p>此外，我们没有将FaRM线程分配给每台机器上的两个硬件线程，而是将它们留给租约管理器。我们的测量表明，租约管理器通常在这些硬件线程上运行，而不会影响其他FaRM线程，但有时它会被更高优先级的任务抢占，导致它在其他硬件线程上运行。因此，在使用短租约时，将租约管理器绑定到硬件线程可能会导致误报。</p><p>最后，我们预先分配租约管理器在初始化期间使用的所有内存，并将它使用的所有代码分页并固定，以避免由于内存管理而导致的延迟。</p><h2 id="5-2、重新配置（Reconfiguration）"><a href="#5-2、重新配置（Reconfiguration）" class="headerlink" title="5.2、重新配置（Reconfiguration）"></a>5.2、重新配置（Reconfiguration）</h2><p>重新配置协议将FaRM实例从一个配置更改为另一个配置。使用单侧RDMA操作对于实现良好的性能很重要，但它对重新配置协议提出了新的要求。例如，实现一致性的一种常用技术是使用租约[18]:服务器在响应访问对象的请求之前检查它们是否持有该对象的租约。如果服务器从配置中被申删去，系统保证它存储的对象在其租约到期(例如[7])之前不会被更改。FaRM在服务来自使用消息与系统通信的外部客户机的请求时使用此技术。但是，由于FaRM配置中的机器使用RDMA读取来读取对象，而不涉及远程CPU，因此服务器的CPU无法检查它是否持有租约。当前的NIC硬件不支持租约，而且不清楚将来是否会支持。</p><p>我们通过实现精确的precise membership[10]来解决这个问题。发生故障后，在允许对象变化之前，新配置中的所有机器必须就其成员关系达成一致。这允许FaRM在客户端而不是在服务器上执行检查。在配置中的机器不会向不在配置中的机器发出RDMA请求，并且不再在配置中的机器对RDMA读的应答和对RDMA写的应答将被忽略。</p><p>图5显示了一个由以下步骤组成的重新配置时间轴示例:</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091022513.png"></p><p><strong>1、怀疑（Suspect）</strong></p><p>当一台机器的租约在CM上到期时，它会怀疑该机器出现故障并启动重新配置。此时，它开始阻止所有外部客户机请求。如果非CM机器怀疑CM由于租约到期而出现故障，它首先要求少数“备份CM”中的一个启动重新配置(使用一致散列的CM的k个后继者)。如果配置在一段超时时间后没有改变，那么它会尝试自己重新配置。这种设计避免了在CM失败时同时进行大量的重新配置尝试。在所有情况下，启动重新配置的机器将尝试成为新的CM，作为重新配置的一部分。</p><p><strong>2、调查（Probe）</strong></p><p>新的CM向配置中的所有机器发出RDMA读取，但可疑的机器除外。任何读取失败的机器也会被怀疑。这些读调查允许处理影响多台机器的相关故障，例如，电源和开关故障，通过一次重新配置。新的CM只有在获得大多数探测的响应时才会进行重新配置。这确保了如果网络是分区的，CM不会在较小的分区中。</p><p><strong>3、更新配置（Update configuration）</strong></p><p>在收到对调查的响应后，新的CM尝试将存储在Zookeeper中的配置数据更新为&lt; c + 1, S, F, CMid &gt;，其中c是当前配置标识符，S是响应调查的机器集合，F是机器到故障域的映射，CMid是它自己的标识符。我们使用Zookeeper znode序列号来实现原子比较和交换，只有当当前配置仍然为c时才会成功。这确保了即使多台机器同时尝试从标识符为c的配置更改配置，也只有一台机器可以成功地将系统移动到标识符为+1的配置(并成为CM)。</p><p><strong>4、重新映射区域（Remap regions）</strong></p><p>然后，新的CM重新分配以前映射到故障机器的区域，以将副本的数量恢复到f + 1。它在容量和故障独立性约束下尝试平衡负载并满足应用程序指定的局部性提示。对于失败的主服务器，它总是将幸存的备份提升为新的主服务器，以减少恢复时间。如果它检测到区域丢失了所有副本，或者没有空间来重新复制区域，则会发出错误信号。</p><p><strong>5、发送新的配置（Send new configuration）</strong></p><p>在重新映射区域之后，CM向配置中的所有机器发送一条new - config消息，其中包含配置标识符、CM自己的标识符、配置中其他机器的标识符以及区域到机器的所有新映射。如果CM发生更改，new - config还会重置租约协议:它展示了从新CM到每台机器的租约请求。如果CM未更改，则在重新配置期间继续进行租约交换，以快速检测其他故障。</p><p><strong>6、应用新配置（Apply new configuration）</strong></p><p>当一台机器接收到配置标识符大于其自身的一个NEW-CONFIG时，它会更新其当前配置标识符和区域映射的缓存副本，并分配空间来容纳分配给它的任何新区域副本。从这一点开始，它不再向不在配置中的机器发出新的请求，并且拒绝来自这些机器的读响应和写应答。它还开始阻止来自外部客户端的请求。机器用NEW-CONFIG-ACK消息回复CM。如果CM发生了更改，这将向CM授予租约并请求租约。</p><p><strong>7、提交新的配置（Commit new configuration）</strong></p><p>一旦CM从配置中的所有机器接收到new - config - ack消息，它将等待以确保以前配置中授予不再在配置中的机器的任何租约都已过期。然后，CM将NEW-CONFIG-COMMIT发送给所有配置成员，这些配置成员也充进行租约授予。所有成员现在解除先前阻止的外部客户端请求并启动事务恢复。</p><h2 id="5-3、事务状态恢复（Transaction-state-recovery）"><a href="#5-3、事务状态恢复（Transaction-state-recovery）" class="headerlink" title="5.3、事务状态恢复（Transaction state recovery）"></a>5.3、事务状态恢复（Transaction state recovery）</h2><p>FaRM使用分布在被事务修改的对象副本上的日志恢复配置更改后的事务状态。这包括恢复被事务修改的对象副本的状态和协调器的状态，以决定事务的结果。图6显示了一个示例事务恢复时间轴。FaRM通过在集群中的线程和机器之间分配工作来实现快速恢复。Draining(步骤2)是对所有消息日志并行执行的。步骤1和步骤3-5对所有区域并行执行。步骤6-7是对所有并行恢复事务执行的。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091031743.png"></p><p><strong>1、禁止访问恢复区域（Block access to recovering regions）</strong></p><p>当一个区域的主要备份发生故障时，其中一个备份将在重新配置期间提升为新的主要备份。在更新该区域的所有事务都反映在新的主服务器上之前，我们不能允许访问该区域。我们通过阻塞对本地指针和对区域的RDMA引用的请求来实现这一点，直到步骤4为更新该区域的所有恢复事务获得了所有写锁。</p><p><strong>2、写入日志（Drain logs）</strong></p><p>单侧RDMA写入也会影响事务恢复。跨配置保持一致性的一般方法是拒绝来自旧配置的消息。FaRM不能使用这种方法，因为NICs接收写入事务日志的commit - backup和COMMIT-PRIMARY记录，而不管它们是在哪个配置中发出的。由于协调器在向应用程序公开更新并报告成功之前只等待这些应答，因此机器在处理以前配置的记录时不能总是拒绝它们。我们通过提取日志来解决这个问题，以确保在恢复期间处理所有相关记录:所有机器在接收到NEW-CONFIG-COMMIT消息时都会处理其日志中的所有记录。当它们完成时，它们在一个变量LastDrained中记录配置标识符。</p><p>FaRM事务具有在提交开始时分配的唯一标识符&lt; c, m, t, l &gt;，这些标识符编码了启动提交时的配置、协调器的机器标识符m、协调器的线程标识符t和线程本地唯一标识符l。配置标识符小于或等于LastDrained的事务的日志记录将被拒绝。</p><p><strong>3、查找恢复事务（Find recovering transactions）</strong></p><p>恢复事务是指其提交阶段跨越配置更改，并且由于重新配置而导致写入对象的某些副本、读对象的某些主对象或协调器发生更改的事务。在写入日志期间，将检查每个日志中的每个日志记录中的事务标识符和更新的区域标识符列表，以确定恢复事务的集合。只有恢复事务才会在主节点和备份节点上进行事务恢复，协调器只会在恢复事务时拒绝硬件应答。</p><p>所有机器必须就给定事务是否为恢复事务达成一致。我们通过在重新配置阶段在通信上附加一些额外的元数据来实现这一点。CM在每台机器上读取LastDrained变量，作为调查读取的一部分。对于自LastDrained以来其映射已更改的每个区域r，CM将在NEW-CONFIG消息中向该机器发送两个配置标识符。当r的主节点发生变化时的最后一个配置标识符是LastPrimaryChange[r]，当r的任何副本发生变化时的最后一个配置标识符是LastReplicaChange[r]。在配置c−1中开始提交的事务在配置c中恢复，除非:对于所有包含被事务更改过对象的区域r有LastReplicaChange[r]&lt;c成立，对于所有包含被事务读取过对象的区域r ‘有LastPrimaryChange[r ‘] &lt; c成立，且协调器尚未从配置c中移除。</p><p>恢复事务的记录可能分布在由事务更新的不同主备份的日志中。区域的每个备份都向主服务器发送一条NEED-RECOVERY消息，其中包含配置标识符、区域标识符和更新该区域的恢复事务标识符。</p><p><strong>4、锁的恢复（Lock recovery）</strong></p><p>每个区域的主服务器将一直等待，直到耗尽本地计算机日志并从每个备份接收到NEED-RECOVERY消息，以构建影响该区域的恢复事务的完整集合。然后，它根据标识符在其线程之间对事务进行分片，以便每个线程t恢复具有协调线程标识符t的事务状态。与此同时，主线程中的线程从尚未存储在本地的备份中获取任何事务日志记录，然后锁定通过恢复事务修改的任何对象。</p><p>当一个区域的锁恢复完成时，该区域处于活动状态，本地和远程协调器可以获得本地指针和RDMA引用，这允许它们在随后的恢复步骤中读取对象并向该区域提交更新。</p><p><strong>5、 复制日志记录（Replicate log records）</strong></p><p>主服务器中的线程通过向备份发送REPLICATE-TX-STATE消息来复制日志记录它们丢失的任何事务。该消息包含区域标识符、当前配置标识符以及与LOCK记录相同的数据。</p><p><strong>6、投票（Vote）</strong></p><p>恢复事务的协调器根据事务更新的每个区域的投票来决定是提交还是中止事务。这些选票由每个地区的主机产生。FaRM使用一致哈希来确定事务的协调器，确保所有主节点独立地就恢复事务的协调器身份达成一致。如果协调器运行的机器仍在配置中，则它不会更改，但是当协调器失败时，协调其恢复事务的责任将分散到集群中的机器上。</p><p>对于修改区域的每个恢复事务，主线程向协调器中的对等线程发送RECOVERY-VOTE消息。如果任何replica看到COMMIT-PRIMARY或COMMIT-RECOVERY，则投票为COMMIT-PRIMARY。否则，如果任何副本看到commit-backup而没有看到ABORT-RECOVERY，它就会投票选择commit-backup。否则，如果任何副本看到了一个lock记录，并且没有ABORT-RECOVERY记录，那么它将投票锁定。否则，它将投反对票。投票消息包括配置标识符、区域标识符、事务标识符和由事务修改的区域标识符列表。 </p><p>有些主服务器可能不会发起对事务的投票，因为它们从未收到该事务的日志记录，或者它们已经截断了该事务的日志记录。协调器向在超时时间(设置为250 μs)内尚未投票的primary发送显式投票请求。REQUEST-VOTE消息包括配置标识符、区域标识符和事务标识符。在等待该事务的日志复制完成后，确实像以前一样拥有事务投票的日志记录的主节点。</p><p>如果事务已被截断，则没有任何事务投票日志记录的primary将被截断，如果未被截断则未知。为了确定事务是否已经被截断，每个线程维护其日志中记录已被截断的事务的标识符集。该集合通过使用非截断事务标识符的下界来保持紧凑。下限是根据每个协调器的下限更新的，这些协调器是在协调器消息和重新配置期间承载的。</p><p><strong>7、决策（Decide）</strong></p><p>如果协调器收到来自任何地区的commit-primary投票，则决定提交事务。否则，它等待所有区域投票并提交，如果至少有一个区域投票了commit-backup，并且被事务修改的所有其他区域都投票了lock、commitbackup或truncated。否则，它决定中止。然后，它向所有参与副本发送COMMIT-RECOVERY或ABORT-RECOVERY。两个消息都包含配置标识符和事务标识符。如果在主服务器上接收到commit - recovery，则与在备份服务器上接收到COMMIT-BACKUP类似。ABORT- recovery的处理类似于ABORT。协调器从所有主服务器和备份服务器接收回消息后，将发送一条TRUNCATE-RECOVERY消息。</p><p><strong>正确性（Correctness）</strong></p><p>接下来，我们将直观地介绍事务恢复的不同步骤如何确保严格的序列化性。关键思想是恢复保留了先前提交或终止的事务的结果。我们认为当主服务器公开事务修改，或者协调器通知应用程序事务已提交时，事务就提交了。当协调器发送终止消息或通知应用程序事务已终止时，事务将被终止。对于结果尚未确定的事务，恢复可以提交或中止事务，但它确保从其他失败中恢复的任何恢复都保留结果。</p><p>未恢复的事务(步骤3)的结果是使用正常情况协议(第4节)确定的。因此，我们将不再进一步讨论它们。</p><p>提交的恢复事务的日志记录保证在日志抽取之前或期间被处理和接受(步骤2)。这是正确的，因为primary仅在处理COMMIT-PRIMARY记录之后才公开修改。如果协调器通知了应用程序，那么在接收NEW-CONFIG之前，它必须已经接收到所有COMMIT-BACKUP记录和至少一个COMMIT-PRIMARY记录的硬件ack(因为它在更改配置后忽略了ack)。因此，由于新配置为每个区域至少包含一个副本，因此至少有一个区域至少有一个副本将处理COMMIT-PRIMARY或COMMIT-BACKUP记录，并且每个区域至少有一个副本将处理COMMIT-PRIMARY、COMMIT-BACKUP或LOCK记录。</p><p>步骤3和4确保被事务修改的区域的主服务器看到这些记录(除非它们已被截断)。他们将这些记录复制到备份中(步骤5)，以保证即使出现后续失败，投票也会产生相同的结果。然后，主机根据他们看到的记录将选票发送给协调器(步骤6)。</p><p>决策步骤保证协调器决定提交先前已提交的任何事务。如果任何副本截断了事务记录，则所有主将投票commit-primary、commit-backup或truncated。至少有一个主节点将发送投票，而不是被截断的投票，否则事务将无法恢复。如果没有副本截断事务记录，则至少有一个主节点将投票给commit-primary或commit-backup，其他节点将投票给commit-primary、commit-backup或lock。类似地，如果事务先前被中止，协调器将决定中止，因为在这种情况下，要么没有提交主记录，要么没有提交备份记录，要么所有副本都收到了abort - recovery。</p><p>阻塞对恢复区域的访问(步骤1)和锁定恢复(步骤4)保证在恢复事务提交或终止之前，没有其他操作可以访问它修改的对象。</p><p><strong>性能</strong></p><p>FaRM使用了几个优化来实现快速故障恢复。识别恢复事务将恢复工作限制为仅受重新配置影响的事务和区域，当大型集群中的单个机器发生故障时，这些事务和区域可能只是总数的一小部分。我们的结果表明，这可以将恢复的事务数量减少一个数量级。恢复工作本身是跨区域、机器和线程并行进行的。锁恢复后立即使区域可用可以提高前台性能，因为访问这些区域的新事务不会长时间阻塞。具体来说，它们不需要等待这些区域的新副本更新，这需要通过网络大量移动数据。</p><h2 id="5-4、恢复数据（Recovering-data）"><a href="#5-4、恢复数据（Recovering-data）" class="headerlink" title="5.4、恢复数据（Recovering data）"></a>5.4、恢复数据（Recovering data）</h2><p>FaRM必须在一个区域的新备份中恢复(重新复制)数据，以确保它能够容忍将来的复制失败。数据恢复对于恢复正常的case操作不是必需的，因此我们将其延迟到所有区域变为活动状态，以尽量减少对延迟关键锁恢复的影响。当以每台机器为主的所有区域都处于活动状态时，每台机器都会向CM发送一条regions - active消息。在接收到所有的REGIONS-ACTIVE消息后，CM向配置中的所有机器发送一条all -REGIONS-ACTIVE消息。此时，FaRM将与前台操作并行地开始新备份的数据恢复。</p><p>一个区域的新备份最初有一个新分配的、归零的本地区域副本。它将该区域划分为多个并行恢复该区域的工作线程。每个线程发出单侧RDMA操作，每次从主线程读取一个块。我们目前使用8 KB的区块，这足够大，可以有效地使用网络，但又足够小，不会影响正常的案例操作。为了减少对前台性能的影响，通过将下一个读取调度为在前一个读取开始后的一段时间内的随机点开始(设置为4ms)来调整恢复的节奏。</p><p>在将每个恢复对象复制到备份之前，必须对其进行检查。如果对象的版本大于本地版本，则备份将使用compare-adn-swap锁定本地版本，更新对象状态并解锁它。否则，对象已经或正在被创建的版本大于或等于恢复的版本的事务更新，并且不应用恢复的状态。</p><h2 id="5-5、分配器状态恢复（Recovering-allocator-state）"><a href="#5-5、分配器状态恢复（Recovering-allocator-state）" class="headerlink" title="5.5、分配器状态恢复（Recovering allocator state）"></a>5.5、分配器状态恢复（Recovering allocator state）</h2><p>FaRM分配器将区域划分为块(1mb)，这些块称为slabs被用于分配小对象。它保留了两部分元数据:包含对象大小的块头和无块列表。分配新块时，将块标头复制到备份中。这确保了它们在发生故障后可以在新的主服务器上使用。由于块标头用于数据恢复，新主服务器在收到new - config - commit后立即将它们发送给所有备份服务器。这避免了在复制块标头时旧主服务器失败时出现的任何不一致。</p><p>slab空闲列表只保留在主节点，以减少对象分配的开销。每个对象在其头中都有一个位，由分配设置，并在事务执行期间由free清除。在事务提交期间复制对对象状态的更改，如第4节所述。发生故障后，通过扫描该区域中的对象，在新的主服务器上恢复空闲列表，该区域在机器上的所有线程之间并行化。为了尽量减少对事务锁恢复的影响，分配恢复在接收到ALL-REGIONS-ACTIVE后开始，并且为了尽量减少对前台工作的影响，每100 μs扫描100个对象。对象释放被排队，直到slab的空闲列表被恢复。</p><h1 id="6、测评（Evaluation）"><a href="#6、测评（Evaluation）" class="headerlink" title="6、测评（Evaluation）"></a>6、测评（Evaluation）</h1><h2 id="6-1、设置（Setup）"><a href="#6-1、设置（Setup）" class="headerlink" title="6.1、设置（Setup）"></a>6.1、设置（Setup）</h2><p>我们的实验测试平台包括用于FaRM集群的90台机器和用于复制Zookeeper实例的5台机器。每台机器都有256gb的DRAM和两个运行Windows Server 2012 R2的8核英特尔E5-2650 cpu。我们启用了超线程，并将前30个线程用于前台工作，其余2个线程用于租约管理器。机器有两个Mellanox ConnectX-3 56 Gbps Infiniband网卡，每个网卡由不同套接字上的线程使用，并通过单个Mellanox SX6512交换机连接，具有全对分带宽。FaRM被配置为使用3路复制(一个主复制和两个备份复制)，租用时间为10毫秒。</p><h2 id="6-2、基准（Benchmarks）"><a href="#6-2、基准（Benchmarks）" class="headerlink" title="6.2、基准（Benchmarks）"></a>6.2、基准（Benchmarks）</h2><p>我们使用两个事务性基准来度量FaRM的性能。我们在c++中针对FaRM API实现了这两个基准测试。由于FaRM使用对称模型来利用局部性，因此每台机器都运行基准代码并存储数据。每台机器在同一进程上运行与FaRM代码链接的基准代码。将来，我们将使用安全语言(如SQL)编译应用程序，以防止应用程序错误损坏数据。</p><p>远程通信应用事务处理[32]是高性能主存数据库的基准。每个数据库表都被实现为一个FaRM哈希表[16]。TATP是读主导的。70%的操作是单行查找，使用FaRM的无锁读取[16]。它们通常可以通过单个RDMA读取来执行，并且不需要提交阶段。10%的操作读取2-4行，并且需要在提交阶段进行验证。其余20%的操作是更新，需要完整的提交协议。由于70%的更新只修改单个对象字段，因此我们将这些字段作为优化发送到对象的主节点。我们使用了一个拥有92亿订阅者的数据库(除非另有说明)。TATP是可分区的，但是我们没有对它进行分区，因此大多数操作访问远程机器上的数据。</p><p>TPC-C[38]是一个著名的数据库基准，具有访问数百行的复杂事务。我们的实现使用具有16个索引的模式。其中12个只需要无序(点)查询和更新，并作为FaRM散列表实现。其中四个索引还需要范围查询。这些都是使用FaRM b树实现的。B-Tree在每台机器上缓存内部节点，因此查找通常需要一次FaRM RDMA读取。我们为每台机器保留8 GB的缓存。我们使用栅栏键(fence key)[17,27]来确保遍历一致性，类似于Minuet[37]。由于篇幅原因，我们省略了对b树的更详细的描述。</p><blockquote><p>“fence key” 是一种用于实现分布式锁的机制。它是一个由多个节点共享的值，用于协调不同节点之间的访问。当一个节点想要获取某个资源的锁时，它会向其他节点发送一个请求，并提供一个 “fence key” 值。如果其他节点上的 “fence key” 值比当前请求中提供的值小，则说明当前请求已经过时，因为有其他请求已经成功获取了该资源的锁。这样可以避免不同节点之间出现竞争条件和死锁等问题。</p></blockquote><h2 id="6-3、通常情况下的性能（Normal-case-performance）"><a href="#6-3、通常情况下的性能（Normal-case-performance）" class="headerlink" title="6.3、通常情况下的性能（Normal-case performance）"></a>6.3、通常情况下的性能（Normal-case performance）</h2><p>我们将FaRM的正常情况(无故障)性能表示为吞吐量-延迟曲线。对于每个基准测试，我们首先将每台机器的活动线程数从2增加到30，然后增加每个线程的并发性，直到吞吐量饱和。请注意，每个图的左端仍然显示显著的并发性和吞吐量。它没有显示FaRM可以实现的最小延迟。</p><p><strong>TATP</strong></p><p>图7显示FaRM每秒执行1.4亿次TATP事务，中位延迟为58 μs，第99百分位延迟为645 μs。在图的左侧，中位延迟仅为9 μs，第99个百分点延迟降至112 μs, FaRM每秒执行200万次操作。TATP使用的多对象分布式事务提交时间为数十微秒，最低吞吐量的平均提交延迟为19 μs，最高吞吐量的平均提交延迟为138 μs。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091139127.png"></p><p>FaRM比Hekaton<a href="%E5%8D%95%E6%9C%BA%E5%86%85%E5%AD%98%E4%BA%8B%E5%8A%A1%E5%BC%95%E6%93%8E">14,26</a>发表的TATP结果高出33倍。Hekaton的结果是使用不同的硬件获得的，但是当我们在一台测试机器上运行Hekaton时，我们预计会有20倍的改进。在一个较小规模的实验中，FaRM仅用三台机器就超过了Hekaton。此外，FaRM支持更大的数据集，因为它可以向外扩展，并且与单机系统不同，它提供了高可用性。</p><p><strong>TPC-C</strong></p><p>我们运行TPC-C 60秒，我们在图8中报告了这段时间内的延迟和平均吞吐量。FaRM每秒执行多达450万次TPC-C“新订单”事务，中位延迟为808 μs，第99百分位延迟为1.9 ms。延迟可以减半，而吞吐量的影响只有10%。我们所知道的最好的TPC-C性能来自Silo[39,40]，这是一个单机内存系统，记录到FusionIO ssd。FaRM的吞吐量比没有日志记录的Silo高17倍，在这个吞吐量水平上的延迟比有日志记录的Silo好128倍。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091140711.png"></p><p><strong>读取性能（Read performance）</strong></p><p>尽管本文的重点是事务性能和故障恢复，但相对于[16]，我们也能够提高只读性能。我们运行了一个只有键值查找的工作负载，其中包含16字节的键和32字节的值，以及统一的访问模式。我们实现了7.9亿次查询/秒的吞吐量，中位延迟为23 μs，第99百分位延迟为73 μs。这比之前报告的同一基准的每台机器吞吐量提高了20%。尽管nic数量增加了一倍，但我们并没有使性能增加一倍，因为基准测试受到CPU限制。</p><h2 id="6-4、故障（Failures）"><a href="#6-4、故障（Failures）" class="headerlink" title="6.4、故障（Failures）"></a>6.4、故障（Failures）</h2><p>为了评估故障情况下的性能，我们运行了相同的基准测试，并在其中一台机器上关闭了FaRM进程。我们显示了89台幸存机器的吞吐量的时间轴，它们以1毫秒的间隔聚合。时间线在实验开始时使用RDMA消息同步。</p><p>图9和图10显示了每个基准测试在不同时间尺度上的典型运行。两者都将吞吐量显示为实线。“达到完全吞吐量所需的时间”是故障的放大视图。它显示了故障机器的租约在CM(“suspect”)上到期的时间;所有读调查完成的时间(“probe”);CM成功更新Zookeeper(“Zookeeper”)的时间;在所有幸存的机器上提交新配置的时间(“config-commit”);所有区域活动的时间(“all-active”);后台数据恢复开始的时间(“data-rec-start”)。“到完全数据恢复的时间”显示了一个缩小视图，其中包括在备份时恢复所有数据的时间(“完成”)。虚线表示一段时间内通过数据恢复恢复的备份区域的累积数量。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091145162.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091145824.png"></p><p><strong>TATP</strong></p><p>典型的TATP运行的时间轴如图9所示。我们将其配置为最大吞吐量:每台机器运行30个线程，每个线程8个并发事务。图9(a)显示，吞吐量在故障时急剧下降，但很快恢复。系统在不到40毫秒的时间内恢复到峰值吞吐量。所有区域在39毫秒内变得活跃。图9(b)显示了数据恢复，这是有节奏的，不会影响前台吞吐量。故障的机器托管了84个2 GB的区域。每个线程每2毫秒获取8 KB块，这意味着在一台机器上恢复2 GB区域需要大约17秒。机器以大致相同的速度并行地恢复一个区域，因此恢复的区域数量会大幅增加。恢复负载(即，在故障机器上有副本的每台机器的区域数量)在集群中很好地平衡:64台机器恢复一个区域，10台机器恢复两个区域。这就解释了为什么大多数区域的复制在17s左右完成，而所有区域的完全复制在不到35s的时间内完成。有些区域没有完全分配，因此恢复所需的时间较少。这就是为什么一些区域的复制在不到17秒的时间内完成。</p><p>该图还显示，即使没有故障，TATP的吞吐量也会有所下降。我们认为，这是由于基准的准入存在偏差;当许多事务发生冲突并同时缓和热键时，吞吐量会下降。</p><p><strong>TPC-C</strong></p><p>图10显示了TPC-C的时间轴。图10(a)显示，系统在不到50 ms的时间内恢复了大部分吞吐量，在此之后不久，所有区域都变得活跃起来。由于TPC-C具有更复杂的事务，因此系统恢复事务锁所需的时间比使用TATP稍微多一些。主要区别在于，尽管TPCC在实验中只恢复了63个区域，但恢复数据所需的时间更长(图10(b))。这是因为TPC-C对其哈希表进行了共同分区，以利用局部性并提高性能，这导致恢复并行性降低，因为在同一组机器上复制了多个区域，以满足应用程序指定的局部性约束。在实验中，两台机器分别恢复17个区域，导致数据恢复时间超过4分钟。注意，在图10(b)中，TPC-C吞吐量随着时间的推移逐渐降低，因为数据库的大小增长得非常快。</p><p><strong>CM故障（Failing the CM）</strong></p><p>图11显示了CM流程失败时随时间变化的TATP吞吐量。恢复速度比非cm进程失败时慢。吞吐量需要大约110 ms才能恢复到故障前的水平。恢复时间增加的主要原因是重新配置时间的增加:从图9(a)中的20 ms增加到97 ms。大部分时间都花在新CM构建仅在CM中维护的数据结构上。通过让所有机器在从CM获取区域映射时增量地维护这些数据结构，应该可以消除这种延迟。</p><p><strong>恢复时间的分布（Distribution of recovery times）</strong></p><p>我们重复了TATP恢复实验(没有CM故障)40次，以获得恢复时间的分布。实验使用较小的数据集(35亿订阅者)来运行，以缩短实验时间，但我们确认，故障后恢复吞吐量的时间与较大的数据集相同。这是因为这段时间主要用于恢复事务状态，并且对于两种数据集大小，并发执行事务的数量是相同的。图12显示了恢复时间的分布。我们测量了从CM怀疑出现故障的机器开始的恢复时间，直到吞吐量恢复到故障前平均吞吐量的80%。恢复时间的中位数大约是50毫秒，超过70%的执行的恢复时间少于100毫秒。在其他情况下，恢复时间超过100毫秒，但总是少于200毫秒。</p><p><strong>相关故障（Correlated failures）</strong></p><p>有些故障会同时影响多台机器，例如电源或开关故障。为了处理这种协调的故障，FaRM允许为每台机器指定一个故障域，CM将一个区域的每个副本放在不同的故障域中。我们将集群中的机器分为五个故障域，每个域有18台机器。这对应于交换机中每个叶子模块的端口数量。我们同时对其中一个故障域中的所有流程进行故障处理，以模拟顶架交换机的故障。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091437655.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091437611.png"></p><p>图13显示了72台未发生故障的机器随时间变化的TATP吞吐量。TATP配置为在每台机器上使用大约55个区域(整个集群中的69亿个订阅者)，以便在故障发生后有足够的空间重新复制失败的区域。FaRM在故障发生后不到400毫秒恢复峰值吞吐量。我们重复了这个实验20次，这次是所有实验的中位数。大部分时间用于恢复事务。我们需要恢复所有运行中的事务，这些事务修改了故障机器中带有副本的任何区域，读取了故障机器中带有主区域的区域，或者在故障机器上拥有协调器。这导致大约130,000个事务需要恢复，而单个故障需要恢复7500个事务。数据的重新复制需要4分钟，因为有1025个区域需要重新复制。正如在以前的实验中一样，这不会影响恢复期间的吞吐量。请注意，在此期间，每个区域仍然有两个可用的副本，因此不需要更积极地重新复制。</p><p><strong>数据恢复速度（Data recovery pacing）</strong></p><p>FaRM调整数据恢复的速度，以减少其对吞吐量的影响。这增加了在新备份中完成区域重新复制的时间。图14显示了具有非常积极的数据恢复的TATP随时间的吞吐量:每个线程同时获取4个32 KB块。故障发生800毫秒后，大部分区域被重新复制，系统才能恢复峰值吞吐量。但是，数据恢复的完成速度要快得多:恢复83个区域副本(166 GB)只需1.1秒。只有当区域丢失除一个副本外的所有副本时，我们才使用此主动恢复设置。积极的恢复速度与RAMCloud[33]相比更具优势，RAMCloud[33]在1.6秒内恢复80台机器上的35 GB。</p><p>与TATP相比，TPC-C对来自后台恢复流量的干扰不太敏感，因为只有一小部分访问远程机器上的对象。这意味着，在可能进行应用程序特定调优的设置中，我们可以更积极地重新复制数据，而不会影响性能。图15显示了当线程每2毫秒获取32 KB块时，TPC-C在恢复期间随时间的吞吐量。重新复制在65秒内完成，这比默认设置快了四倍，而且对吞吐量没有任何影响。</p><h2 id="6-5、租约时间（Lease-times）"><a href="#6-5、租约时间（Lease-times）" class="headerlink" title="6.5、租约时间（Lease times）"></a>6.5、租约时间（Lease times）</h2><p>为了评估我们的租约管理器优化(第5.1节)，我们运行了一个实验，其中所有机器中的所有线程重复向CM发出RDMA读取，持续10分钟。我们禁用了恢复功能，并针对不同的租约管理器的实现和不同的租约持续时间计算了整个集群的租约到期事件(误报)数量。这个基准测试是一个很好的压力测试，因为它在CM上生成的流量比我们描述的任何基准测试都多。</p><p>图16比较了四种租约管理器实现。第一个使用FaRM的RPC (RPC)。其他的使用不可靠的数据报:在共享线程(UD)上，在正常优先级的专用线程(UD+thread)上，以及在高优先级、中断和无固定(UD+thread+pri)上。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305091444180.png"></p><p>结果表明，所有优化都是必要的，以启用使用10 ms或更少的租赁时间而不出现误报。使用共享队列对，即使是100毫秒的租约也经常到期。通过使用不可靠的数据报可以减少误报的数量，但由于CPU的争用，误报的数量并没有消除。使用专用线程允许我们使用100毫秒的租约而没有误报，但是由于FaRM机器上运行的后台进程的CPU争用，10毫秒的租约仍然会过期。在中断驱动的租赁管理器以高优先级运行的情况下，我们可以在10分钟内使用5毫秒的租赁，没有误报。对于较短的租期，我们有时仍会出现误报。我们受到网络往返时间和系统计时器分辨率的限制，前者在负载情况下最多为1毫秒，后者为0.5毫秒。系统计时器的有限分辨率解释了为什么中断驱动的租约管理器比基于轮询的租约管理器有更多的误报。</p><p>在我们所有的实验中，我们保守地将租约设置为10毫秒，并且在执行过程中没有观察到任何误报。</p><h1 id="7、相关工作（Related-work）"><a href="#7、相关工作（Related-work）" class="headerlink" title="7、相关工作（Related work）"></a>7、相关工作（Related work）</h1><p>据我们所知，FaRM是第一个同时提供高可用性、高吞吐量、低延迟和严格串行化的系统。在之前的工作[16]中，我们概述了FaRM的早期版本，该版本将log记录到SSDs以获得持久性和可用性，但我们没有描述从故障中恢复。本文描述了一个新的快速恢复协议和一个优化的事务和复制协议，该协议发送的消息大大减少，并利用NVRAM避免记录到SSDs。与[16]中描述的事务协议相比，优化后的协议发送的消息最多减少44%，并且在验证阶段还通过单方面的RDMA读取来替换消息。[16]中的工作仅使用YCSB基准测试在没有故障的情况下评估单键事务的性能。在这里，我们使用TATP和TPC-C基准测试来评估有故障和没有故障的事务的性能。</p><p>RAMCloud[33,34]是一个键值存储，它在内存中存储数据的单个副本，并使用分布式日志来保持持久性。它不支持多对象事务。发生故障时，它在多台机器上并行恢复，在这段时间内(可能需要几秒钟)，故障机器上的数据不可用。FaRM支持事务，使数据在发生故障的几十毫秒内可用，并且每台机器的吞吐量提高了一个数量级。</p><p>Spanner[11]已在第4节中讨论。它提供了严格的可序列化性，但没有针对RDMA的性能进行优化。它使用2f + 1个副本，而FaRM使用2f + 1个副本，并且比FaRM发送更多的消息提交。Sinfonia[8]提供了一个共享的地址空间，通过使用两阶段提交实现可序列化的事务，并在特殊情况下将读取装载到两阶段提交中。FaRM提供了利用RDMA优化的一般分布式事务。</p><p>HERD[23]是一种基于内存RDMA的键值存储，它在客户端与服务器运行在不同机器上的非对称设置中为每台服务器提供高性能。它使用RDMA写入和发送/接收verbs进行消息传递，但不使用RDMA读取。[23]的作者表明，在不对称设置中，单侧RDMA读取的性能比没有可靠性的专用RPC实现更差。我们的结果在对称设置中使用可靠的通信，其中每台机器既是客户机又是服务器。这允许我们利用局部性，这很重要，因为访问本地DRAM比使用RDMA访问远程DRAM[16]要快得多。Pilaf[31]是一个使用RDMA读取的键值存储。Pilaf和HERD都不支持事务。HERD不能容错，而Pilaf通过记录到本地磁盘获得持久性，但不是可用性。</p><p>Silo[39,40]是一个单机主存数据库，它通过将log记录到持久存储来实现持久性。它将已提交的事务分批写入存储，以实现高吞吐量。故障恢复包括从存储中读取检查点和日志记录。Silo中的存储是本地的，因此当机器出现故障时，可用性将丢失。相比之下，FaRM是分布式的，并在NVRAM中使用复制来实现持久性和高可用性。对于一个大得多的数据库，FaRM在故障后恢复峰值吞吐量的速度比Silo快两个数量级。通过向外扩展和在NVRAM中使用复制，FaRM还实现了比Silo更高的吞吐量和更低的延迟。Hekaton[14,26]也是一个单机主存数据库，不支持横向扩展或分布式事务。拥有3台机器的FaRM与Hekaton的性能相当，拥有90台机器的吞吐量是Hekaton的33倍。</p><h1 id="8、总结（Conclusion）"><a href="#8、总结（Conclusion）" class="headerlink" title="8、总结（Conclusion）"></a>8、总结（Conclusion）</h1><p>事务使分布式系统编程更容易，但许多系统避免使用事务或削弱它们的一致性以提高可用性和性能。FaRM是用于现代数据中心的分布式主存计算平台，提供严格序列化的事务，具有高吞吐量、低延迟和高可用性。实现这一目标的关键是根据第一原则设计的新的交易、复制和恢复协议，利用RDMA的商品网络和一种新的、廉价的方法来提供非易失性DRAM。实验结果表明，FaRM比现有的内存数据库提供了更高的吞吐量和更低的延迟。FaRM还可以在不到50毫秒的时间内从机器故障恢复到提供峰值吞吐量，使故障对应用程序透明。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FaRM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spanner</title>
      <link href="/2023/050732546.html"/>
      <url>/2023/050732546.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>Spanner 是谷歌公司研发的、可扩展的、多版本、全球分布式、同步复制数据库。它是第一个把数据分布在全球范围内的系统，并且支持外部一致性的分布式事务。本文描述了 Spanner 的架构、特性、不同设计决策的背后机理和一个新的时间 API，这个 API 可以暴露时钟的不确定性。这个 API 及其实现，对于支持外部一致性和许多强大特性而言，是非常重要的，这些强大特性包括:非阻塞的读、不采用锁机制的只读事务、原子模式变更。</p><h1 id="1、介绍（Introduction）"><a href="#1、介绍（Introduction）" class="headerlink" title="1、介绍（Introduction）"></a>1、介绍（Introduction）</h1><p>Spanner 是一个可扩展的、全球分布式的数据库，是在谷歌公司设计、开发和部署的。</p><p>在最高抽象层面，Spanner 就是一个数据库，把数据分片存储在许多 Paxos[21]状态机上，这些机器位于遍布全球的数据中心内。复制技术可以用来服务于全球可用性和地理局部性。客户端会自动在副本之间进行失败恢复。随着数据的变化和服务器的变化，Spanner 会自动把数据进行重新分片，从而有效应对负载变化和处理失败。Spanner 被设计成可以扩展到几百万个机器节点，跨越成百上千个数据中心，具备几万亿数据库行的规模。</p><p>应用可以借助于 Spanner 来实现高可用性，通过在一个洲的内部和跨越不同的洲之间复制数据，保证即使面对大范围的自然灾害时数据依然可用。我们最初的客户是 F1[35]，一个谷歌广告后台的重新编程实现。F1 使用了跨越美国的 5 个副本。绝大多数其他应用很可能会在属于同一个地理范围内的 3-5 个数据中心内放置数据副本，采用相对独立的失败模式。也就是说，许多应用都会首先选择低延迟，而不是高可用性，只要系统能够从 1-2 个数据中心失败中恢复过来。</p><p>Spanner 的主要工作，就是管理跨越多个数据中心的数据副本，但是，在我们的分布式系统体系架构之上设计和实现重要的数据库特性方面，我们也花费了大量的时间。尽管有许多项目可以很好地使用 BigTable[9]，我们也不断收到来自客户的抱怨，客户反映 BigTable 无法应用到一些特定类型的应用上面，比如具备复杂可变的模式，或者对于在大范围内分布的多个副本数据具有较高的一致性要求。其他研究人员也提出了类似的抱怨[37]。谷歌的许多应用已经选择使用 Megastore[5]，主要是因为它的半关系数据模型和对同步复制的支持，尽管 Megastore 具备较差的写操作吞吐量。由于上述多个方面的因素，Spanner 已经从一个类似 BigTable 的单一版本的键值存储，演化成为一个具有时间属性的多版本的数据库。数据被存储到模式化的、半关系的表中，数据被版本化，每个版本都会自动以提交时间作为时间戳，旧版本的数据会更容易被垃圾回收。应用可以读取旧版本的数据。Spanner 支持通用的事务，提供了基于 SQL 的查询语言。</p><p>作为一个全球分布式数据库，Spanner 提供了几个有趣的特性:第一，在数据的副本配置方面，应用可以在一个很细的粒度上进行动态控制。应用可以详细规定，哪些数据中心包含哪些数据，数据距离用户有多远(控制用户读取数据的延迟)，不同数据副本之间距离有多远(控制写操作的延迟)，以及需要维护多少个副本(控制可用性和读操作性能)。数据也可以被动态和透明地在数据中心之间进行移动，从而平衡不同数据中心内资源的使用。第二， Spanner 有两个重要的特性，很难在一个分布式数据库上实现，即 Spanner 提供了读和写操作的外部一致性，以及在一个时间戳下面的跨越数据库的全球一致性的读操作。这些特性使得 Spanner 可以支持一致的备份、一致的 MapReduce 执行[12]和原子模式变更，所有都是在全球范围内实现，即使存在正在处理中的事务也可以。</p><p>之所以可以支持这些特性，是因为 Spanner 可以为事务分配全球范围内有意义的提交时间戳，即使事务可能是分布式的。这些时间戳反映了事务序列化的顺序。除此以外，这些序列化的顺序满足了外部一致性的要求:如果一个事务 T1 在另一个事务 T2 开始之前就已经提交了，那么，T1 的时间戳就要比 T2 的时间戳小。Spanner 是第一个可以在全球范围内提供这种保证的系统。</p><p>实现这种特性的关键技术就是一个新的 TrueTime API 及其实现。这个 API 可以直接暴露时钟不确定性，Spanner 时间戳的保证就是取决于这个 API 实现的界限。如果这个不确定性很大，Spanner 就降低速度来等待这个大的不确定性结束。谷歌的集群管理器软件提供了一个 TrueTime API 的实现。这种实现可以保持较小的不确定性(通常小于 10ms)，主要是借助于现代时钟参考值(比如 GPS 和原子钟)。</p><p>第 2 部分描述了 Spanner 实现的结构、特性和设计时工程方面的决策;第 3 部分介绍我们的新的 TrueTime API，并且描述了它的实现;第 4 部分描述了 Spanner 如何使用 TrueTime 来实现外部一致性的分布式事务、不用锁机制的只读事务和原子模式更新。第 5 部分提供了测试 Spanner 性能和 TrueTime 行为的测试基准，并讨论了 F1 的经验。第 6、7 和 8 部分讨论了相关工作，并给出总结。</p><h1 id="2、实现（Implementation）"><a href="#2、实现（Implementation）" class="headerlink" title="2、实现（Implementation）"></a>2、实现（Implementation）</h1><p>本部分内容描述了 Spanner 的结构和背后的实现机理，然后描述了目录抽象，它被用来管理副本和局部性，并介绍了数据的转移单位。最后，将讨论我们的数据模型，从而说明为什么 Spanner 看起来更加像一个关系数据库，而不是一个键值数据库;还会讨论应用如何可以控制数据的局部性。</p><p>一个 Spanner 部署称为一个 universe。假设 Spanner 在全球范围内管理数据，那么，将会只有可数的、运行中的 universe。我们当前正在运行一个测试用的 universe，一个部署/线上用的 universe 和一个只用于线上应用的 universe。</p><p>Spanner 被组织成许多个 zone 的集合，每个 zone 都大概像一个 BigTable 服务器的部署。 zone 是管理部署的基本单元。zone 的集合也是数据可以被复制到的位置的集合。当新的数据中心加入服务，或者老的数据中心被关闭时，zone 可以被加入到一个运行的系统中，或者从中移除。zone 也是物理隔离的单元，在一个数据中心中，可能有一个或者多个 zone， 例如，当属于不同应用的数据必须被分区存储到同一个数据中心的不同服务器集合中时，一个数据中心就会有多个 zone 。</p><p>图 1 显示了在一个 Spanner 的 universe 中的服务器。一个 zone 包括一个 zonemaster， 和一百至几千个 spanserver。Zonemaster 把数据分配给 spanserver，spanserver 把数据提供给客户端。客户端使用每个 zone 上面的 location proxy 来定位可以为自己提供数据的 spanserver。Universe master 和 placement driver，当前都只有一个。Universe master 主要是一个控制台，它显示了关于 zone 的各种状态信息，可以用于相互之间的调试。Placement driver 会周期性地与 spanserver 进行交互，来发现那些需要被转移的数据，或者是为了满足新的副本约束条件，或者是为了进行负载均衡。</p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071506297.png" alt="image-20230507150552596"  /><h2 id="2-1、Spanserver软件栈（Spanserver-Software-Stack）"><a href="#2-1、Spanserver软件栈（Spanserver-Software-Stack）" class="headerlink" title="2.1、Spanserver软件栈（Spanserver Software Stack）"></a>2.1、Spanserver软件栈（Spanserver Software Stack）</h2><p>本部分内容主要关注 spanserver 实现，来解释复制和分布式事务是如何被架构到我们的基于 BigTable 的实现之上的。图 2 显示了软件栈。在底部，每个 spanserver 负载管理 100-1000 个称为 tablet 的数据结构的实例。一个 tablet 就类似于 BigTable 中的 tablet，也实现了下面的映射: (key:string, timestamp:int64)-&gt;string</p><blockquote><p>一个tablet是一个容器，可以封装行空间的多个分区。这个决定是为了使得多个经常一起访问的目录可以共存。</p></blockquote><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071508173.png"></p><p>与 BigTable 不同的是，Spanner 会把时间戳分配给数据，这种非常重要的方式，使得 Spanner 更像一个多版本数据库，而不是一个键值存储。一个 tablet 的状态是存储在类似于 B-树的文件集合和写前(write-ahead)的日志中，所有这些都会被保存到一个分布式的文件系统中，这个分布式文件系统被称为 Colossus，它继承自 Google File System。</p><p>为了支持复制，每个 spanserver 会在每个 tablet 上面实现一个单个的 Paxos 状态机。一个早期 实现的Spanner 可以支持在每个 tablet 上面实现多个 Paxos 状态机器，它可以允许更加灵活的复制配置，但是，这种设计过于复杂，被我们舍弃了。每个状态机器都会在相应的 tablet 中保存自己的元数据和日志。我们的 Paxos 实现支持长寿命的领导者（采用基于时间的领导者租约），时间通常在 0 到 10 秒之间。当前的 Spanner 实现中，会对每个 Paxos 写操作进行两次记录:一次是写入到 tablet 日志中，一次是写入到 Paxos 日志中。这种做法只是权宜之计，我们以后会进行完善。我们在 Paxos 实现上采用了管道化的方式，从而可以在存在广域网延迟时改进 Spanner 的吞吐量，但是，Paxos 会把写操作按照顺序的方式执行。</p><p>Paxos 状态机是用来实现一系列被一致性复制的映射。每个副本的键值映射状态，都会被保存到相应的 tablet 中。写操作必须在领导者上初始化 Paxos 协议，读操作可以直接从底层的任何副本的 tablet 中访问状态信息，只要这个副本足够新。副本的集合被称为一个 Paxos group。</p><p>对于每个是领导者的副本而言，每个 spanserver 会实现一个锁表来实现并发控制。这个锁表包含了两阶段锁机制的状态:它把键的值域映射到锁状态上面。注意，采用一个长寿命的 Paxos 领导者，对于有效管理锁表而言是非常关键的。在 BigTable 和 Spanner 中，我们都专门为长事务做了设计，比如，对于报表操作，可能要持续几分钟，当存在冲突时，采用乐观并发控制机制会表现出很差的性能。对于那些需要同步的操作，比如事务型的读操作，需要获得锁表中的锁，而其他类型的操作则可以不理会锁表。</p><p>对于每个扮演领导者角色的副本，每个 spanserver 也会实施一个事务管理器来支持分布式事务。这个事务管理器被用来实现一个 participant leader，该组内的其他副本则是作为 participant slaves。如果一个事务只包含一个 Paxos 组(对于许多事务而言都是如此)，它就可以绕过事务管理器，因为锁表和 Paxos 二者一起可以保证事务性。如果一个事务包含了多 于一个 Paxos 组，那些组的领导者之间会彼此协调合作完成两阶段提交。其中一个参与者组，会被选为协调者，该组的 participant leader 被称为 coordinator leader，该组的 participant slaves 被称为 coordinator slaves。每个事务管理器的状态，会被保存到底层的 Paxos 组。</p><h2 id="2-2、目录和放置（Directories-and-Placement）"><a href="#2-2、目录和放置（Directories-and-Placement）" class="headerlink" title="2.2、目录和放置（Directories and Placement）"></a>2.2、目录和放置（Directories and Placement）</h2><p>在一系列键值映射的上层，Spanner 实现支持一个被称为“目录”的桶抽象，也就是包含公共前缀的连续键的集合。(选择“目录”作为名称，主要是由于历史沿袭的考虑，实际 上更好的名称应该是“桶”)。我们会在第 2.3 节解释前缀的源头。对目录的支持，可以让应用通过选择合适的键来控制数据的局部性。</p><p>一个目录是数据放置的基本单元。属于一个目录的所有数据，都具有相同的副本配置。 当数据在不同的 Paxos 组之间进行移动时，会一个目录一个目录地转移，如图 3 所示。Spanner 可能会移动一个目录从而减轻一个 Paxos 组的负担，也可能会把那些被频繁地一起访问的目录都放置到同一个组中，或者会把一个目录转移到距离访问者更近的地方。当客户端操作正在进行时，也可以进行目录的转移。我们可以预期在几秒内转移 50MB 的目录。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071520628.png"></p><p>一个 Paxos 组可以包含多个目录，这意味着一个 Spanner tablet 是不同于一个 BigTable tablet 的。一个 Spanner tablet 没有必要是一个行空间内按照词典顺序连续的分区，相反，它可以是行空间内的多个分区。我们做出这个决定，是因为这样做可以让多个被频繁一起访问的目录被整合到一起。</p><p>Movedir 是一个后台任务，用来在不同的 Paxos 组之间转移目录[14]。Movedir 也用来为 Paxos 组增加和删除副本[25]，因为 Spanner 目前还不支持在一个 Paxos 内部进行配置的变更。 Movedir 并不是作为一个事务来实现，这样可以避免在一个块数据转移过程中阻塞正在进行的读操作和写操作。相反，Movedir 会注册一个事实(fact)，表明它要转移数据，然后在后台运行转移数据。当它几乎快要转移完指定数量的数据时，就会启动一个事务来自动转移那部分数据，并且为两个 Paxos 组更新元数据。</p><p>一个目录也是一个应用可以指定的地理复制属性(即放置策略)的最小单元。我们的放置规范语言的设计，把管理复制的配置这个任务单独分离出来。管理员需要控制两个维度: 副本的数量和类型，以及这些副本的地理放置属性。他们在这两个维度里面创建了一个命名 选项的菜单。通过为每个数据库或单独的目录增加这些命名选项的组合，一个应用就可以控制数据的复制。例如，一个应用可能会在自己的目录里存储每个终端用户的数据，这就有可能使得用户 A 的数据在欧洲有三个副本，用户 B 的数据在北美有 5 个副本。</p><p>为了表达的清晰性，我们已经做了尽量简化。事实上，当一个目录变得太大时，Spanner 会把它分片存储。每个分片可能会被保存到不同的 Paxos 组上(因此就意味着来自不同的服 务器)。Movedir 在不同组之间转移的是分片，而不是转移整个目录。</p><h2 id="2-3、数据模型-Data-Model"><a href="#2-3、数据模型-Data-Model" class="headerlink" title="2.3、数据模型(Data Model)"></a>2.3、数据模型(Data Model)</h2><p>Spanner 会把下面的数据特性集合暴露给应用:<strong>基于模式化半关系表，查询语言和通用事务的数据模型</strong>。支持这些特性的动机，是受到许多因素驱动的。需要支持模式化的半关系表是由 Megastore[5]的普及来支持的。在谷歌内部至少有 300 个应用使用 Megastore(尽 管它具有相对低的性能)，因为它的数据模型要比 BigTable 简单，更易于管理，并且支持在跨数据中心层面进行同步复制。BigTable 只可以支持跨数据中心的最终事务一致性。使用 Megastore 的著名的谷歌应用是 Gmail,Picasa,Calendar,Android Market, AppEngine。在 Spanner 中需要支持 SQL 类型的查询语言，也很显然是非常必要的，因为 Dremel[28]作为交互式分析工具已经非常普及。最后，在 BigTable 中跨行事务的缺乏来导致了用户频繁的抱怨; Percolator[32]的开发就是用来部分解决这个问题的。一些作者都在抱怨，通用的两阶段提交的代价过于昂贵，因为它会带来可用性问题和性能问题[9] [10] [19]。我们认为，最好让应用 程序开发人员来处理由于过度使用事务引起的性能问题，而不是总是围绕着“缺少事务”进行编程。在 Paxos 上运行两阶段提交弱化了可用性问题。</p><p>应用的数据模型是架构在被目录桶装的键值映射层之上。一个应用会在一个 universe 中创建一个或者多个数据库。每个数据库可以包含无限数量的模式化的表。每个表都和关系数据库表类似，具备行、列和版本值。我们不会详细介绍 Spanner 的查询语言，它看起来很像 SQL，只是做了一些扩展。</p><p>Spanner 的数据模型不是纯粹关系型的，它的行必须有名称。更准确地说，每个表都需 要有包含一个或多个主键列的排序集合。这种需求，让 Spanner 看起来仍然有点像键值存储: 主键形成了一个行的名称，每个表都定义了从主键列到非主键列的映射。当一个行存在时，必须要求已经给行的一些键定义了一些值(即使是 NULL)。采用这种结构是很有用的，因为这可以让应用通过选择键来控制数据的局部性。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071601199.png"></p><p>图 4 包含了一个 Spanner 模式的实例，它是以每个用户和每个相册为基础存储图片元数据。这个模式语言和 Megastore 的类似，同时增加了额外的要求，即每个 Spanner 数据库必 须被客户端分割成一个或多个表的层次结构(hierarchy)。客户端应用会使用 INTERLEAVE IN 语句在数据库模式中声明这个层次结构。这个层次结构上面的表，是一个目录表。目录表中的每行都具有键 K，和子孙表中的所有以 K 开始(以字典顺序排序)的行一起，构成了一个目录。ON DELETE CASCADE 意味着，如果删除目录中的一个行，也会级联删除所有相关的子孙行。这个图也解释了这个实例数据库的交织层次(interleaved layout)，例如 Albums(2,1) 代表了来自 Albums 表的、对应于 user_id=2 和 album_id=1 的行。这种表的交织层次形成目录，是非常重要的，因为它允许客户端来描述存在于多个表之间的位置关系，这对于一个分片的分布式数据库的性能而言是很重要的。没有它的话，Spanner 就无法知道最重要的位置关系。</p><h1 id="3、TrueTime"><a href="#3、TrueTime" class="headerlink" title="3、TrueTime"></a>3、TrueTime</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071603031.png"></p><p>本部分内容描述 TrueTime API，并大概给出它的实现方法。我们把大量细节内容放在另一篇论文中，我们的目标是展示这种 API 的力量。表 1 列出了 API 的方法。TrueTime 会显式地把时间表达成 TTinterval，这是一个时间区间，具有有界限的时间不确定性(不像其他 的标准时间接口，没有为客户端提供不确定性这种概念)。TTinterval 区间的端点是 TTstamp 类型。TT.now()方法会返回一个 TTinterval，它可以保证包含 TT.now()方法在调用时的绝对 时间。这个时间和具备闰秒涂抹(leap-second smearing)的 UNIX 时间一样。把即时误差边 界定义为 ε,平均误差边界为ε。TT.after()和 TT.before()方法是针对 TT.now()的便捷的包装器。</p><p>$t_{abs}(e)$  表示一个事件e的绝对时间，如果用更加形式化的术语，TrueTime 可以保证，对于一个调用 tt=TT.now()，有 tt.earliest≤$t_{abs}(e_{now})$≤tt.latest，其中， $e_{now}$ 是调用的事件。</p><p>在底层，TrueTime 使用的时间是 GPS 和原子钟。TrueTime 使用两种类型的时间，是因为它们有不同的失败模式。GPS 参考时间的弱点是天线和接收器失效、局部电磁干扰和相关失败(比如设计上的缺陷导致无法正确处理闰秒和电子欺骗)，以及 GPS 系统运行中断。原子钟也会失效，不过失效的方式和 GPS 无关，不同原子钟之间的失效也没有彼此关联。 由于存在频率误差，在经过很长的时间以后，原子钟都会产生明显误差。</p><p>TrueTime 是由每个数据中心上面的许多 time master 机器和每台机器上的一个 timeslave daemon 来共同实现的。大多数 master 都有具备专用天线的 GPS 接收器，这些 master 在物理上是相互隔离的，这样可以减少天线失效、电磁干扰和电子欺骗的影响。剩余的 master (我们称为 Armageddon master)则配备了原子钟。一个原子钟并不是很昂贵:一个 Armageddon master 的花费和一个 GPS master 的花费是同一个数量级的。所有 master 的时间 参考值都会进行彼此校对。每个 master 也会交叉检查时间参考值和本地时间的比值，如果二者差别太大，就会把自己驱逐出去。在同步期间，Armageddon master 会表现出一个逐渐增加的时间不确定性，这是由保守应用的最差时钟漂移引起的。GPS master 表现出的时间不确定性几乎接近于 0。</p><p>每个 daemon 会从许多 master[29]中收集投票，获得时间参考值，从而减少误差。被选中的 master 中，有些 master 是 GPS master，是从附近的数据中心获得的，剩余的 GPS master 是从远处的数据中心获得的;还有一些是 Armageddon master。Daemon 会使用一个 Marzullo 算法[27]的变种，来探测和拒绝欺骗，并且把本地时钟同步到非撒谎 master 的时间参考值。 为了免受较差的本地时钟的影响，我们会根据组件规范和运行环境确定一个界限，如果机器的本地时钟误差频繁超出这个界限，这个机器就会被驱逐出去。</p><p>在同步期间，一个 daemon 会表现出逐渐增加的时间不确定性。ε 是从保守应用的最差 时钟漂移中得到的。ε 也取决于 time master 的不确定性，以及与 time master 之间的通讯延迟。在我们的线上应用环境中，ε 通常是一个关于时间的锯齿形函数。在每个投票间隔中， ε 会在 1 到 7ms 之间变化。因此，在大多数情况下，ε的值是 4ms。Daemon 的投票间隔，在当前是 30 秒，当前使用的时钟漂移比率是 200 微秒/秒，二者一起意味着 0 到 6ms 的锯齿形边界。剩余的 1ms 主要来自到 time master 的通讯延迟。在失败的时候，超过这个锯齿形边界也是有可能的。例如，偶尔的 time master 不确定性，可能会引起整个数据中心范围内的 ε 值的增加。类似的，过载的机器或者网络连接，都会导致 ε 值偶尔地局部增大。</p><h1 id="4、并发控制（Concurrency-Control）"><a href="#4、并发控制（Concurrency-Control）" class="headerlink" title="4、并发控制（Concurrency Control）"></a>4、并发控制（Concurrency Control）</h1><p>本部分内容描述 TrueTime 如何可以用来保证并发控制的正确性，以及这些属性如何用来实现一些关键特性，比如外部一致性的事务、无锁机制的只读事务、针对历史数据的非阻塞读。这些特性可以保证，在时间戳为 t 的时刻的数据库读操作，一定只能看到在 t 时刻之 前已经提交的事务。</p><p>进一步说，把 Spanner 客户端的写操作和 Paxos 看到的写操作这二者进行区分，是非常重要的，我们把 Paxos 看到的写操作称为 Paxos 写操作。例如，两阶段提交会为准备提交阶段生成一个 Paxos 写操作，这时不会有相应的客户端写操作。</p><h2 id="4-1、时间戳管理（Timestamp-Management）"><a href="#4-1、时间戳管理（Timestamp-Management）" class="headerlink" title="4.1、时间戳管理（Timestamp Management）"></a>4.1、时间戳管理（Timestamp Management）</h2><p>表 2 列出了 Spanner 支持的操作的类型。Spanner 可以支持读写事务、只读事务(预先声明的快照隔离事务)和快照读。独立写操作，会被当成读写事务来执行。非快照独立读操作，会被当成只读事务来执行。二者都是在内部进行 retry，客户端不用进行这种 retry loop。</p><p>一个只读事务具备快照隔离的性能优势[6]。一个只读事务必须事先被声明不会包含任何写操作，它并不是一个简单的不包含写操作的读写事务。在一个只读事务中的读操作，在执行时会采用一个系统选择的时间戳，不包含锁机制，因此，后面到达的写操作不会被阻塞。 在一个只读事务中的读操作，可以到任何足够新的副本上去执行(见第 4.1.3 节)。</p><p>一个快照读操作，是针对历史数据的读取，执行过程中，不需要锁机制。一个客户端可以为快照读确定一个时间戳，或者提供一个时间范围让 Spanner 来自动选择时间戳。不管是 哪种情况，快照读操作都可以在任何具有足够新的副本上执行。</p><p>对于只读事务和快照读而言，一旦已经选定一个时间戳，那么，提交就是不可避免的，除非在那个时间点的数据已经被垃圾回收了。因此，客户端不必在 retry loop 中缓存结果。 当一个服务器失效的时候，客户端就可以使用同样的时间戳和当前的读位置，在另外一个服务器上继续执行读操作。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071645858.png"></p><h3 id="4-1-1、Paxos领导者租约（Paxos-Leader-Leases）"><a href="#4-1-1、Paxos领导者租约（Paxos-Leader-Leases）" class="headerlink" title="4.1.1、Paxos领导者租约（Paxos Leader Leases）"></a>4.1.1、Paxos领导者租约（Paxos Leader Leases）</h3><p>Spanner 的 Paxos 实现中使用了时间化的租约，来实现长时间的领导者地位(默认是 10秒)。一个潜在的领导者会发起请求，请求时间化的租约投票，在收到指定数量的投票后，这个领导者就可以确定自己拥有了一个租约。一个副本在成功完成一个写操作后，会隐式地延期自己的租约。对于一个领导者而言，如果它的租约快要到期了，就要显示地请求租约延期。另一个领导者的租约有个时间区间，这个时间区间的起点就是这个领导者获得指定数量的投票那一刻，时间区间的终点就是这个领导者失去指定数量的投票的那一刻(因为有些投 票已经过期了)。Spanner 依赖于下面这些“不连贯性”:对于每个 Paxos 组，每个 Paxos 领 导者的租约时间区间，是和其他领导者的时间区间完全隔离的。附录 A 显示了如何强制实现这些不连贯性。</p><p>Spanner 实现允许一个 Paxos 领导者通过把 slave 从租约投票中释放出来这种方式，实现领导者的退位。为了保持这种彼此隔离的不连贯性，Spanner 会对什么时候退位做出限制。把 $s_{max}$定义为一个领导者可以使用的最大的时间戳。后面的小节将描述何时使用$s_{max}$。在退位之前，一个领导者必须等到 TT.after($s_{max}$)是真。</p><h3 id="4-1-2、为读写事务分配时间戳（Assigning-Timestamps-to-RW-Transactions）"><a href="#4-1-2、为读写事务分配时间戳（Assigning-Timestamps-to-RW-Transactions）" class="headerlink" title="4.1.2、为读写事务分配时间戳（Assigning Timestamps to RW Transactions）"></a>4.1.2、为读写事务分配时间戳（Assigning Timestamps to RW Transactions）</h3><p>事务读和写采用两段锁协议。当所有的锁都已经获得以后，在任何锁被释放之前，就可以给事务分配时间戳。对于一个给定的事务，Spanner 会为事务分配时间戳，这个时间戳是 Paxos 分配给 Paxos 写操作的，它代表了事务提交的时间。</p><p>Spanner 依赖下面这些单调性:在每个 Paxos 组内，Spanner 会以单调增加的顺序给每个 Paxos 写操作分配时间戳，即使在跨越多个领导者时也是如此。一个单个的领导者副本，可以很容易地以单调增加的方式分配时间戳。在多个领导者之间就会强制实现彼此隔离的不连 贯:一个领导者必须只能分配属于它自己租约时间区间内的时间戳。要注意到，一旦一个时间戳 s 被分配，smax 就会被增加到 s，从而保证彼此隔离性(不连贯性)。</p><p>Spanner 也会实现下面的外部一致性:如果一个事务 T2 在事务 T1 提交以后开始执行， 那么，事务 T2 的时间戳一定比事务 T1 的时间戳大。对于一个事务 Ti 而言，定义开始和提交事件$e_{i}^{start}$和$e_{i}^{commit}$，事务提交时间为$s_{i}$。对外部一致性的要求就变成了:<br>$t_{abs}(e_{1}^{commit})&lt;t_{abs}(e_{2}^{start})=&gt;s_{1}&lt;s_{2}$。执行事务的协议和分配时间戳的协议，遵守两条规则，二者一起保证外部一致性。对于一个写操作 $T_{i}$而言，担任协调者的领导者发出的提交请求的事件为$e_{i}^{server}$ 。</p><p><strong>Start.</strong> 为一个事务 Ti 担任协调者的领导者分配一个提交时间戳 $s_{i}$，不会小于 TT.now().latest 的值，TT.now().latest的值是在$e_{i}^{server}$事件之后计算得到的。要注意，担任参与者的领导者， 在这里不起作用。第 4.2.1 节描述了这些担任参与者的领导者是如何参与下一条规则的实现的。</p><p><strong>Commit Wait.</strong> 担任协调者的领导者，必须确保客户端不能看到任何被 $T_{i}$提交的数据，直到 TT.after($s_{i}$)为真。提交等待，就是要确保 si 会比 Ti 的绝对提交时间小，或者$s_{i}&lt;t_{abs}(e_{i}^{commmit})$。提交等待的实现在 4.2.1 节中描述。证明如下:</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071657881.png"></p><h3 id="4-1-3、在某个时间戳下的读操作（Serving-Reads-at-a-Timestamp）"><a href="#4-1-3、在某个时间戳下的读操作（Serving-Reads-at-a-Timestamp）" class="headerlink" title="4.1.3、在某个时间戳下的读操作（Serving Reads at a Timestamp）"></a>4.1.3、在某个时间戳下的读操作（Serving Reads at a Timestamp）</h3><p>第 4.1.2 节中描述的单调性，使得 Spanner 可以正确地确定一个副本是否足够新，从而能够满足一个读操作的要求。每个副本都会跟踪记录一个值，这个值被称为安全时间 $t_{safe}$，它是一个副本最近更新后的最大时间戳。如果一个读操作的时间戳是 t，当满足 $t&lt;=t_{safe}$ 时， 这个副本就可以被这个读操作读取。</p><p>定义$t_{safe}=min(t_{safe}^{Paxos},t_{safe}^{TM})$，其中每个Paxos状态机都有一个安全时间$t_{safe}^{Paxos}$，每个事务管理器都有一个安全时间$t_{safe}^{TM}$。$t_{safe}^{Paxos}$安全性更简单:它是应用最多的Paxos写入的时间戳。由于时间戳单调地增加，并且写入是按顺序应用的，因此相对于Paxos，小于等于$t_{safe}^{Paxos}$的情况下写入将不再发生。</p><p>如果没有准备(但未提交)事务，即处于两阶段提交的两个阶段之间的事务，则副本的$t_{safe}^{TM}$安全性为$\infty$。(对于participant slave，$t_{safe}^{Paxos}$实际上指的是副本的leader的事务管理器，slave可以通过Paxos写传递的元数据推断其状态。)如果存在这样的事务，那么受这些事务影响的状态是不确定的:参与者副本还不知道这些事务是否会提交。正如我们在4.2.1节中讨论的那样，提交协议确保每个参与者都知道准备好的事务时间戳的下限。事务$T_{i}$的每个参与者领导者(对于组g)为其准备记录分配一个准备时间戳$s_{i,g}^{prepare}$。协调器领导者确保事务的提交时间戳$s_{i}&gt;=s_{i,g}^{prepare}$，覆盖所有参与者组g。因此，对于组g中的每个副本，在g准备的所有事务$T_{i}$ 上，$t_{safe}^{TM}=min_{i}(s_{i,g}^{prepare})-1$均成立。</p><h3 id="4-1-4、为只读事务分配时间戳（Assigning-Timestamps-to-RO-Transactions）"><a href="#4-1-4、为只读事务分配时间戳（Assigning-Timestamps-to-RO-Transactions）" class="headerlink" title="4.1.4、为只读事务分配时间戳（Assigning Timestamps to RO Transactions）"></a>4.1.4、为只读事务分配时间戳（Assigning Timestamps to RO Transactions）</h3><p>一个只读事务分成两个阶段执行:分配一个时间戳 $s_{read}$[8]，然后当成 $s_{read}$时刻的快照读来执行事务读操作。快照读可以在任何足够新的副本上面执行。</p><p>在一个事务开始后的任意时刻，可以简单地分配 $s_{read}$=TT.now().latest，通过第 4.1.2 节中描述过的类似的方式来维护外部一致性。但是，对于时间戳$s_{read}$而言，如果$t_{safe}$没有增加到足够大，可能需要对 $s_{read}$时刻的读操作进行阻塞。除此以外还要注意，选择一个 $s_{read}$的值可 能也会增加 $s_{max}$的值，从而保证不连贯性。为了减少阻塞的概率，Spanner 应该分配可以保持外部一致性的最老的时间戳。第 4.2.2 节描述了如何选择这种时间戳。</p><h2 id="4-2、细节（Details）"><a href="#4-2、细节（Details）" class="headerlink" title="4.2、细节（Details）"></a>4.2、细节（Details）</h2><p>这部分内容介绍一些读写操作和只读操作的实践细节，以及用来实现原子模式变更的特定事务的实现方法。然后，描述一些基本模式的细化。</p><h3 id="4-2-1、读写事务（Read-Write-Transactions）"><a href="#4-2-1、读写事务（Read-Write-Transactions）" class="headerlink" title="4.2.1、读写事务（Read-Write Transactions）"></a>4.2.1、读写事务（Read-Write Transactions）</h3><p>就像 Bigtable 一样，发生在一个事务中的写操作会在客户端进行缓存，直到提交。由此导致的结果是，在一个事务中的读操作，不会看到这个事务的写操作的结果。这种设计在 Spanner 中可以很好地工作，因为一个读操作可以返回任何数据读的时间戳，未提交的写操作还没有被分配时间戳。</p><p>在读写事务内部的读操作，使用伤停等待(wound-wait)[33]来避免死锁。客户端对位于合适组内的领导者副本发起读操作，需要首先获得读锁，然后读取最新的数据。当一个客户端事务保持活跃的时候，它会发送“保持活跃”信息，防止那些参与的领导者让该事务过时。当一个客户端已经完成了所有的读操作，并且缓冲了所有的写操作，它就开始两阶段提交。客户端选择一个协调者组，并且发送一个提交信息给每个参与的、具有协调者标识的领导者，并发送提交信息给任何缓冲的写操作。让客户端发起两阶段提交操作，可以避免在大范围连接内发送两次数据。</p><p>一个参与其中的、扮演非协调者角色的领导者，首先需要获得写锁。然后，它会选择一 个预备时间戳，这个时间戳应该比之前分配给其他事务的任何时间戳都要大(这样可以保持 单调性)，并且通过 Paxos 把准备提交记录写入日志。然后，每个参与者就把自己的准备时 间戳通知给协调者。</p><p>扮演协调者的领导者，也会首先获得写锁，但是，会跳过准备阶段。在从所有其他的、扮演参与者的领导者那里获得信息后，它就会为整个事务选择一个时间戳。这个提交时间戳 s 必须大于或等于所有的准备时间戳(这是为了满足第 4.1.3 节讨论的限制条件)，在协调者收到它的提交信息时，s 应该大于 TT.now().latest，并且 s 应该大于这个领导者为之前的其他 所有事务分配的时间戳(再次指出，这样做是为了满足单调性)。这个扮演协调者的领导者，就会通过 Paxos 在日志中写入一个提交记录(或者当等待其他参与者发生超时就在日志中写 入终止记录)。</p><p>在允许任何协调者副本去提交记录之前，扮演协调者的领导者会一直等待到 TT.after(s)， 从而可以保证遵循第 4.1.2 节中描述的提交等待规则。因为，扮演协调者的领导者会根据 TT.now().latest 来选择 s，而且必须等待直到那个时间戳可以确保成为过去，预期的等待时间 至少是 $2*\overline{\epsilon}$。这种等待时间通常会和 Paxos 通信时间发生重叠。在提交等待之后，协调者就会发送一个提交时间戳给客户端和所有其他参与的领导者。每个参与的领导者会通过 Paxos 把事务结果写入日志。所有的参与者会在同一个时间戳进行提交，然后释放锁。</p><h3 id="4-2-2、只读事务（Read-Only-Transactions）"><a href="#4-2-2、只读事务（Read-Only-Transactions）" class="headerlink" title="4.2.2、只读事务（Read-Only Transactions）"></a>4.2.2、只读事务（Read-Only Transactions）</h3><p>分配一个时间戳需要一个协商阶段，这个协商发生在所有参与到该读操作中的 Paxos 组之间。由此导致的结果是，Spanner 需要为每个只读事务提供一个 scope 表达式，它可以指出整个事务需要读取哪些键。对于单独的查询，Spanner 可以自动计算出 scope。</p><p>如果 scope 的值是由单个 Paxos 组来提供的，那么，客户端就会给那个组的领导者发起一个只读事务(当前的 Spanner 实现中，只会为 Paxos leader 中的只读事务选择一个时间戳)， 为那个领导者分配 $s_{read}$并且执行读操作。对于一个单个位置的读操作，Spanner 通常会比 TT.now().latest 做得更好。我们把 LastTS()定义为在 Paxos 组中最后提交的写操作的时间戳。如果没有准备提交的事务，这个分配到的时间戳 $s_{read}$=LastTS()就很容易满足外部一致性要求: 这个事务将可以看见最后一个写操作的结果，然后排队排在它之后。</p><p>如果 scope 的值是由多个 Paxos 组来提供的，就会有几种选择。最复杂的选择就是，和所有组的领导者进行一轮沟通，大家根据 LastTS()进行协商得到 $s_{read}$。Spanner 当前实现了一个更加简单的选择。这个选择可以避免一轮协商，让读操作在 $s_{read}$=TT.now().latest 时刻去执行(这可能会等待安全时间的增加)。这个事务中的所有读操作，可以被发送到任何足够新的副本上执行。</p><h3 id="4-2-3、模式变更事务（Schema-Change-Transactions）"><a href="#4-2-3、模式变更事务（Schema-Change-Transactions）" class="headerlink" title="4.2.3、模式变更事务（Schema-Change Transactions）"></a>4.2.3、模式变更事务（Schema-Change Transactions）</h3><p>TrueTime 允许 Spanner 支持原子模式变更。使用一个标准的事务是不可行的，因为参与者的数量(即数据库中组的数量)可能达到几百万个。Bigtable 可以支持在一个数据中心内进行原子模式变更，但是，这个操作会阻塞所有其他操作。</p><p>一个 Spanner 模式变更事务通常是一个标准事务的、非阻塞的变种。首先，它会显式地分配一个未来的时间戳，这个时间戳会在准备阶段进行注册。由此，跨越几千个服务器的模式变更，可以在不打扰其他并发活动的前提下完成。其次，读操作和写操作，它们都是隐式地依赖于模式，它们都会和任何注册的模式变更时间戳t保持同步:当它们的时间戳小于 t 时， 读写操作就执行到时刻 t;当它们的时间戳大于时刻 t 时，读写操作就必须阻塞，在模式变更事务后面进行等待。如果没有 TrueTime，那么定义模式变更发生在 t 时刻，就变得毫无意义。</p><h3 id="4-2-4、细化（Refinements）"><a href="#4-2-4、细化（Refinements）" class="headerlink" title="4.2.4、细化（Refinements）"></a>4.2.4、细化（Refinements）</h3><p>如上所定义的$t_{safe}^{TM}$有一个缺点，即单个准备好的事务会阻止$t_{safe}$向前推进。因此，在以后的时间戳上不能发生任何读操作，即使这些读操作与事务不冲突。通过使用从键范围到准备事务时间戳的细粒度映射来增加$t_{safe}^{TM}$，可以消除这种错误冲突。该信息可以存储在锁表中，锁表已经将键范围映射到锁元数据。当读取到达时，只需要根据与读取冲突的键范围的细粒度安全时间检查它。</p><p>上面定义的LastTS()也有类似的缺点:如果一个事务刚刚提交，必须为一个不冲突的只读事务分配空间，以便跟踪该事务。因此，读取的执行可能会延迟。这个缺点可以类似地通过使用从键范围到锁表中的提交时间戳的细粒度映射来扩展LastTS()来弥补。(我们还没有实现这个优化。)当一个只读事务到达时，可以通过获取与该事务冲突的键范围的LastTS()的最大值来分配它的时间戳，除非存在冲突的准备事务(可以从细粒度安全时间确定)。</p><p>如上所述，$t_{safe}^{TM}$有一个缺点，即在没有Paxos写操作的情况下无法前进。也就是说，在t点读取快照不能在上一次写操作发生在t点之前的Paxos组上执行。Spanner通过利用领导者租约间隔的不连接性来解决这个问题。每个Paxos领导者通过保持一个阈值来提高$t_{safe}^{TM}$，超过这个阈值以后将发生写时间戳:它维护一个映射MinNextTS(n)，从Paxos序列号n到可能分配给Paxos序列号n + 1的最小时间戳。当副本应用到n时，副本可以将$t_{safe}^{TM}$推进到MinNextTS(n)−1</p><p>单个领导者可以轻松地强制执行其MinNextTS()承诺。因为MinNextTS()承诺的时间戳位于领导者租约内，所以不相交的不变量强制执行跨领导者的MinNextTS()承诺。如果领导者希望将MinNextTS()推进到其领导租约的结束之后，它必须首先延长其租约。请注意，为了保持不相交性，$s_{max}$始终被推进到MinNextTS()中的最高值。</p><p>默认情况下，leader每8秒更新一次MinNextTS()值。因此，在没有准备好的事务的情况下，在最坏的情况下，空闲Paxos组中健康的从服务器可以在大于8秒的时间戳上提供读操作。领导者还可以根据slave的要求提高MinNextTS()的值。</p><h1 id="5、实验分析（Evaluation）"><a href="#5、实验分析（Evaluation）" class="headerlink" title="5、实验分析（Evaluation）"></a>5、实验分析（Evaluation）</h1><p>我们对 Spanner 性能进行了测试，包括复制、事务和可用性。然后，我们提供了一些关于 TrueTime 的实验数据，并且提供了我们的第一个用例——F1。</p><h2 id="5-1、微测试基准（Microbenchmarks）"><a href="#5-1、微测试基准（Microbenchmarks）" class="headerlink" title="5.1、微测试基准（Microbenchmarks）"></a>5.1、微测试基准（Microbenchmarks）</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305071810758.png"></p><p>表 3 给出了一用于 Spanner 的微测试基准(microbenchmark)。这些测试是在分时机器上实现的:每个 spanserver 采用 4GB 内存和四核 CPU(AMD Barcelona 2200MHz)。客户端运行在单独的机器上。每个 zone 都包含一个 spanserver。客户端和 zone 都放在一个数据中心集合内，它们之间的网络距离不会超过 1ms。这种布局是很普通的，许多数据并不需要把数 据分散存储到全球各地)。测试数据库具有 50 个 Paxos 组和 2500 个目录。操作都是独立的 4KB 大小的读和写。所有的读取都是在压缩后从内存中提供的，因此我们只测量Spanner调用堆栈的开销。此外，还会进行一轮读操作，来预热任何位置的缓存。</p><p>对于延迟实验而言，客户端发出足够少的操作，以避免在服务器上排队。在1个副本的实验中，提交等待时间约为5ms, Paxos延迟时间约为9ms。随着副本数量的增加，延迟大致保持不变，标准差较小，因为Paxos在组的副本上并行执行。随着副本数量的增加，实现仲裁的延迟对一个从副本的慢速变得不那么敏感。</p><p>对于吞吐量的实验而言，客户端发起足够数量的操作，从而使得 CPU 处理能力达到饱和。快照读操作可以在任何足够新的副本上进行，因此，快照读的吞吐量会随着副本的数量增加而线性增加。单个读的只读事务，只会在领导者上执行，因为，时间戳分配必须发生在领导者上。只读事务吞吐量会随着副本数量的增加而增加，因为有效的 spanserver 的数量会增加:在这个实验的设置中，spanserver 的数量和副本的数量相同，领导者会被随机分配到不同的 zone。写操作的吞吐量也会从这种实验设置中获得收益(副本从 3 变到 5 时写操作吞吐量增加了，就能够说明这点)，但是，随着副本数量的增加，每个写操作执行时需要完 成的工作量也会线性增加，这就会抵消前面的收益。</p><p>表 4 显示了两阶段提交可以扩展到合理数量的参与者:它是对一系列实验的总结，这些实验运行在 3 个 zone 上，每个 zone 具有 25 个 spanserver。扩展到 50 个参与者，无论在平均值还是第 99 个百分位方面，都是合理的。在 100 个参与者的情形下，延迟开发明显增加。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305072020086.png"></p><h2 id="5-2、可用性（Availability）"><a href="#5-2、可用性（Availability）" class="headerlink" title="5.2、可用性（Availability）"></a>5.2、可用性（Availability）</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305072022294.png"></p><p>图 5 显示了在多个数据中心运行 Spanner 时的可用性方面的收益。它显示了三个吞吐量实验的结果，并且存在数据中心失败的情形，所有三个实验结果都被重叠放置到一个时间轴 上。测试用的 universe 包含 5 个 zone Zi，每个 zone 都拥有 25 个 spanserver。测试数据库被 分片成 1250 个 Paxos 组，100 个客户端不断地发送非快照读操作，累积速率是每秒 50K 个读操作。所有领导者都会被显式地放置到 Z1。每个测试进行 5 秒钟以后，一个 zone 中的所有服务器都会被“杀死”:non-leader 杀掉 Z2，leader-hard 杀掉 Z1，leader-soft 杀掉 Z1，但是，它会首先通知所有服务器它们将要交出领导权。</p><p>杀掉 Z2 对于读操作吞吐量没有影响。杀掉 Z1，给领导者一些时间来把领导权交给另一个 zone 时，会产生一个小的影响:吞吐量会下降，不是很明显，大概下降 3-4%。另一方面，没有预警就杀掉 Z1 有一个明显的影响:完成率几乎下降到 0。随着领导者被重新选择，系统的吞吐量会增加到大约每秒 100K 个读操作，主要是由于我们的实验设置:系统中有额外的能力，当找不到领导者时操作会排队。由此导致的结果是，系统的吞吐量会增加直到到达 系统恒定的速率。</p><p>我们可以看看把 Paxos 领导者租约设置为 10ms 的效果。当我们杀掉这个 zone，对于这 个组的领导者租约的过期时间，会均匀地分布到接下来的 10 秒钟内。来自一个死亡的领导者的每个租约一旦过期，就会选择一个新的领导者。大约在杀死时间过去 10 秒钟以后，所有的组都会有领导者，吞吐量就恢复了。短的租约时间会降低服务器死亡对于可用性的影响， 但是，需要更多的更新租约的网络通讯开销。我们正在设计和实现一种机制，它可以在领导者失效的时候，让 slave 释放 Paxos 领导者租约。</p><h2 id="5-3、TrueTime"><a href="#5-3、TrueTime" class="headerlink" title="5.3、TrueTime"></a>5.3、TrueTime</h2><p>于 TrueTime，必须回答两个问题: ε 是否就是时钟不确定性的边界? ε 会变得多糟糕? 对于第一个问题，最严峻的问题就是，如果一个局部的时钟漂移大于 200us/sec，那就会破坏 TrueTime 的假设。我们的机器统计数据显示，坏的 CPU 的出现概率要比坏的时钟出现概率大 6 倍。也就是说，与更加严峻的硬件问题相比，时钟问题是很少见的。由此，我们也相信，TrueTime 的实现和 Spanner 其他软件组件一样，具有很好的可靠性，值得信任。</p><p>图 6 显示了 TrueTime 数据，是从几千个 spanserver 中收集的，这些 spanserver 跨越了多 个数据中心，距离 2200 公里以上。图中描述了 ε 的第 90 个、99 个和 99.9 个百分位的情况， 是在对 timemaster 进行投票后立即对 timeslave daemon 进行样本抽样的。这些抽样数据没有考虑由于时钟不确定性带来的 ε 值的锯齿，因此测量的是 timemaster 不确定性(通常是 0) 再加上通讯延迟。</p><p>图 6 中的数据显示了，在决定 ε 的基本值方面的上述两个问题，通常都不会是个问题。 但是，可能会存在明显的拖尾延迟问题，那会引起更高的 ε 值。图中，3 月 30 日拖尾延迟的降低，是因为网络的改进，减少了瞬间网络连接的拥堵。在 4 月 13 日 ε 的值增加了，持续了大约 1 个小时，主要是因为例行维护时关闭了两个 time master。我们会继续调研并且消除引起 TrueTime 突变的因素。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305072103901.png"></p><h2 id="5-4、F1"><a href="#5-4、F1" class="headerlink" title="5.4、F1"></a>5.4、F1</h2><p>Spanner 在 2011 年早期开始进行在线负载测试，它是作为谷歌广告后台 F1[35]的重新实现的一部分。这个后台最开始是基于 MySQL 数据库，在许多方面都采用手工数据分区。未 经压缩的数据可以达到几十 TB，虽然这对于许多 NoSQL 实例而言数据量是很小的，但是， 对于采用数据分区的 MySQL 而言，数据量是非常大的。MySQL 的数据分片机制，会把每个客户和所有相关的数据分配给一个固定的分区。这种布局方式，可以支持针对单个客户的 索引构建和复杂查询处理，但是，需要了解一些商业知识来设计分区。随着客户数量的增长， 对数据进行重新分区，代价是很大的。最近一次的重新分区，花费了两年的时间，为了降低风险，在多个团队之间进行了大量的合作和测试。这种操作太复杂了，无法常常执行，由此导致的结果是，团队必须限制 MySQL 数据库的增长，方法是，把一些数据存储在外部的 Bigtable 中，这就会牺牲事务和查询所有数据的能力。</p><p>F1 团队选择使用 Spanner 有几个方面的原因。首先，Spanner 不需要手工分区。其次， Spanner 提供了同步复制和自动失败恢复。在采用 MySQL 的 master-slave 复制方法时，很难进行失败恢复，会有数据丢失和当机的风险。再次，F1 需要强壮的事务语义，这使得使用 其他 NoSQL 系统是不实际的。应用语义需要跨越任意数据的事务和一致性读。F1 团队也需要在他们的数据上构建二级索引(因为 Spanner 没有提供对二级索引的自动支持)，也有能力使用 Spanner 事务来实现他们自己的一致性全球索引。</p><p>所有应用写操作，现在都是默认从 F1 发送到 Spanner。而不是发送到基于 MySQL 的应 用栈。F1 在美国的西岸有两个副本，在东岸有三个副本。这种副本位置的选择，是为了避免发生自然灾害时出现服务停止问题，也是出于前端应用的位置的考虑。实际上，Spanner 的失败自动恢复，几乎是不可见的。在过去的几个月中，尽管有不在计划内的机群失效，但是，F1 团队最需要做的工作仍然是更新他们的数据库模式，来告诉 Spanner 在哪里放置 Paxos 领导者，从而使得它们尽量靠近应用前端。</p><p>Spanner 时间戳语义，使得它对于 F1 而言，可以高效地维护从数据库状态计算得到的、放在内存中的数据结构。F1 会为所有变更都维护一个逻辑历史日志，它会作为每个事务的 一部分写入到 Spanner。F1 会得到某个时间戳下的数据的完整快照，来初始化它的数据结构， 然后根据数据的增量变化来更新这个数据结构。</p><p>表 5 显示了 F1 中每个目录的分片数量的分布情况。每个目录通常对应于 F1 上的应用栈中的一个用户。绝大多数目录(同时意味着绝大多数用户)都只会包含一个分片，这就意味着，对于这些用户数据的读和写操作只会发生在一个服务器上。多于 100 个分片的目录，是那些包含 F1 二级索引的表:对这些表的多个分片进行写操作，是极其不寻常的。F1 团队也只是在以事务的方式进行未经优化的批量数据加载时，才会碰到这种情形。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305072105493.png"></p><p>表 6 显示了从 F1 服务器来测量的 Spanner 操作的延迟。在东海岸数据中心的副本，在 选择 Paxos 领导者方面会获得更高的优先级。表 6 中的数据是从这些数据中心的 F1 服务器 上测量得到的。写操作延迟分布上存在较大的标准差，是由于锁冲突引起的肥尾效应(fat tail)。在读操作延迟分布上存在更大的标准差，部分是因为 Paxos 领导者跨越了两个数据中心，只有其中的一个是采用了固态盘的机器。此外，测试内容还包括系统中的每个针对两个 数据中心的读操作:字节读操作的平均值和标准差分别是 1.6KB 和 119KB。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305072105901.png"></p><h1 id="6、相关工作（Related-Work）"><a href="#6、相关工作（Related-Work）" class="headerlink" title="6、相关工作（Related Work）"></a>6、相关工作（Related Work）</h1><p>Megastore[5]和 DynamoDB[3]已经提供了跨越多个数据中心的一致性复制。DynamoDB 提供了键值存储接口，只能在一个 region 内部进行复制。Spanner 和 Megastore 一样，都提供了半关系数据模型，甚至采用了类似的模式语言。Megastore 无法活动高性能。Megastore 是架构在 Bigtable 之上，这带来了很高的通讯代价。Megastore 也不支持长寿命的领导者， 多个副本可能会发起写操作。来自不同副本的写操作，在 Paxos 协议下一定会发生冲突，即使他们不会发生逻辑冲突:会严重影响吞吐量，在一个 Paxos 组内每秒钟只能执行几个写操作。Spanner 提供了更高的性能，通用的事务和外部一致性。</p><p>Pavlo 等人[31]对数据库和 MapReduce[12]的性能进行了比较。他们指出了几个努力的方向，可以在分布式键值存储之上充分利用数据库的功能[1][4][7][41]，二者可以实现充分的融合。我们比较赞同这个结论，并且认为集成多个层是具有优势的:把复制和并发控制集成起来，可以减少 Spanner 中的提交等待代价。</p><p>在一个采用了复制的存储上面实现事务，可以至少追述到 Gifford 的论文[16]。Scatter[17] 是一个最近的基于 DHT 的键值存储，可以在一致性复制上面实现事务。Spanner 则要比 Scatter 在更高的层次上提供接口。Gray 和 Lamport[18]描述了一个基于 Paxos 的非阻塞的提交协议，他们的协议会比两阶段提交协议带来更多的代价，而两阶段提交协议在大范围分布 式的组中的代价会进一步恶化。Walter[36]提供了一个快照隔离的变种，但是无法跨越数据中心。相反，我们的只读事务提供了一个更加自然的语义，因为我们对于所有的操作都支持外部语义。</p><p>最近，在减少或者消除锁开销方面已经有大量的研究工作。Calvin[40]消除了并发控制: 它会重新分配时间戳，然后以时间戳的顺序执行事务。HStore[39]和 Granola[11]都支持自己的事务类型划分方法，有些事务类型可以避免锁机制。但是，这些系统都无法提供外部一致性。Spanner 通过提供快照隔离，解决了冲突问题。</p><p>VoltDB[42]是一个分片的内存数据库，可以支持在大范围区域内进行主从复制，支持灾难恢复，但是没有提供通用的复制配置方法。它是一个被称为 NewSQL 的实例，这是实现 可扩展的 SQL[38]的强大的市场推动力。许多商业化的数据库都可以支持历史数据读取，比如 Marklogic[26]和 Oracle’ Total Recall[30]。Lomet 和 Li[24]对于这种时间数据库描述了一种 实现策略。</p><p>Faresite 给出了与一个受信任的时钟参考值相关的时钟不确定性的边界[13]:Farsite 中的服务器租约的方式，和 Spanner 中维护 Paxos 租约的方式相同。在之前的工作中[2] [23]，宽松同步时钟已经被用来进行并发控制。我们已经展示了 TrueTime 可以从 Paxos 状态机集合中推导出全球时间。</p><h1 id="7、未来的工作（Future-Work）"><a href="#7、未来的工作（Future-Work）" class="headerlink" title="7、未来的工作（Future Work）"></a>7、未来的工作（Future Work）</h1><p>在过去一年的大部分时间里，我们都是 F1 团队一起工作，把谷歌的广告后台从 MySQL 迁移到 Spanner。我们正在积极改进它的监控和支撑工具，同时在优化性能。此外，我们已经开展了大量工作来改进备份恢复系统的功能和性能。我们当前正在实现 Spanner 模式语言，自动维护二级索引和自动基于负载的分区。在未来，我们会调研更多的特性。以最优化的方式并行执行读操作，是我们追求的有价值的策略，但是，初级阶段的实验表明，实现这个目标比较艰难。此外，我们计划最终可以支持直接变更 Paxos 配置[22]34]。</p><p>我们希望许多应用都可以跨越数据中心进行复制，并且这些数据中心彼此靠近。 TrueTime ε 可能会明显影响性能。把 ε 值降低到 1ms 以内，并不存在不可克服的障碍。 Time-master-query 间隔可以继续减少，Time-master-query 延迟应该随着网络的改进而减少， 或者通过采用分时技术来避免延迟。</p><p>最后，还有许多有待改进的方面。尽管 Spanner 在节点数量上是可扩展的，但是与节点相关的数据结构在复杂的 SQL 查询上的性能相对较差，因为，它们是被设计成服务于简单的键值访问的。来自数据库文献的算法和数据结构，可以极大改进单个节点的性能。另外，根据客户端负载的变化，在数据中心之间自动转移数据，已经成为我们的一个目标，但是，为了有效实现这个目标，我们必须具备在数据中心之间自动、协调地转移客户端应用进程的能力。转移进程会带来更加困难的问题——如何在数据中心之间管理和分配资源。</p><h1 id="8、总结（Conclusions）"><a href="#8、总结（Conclusions）" class="headerlink" title="8、总结（Conclusions）"></a>8、总结（Conclusions）</h1><p>总的来说，Spanner 对来自两个研究群体的概念进行了结合和扩充:一个是数据库研究群体，包括熟悉易用的半关系接口，事务和基于 SQL 的查询语言;另一个是系统研究群体，包括可扩展性，自动分区，容错，一致性复制，外部一致性和大范围分布。自从 Spanner 概念成形，我们花费了 5 年以上的时间来完成当前版本的设计和实现。花费这么长的时间，一部分原因在于我们慢慢意识到，Spanner 不应该仅仅解决全球复制的命名空间问题，而且也应该关注 Bigtable 中所丢失的数据库特性。</p><p>我们的设计中一个亮点特性就是 TrueTime。我们已经表明，在时间 API 中明确给出时钟不确定性，可以以更加强壮的时间语义来构建分布式系统。此外，因为底层的系统在时钟不确定性上采用更加严格的边界，实现更强壮的时间语义的代价就会减少。作为一个研究群体，我们在设计分布式算法时，不再依赖于弱同步的时钟和较弱的时间 API。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spanner </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Frangipani</title>
      <link href="/2023/05071317.html"/>
      <url>/2023/05071317.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>理想的分布式文件系统应该为所有用户提供对同一组文件的一致的统一的访问，并且可以任意伸缩，以便为不断增长的用户社区提供更多的存储空间和更高的性能。尽管组件出现故障，但它仍然具有很高的可用性。这将需要最少的人工管理，并且随着添加更多组件，管理不会变得更加复杂。</p><p>Frangipani是一种新的文件系统，它近似于这种理想状态，而且由于它的两层结构，构建起来相对容易。底层是Petal(在之前的文章描述过)，这是一种分布式存储服务，提供可扩展、高可用性、自动管理的虚拟磁盘。在上层，多台机器在共享的Petal虚拟磁盘上运行相同的Frangipani文件系统代码，使用分布式锁服务来确保一致性。</p><p>Frangipani是在拥有统一管理下的集群中运行的，可以安全的通信。因此，机器之间相互信任，共享虚拟磁盘方法是可行的。当然，Frangipani文件系统可以使用普通网络文件访问协议剔除不受信任的机器。</p><p>我们在运行数码UNIX 4.0的<code>AlphaS</code>集合上实施了Frangipani。初始测量表明，Frangipani随着服务器的增加，其依然具有优异的单服务器性能和可扩展性。</p><h1 id="1、介绍（Introduction）"><a href="#1、介绍（Introduction）" class="headerlink" title="1、介绍（Introduction）"></a>1、介绍（Introduction）</h1><p>使用当下技术构建的可应用于大型、持续增长的计算机集群的文件管理系统，处理现有业务来说是一项艰巨的任务。其困局是，为了保存更多文件并为更多用户提供服务，必须添加更多磁盘，连接到更多机器上。 这些组件中的每一个都需要人工维护。 文件组通常手动分配到特定磁盘，然后在组件装满、出现故障或成为性能热点时手动移动或复制。 使用RAID技术将多个磁盘驱动器连接成一个单元只是部分解决方案；当系统变得足够大，需要多个raid和多个服务器时，仍然会出现管理问题。</p><blockquote><p>RAID技术是一种将多个磁盘驱动器组合在一起以提高数据存储性能和/或数据冗余的技术。RAID代表“冗余阵列独立磁盘”（Redundant Array of Independent Disks），它通过将数据分散存储在多个磁盘上来提高读写速度，并且可以使用冗余备份来保护数据免受硬件故障的影响。</p></blockquote><p>Frangipani是一种新的可扩展的分布式文件系统，它将多台机器上的磁盘集合管理为一个共享存储池。假定这些机器处于共同的管理之下，并且能够安全地通信。在构建分布式文件系统方面，已经有很多早期的尝试，它们在吞吐量和容量上都有很好的扩展性[1,11,19,20,21,22,26,31,33,34]。Frangipani的一个显著特征是它有一个非常简单的内部结构—一组相互协作的机器使用一个公共存储并用锁同步对该存储的访问。这个简单的结构使我们能够用很少的机器处理系统恢复、重新配置和负载平衡。Frangipani的另一个关键在于，它结合了一组特性，使其比我们所知道的现有文件系统更容易使用和管理Frangipani。</p><ol><li>所有用户都会给出相同一组文件的一致视图。</li><li>可以轻松地将更多服务器添加到现有Frangipani集群中，以增加其存储容量和吞吐量，而无需更改现有服务器的配置或中断其操作。这些服务器可以被看作是“砖块”，可以增量堆叠，以根据需要构建尽可能大的文件系统。</li><li>系统管理员可以添加新用户，而无需考虑哪些计算机将管理其数据或哪些磁盘将存储数据。</li><li>系统管理员可以在不关闭整个文件系统的情况下对整个文件系统进行完整且一致的备份。备份可以在线保存，允许用户快速访问意外删除的文件。</li><li>文件系统能够容忍机器、网络和磁盘故障，并在无需操作员干预的情况下进行恢复。</li></ol><p>Frangipani位于Petal[24]之上，Petal是一个易于管理的分布式存储系统，它为客户端提供虚拟磁盘。与物理磁盘一样，Petal虚拟磁盘提供了可以在块中读写的存储空间。与物理磁盘不同，虚拟磁盘提供不连续的2^64字节地址空间，物理存储空间按需分配。Petal可以选择性的复制数据以实现高可用性。Petal还提供了高效的快照[7,10]来支持一致的备份。Frangipani从底层存储系统继承了许多可伸缩性、容错性和易于管理的特性，但是需要仔细设计才能将这些属性扩展到文件系统级别。下一节将详细介绍Frangipani的结构及其与Petal的关系。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051750336.png"></p><p>图1：Frangipani分层。几个可互换的Frangipani服务器提供对一个Petal虚拟磁盘上的一组文件的访问</p><p>图1演示了Frangipani系统中的分层。多个可互换的Frangipani服务器通过在共享的Petal虚拟磁盘上运行来提供对相同文件的访问，用锁来协调它们的操作，以确保一致性。文件系统层可以通过添加Frangipani服务器来缩放。它通过自动从服务器故障中恢复并继续使用幸存的服务器来实现容错。它在单一的网络文件服务器上提供了改进的负载平衡，通过分流文件系统负载并将其转移到正在使用这些文件的机器上。Petal和锁服务也被用于在可伸缩性、容错和负载平衡方面。</p><p>Frangipani服务器，Petal服务器和锁服务相互信任。Frangipani设计之初用于在单个管理域内的工作站集群中运行良好，但Frangipani文件系统可以导出到其他域。因此，Frangipani可以看作是一个集群文件系统。</p><p>我们已经在DIGITAL Unix 4.0下实现了Frangipani。由于Frangipani在现有Petal服务之上的清晰分层，我们能够在短短几个月内实现一个工作系统。</p><p>Frangipani针对具有程序开发和工程工作负载的环境。我们的测试表明，在此类工作负载上，Frangipani具有出色的性能，并缩小网络限制。</p><h1 id="2、系统结构（System-Structure）"><a href="#2、系统结构（System-Structure）" class="headerlink" title="2、系统结构（System Structure）"></a>2、系统结构（System Structure）</h1><p>图2描述了系统的一个经典情况。上面显示的机器运行用户程序和Frangipani文件服务器模块；它们可以是无磁盘的。底部显示的运行Petal和分布式锁服务。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051753573.png"></p><p>图2：Frangipani结构。在一个典型的Frangipani配置中，一些机器运行用户程序和Frangipani文件服务器模块；另一些运行Petal和分布式锁服务。在其他配置中，相同的机器可能同时扮演这两个角色。</p><p>Frangipani的组件不必完全按照图2所示的方式分配给机器。Frangipani和Petal服务器不需要在单独的机器上；每台Petal机器也可以运行Frangipani，特别是在Petal机器没有重载的情况下。分布式锁服务独立于系统的其他部分;我们展示了在每台Petal服务器上运行一个lock服务器，但它们也可以在Frangipani主机或任何其他可用的机器上运行。</p><h2 id="2-1、组件（Components）"><a href="#2-1、组件（Components）" class="headerlink" title="2.1、组件（Components）"></a>2.1、组件（Components）</h2><p>如图2所示，用户程序通过标准操作系统调用接口访问Frangipani。在不同机器上运行的程序都看到相同的文件，它们的视图是一致的；也就是说，对一台计算机上的文件或目录所做的更改在所有其他计算机上都立即可见。程序基本上得到了与本地Unix文件系统相同的语义保证：对文件内容的更改通过本地内核缓冲池暂存，在下一次适用的fsync或sync系统调用之前不能保证到达非易失性存储，但是元数据的更改会被记录下来，并且可以选择在系统调用返回时保证为非易失性。与本地文件系统语义稍有不同的是，Frangipani仅粗略地维护一个文件的最后访问时间，以避免每次读取数据时都进行元数据写操作</p><p>每台机器上的Frangipani文件服务器模块在操作系统内核内运行。它将自己注册到内核的文件系统中，作为可用的文件系统实现之一。文件服务器模块使用内核的缓冲池来缓存最近使用的文件中的数据。它使用本地Petal设备驱动程序读取和写入Petal虚拟磁盘。所有文件服务器在共享Petal磁盘上读取和写入相同的文件系统数据结构，但每个服务器在Petal磁盘的不同部分保留其自己的挂起更改重做日志。日志保存在Petal中，以便在Frangipani服务器崩溃时，另一台服务器可以访问日志并运行恢复。Frangipani服务器之间不需要直接通信；它们只与Petal和锁服务通信。这使服务器的添加、删除和恢复变得简单。</p><p>Petal设备驱动程序隐藏了Petal的分布式特性，使得Petal对于操作系统的更高层来说就像一个普通的本地磁盘。驱动程序负责于对应的Petal服务器通信，并在发生故障时切换到另一个服务器。任何Digital Unix文件系统都可以在Petal上运行，但只有Frangipani提供了从多台机器对相同文件的一致访问。</p><p>Petal服务器协同运行，为Frangipani提供大型的、可伸缩的、容错的虚拟磁盘，这些虚拟磁盘是在连接到每个服务器的普通物理磁盘之上实现的。Petal可以容忍一个或多个磁盘或服务器故障，只要Petal服务器的大部分保持正常并保持通信，每个数据块至少有一个副本保持物理上可访问。Petal的更多细节可在另一份文件[24]。</p><p>锁服务是一种通用服务，它向网络上的客户端提供<code>多读/单写</code>锁。它的实现是分布式的，以容错和可扩展的性能。Frangipani使用锁服务来协调对虚拟磁盘的访问，并在多个服务器上保持缓冲区缓存一致。</p><h2 id="2-2、安全和客户端-服务器配置（Security-and-the-Client-Server-Configuration）"><a href="#2-2、安全和客户端-服务器配置（Security-and-the-Client-Server-Configuration）" class="headerlink" title="2.2、安全和客户端/服务器配置（Security and the Client/Server Configuration）"></a>2.2、安全和客户端/服务器配置（Security and the Client/Server Configuration）</h2><p>在图2所示的配置中，运行用户程序的每台计算机也运行一个Frangipani文件服务器模块。这种配置有可能实现良好的负载平衡和扩展，但会带来安全问题。任何Frangipani机器都可以读取或写入共享Petal虚拟磁盘的任何块，因此Frangipani必须仅在具有可信操作系统的机器上运行；Frangipani机器向Petal验证自己是否代表特定用户是不够的，就像在NFS等远程文件访问协议中所做的那样。完全安全性还要求Petal服务器和锁服务器在受信任的操作系统上运行，并要求所有三种类型的组件彼此进行身份验证。最后，为了确保文件数据保密，应防止用户在连接Petal和Frangipani机器的网络上窃听。</p><p>通过将机器放置在一个环境中，防止用户在机器上启动修改过的操作系统内核，并将其与用户进程无权访问的专用网络互连，可以完全解决这些问题。这并不一定意味着必须将机器锁定在具有专用物理网络的房间中；可以使用已知的用于安全引导、身份验证和加密链接的加密技术[13,37]。此外，在许多应用中，部分解决方案是可以接受的；典型的现有NFS安装对于在工作站上引导修改过的内核的用户的网络窃听甚至数据修改都不安全。到目前为止，我们还没有实施任何这些安全措施，但是我们可以通过让Petal服务器只接受来自属于受信任的Frangipani服务器机器的网络地址列表的请求，大致达到NFS安全级别。</p><blockquote><p>NFS代表“网络文件系统”（Network File System），它是一种远程文件访问协议，允许计算机通过网络透明地访问和共享文件。</p></blockquote><p>Frangipani文件系统可以使用图3所示的配置导出到管理域之外的不受信任的机器。这里我们区分Frangipani客户端和服务器。只有受信任的Frangipani服务器与Petal和锁服务通信。它们可以位于受限环境中，并通过如上所述的专用网络互连。远程、不受信任的客户端通过单独的网络与Frangipani服务器通信，无法直接访问Petal服务器。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305052232083.png"></p><p>图3:客户机/服务器配置 Frangipani服务器不仅可以为本地计算机提供文件访问，还可以为通过标准网络文件系统协议连接的远程客户端计算机提供文件访问。</p><p>客户端可以使用主机操作系统支持的任何文件访问协议（如DCE/DFS、NFS或SMB）与Frangipani服务器通信，因为Frangipani看起来就像运行Frangipani服务器的机器上的本地文件系统。当然，一个支持一致性访问的协议(例如 DCE/DFS)是最好的，这样Frangipani跨多个服务器的一致性就不会在下一级丢失。 理想情况下，该协议还应该支持从一个Frangipani服务器到另一个Frangipani服务器的故障转移。刚才提到的协议不直接支持故障转移，但是让新机器接管故障机器的IP地址的技术已经在其他系统中使用过[3,25]，也可以在这里应用。</p><p>除了安全性之外，使用此客户机/服务器配置还有第二个原因。因为Frangipani在内核中运行，所以它不能在不同的操作系统甚至不同版本的Unix之间快速移植。客户端可以通过远程访问受支持的系统，从不受支持的系统使用Frangipani。</p><h2 id="2-3、讨论（Discussion）"><a href="#2-3、讨论（Discussion）" class="headerlink" title="2.3、讨论（Discussion）"></a>2.3、讨论（Discussion）</h2><p>将文件系统分为两层构建的想法——较低级别提供存储库，较高级别提供名称、目录和文件——并不是Frangipani所独有的。我们知道的最早的例子是通用文件服务器[4]。然而，Petal提供的存储设施与早期的系统有很大不同，这也导致了不同的更高级别结构。第10节包含与以前系统的详细比较。</p><p>Frangipani的设计目的是与Petal提供的存储空间配合使用。我们还没有充分考虑开发NASD等替代存储抽象所需的设计更改[13]。</p><p>Petal提供了高可用性存储，可以随着资源的添加而扩展吞吐量和容量。然而，Petal没有提供在多个客户端之间协调或共享存储的功能。此外，大多数应用程序不能直接使用Petal的客户端接口，因为它是磁盘类型而不是文件类型。Frangipani提供了一个文件系统层，使Petal在保留和扩展其良好属性的同时对应用程序有用。</p><p>Frangipani的优势在于它允许透明的添加服务器、删除和故障恢复。通过将预写式日志和锁与一个统一的可访问的、高可用性的存储结合起来，它能够轻松地做到这一点。</p><p>Frangipani的另一个优势是它能够在系统运行时创建一致的备份。第8节讨论了Frangipani的备份机制。</p><p>Frangipani的设计有三个方面可能会有问题。将Frangipani与复制的Petal虚拟磁盘一起使用，意味着日志记录有时会发生两次，一次是到Frangipani日志，另一次是在Petal本身。其次，Frangipani在放置数据时不使用磁盘位置信息，事实上它不能，因为Petal虚拟了磁盘。最后，Frangipani锁定整个文件和目录，而不是单个块。我们没有足够的使用经验来评估我们设计的这些方面，但尽管如此，Frangipani在我们测试的工程工作负载上的测量性能还是不错的。</p><h1 id="3、磁盘布局（Disk-Layout）"><a href="#3、磁盘布局（Disk-Layout）" class="headerlink" title="3、磁盘布局（Disk Layout）"></a>3、磁盘布局（Disk Layout）</h1><p>Frangipani使用Petal的大而稀疏的磁盘地址空间来简化其数据结构。这个总体思路让人想起了过去在大内存地址空间的计算机编程工作。有这么多的地址空间可用，可以慷慨地将其分割开来。</p><p>Petal虚拟磁盘有2^64字节的地址空间。Petal仅在写入虚拟地址时才将物理磁盘空间提交给虚拟地址。Petal还提供了一个decommit原语，可以释放支持一系列虚拟磁盘地址的物理空间。</p><p>为了保持内部数据结构的小型化，Petal以相当大的块（目前为64 KB）提交和释放空间。也就是说，每个64 KB的地址范围【a* 2^16，(a+1)*2^16】（其中一些数据已写入且未解除提交）都分配有64 KB的物理磁盘空间。因此，Petal客户机不能使其数据结构过于稀疏，否则过多的物理磁盘空间将因碎片化而被浪费。图4显示了Frangipani是如何划分其虚拟磁盘空间的。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305052233797.png"></p><p>图4:磁盘布局。 Frangipani利用Petal巨大而不连续的磁盘地址空间来简化其数据结构。每个服务器都有自己的日志和自己的分配位图空间块。</p><p>第一个区域存储共享的配置参数和管理信息（Housekeeping information）。我们允许这个区域有一兆字节（TB）的虚拟空间，但实际上目前只使用了其中的几千字节。</p><blockquote><p>Housekeeping information是指文件系统中用于管理文件和目录的元数据，例如文件大小、创建时间、修改时间、访问权限等。</p></blockquote><p>第二个区域存储日志。每台Frangipani服务器获得 一部分空间来存放它的私人日志。我们已经为这个区域保留了 1TB（2^40字节）给这个区域，划分为256个日志。这 这个选择限制了我们目前的实施，使其只能容纳256个服务器，但这很容易进行调整。</p><p>第三个区域用于分配位图，以描述剩余区域中的哪些块是空闲的。每个Frangipani服务器都会锁定位图空间的一部分以供其专用。当服务器的位图空间填满时，它会查找并锁定另一个未使用的部分。位图区域的长度为3 TB。</p><p>第四个区域存放节点。每个文件都需要一个<code>inode</code>来保存其元数据，如时间戳和指向其数据位置的指针。符号链接将其数据直接存储在inode节点中。我们将节点的长度定为512字节，也就是一个磁盘块的大小，从而避免了服务器之间不必要的争夺（“虚假共享”），如果两个服务器需要访问同一块中的不同节点，就会出现这种情况。我们分配了1TB的节点空间，允许2^31个节点的空间。分配位图和节点之间的映射是固定的，所以每个Frangipani服务器只从与分配位图的部分相对应的节点空间中为新文件分配节点。但任何Frangipani服务器都可以读取、写入或释放任何现有文件的节点。</p><p>第五个区域存放小数据块，每个4 KB（2^12字节）大小。一个文件的前64 KB（16个块）被存储在小块中。如果一个文件增长到超过64KB，剩下的就存储在一个大块中。我们为小块分配2^47个字节，因此最多允许有2^35个小块，是最大节点数的16倍。</p><p>Petal地址空间的其余部分存放大数据块。每个大数据块都保留了1TB的地址空间。</p><p>我们使用4KB块的磁盘布局策略可能会比更谨慎地支配磁盘空间的策略遭受更多的碎片。另外，为每个节点分配512字节的空间也有些浪费。我们可以通过将小文件存储在inode本身来缓解这些问题[29]。我们的设计所获得的是简单性，我们相信这对于额外的物理磁盘空间的成本来说是一个合理的权衡。</p><p>目前的方案将Frangipani限制在略低于2^24（1600万）大文件，其中大文件是指大于64KB的任何文件。另外，任何文件都不能大于16个小块加一个大块（64KB加1TB）。如果这些限制被证明太小，我们可以很容易地减少大块的大小，从而使更多的数量可用，并允许大文件跨越一个以上的大块，从而提高最大文件大小。如果2^64字节的地址空间限制被证明是不够的，一个Frangipani服务器可以在多个虚拟磁盘上支持多个Frangipani文件系统。</p><p>我们根据早期文件系统的使用经验，选择了这些文件系统参数。我们相信我们的选择将为我们提供良好的服务，但只有时间和使用才能证实这一点。Frangipani的设计足够灵活，我们可以以文件系统的备份和恢复为代价来试验不同的布局。</p><h1 id="4、日志和恢复（Logging-and-Recovery）"><a href="#4、日志和恢复（Logging-and-Recovery）" class="headerlink" title="4、日志和恢复（Logging and Recovery）"></a>4、日志和恢复（Logging and Recovery）</h1><p>Frangipani使用元数据的<strong>预写重做</strong>日志记录来简化故障恢复并提高性能；用户数据不被记录。每个Frangipani服务器在Petal中都有自己的私有日志。当Frangipani文件服务器需要进行元数据更新时，它首先创建一个描述更新的记录，并将其附加到其内存中的日志中。这些日志记录会按照它们所描述的更新被请求的顺序定期写入Petal。(我们可以选择让日志记录同步写入。这提供了更好的故障语义，但增加了元数据操作的延迟。）。只有在日志记录被写入Petal之后，服务器才会修改其固定位置中的实际元数据。Unix update demon会定期（大约每30秒）更新固定位置。</p><p>日志的大小是有限制的，在目前的实现中是128KB。考虑到Petal的分配策略，一个日志将由两个不同的物理磁盘上的两个64KB的片段组成。为每个日志分配的空间被作为一个循环缓冲区管理。当日志填满时，Frangipani会回收最旧的25%的日志空间，用于新的日志条目。通常情况下，回收区域的所有条目都是指已经写入Petal的元数据块（在之前的同步操作中），在这种情况下，不需要进行额外的Petal写入。如果有尚未写入的元数据块，这项工作将在日志被回收之前完成。考虑到日志的大小和Frangipani日志记录的典型大小（80-128字节），如果在两个周期性同步操作之间有大约1000-1600个修改元数据的操作，日志就会被填满。</p><p>如果一个Frangipani服务器崩溃了，系统最终会检测到失败，并在该服务器的日志上运行恢复。故障可能是由故障服务器的客户端检测到的，或者当锁服务要求故障服务器返回它所持有的锁而没有得到答复时。恢复守护进程被隐式的赋予失败服务器的日志和锁的所有权。该守护进程找到日志的开始和结束，然后按顺序检查每条记录，执行每一个尚未完成的描述性更新。在日志处理完成后，恢复进程释放其所有的锁并释放日志。然后，其他Frangipani服务器可以不受故障服务器的阻碍，故障服务器本身也可以选择重新启动（有一个空日志）。只要底层的Petal卷保持可用，系统就可以容忍无限数量的Frangipani服务器故障。</p><p>为了确保恢复能够找到日志的结尾（即使磁盘控制器不按顺序写入数据），我们在日志的每个512字节块上附加一个单调增加的日志序列号。通过找到一个低于前一个的序列号，可以可靠地检测到日志的结束。</p><p>Frangipani确保在有多个日志的情况下，日志和恢复工作正常。这需要注意几个细节。</p><p>首先，Frangipani的锁协议，在下一节中描述，确保不同服务器对相同数据的更新请求是序列化的。覆盖脏数据的写锁只有在脏数据被写入 Petal 之后才能更改所有者，可以是原始锁持有者写入，也可以是代表它运行的恢复进程写入。这意味着对于任何给定的块，最多只能有一个日志保存未完成的更新。</p><p>其次，Frangipani确保恢复只适用于自服务器获得覆盖它们的锁后所记录的更新，并且它仍然持有这些锁。这是为了确保锁协议所规定的序列化不被违反而需要的。我们通过强制执行一个更强的条件来实现这一保证：恢复绝不重复描述已经完成的更新的日志记录。为了实现后者，我们在每个512字节的元数据块上保留一个版本号。元数据如目录，它跨越了多个块，有多个版本号。对于日志记录所更新的每一个块，该记录包含了对更改的描述和新的版本号。在恢复过程中，只有当块的版本号小于记录的版本号时，才会应用对块的修改。</p><p>因为用户数据的更新没有被记录下来，只有元数据块有预留空间给版本号。这就产生了一个强制性的问题。如果一个块被用于元数据，被释放，然后又被重新用于用户数据，那么在版本号被错误的用户数据覆盖后，引用该块的旧日志记录可能不会被正确跳过。Frangipani通过重用释放的元数据块来保存新的元数据，从而避免了这个问题。</p><p>最后，Frangipani确保在任何时候只有一个恢复进程试图重放特定服务器的日志区域。锁服务通过授予活动的恢复进程对日志的独占锁来保证这一点。</p><p>Frangipani的记录和恢复方案假定，磁盘写入失败会使单个扇区的内容处于旧状态或新状态，但绝不会同时处于这两种状态。如果一个扇区被损坏，以至于读取它时出现CRC错误，Petal的内置复制通常可以恢复它。如果一个扇区的两个副本都丢失了，或者Frangipani的数据结构被软件错误破坏了，就需要一个元数据一致性检查和修复工具（像Unix fsck）。到目前为止，我们还没有实现这样的工具。</p><p>Frangipani的日志不是为了向用户提供高级别的语义保证。它的目的是提高元数据更新的性能，并通过避免每次服务器故障时运行fsck等程序来加速故障恢复。只有元数据被记录下来，而不是用户数据，所以用户不能保证在故障后文件系统的状态在他看来是一致的。我们并不声称这些语义是理想的，但它们与标准的本地Unix文件系统所提供的相同。在本地 Unix 文件系统和 Frangipani 中，用户可以通过在适当的检查点调用 fsync 来获得更好的一致性语义。</p><p>Frangipani的日志记录是应用了最早为数据库开发的技术[2]，后来被用于其他几个基于日志的文件系统[9, 11, 16, 18]。Frangipani不是一个日志结构的文件系统[32]；它不把所有的数据保存在日志中，而是维护传统的磁盘数据结构，用一个小的日志作为辅助，以提供更好的性能和故障原子性。与上述其他基于日志的文件系统不同，但与日志结构的文件系统Zebra[17]和xFS[1]一样，Frangipani保留多个日志。</p><h1 id="5、同步和缓存一致性（Synchronization-and-Cache-Coherence）"><a href="#5、同步和缓存一致性（Synchronization-and-Cache-Coherence）" class="headerlink" title="5、同步和缓存一致性（Synchronization and Cache Coherence）"></a>5、同步和缓存一致性（Synchronization and Cache Coherence）</h1><p>由于多个Frangipani服务器都在修改共享的磁盘数据结构，因此需要谨慎地进行同步，以便为每个服务器提供一致的数据视图，同时允许有足够的并发性，以便在负载增加或服务器增加时扩展性能。Frangipani使用多读/单写锁来实现必要的同步。当锁服务检测到冲突的锁请求时，会要求锁的当前持有者释放或降级以消除冲突。</p><p>一个读锁允许服务器从磁盘上读取相关数据并进行缓存。如果一个服务器被要求释放它的读锁，它必须在遵守之前使其缓存条目失效。写锁允许服务器读取或写入相关的数据并缓存它。服务器缓存的磁盘块副本只有在它持有相关的写锁时才能与磁盘上的版本不同。因此，如果一个服务器 被要求释放其写锁或将其降级为读锁，它必须在遵守之前将脏数据写到磁盘。如果是降级锁，它可以保留其缓存条目，但如果释放锁，则必须使其失效。</p><p>当写锁被释放或降级时，我们可以选择绕过磁盘，将脏数据直接转发给请求者，而不是将脏数据刷到磁盘。出于简单的原因，我们没有这样做。首先，在我们的设计中，Frangipani服务器不需要相互通信。它们只与Petal和锁服务器进行通信。其次，我们的设计确保当一个服务器崩溃时，我们只需要处理该服务器使用的日志。如果直接转发脏缓冲区，并且具有脏缓冲区的目标服务器崩溃，那么指向脏缓冲区的日志条目可能分布在多台机器上。这将给恢复和在日志空间填满时回收日志空间带来问题。</p><p>我们将磁盘上的结构分为逻辑段，并为每个段加锁。为了避免错误的共享，我们确保一个磁盘扇区不包含一个以上可以共享的数据结构。我们将磁盘上的数据结构划分为可上锁的段，旨在保持锁的数量合理地少，但又能避免普通情况下的锁争夺，从而使锁服务不成为系统的瓶颈。</p><p>因为日志是私有的，所以每个日志都是一个单独的可锁定段。位图空间也被划分为独占锁定的段，这样当分配新文件时就不会有争用。当前未分配给文件的数据块或索引节点受到分配位图段上的锁的保护，该段上的锁持有标记为空闲的位。最后，每个文件、目录或符号链接都是一个段;也就是说，一个锁同时保护inode和它所指向的任何文件数据。这种每个文件的锁粒度适合于很少并发写共享的工程工作负载。然而，其他工作负载可能需要更细粒度的锁定。</p><p>有些操作需要原子化的更新由不同锁覆盖的几个磁盘数据结构。我们通过对这些锁进行全局排序并在两个阶段获得这些锁来避免死锁。首先，一个服务器确定它需要什么锁。这可能涉及到获取和释放一些锁，例如在一个目录中查找名字。其次，它按照节点地址对锁进行排序，并依次获取每个锁。然后，服务器检查它在第一阶段检查的任何对象是否在其锁被释放时被修改。如果是的话，它就释放锁，并循环重复第一阶段。否则，它就执行操作，弄脏缓存中的一些块，并写一条日志记录。它保留每个锁，直到它覆盖的脏块被写回磁盘。</p><p>我们刚刚描述的缓存一致性协议与Echo[26]、Andrew文件系统[19]、DCE/DFS[21]和Sprite[30]中用于客户端文件缓存的协议相似。避免死锁的技术与Echo的类似。和Frangipani一样，Oracle数据库（Oracle Parallel Server），也是将脏数据写入磁盘，而不是在写入锁的后续所有者之间使用缓存到缓存的传输。</p><h1 id="6、锁服务（The-Lock-Service）"><a href="#6、锁服务（The-Lock-Service）" class="headerlink" title="6、锁服务（The Lock Service）"></a>6、锁服务（The Lock Service）</h1><p>Frangipani只需要其lock server的一小部分通用功能，而且我们不希望该服务在正常运行中成为性能瓶颈，因此许多不同的实现可以满足其要求。在Frangipani项目的过程中，我们已经使用了三种不同的lock server的实现，并且其他现有的lock server可以提供必要的功能，也许只需在上面加一层薄薄的代码。</p><p>lock server提供多读/单写锁。锁是粘性的；也就是说，一个客户端通常会保留一个锁，直到其他客户端需要一个冲突的锁。(回顾一下，锁服务的客户端是Frangipani服务器）。</p><p>锁定服务使用租约来处理客户端故障[15, 26]。当一个客户端第一次通讯lock server时，它获得了一个租约。客户端获得的所有锁都与租约相关。每个租约都有一个过期时间，目前设置为创建或最后一次更新后的30秒。客户端 必须在到期时间前更新其租约，否则服务会认为它已经失败。</p><p>网络故障可以阻止Frangipani服务器更新其租约，即使它没有崩溃。当这种情况发生时，服务器会丢弃它所有的锁和缓存中的数据。如果缓存中的任何东西是脏的，Frangipani会打开一个内部标志，使所有来自用户程序的后续请求返回一个错误。文件系统必须被卸载以清除这个错误状况。我们选择了这种激进的报错方式，使它难以被无意中忽略。</p><p>我们最初的lock server实现是一个单一的、集中的服务器，它将所有的锁状态保存在易失性内存中。这样的服务器对Frangipani来说是足够的，因为Frangipani servers和他们的日志持有足够的状态信息，即使锁服务在崩溃中失去了所有的状态，也可以恢复。然而，锁服务的失败将导致一个巨大的性能故障。</p><p>我们的第二个实施方案将锁的状态存储在Petal虚拟磁盘上，在返回客户端之前，将每个锁的状态变化写到Petal上。如果主lock server崩溃了，备份服务器将从Petal中读取当前状态并接管，以提供持续服务。有了这个方案，故障恢复更加透明，但普通情况下的性能比集中式的内存方法要差。在进入下一个实施方案之前，我们没有完全实现对所有故障模式的自动恢复。</p><p>我们的第三个也是最后一个锁服务实现是完全分布式的，用于容错和可扩展的性能。它由一组相互合作的锁服务器和一个连接到每个Frangipani服务器的客户端模块(clerk module)组成。</p><p>锁服务将锁组织成由ASCII字符串命名的表。表内的各个锁是由64位整数命名的。回顾一下，一个Frangipani文件系统只使用一个Petal虚拟磁盘，尽管多个Frangipani文件系统可以安装在同一台机器上。每个文件系统都有一个与之相关的表。当一个Frangipani文件系统被挂载时，Frangipani服务器调用clerk，打开与该文件系统相关的锁表。锁服务器在成功打开时给clerk一个租赁标识符，这个标识符被用于他们之间所有的次序通信。当文件系统被卸载时，clerk关闭锁表。</p><p>客户端和锁服务器通过异步消息而不是RPC进行通信，以尽量减少内存的使用量，并实现良好的灵活性和性能。对锁进行操作的基本消息类型是<strong>请求、授予、撤销和释放</strong>。请求和释放消息类型是由客户端发送给锁服务器的，而授予和撤销消息类型是由锁服务器发送给客户端的。锁的升级和降级操作也是使用这四种消息类型处理的。</p><p>锁服务使用一个容错的分布式故障检测机制来检测锁服务器的崩溃。这与Petal使用的机制相同。它是基于各组服务器之间及时交换心跳信息。它使用多数共识来容忍网络分区。</p><p>锁在服务器和每个clerk那里都要消耗内存。在我们目前的实现中，服务器为每个锁分配了112个字节的块，此外还有104个字节给每个有未决或已批准的锁请求的clerk。每个客户端每个锁占用232字节。为了避免因为粘性锁而消耗过多的内存，clerk 会丢弃那些长时间（1小时）没有使用的锁。</p><p>使用Lamport的Paxos算法[23]，在所有锁服务器上持续复制少量不经常变化的全局状态信息。锁服务重复使用最初为Petal编写的Paxos的实现。全局状态信息包括一个锁服务器的列表，每个服务器负责服务的锁的列表，以及已经打开但尚未关闭每个锁表的clerk的列表。这些信息被用来达成共识，在锁服务器之间重新分配锁，在锁服务器崩溃后从clerk那里恢复锁状态，并促进Frangipani服务器的恢复。为了提高效率，锁被划分为大约一百个不同的锁组，并按组分配给服务器，而不是单独分配。</p><p>锁偶尔会在不同的锁服务器之间重新分配，以弥补一个崩溃的锁服务器或利用一个新恢复的锁服务器。当一个锁服务器被永久地添加到系统中或从系统中移除时，也会发生类似的重新分配。在这种情况下，锁总是被重新分配，以便每个服务器提供的锁的数量是平衡的，重新分配的数量是最小的，并且每个锁正好由一个锁服务器提供。重新分配分两个阶段进行。在第一阶段，失去锁的锁服务器从其内部状态中丢弃这些锁。在第二阶段，获得锁的锁服务器与打开相关锁表的clerk联系。这些服务器从clerk那里恢复其新锁的状态，而clerk则被告知其锁的新服务器。</p><p>当Frangipani服务器崩溃时，在执行适当的恢复操作之前，无法释放其拥有的锁。具体来说，必须处理崩溃的Frangipani服务器的日志，并且必须将任何挂起的更新写入Petal。当Frangipani服务器的租约到期时，锁服务将要求另一台Frangipani机器上的clerk执行恢复，然后重新租用属于崩溃的Frangipani服务器的所有锁。该clerk被授予一个锁，以确保以独占方式访问日志。此锁本身由租约覆盖，因此如果此恢复过程失败，锁服务将启动另一个恢复过程。</p><p>一般来说，Frangipani系统可以容忍网络分区，在可能的情况下继续运行，否则会完全关闭。具体来说，Petal可以在网络分区的情况下继续运行，只要大多数Petal服务器保持正常并处于通信状态，但如果大多数分区中没有副本，Petal虚拟磁盘的部分将无法访问。只要大多数锁服务器保持正常并处于通信状态，锁服务就会继续运行。如果一个Frangipani服务器与锁服务分开，它将无法续租。锁服务将宣布这样的Frangipani服务器死亡，并从它在Petal上的日志开始恢复。如果一个Frangipani服务器被脑裂无法访问Petal，它将无法读取或写入虚拟磁盘。在这两种情况下，服务器将不允许用户进一步访问受影响的文件系统，直到脑裂恢复和文件系统被重新挂载。</p><p>当Frangipani server的租约过期时，有一个小的危险。如果服务器没有真正崩溃，而只是由于网络问题与锁服务失去联系，它可能在租约过期后仍然试图访问Petal。Frangipani服务器会检查它的租约是否仍然有效（并且在一定的时间内仍然有效），在失效之前依然试图对Petal进行写入。然而，当写请求到达时，Petal不做任何检查。因此，如果在Frangipani的租约检查和随后的写请求到达Petal之间有足够的时间延迟，我们可能会有一个问题：租约可能已经过期，锁已经给了另一个服务器。我们使用了足够大的误差范围（15秒），在正常情况下，这个问题不会发生，但我们不能绝对排除它。</p><p>在未来，我们希望能消除这种危险；一种可行的方法是如下。我们在每个写给Petal的请求上添加一个到期时间戳。时间戳设置为生成写请求时的当前租约到期时间，减去锁延时删除的时间。然后我们让Petal忽略任何时间戳小于当前时间的写请求。只要Petal和Frangipani服务器上的时钟同步在差值范围内，这种方法就能可靠地拒绝租约过期的写入。</p><p>另一种不需要同步时钟的方法是将锁服务器与Petal集成，并将从锁服务器获得的租约标识符包含在每个对Petal的写入请求中。然后，Petal将拒绝任何具有过期租约标识符的写入请求。</p><h1 id="7、添加和删除服务器（Adding-and-Removing-Servers）"><a href="#7、添加和删除服务器（Adding-and-Removing-Servers）" class="headerlink" title="7、添加和删除服务器（Adding and Removing Servers）"></a>7、添加和删除服务器（Adding and Removing Servers）</h1><p>随着Frangipani安装的增长和变化，系统管理员偶尔会需要增加或删除服务器机器。Frangipani的设计使这项任务变得简单。</p><p>在一个正在运行的系统中添加另一个Frangipani服务器，只需要少量的管理工作。新的服务器只需要被告知使用哪个Petal虚拟磁盘和在哪里找到锁服务。新的服务器与锁服务通讯以获得租约，从租约标识符中确定使用哪一部分日志空间，然后开始运行。管理员不需要接触其他服务器；它们会自动适应新服务器的存在。</p><p>移除Frangipani服务器甚至更容易。简单地关闭服务器就可以了。服务器最好刷新所有脏数据并在停止前释放其锁，但这并不是严格的需要。如果服务器突然停止，在下次启动时，它先获取一个锁，然后在它的日志上运行恢复程序，使共享磁盘进入一个一致的状态。同样，管理员不需要接触其他服务器。</p><p>Petal服务器也可以透明地添加和删除，如Petal论文[24]中所述。锁定服务器的添加和删除方式类似。</p><h1 id="8、备份（Backup）"><a href="#8、备份（Backup）" class="headerlink" title="8、备份（Backup）"></a>8、备份（Backup）</h1><p>Petal的快照功能为我们提供了一种方便的方式，使Frangipani文件系统的完整转储一致。Petal允许客户在任何时间点创建一个虚拟磁盘的精确拷贝。快照副本与普通虚拟磁盘相同，只是无法修改。为了提高效率，该实现使用了写时拷贝技术。快照是崩溃一致的；也就是说，快照反映了一种一致的状态，如果所有Frangipani服务器崩溃，Petal虚拟磁盘可能会处于这种状态。</p><p>因此，我们可以简单地通过提取Petal快照并复制到磁带上来备份一个Frangipani文件系统。该快照将包括所有的日志，因此可以通过将其恢复到新的Petal虚拟磁盘，并在每个日志上运行恢复功能来恢复它。由于崩溃的一致性，从快照中恢复与从整个系统的电源故障中恢复的问题相同。</p><p>我们可以通过对Frangipani的一个小改动来改进这个方案，创建在文件系统层面上一致的快照，并且不需要恢复。我们可以通过让备份程序强制所有的Frangipani服务器进入一个屏障来实现这一目标，该屏障使用一个由锁服务提供的普通全局锁。Frangipani服务器以共享模式获得这个锁，以进行任何修改操作，而备份程序则以独占模式请求它。当Frangipani服务器收到释放屏障锁的请求时，它通过阻止所有修改数据的新文件系统调用进入屏障，清理其缓存中的所有脏数据，然后释放该锁。当所有的Frangipani服务器都进入屏障时，备份程序能够获得最终锁；然后，它创建一个Petal快照并释放锁。此时，服务器以共享模式重新获取锁，并恢复正常操作。</p><p>使用后一种方案，新快照可以作为Frangipani卷装载，而无需恢复。新卷可以在线访问以检索单个文件，也可以以传统备份格式转储到磁带上，而不需要Frangipani进行恢复。但是，新卷必须以只读方式装载，因为Petal快照当前是只读的。将来，我们可能会扩展Petal以支持可写快照，或者在Petal上实现一个分层来模拟它们。</p><h1 id="9、性能（Performance）"><a href="#9、性能（Performance）" class="headerlink" title="9、性能（Performance）"></a>9、性能（Performance）</h1><p>Frangipani的分层结构使其比单片系统更容易构建，但人们可能会认为分层会导致性能下降。在本节中，我们展示了尽管有分层，Frangipani的性能仍然很好。</p><p>与其他文件系统一样，通过在磁盘前面添加非易失性内存(NVRAM)缓冲区，可以直接解决Frangipani中的延迟问题。在我们的系统中放置NVRAM最有效的位置是直接在物理磁盘和Petal服务器软件之间。普通的PrestoServe卡和驱动程序足以满足此目的，无需更改Petal或Frangipani。Petal服务器上NVRAM的故障被Petal视为等同于服务器故障。</p><p>franangipani和Petal的几个方面结合起来提供了良好的吞吐量缩放。系统的两层都具有并行性:多个Frangipani服务器、多个petals服务器和多个磁盘分支都并行工作。当许多客户机使用系统时，这种并行性增加了总吞吐量。与集中式网络文件服务器相比，Frangipani处理热点的难度应该更小，因为文件系统处理是分开的，并转移到正在使用这些文件的机器上。Frangipani和Petal日志都可以在一次日志写入(组提交)中提交来自许多不同客户端的更新，从而在负载下提供改进的日志吞吐量。由于 Petal 在多个磁盘和服务器之间分离数据，因此执行大型写入的单个客户端也受益于并行性。</p><h2 id="9-1、实验装置（Experimental-Setup）"><a href="#9-1、实验装置（Experimental-Setup）" class="headerlink" title="9.1、实验装置（Experimental Setup）"></a>9.1、实验装置（Experimental Setup）</h2><p>我们计划建立一个大型存储测试平台，其中大约有100个Petal节点连接到数百个磁盘和大约50个Frangipani服务器。Petal节点将是连接到现成磁盘和网络的小型阵列控制器。Frangipani服务器将是典型的工作站。这个测试平台将允许我们研究在大配置下的franangipani的性能。由于这还没有准备好，所以我们从一个较小的配置中报告数字。</p><p>对于下面报告的测量，我们使用了7台333 MHz DEC Alpha 500 5/333机器作为Petal服务器。每台机器将数据存储在9个DIGITAL RZ29磁盘上，这些磁盘是3.5英寸快速SCSI驱动器，每个磁盘存储4.3 GB，平均寻道时间为9毫秒，持续传输速率为6 MB/s。每台机器都通过自己的155 Mbit/s点对点链路连接到一个24端口的ATM交换机。包含8 MB NVRAM的PrestoServe卡在这些服务器上使用，如下所示。7个Petal服务器可以以100mb /s的总速率提供数据。使用复制的虚拟磁盘，Petal服务器可以以43 MB/s的总速率接收数据。</p><h2 id="9-2、单机性能（Single-Machine-Performance）"><a href="#9-2、单机性能（Single-Machine-Performance）" class="headerlink" title="9.2、单机性能（Single Machine Performance）"></a>9.2、单机性能（Single Machine Performance）</h2><p>本小节比较了Frangipani的代码流程与另一个Unix vnode文件系统，即DIGITAL的高级文件系统(AdvFS)的优劣。</p><p>我们使用AdvFS进行比较，而不是更熟悉的BSD-derived的UFS文件系统[27]，因为AdvFS比UFS快得多。特别是，AdvFS可以跨多个磁盘分条文件，从而在我们的测试机器上实现几乎两倍的UFS吞吐量。此外，与同步更新元数据的UFS不同，AdvFS使用像Frangipani这样的预写日志。这大大减少了文件创建等操作的延迟。AdvFS和UFS在读取小文件和目录时具有相似的性能。</p><blockquote><p>BSD-derived是指基于Berkeley Software Distribution（BSD）操作系统的衍生版本或相关软件。</p></blockquote><p>我们在两台相同的机器上运行AdvFS和Frangipani文件系统，其存储子系统具有相当的I/O性能。每台机器都有一个225 MHz的DEC Alpha 3000/700 CPU和192 MB的RAM，由统一缓冲缓存(UBC， unified buffer cache)管理。每个都通过自己的点对点链路连接到ATM交换机。</p><p>Frangipani文件系统不使用本地磁盘，而是通过Petal设备驱动程序访问复制的Petal虚拟磁盘。当使用64kb的块大小通过原始设备接口访问时，Petal驱动程序可以以大约16mb /s的速度读写数据，从而使到Petal服务器的ATM链路饱和。CPU利用率约为4%。Petal磁盘的读延迟大约是11ms。</p><p>AdvFS文件系统使用一个存储子系统，其性能与我们使用的Petal配置大致相当。它由8个DIGITAL RZ29磁盘组成，通过两个10 MB/s的快速SCSI字符串连接到两个背板控制器。当通过原始设备接口访问时，控制器和磁盘可以以大约17mb /s的速度提供数据，CPU利用率为4%。读取延迟大约是10 ms.(我们可以将AdvFS文件系统连接到一个Petal虚拟磁盘，以确保两个文件系统使用相同的存储子系统。先前的实验表明，如果在“Petal”上运行，AdvFS将会慢4%左右。为了最好地呈现AdvFS，我们选择不这样做。)</p><p>我们不打算将Petal的成本/性能与本地附加磁盘进行比较。显然，为Frangipani和AdvFS提供存储子系统所需的硬件资源有很大的不同。我们的目标是证明，与现有的、调优的商业文件系统相比，Frangipani代码流程是高效的。我们为Petal使用的硬件资源不是微不足道的，但是这些资源是在多个Frangipani服务器之间分摊的。</p><p>表1和表2比较了两个系统在标准基准测试中的性能。每个表有四列。在AdvFS Raw列中，在AdvFS直接访问本地磁盘的情况下运行基准测试。在AdvFS NVR专栏中，重新运行了在本地磁盘前面插入NVRAM的基准测试。在Frangipani Raw列中，在Frangipani通过设备接口访问Petal的情况下运行基准测试。在Frangipani NVR列中，通过在Petal和磁盘之间添加NVRAM缓冲，重新测试了Frangipani配置。所有数字都是在10次基准测试中平均的。在所有情况下，标准差都小于平均值的12%。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061058214.png"></p><p>表1给出了Modified Andrew Benchmark的结果，这是一个广泛使用的文件系统基准测试。基准测试的第一阶段创建目录树。第二阶段将350 KB的C源文件集合复制到树中。第三阶段遍历新树并检查每个文件和目录的状态。第四个阶段读取新树中的每个文件。第五阶段编译和链接文件。</p><p>不幸的是，很难使用标准形式的Modified Andrew Benchmark进行比较测量。这是因为基准测试不考虑由文件系统实现延迟的工作。在基准测试的一个阶段中延迟的工作可以在后面的阶段中执行，从而不适当地增加到该阶段，而有些工作可以延迟到基准测试结束后，因此永远不会考虑。</p><p>与传统的Unix文件系统一样，AdvFS和Frangipani都将写入脏文件数据的成本推迟到下一个同步操作，这个同步操作可能由用户显式请求或在后台由定期更新程序触发。然而，与传统的Unix文件系统不同，AdvFS和Frangipani都是基于日志的，不将元数据更新同步写入磁盘。相反，元数据更新也会延迟到下一次同步，或者至少延迟到日志包装。</p><p>为了正确地考虑延迟工作的所有来源，我们将基准更改为在每个阶段之后卸载文件系统。我们选择卸载而不是使用同步调用，因为在Digital Unix上，同步将脏数据排在队列中等待写入，但不能保证它在返回之前已经到达磁盘。结果如表1所示，Frangipani与AdvFS在各阶段均具有可比性。</p><p>表2显示了运行Connectathon Benchmark的结果。Connectathon基准测试单个操作或小组相关操作，提供对Andrew基准中可见的差异来源的更深入的了解。与Andrew基准测试一样，该基准测试也不考虑延迟的工作，因此我们再次在每个阶段结束时卸载文件系统。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061106709.png"></p><p>NVRAM的Frangipani延迟与AdvFS大致相当，但有四个明显的例外。测试1、4和6表明，使用Frangipani创建文件、设置属性和读取目录所花费的时间要长得多。然而，在实践中，这些延迟小到足以被用户忽略，所以我们并没有非常努力地去优化它们。</p><p>使用Frangipani创建文件需要更长的时间，部分原因是在测试期间128 KB的日志被填满了几次。如果我们将日志大小增加一倍，则时间减少到0.89和0.86秒。</p><p>Frangipani在文件读取测试(5b)上要慢得多。AdvFS在文件读取测试中做得很好，因为它的实现中有一个特殊的构件。在每次读取测试的迭代中，基准测试在读入文件之前都会进行一次系统调用，使缓冲区缓存中的文件失效。当前的AdvFS实现似乎忽略了这个无效指令。因此，读取测试测量AdvFS从缓存读取而不是从磁盘读取的性能。当我们用冷AdvFS文件缓存重新做这个测试时，性能与Frangipani的相似(1.80秒，有或没有NVRAM)。</p><p>接下来我们将报告单个Frangipani服务器在读取和写入大文件时实现的吞吐量。文件读取器位于一个循环中，读取一组10个文件。在循环的每次迭代之前，它从缓冲区缓存中刷新文件的内容。文件写入器处于一个循环中，反复写入一个大的(350mb)私有文件。该文件足够大，有一个稳定的写流量流到磁盘。读和写测试都运行了几分钟，我们观察到吞吐量没有显著变化。表3总结了时间平均稳态结果。NVRAM的存在与否对时间几乎没有影响。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061114817.png"></p><p>一台Frangipani机器可以以15.3 MB/s的速度写数据，这大约是我们机器上ATM链路和UDP/IP软件限制的96%。Frangipani通过将对Petal的写入聚类成自然对齐的64 KB块来实现良好的性能。很难弥补最后的4%，因为Frangipani偶尔(例如，在同步期间)必须将部分数据写入较小的块中。使用较小的块大小会减少通过UDP/IP堆栈的最大可用吞吐量。Frangipani服务器的CPU利用率约为42%，而Petal服务器的CPU不是瓶颈。</p><p>一台Frangipani机器可以以10.3 MB/s的速度读取数据，CPU利用率为25%。我们相信这种性能可以通过改变Frangipani中使用的预读算法来改善。Frangipani目前使用从BSD-derived文件系统UFS借鉴的预读算法，该算法不如AdvFS使用的算法有效。</p><p>相比之下，AdvFS在访问连接到两个控制器的8个RZ29磁盘上的大文件时，写入数据的速度约为13.3 MB/s。CPU利用率约为80%。在CPU利用率为50%的情况下，AdvFS的读性能约为13.2 MB/s。CPU和控制器都没有瓶颈，所以我们相信AdvFS的性能可以通过更多的调优来提高一点。</p><p>有趣的是，尽管Frangipani使用简单的策略来布局数据，但它的延迟和写吞吐量与使用更复杂策略的传统文件系统相当。</p><p>Frangipani具有良好的写延迟，因为延迟关键型元数据更新是异步记录的，而不是就地同步执行的。像UFS这样同步更新元数据的文件系统必须更加小心数据放置。在这里没有描述的单独实验中，我们发现即使在Frangipani同步更新其日志时，性能仍然相当好，因为日志分配在大的物理上连续的块中，并且NVRAM吸收了大部分写延迟。</p><p>Frangipani实现了良好的写吞吐量，因为大文件在许多磁盘和机器上以连续的64 KB单位物理分割，而且Frangipani可以利用这种结构中固有的并行性。出于同样的原因，Frangipani对于大文件具有良好的读取吞吐量。</p><p>回想第3节，对于小于64 KB的文件，不能在磁盘上连续分配单个4 KB块。此外，Frangipani并不对小文件进行预读，因此它不能总是隐藏磁盘查找访问时间。因此，Frangipani在小文件上的读取性能可能很差。为了量化小文件读取性能，我们进行了一个实验，在一台Frangipani机器上，30个进程试图在缓冲区缓存失效后读取单独的8 KB文件。Frangipani的吞吐量为6.3 MB/s, CPU是瓶颈。使用4 KB块通过原始设备接口访问的petals可以传输8 MB/s。因此，在这种情况下，franangipani获得了大约80%的最大吞吐量。</p><h2 id="9-3、缩放（Scaling）"><a href="#9-3、缩放（Scaling）" class="headerlink" title="9.3、缩放（Scaling）"></a>9.3、缩放（Scaling）</h2><p>本节研究 Frangipani 的缩放特性。理想情况下，我们希望看到操作延迟保持不变，吞吐量随着服务器的增加而线性扩展。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061122895.png"></p><p>图5显示了运行Modified Andrew Benchmark时缩放对Frangipani的影响。在本实验中，随着机器数量的增加，我们测量一台franangipani机器完成基准测试所需的平均时间。这个实验模拟了几个用户在共享数据池上进行程序开发的行为。我们注意到，随着Frangipani机器的增加，对延迟的负面影响最小。实际上，在单机器和六台机器实验之间，平均延迟只增加了8%。这并不奇怪，因为基准测试显示很少有写共享，并且我们希望延迟不受服务器数量增加的影响。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061123879.png"></p><p>图6展示了Frangipani在未缓存数据上的读吞吐量。在这个测试中，我们在多个服务器上复制单服务器实验中的读取器。测试运行了几分钟，我们观察到稳定状态吞吐量的变化可以忽略不计。如图所示，franangipani在本次测试中表现出良好的缩放性。我们正在将Frangipani安装到更多的机器上，我们预计总的读取性能会不断提高，直到达到Petal服务器的容量饱和。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061126840.png"></p><p>图7展示了Frangipani的写吞吐量。这里，单服务器实验中的写入器被复制到多个服务器上。每个服务器都有一个不同的大文件。实验运行了几分钟，在这段时间内，我们观察到稳定状态吞吐量的变化很小。由于实验中没有锁争用，因此性能被认为可以很好地扩展，直到 ATM 链接到 Petal 服务器已经饱和。由于虚拟磁盘是复制的，因此来自Frangipani服务器的每次写入都会变成对Petal服务器的两次写入。</p><h2 id="9-4、锁争用的影响（Effects-of-Lock-Contention）"><a href="#9-4、锁争用的影响（Effects-of-Lock-Contention）" class="headerlink" title="9.4、锁争用的影响（Effects of Lock Contention）"></a>9.4、锁争用的影响（Effects of Lock Contention）</h2><p>由于Frangipani对整个文件使用粗粒度锁，因此研究锁争用对性能的影响非常重要。我们在这里报告三个实验。</p><p>第一个实验测量读/写共享对文件的影响。一个或多个读取器与单个写入器竞争同一个大文件。最初，文件不是由读取器或写入器缓存的。读取器按顺序读取文件，而写入器则重写整个文件。因此，写入器反复获得写锁，然后获得一个回调来降级它，以便读取器可以获得读锁。这个回调导致写入器将数据刷新到磁盘。同时，每个读操作重复地获得读锁，然后获得一个回调来释放它，这样写操作就可以获得写锁。这个回调会导致读取器使其缓存无效，因此在重新获取锁后的下一次读取必须从磁盘中获取数据。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061131153.png"></p><p>我们在这个实验中观察到的第一个结果是出乎意料的。我们的分布式锁管理器被设计为公平地授予锁，模拟表明实现是这样的。如果单个写入器和n个读取器以统一的速率发出锁请求，那么它们将以轮询的方式得到服务，因此向写入器连续授予写锁与向读取器授予n次读锁会分开。在两次降级回调之间的间隔期间，可以预期读请求的数量和总读吞吐量会随着读取器的增加而增加。在n很大的极限下，缩放是线性的。然而，我们在实验中并没有观察到这种行为。相反，在运行两个读取器后，读取吞吐量趋于平缓，约为2 MB/s，如图8中的虚线所示。如前面图6所示，在没有锁争用的情况下，这仅是两台Frangipani服务器所能实现的10%左右。</p><p>我们推测这种异常行为是由预读引起的，所以我们在没有预读的情况下重复了这个实验来检查。预读在存在严重的读/写争用时是不利的，因为当回调读器以释放其锁时，它必须使其缓存无效。如果缓存中有任何尚未交付给客户端的预读数据，则必须丢弃它，并且读取它的工作被证明是浪费的。因为读取器在做额外的工作，所以它们不能以与写入器相同的速度发出锁请求。在禁用预读的情况下重新进行实验，得到了预期的缩放结果，如图8中的实线所示。</p><p>我们可以让用户显式地禁用特定文件的预读，或者设计一种识别这种情况并自动禁用预读的启发式方法，从而使用户能够获得这种性能改进。前者实现起来很简单，但会影响到Frangipani本身以外的操作系统内核的一部分，从而不方便跨内核的未来版本提供支持。后一种方法似乎更好，但我们尚未设计或测试适当的启发式。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305061259733.png"></p><p>第二个实验是第一个实验的变体。这里，读取器和以前一样运行，但是写入器修改的文件数据量不同。由于Frangipani锁定了整个文件，因此无论写入器的行为如何，读取器都必须使其整个缓存无效。但是，当写入器更新的数据块较少时，读取器可以更快地获得锁，因为写入器只需将更少量的数据刷新到磁盘。图9显示了当读取器和写入器同时共享不同数量的数据时，Frangipani(禁用预读)的性能。正如预期的那样，当共享数据更小时，我们可以获得更好的性能。</p><p>第三个实验测量写/写共享对文件的影响。作为基本情况，一个Frangipani服务器孤立地写一个文件。然后，我们添加了编写相同文件的Frangipani服务器，并测量了性能的下降。写入器以64kb为块修改文件数据。由于Frangipani执行全文件锁定，因此编写器使用的偏移量与此测试无关。我们发现，所有写入器看到的总带宽从单写入器情况下的15 MB/s下降到两个或更多写入器情况下的略高于1 MB/s。这并不奇怪，因为当多个写程序试图修改一个文件时，几乎每个写系统调用都会导致一个锁撤销请求。这个撤销请求导致锁持有者将其脏数据刷新到Petal。由于每次写系统调用都会撤销锁，而且每次调用只会弄脏64 KB的数据，因此吞吐量非常有限。块大小越小，吞吐量就越小。</p><p>我们没有太多处理并发写共享的工作负载的经验。如果有必要，我们认为扩展Frangipani来实现字节范围锁定[6]或块锁定是很简单的。这将提高读取和写入同一文件的不同部分的工作负载的性能，使其与当前系统中写入不同文件的性能相似。多台机器并发地读写同一文件(文件系统被用作进程间通信通道)的相同块的工作负载将执行如上所述。franangipani根本不适合这种工作量。</p><h1 id="10、相关工作（Related-Work）"><a href="#10、相关工作（Related-Work）" class="headerlink" title="10、相关工作（Related Work）"></a>10、相关工作（Related Work）</h1><p>像Frangipani一样，Cambridge(或Universal)文件服务器采用两层方法来构建文件系统[4,28]。然而，这两层之间的划分与我们的大不相同。底层的CFS为客户端提供了两个抽象:文件和索引。构建在CFS之上的文件系统可以使用这些抽象来实现文件和目录。CFS和Petal之间的一个主要区别是，在CFS中，一台机器管理所有的存储。</p><blockquote><p>CFS是指Cambridge (or Universal) File Server，是一种基于索引的文件系统。</p></blockquote><p>NFS[31,33]本身并不是一个文件系统，而只是一个远程文件访问协议。NFS协议提供了一个较弱的缓存一致性概念，其无状态设计要求客户端频繁访问服务器以维持这种级别的一致性。Frangipani提供了一个高度一致的单一系统视图，它使用一个协议来维护更多的状态，但消除了对服务器不必要的访问。</p><p>Andrew文件系统(AFS)[19]及其分支DCE/DFS[21]提供了比NFS更好的缓存性能和一致性。AFS的可扩展性与Frangipani不同。Frangipani提供了一个统一的集群文件系统，它从单个存储池中提取数据，并且可以扩展到在一个公共管理下跨多台机器的多个磁盘驱动器。相反，AFS具有全局名称空间和安全体系结构，允许在广泛的区域内插入许多独立的文件服务器和客户端。我们认为，AFS和Frangipani的扩展方法是互补的;对于Frangipani服务器来说，使用AFS或DCE/DFS名称空间和访问协议将文件系统导出到广域客户机是很有意义的。</p><p>像Frangipani一样，Echo文件系统[5,18,26,35]基于日志，复制数据以保证可靠性，复制访问路径以保证可用性，允许卷跨越多个磁盘，并提供一致的缓存。然而，Echo不具备Frangipani的可扩展性。每次只能由一台服务器管理每个Echo卷，并将故障转移到一个指定的备份。一个卷只能跨越连接到一台机器上的尽可能多的磁盘。在磁盘服务之上有一个内部的文件服务层，但是Echo实现要求这两个层在同一台机器上的相同地址空间中运行，使用Echo的经验表明服务器CPU是一个瓶颈。</p><p>VMS集群文件系统[14]将文件系统处理工作分配到作为集群成员的各个机器上，就像Frangipani所做的那样。每个集群成员在共享物理磁盘上运行自己的文件系统代码实例，由分布式锁服务提供同步。共享的物理磁盘可以通过专用的集群互连(磁盘控制器可以直接连接到集群互连)访问，也可以通过普通网络(如以太网和充当磁盘服务器的机器)访问。Frangipani在几个方面改进了这种设计:由petals提供的可扩展的共享虚拟磁盘取代了共享物理磁盘;Frangipani文件系统基于日志，可以快速恢复故障;Frangipani提供了大量的数据和元数据缓存，以获得更好的性能。</p><p>Spiralog文件系统[20]还将其文件系统处理工作分配给运行在共享存储系统层之上的单个集群成员。Spiralog中各层之间的接口既不同于最初的VMS Cluster文件系统，也不同于petals。底层既不是文件，也不是简单的磁盘;相反，它提供了一个稳定存储的字节数组，并允许原子操作更新数组中任意分散的字节集。Spiralog的分层简化了文件系统，但使存储系统相当复杂。与此同时，Spiralog的存储系统没有Petal的可扩展性或容错性;Spiralog体积只能跨越连接到一台机器的磁盘，并且在该机器崩溃时变得不可用。</p><p>虽然是作为集群文件系统设计的，但Calypso[11]类似于Echo，而不是VMS Clusters或Frangipani。和Echo一样，Calypso将文件存储在多端口磁盘上。直接连接到每个磁盘的机器之一充当存储在该磁盘上的数据的文件服务器;如果那台机器坏了，另一台就会接替。Calypso集群的其他成员作为文件系统客户端访问当前服务器。与Frangipani和Echo一样，客户端也有缓存，与多读/单写锁定协议保持一致。</p><p>Shillner和Felten在共享逻辑磁盘[34]之上构建了一个分布式文件系统。他们系统中的分层与我们的类似:在底层，多台机器合作实现单个逻辑磁盘。在上层，多个独立的机器在一个逻辑磁盘上运行相同的文件系统代码，所有机器都提供对相同文件的访问。与Petal不同，它们的逻辑磁盘层不提供冗余。当节点发生故障并重新启动时，系统可以恢复，但不能动态配置故障节点或配置其他节点。他们的文件系统对元数据写入进行了仔细的排序，而不是像Frangipani那样进行日志记录。与日志记录一样，他们的技术避免了在服务器崩溃后进行完整的元数据扫描(fsck)来恢复一致性的需要，但与日志记录不同的是，它可能会在崩溃时丢失对空闲块的跟踪，因此需要偶尔进行垃圾收集扫描才能再次找到它们。目前我们无法将他们的系统性能与我们的系统进行比较，因为他们的文件系统层的性能数据不可用。</p><p>xFS文件系统[1,36]在本质上最接近于Frangipani。事实上，两种体系的目标在本质上是相同的。两者都尝试在多台机器上分配文件的管理责任，并提供良好的可用性和性能。在与xFS相同的意义上，Frangipani实际上是“无服务器”的——该服务分布在所有机器上，并且可以在每台机器上配置Frangipani服务器和Petal服务器。Frangipani的锁定比xFS更粗粒度，后者支持块级锁定。</p><p>我们的工作在两个主要方面与xFS不同:</p><p>首先，我们的文件系统的内部组织及其与存储系统的接口与xFS有很大的不同。与Frangipani不同，xFS为每个文件预先指定了一个管理器，并且它的存储服务器是日志结构的。相反，Frangipani被组织成一组协作的机器，这些机器使用Petal作为共享存储，并使用单独的锁服务进行并发控制。我们的模型更简单，让人想起多线程共享内存程序，它们通过公共存储进行通信，并使用锁进行同步。这个模型允许我们用比xFS更少的机器来处理文件系统恢复和服务器添加和删除，这使得我们的系统更容易实现和测试。</p><p>其次，我们已经解决了文件系统恢复和重新配置。到目前为止，这些问题一直是xFS工作的开放性问题。</p><p>我们本来希望将Frangipani的性能与xFS的性能进行比较，但是在当前的xFS原型[1]上还有大量的性能工作要完成。此时对系统进行比较是不成熟的，而且对xFS不公平。</p><h1 id="11、结论（Conclusions）"><a href="#11、结论（Conclusions）" class="headerlink" title="11、结论（Conclusions）"></a>11、结论（Conclusions）</h1><p>Frangipani文件系统为所有用户提供对同一组文件的一致的、共享的访问，并且随着用户群组的增长，可以扩展以提供更多的存储空间、更高的性能和负载平衡。尽管组件出现故障，它仍然可用。它只需要很少的人工管理，而且随着越来越多的组件被添加到不断增长的安装中，管理也不会变得更加复杂。</p><p>构建Frangipani是可行的，因为它有两层结构，由多个文件服务器组成，这些服务器在共享的Petal虚拟磁盘上运行相同的简单文件系统代码。使用Petal作为底层提供了几个好处。Petal实现了高可用性的数据复制，从而避免了Frangipani这样做的需要。所有Frangipani服务器都可以统一访问Petal虚拟磁盘，因此任何服务器都可以提供任何文件，当服务器出现故障时，任何机器都可以运行恢复。Petal的大而稀疏的地址空间允许我们简化Frangipani的磁盘数据结构。</p><p>尽管Frangipani具有简单的数据布局和分配策略以及粗粒度锁，但我们对它的性能还是很满意的。在我们最初的性能测量中，Frangipani已经可以与生产的DIGITAL Unix文件系统相媲美，我们希望通过进一步调优来改进。Frangipani已经显示出良好的扩展特性，直到我们的测试平台配置的大小(7个Petal节点和6个Frangipani节点)。结果让我们乐观地认为，系统将继续扩展到更多的节点。</p><p>我们未来的计划包括为我们自己的日常使用部署Frangipani。我们希望通过负载下的原型获得更多的经验，通过在更大的配置中测试它来验证它的可伸缩性，试验细粒度锁，并完成我们在备份上的工作。最后，当然，我们希望看到Frangipani的想法进入商业产品。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Frangipani </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Aurora</title>
      <link href="/2023/050563308.html"/>
      <url>/2023/050563308.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>Aurora是亚马逊网络服务(AWS)的一部分，为OLTP业务提供关系型数据库服务。本文介绍了Aurora的系统架构以及背后设计上的考虑。我们认为，高吞吐量数据处理的核心问题已经从计算和存储移到了网络IO。为了解决这个问题，Aurora提出了一种新的关系型数据库架构，将REDO日志的处理下沉到一个专门为Aurora定制的多客户可扩展的存储服务(multi-tenant scale-out storage service)上。我们介绍了这种架构的一些优点，包括减少了网络流量，可以实现快速的故障恢复，无损的故障切换到备机，提供容错并且自愈的存储服务。接着，我们介绍了Aurora如何使用一种高效的异步方法，在大量的存储节点上实现可持久化状态的一致性，避免使用昂贵且沟通复杂的恢复协议。最后，基于在生产环境运维Aurora 18个月的经验，我们分享了从客户上学习到一些心得：客户期望现代云服务中的数据库层是怎样的。</p><blockquote><p>OLTP是Online Transaction Processing的缩写，指的是在线事务处理。它是一种计算机处理方式，用于支持企业日常业务操作，如订单处理、库存管理、客户服务等。OLTP系统通常需要快速响应用户请求，并且需要保证数据的一致性和可靠性。</p><p>Multi-tenant是指一种软件架构，其中单个实例的应用程序同时为多个客户（或租户）提供服务。每个客户都可以访问该应用程序的共享实例，但是他们的数据和配置是相互隔离的，以保护各个客户之间的数据安全性和隐私。</p></blockquote><h2 id="1、引言（Introduction）"><a href="#1、引言（Introduction）" class="headerlink" title="1、引言（Introduction）"></a>1、引言（Introduction）</h2><p>IT业务现在正加速向公有云迁移。这个产业级别的转变背后一个重要原因是，公有云能提供弹性的按需容量，（IT企业将这部分费用）作为经营性支出支付，而不用采用资本投入的模式。大量的IT业务需要支持OLTP的数据库，而提供与自建数据库等同甚至更高级的数据库服务，对支持这个长期转变的过程是至关重要的。</p><p>在现代的分布式云服务中，弹性和可扩展性可以通过将计算和存储解耦，并在多个节点上提供存储的副本来实现。这样的结构可以让我们更容易的实现一些操作，比如替换掉异常或者不可达的主机，添加副本，主机故障后切换到副本，增加或者降低一个数据库实例的容量。在这种环境下，传统数据库所面临的IO瓶颈已经发生了变化。由于IO操作已经分布到一个多客户平台上的多个数据节点的多个数据盘上，单个数据盘或者节点不再是热点。取而代之的是，系统的瓶颈移动到发起这些IO操作的数据库层，以及真正执行这些IO的存储层之间。除了基本的PPS和带宽的瓶颈外，这里还存在着流量的放大效应，因为一个高性能的数据库必须并行的将数据写入到存储层。性能最低的节点、数据盘、网络路径决定着整体的响应时间。</p><p>尽管数据库中的很多操作存在着交叉，还是有许多场景同步操作是必须的。这就导致了暂停和上下文切换。其中一个场景是，一次由于数据库缓存池未命中引起的磁盘读，这个时候读取线程在磁盘读完成之前是不能继续执行的。一次缓存未命中，可能带来额外的惩罚：将一个脏页剔除并写入到数据盘，腾出位置给新的页。另外，一些后台处理，如建立checkpoint或者刷脏页的操作，可以减少这种惩罚出现的几率，但是也会导致暂停、上下文切换以及资源竞争。</p><p>事务的提交是另外一种（性能的）干扰项，一个提交的阻塞会导致后面的事务提交的无法处理。用多阶段同步提交协议，如2PC（2-phase commit），处理提交是一项极具挑战性的工作。在高度扩展的分布系统中，系统中存在着持续的软硬故障，这些协议在这种场景下的支持不够好，并且有较大的处理时延，因为分布式系统中的节点可能分布在多个数据中心。</p><p>在本文中，我们介绍Amazon Aurora，一种通过将REDO日志分散在高度分布云服务环境中，来解决上述问题的新型数据库服务。Aurora使用了创新的面向服务的系统架构，使用多客户可扩展的存储服务层，来抽象虚拟化的分段REDO日志，并松散的与数据库实例层连接在一起。尽管每个数据库实例仍然包含一个传统数据库内核的大部分组件（查询处理器，事务，锁，buffer cache，访问方式以及UNDO日志的管理），一些功能（如REDO日志记录，持久化存储，故障恢复，备份以及恢复数据）都下沉交给存储层来做。</p><p>相对于传统的数据库，Aurora的系统架构有三个重要的优势。首先，通过将存储构建为一个<strong>跨数据中心容错且自修复</strong>的服务，我们可以保护数据库免遭系统性能抖动以及网络或者存储层的短期或者长期的故障的影响。我们注意到，一个可持久化的故障可以认为是系统长时间不可用的事件，而系统的不可用时间又可以建模为长时间的系统性能抖动。一个设计良好的系统可以无差别地处理这些问题。其次，通过<strong>只将REDO日志写入存储层，我们可以将网络的IOPS降低一个数量级</strong>。一旦我们移除了这个瓶颈，我们可以更进一步地优化其他的竞争点，从而可以在原有的MySQL源码基础上有重大的提升。第三点，我们<strong>将一些很复杂且关键的功能（备份，REDO恢复），从原来是数据库引擎中的一次性的昂贵的操作，转变为均摊在一个大型分布式存储层上连续异步的操作</strong>。这样，我们可以实现近乎即时的不需要checkpoint的故障恢复，以及廉价的不影响前台处理的备份操作。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305041824287.png"></p><p>在本文中，我们首先介绍三个主要贡献：</p><p>1、如何在云规模上实现可持久性，如何设计一个多数派系统以应对关联故障（第二节）</p><p>2、如何将传统数据库最下面的一部分下沉到存储层来实现智能的存储（第三节）</p><p>3、如何在分布式存储中移除多阶段的同步，如何故障恢复以及建立checkpoint（第四节）</p><p>我们接着在第五节展示如何将这三个想法结合起来设计Aurora的整体架构，紧接的第六节是我们的性能测试结果。第七节讲的是我们在这个过程中学习到的心得。最后，我们在第八节简要地介绍了相关的工作。第九节是结束语。</p><h1 id="2、大规模系统中的可持久性（DURABILITY-AT-SCALE）"><a href="#2、大规模系统中的可持久性（DURABILITY-AT-SCALE）" class="headerlink" title="2、大规模系统中的可持久性（DURABILITY AT SCALE）"></a>2、大规模系统中的可持久性（DURABILITY AT SCALE）</h1><p>数据库专门设计来满足一种协议，一旦数据写入，就可以被读出来。不过，不是所有的系统都是这样的。我们在这一节介绍我们的多数派模型以及对数据分段背后的理念，将这两者结合起来，如何既能实现可持久性、可用性、减少抖动，又能帮助我们解决大规模存储层的运维问题。</p><h2 id="2-1、复制以及关联故障（Replication-and-Correlated-Failures）"><a href="#2-1、复制以及关联故障（Replication-and-Correlated-Failures）" class="headerlink" title="2.1、复制以及关联故障（Replication and Correlated Failures）"></a>2.1、复制以及关联故障（Replication and Correlated Failures）</h2><p>实例的生命周期与存储的生命周期不是强耦合的。实例可以挂掉，用户也可以将他们停掉，也可以根据负载升级或者降级实例。基于这些原因，将存储层和计算层分开是有实际意义的。</p><p>一旦分离了计算和存储，存储节点本身和数据盘也会故障挂掉。因而，他们必须以某种形式复制来应对故障。在大规模的云环境中，长期存在着低频的节点、数据盘、网络路径故障的背景噪音。每一个故障可能具有不同的持续时间和影响范围。举个例子，可能某一个节点会存在短暂的网络不可用的情况，由于重启引起的短暂的停服，或者也存在着一个数据盘、节点、机架、网络交换设备的叶子或者主干，甚至整个数据中心的永久性故障。</p><p>在一个复制系统的里面应对故障的一个方案是，使用基于多数派投票的协议。如果V个副本每个都有一个投票权，那么一个读或者写操作必须分别获得读多数派Vr票，以及写多数派Vw票。为了保证一致性，这些多数派必须满足两个规则。首先，为了读到最新的数据，必须满足Vr+Vw &gt; V。这个规则保证最近的一次写多数派和读多数派至少包含相同的一个节点，从而保证读到最新的数据。其次，为了避免写冲突，感知到最新的写入操作，写操作的涉及的副本数必须满足Vw &gt; V/2。</p><p>通常的为了避免一个节点故障的方式是将数据复制三份，设置V为3，读多数派为Vr=2，写多数派为Vw=2。</p><p>但是我们认为设计2/3为多数派是不够的。为了理解这是为什么，我们必须先理解AWS中可用区的概念。一个可用区是一个地域的子集，与该区域的其他可用区通过低延时的链路连接。可用区之间对很多故障是隔离的，包括供电、网络、软件、洪灾等。将数据副本存放在不同的可用区中，可以保证通常的故障模式只会影响到一个副本。这也就意味着，用户只要将三个副本存放在不同的可用区中，就可以应对大规模的事件和小范围内个别的故障。</p><p>我们将Aurora设计为能容忍（a）挂掉整个可用区（AZ）以及一个额外的节点（AZ+1）而不影响读取数据，（b）挂掉一整个可用区而不影响写入数据。我们通过将数据复制为6个副本，存放在3个可用区中，每个可用区2个。我们将大多数派模型中的V值设为6，这样写多数派为Vw=4，读多数派为Vr=3。通过这个模型，我们在挂掉一个可用区加一个节点仍然提供读服务，挂掉一个可用区仍然提供写服务。确保读多数派，能使我们添加一个副本就可以重建写多数派。</p><h2 id="2-2、分段存储（Segmented-Storage）"><a href="#2-2、分段存储（Segmented-Storage）" class="headerlink" title="2.2、分段存储（Segmented Storage）"></a>2.2、分段存储（Segmented Storage）</h2><p>我们考虑一下AZ+1的方案是否能提供足够的可持久性。为了在这个模型中保持足够的可持久性，必须保证两个不相关故障成对出现的概率（平均故障间隔），要比平均修复时间小得多。如果成对故障出现的概率非常高，可能会导致一个AZ故障，从而形成不了多数派。过了某个点之后，很难去进一步降低独立事件的平均故障时间。因而，我们将重点放在通过降低平均修复时间来降低成对故障的影响。我们采用的具体做法是，将数据库的总容量划分为固定大小的数据段，大小为10G。每个数据段有6个副本，组成一个Protect Group（PG），分布在3个AZ中，每个AZ 2个。一个Aurora数据卷通过一组PGs连接而成，物理上由一组挂载本地SSD的EC2主机作为一个存储节点，每个存储节点有多个存储单元。通过分配更多的PG，可以线性的扩展数据卷的容量，Aurora支持的最大数据卷（一个副本）容量为64T。</p><p>数据段是系统中最小的故障和恢复单元，自动的监控和修复故障是整个服务的一个部分。之所以选择10G，是因为在万兆网络条件下，恢复一个数据段只需要10秒钟。在这种情况，如果要打破多数派，那么必须同时出现两个数据段同时故障加上一个AZ故障，同时AZ故障不包含之前两个数据段故障的独立事件。通过我们对故障率的观察，这种情况出现的概率足够低，即使是在我们现在为客户服务的数据库量级上。</p><h2 id="2-3、弹性的运维优势（Operational-Advantages-of-Resilience）"><a href="#2-3、弹性的运维优势（Operational-Advantages-of-Resilience）" class="headerlink" title="2.3、弹性的运维优势（Operational Advantages of Resilience）"></a>2.3、弹性的运维优势（Operational Advantages of Resilience）</h2><p>一旦我们设计了一个能对长时间故障保持韧性的系统，那么这个系统就能轻松处理短时间的故障了。一个存储系统如果能应对一个AZ的长时间故障，也能应对由于停电或者软件故障引起的短时间服务不可用。同理，如果能应对一个多数派中的成员数秒钟的失联，当然也能处理短时间的网络拥塞或者存储节点的高负载。</p><p>由于Aurora系统对故障有着高度的忍耐性，我们可以通过这一点来处理导致数据段不可用的运维操作。举个例子，<strong>热点管理</strong>可以变得很直观。我们可以直接将一个热点数据盘或者节点标记为故障，通过将数据迁移到冷存储节点上来迅速地修复多数派。而<strong>操作系统和安全漏洞修复</strong>对于存储节点来说，就是一个短时间的不可用事件。甚至，<strong>存储层的软件升级</strong>也可以类似的处理。我 每次处理一个AZ，同时保证同一个PG内没有两个副本所在的节点同时被处理。基于这些，我们在存储服务上可以使用敏捷方法和快速部署。</p><h1 id="3、日志即数据库（THE-LOG-IS-THE-DATABASE）"><a href="#3、日志即数据库（THE-LOG-IS-THE-DATABASE）" class="headerlink" title="3、日志即数据库（THE LOG IS THE DATABASE）"></a>3、日志即数据库（THE LOG IS THE DATABASE）</h1><p>在这一节，我们阐释了为什么传统的数据库使用分段冗余的存储系统，会引起不能承受的网络IO和同步阻塞等性能负担。接着，介绍Aurora采用的将日志处理交给存储服务层来做的方案，并且用实验数据说明了该方案能显著地降低网络IOs。最后，介绍了Aurora存储服务中使用的一些技巧，用于将同步阻塞和不必要的写操作最小化。</p><h2 id="3-1、成倍放大的写负担（The-Burden-of-Amplified-Writes）"><a href="#3-1、成倍放大的写负担（The-Burden-of-Amplified-Writes）" class="headerlink" title="3.1、成倍放大的写负担（The Burden of Amplified Writes）"></a>3.1、成倍放大的写负担（The Burden of Amplified Writes）</h2><p>我们的模型中将数据整体容量分段，并将分段复制为6个副本形成4/6写多数派，给整个系统带来了韧性。不过，这个模型会让传统的数据库如MySQL对单次应用层的写入产生过多的真实IO操作，使得整个系统的性能无法接受。高IO被复制操作成倍的放大，产生的高包量PPS让系统负担很重。同时，这些IO操作也产生一些同步点，导致数据管道阻塞、延时被放大。虽然链式复制及其变种可以减少网络开销，但是仍然受困于同步阻塞以及延时放大。</p><p>我们来审视一下写操作如何在传统的数据库中执行的。数据库系统如MySQL将数据页写到数据对象中（如堆文件、B树等），同时将REDO日志写入Write-Ahead日志WAL。每一条REDO日志包含着一个数据页的前镜像和后镜像的差异。将REDO日志应用到前镜像上可以得到数据页的后镜像。</p><p>在实际中，一些其他的数据也必须被写入。比如，考虑一对同步镜像的MySQL实例，通过部署在不同的数据中心形成主从结构来获取高可用性。在AZ1中有一个MySQL实例，通过EBS挂载带网络的存储。在AZ2中有一个从机，同样通过EBS挂载带网络的存储。写入到主EBS的数据会通过软件镜像同步到一个从EBS上。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305050952283.png"></p><p>图2展示了数据库引擎需要写入的不同类型的数据，包括REDO日志，为支持任意时间回档归档到S3上的二进制日志，被修改的数据页，为了防止页损坏而双写的数据，还有元数据FRM文件。图中同样描述了IO流的顺序。在步骤1和2中，会写入数据到主EBS上，同时同步到在同一个AZ中的从EBS上，当两个都写完了才回复确认。接着，在步骤3中，写入数据会使用块级别的软件镜像同步到MySQL从机上。最后，在步骤4和5中，数据会被写到MySQL从机上挂载的一对主从EBS上。</p><p>上面描述的MySQL镜像模型在现实中是不可取的，不仅是因为数据是如何写入的，同时也因为有哪些数据被写入。首先，步骤1、3、5是顺序且同步的。延时会因为同步写而累积。抖动会被放大，主要是因为即使是异步写，也必须等待最慢的一次操作，系统的性能由最坏的操作结果决定。从分布式系统的角度看，这个模型可以看作一个4/4写多数派模型，在故障和最坏操作的性能限制条件下很脆弱。其实，由OLTP应用产生的用户操作可能导致多种不同的类型的写入，而实际上代表的是同样的信息—比如，为了防止存储基础设施中的页损坏而设计的双写操作。</p><h2 id="3-2、REDO日志处理下沉到存储（Offloading-Redo-Processing-to-Storage）"><a href="#3-2、REDO日志处理下沉到存储（Offloading-Redo-Processing-to-Storage）" class="headerlink" title="3.2、REDO日志处理下沉到存储（Offloading Redo Processing to Storage）"></a>3.2、REDO日志处理下沉到存储（Offloading Redo Processing to Storage）</h2><p>当一个传统数据库修改一个数据页，会产生一个REDO日志记录，并调用Log Applicator将其应用在内存中的页的前镜像上产生页的后镜像。事务的提交要求首先必须写入日志，数据页的刷盘可能会滞后。</p><p>在Aurora中，需要通过网络传输的写数据只有REDO日志。数据库层不会因为后台操作或者建立检查点而写入其他数据。取而代之的是，Log Applicator被下推到了存储层，用来在后台或者按需产生数据页。诚然，从头开始按每页修改的完整路径来生成每个数据页是相当昂贵的操作。因而，我们在后台不断地使用REDO日志来生成数据页，来避免每次都按需从头生成。注意到，后台的数据生成从正确性的角度来看完全是可选的：因为从存储引擎的角度出来，日志就是数据库，所有生成的数据页不过是日志的缓存。同时，不像建立检查点，只有有一连串修改记录的数据页需要重新生成。建立检查点，与完整REDO日志链的有关，而Aurora的数据页生成只与这个页的日志链有关。</p><p>我们的方案即使是在由于复制引起的放大写的条件下，不仅减少了网络负载，而且还提供了可观的性能和可持久性。存储服务可以以并行独立任务的方式来扩展IO，并且不影响数据库引擎的吞吐量。举个例子，图3展示了一个Aurora集群，包括一个主实例和多个副本，部署在多个不同的可用区中。在这个模型中，主实例将REDO日志写入存储层，并将日志以及元数据的更新一起发送给副本实例。IO流根据目的地来将日志顺序打成batch，并将每个batch传给数据的6个副本并持久化到数据盘上。数据库引擎只要收到6个中的4个回复就形成了一个写多数派，此时可认为这些日志文件被持久化了。每个数据副本使用这些REDO日志将数据页的变更应用在他们的buffer cache中。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305050958326.png"></p><p>为了测试网络IO，我们用SysBench跑了一个写压力测试，100G的数据量写入两个不同配置的数据库：一个是之前介绍的部署在不同可用的区的MySQL同步镜像，另外一个是Aurora（副本在不同的可用区）。对两个数据库实例，在r3.8xlarge EC2实例上运行测试30分钟。</p><p>我们的测试结果归纳在表1中。在30分钟的测试过程中，Aurora可以负载比MySQL镜像多35倍的事务。每个事务所需的IO次比MySQL镜像少7.7倍。我们通过将更少的数据通过网络写，使得我们可以更积极地复制数据获得持久性和可用性，可以并发的请求来最小化性能的抖动。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051006673.png"></p><p>将日志处理放在存储层可以通过一系列手段来提升可用性，包括减少故障恢复时间，消除由于后台操作如建立检查点、数据页写入以及备份等引起的性能抖动。</p><p>我们来对比一下故障恢复。在传统的数据库中，系统必须从最近的一个检查点开始恢复，重放日志确保所有REDO日志都被应用。在Aurora中，可持久化REDO日志不断地、异步的应用在存储层，分布在各个数据节点上。如果数据页还没被生成，一个读请求可能会应用一些REDO日志来生成数据页。这样一来，故障恢复的过程被分散在所有的正常的前台操作中。在数据库启动的时候不需要做任何事情。</p><h2 id="3-3、存储服务的设计点（Storage-Service-Design-Points）"><a href="#3-3、存储服务的设计点（Storage-Service-Design-Points）" class="headerlink" title="3.3、存储服务的设计点（Storage Service Design Points）"></a>3.3、存储服务的设计点（Storage Service Design Points）</h2><p>存储服务的一个核心设计点是尽可能减少前台写操作的延时。我们将大部分的存储处理操作移到了后台。考虑到存储层从峰值到平均请求的巨大差异，我们有足够的时间在前台操作路径之外处理这些任务。我们也可以使用计算来换存储。举个例子，如果存储节点在忙着处理前台写请求的时候，没有必要运行GC来回收老的数据页版本，除非是数据盘快满了。在Aurora中，后台处理和前台处理是负相关的。这与传统的数据库不同，传统数据库后台的脏页刷盘和建立检查点与前台的负载是正相关的。在这样的系统中，如果后台积累了许多未处理的任务，那么必须扼制前台正常的处理流程才能防止后台任务越积累越多。由于在Aurora中数据段被分散在不同的存储节点上，一个存储节点卡死可以轻易被4/6写多数派处理，卡死的存储节点会被看作一个慢节点（不影响整体的流程）。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051010366.png"></p><p>我们来进一步看看存储节点的处理流程。如图4所示，它包括以下的步骤：（1）收到日志记录并将其加入内存的队列，（2）持久化记录并确认写入，（3）整理日志记录并确认日志中有哪些缺失，因为有些包可能丢了，（4）与其他数据节点交互填补空缺，（5）用日志记录生成新的数据页，（6）不断的将数据页和REDO日志持久化到S3，（7）周期性的回收旧的版本，（8）最后周期性的对数据页进行CRC校验。</p><p>注意上面的步骤都是异步的，只有步骤（1）和（2）是在前台操作的路径中，可能会影响延时。</p><h1 id="4、日志驱动（THE-LOG-MARCHES-FORWARD）"><a href="#4、日志驱动（THE-LOG-MARCHES-FORWARD）" class="headerlink" title="4、日志驱动（THE LOG MARCHES FORWARD）"></a>4、日志驱动（THE LOG MARCHES FORWARD）</h1><p>在这一节中，我们介绍了数据库引擎是如何产生日志的，这样可持久化状态、运行时状态、以及复制状态永远是一致的。重点讲述了如何不通过复杂的2PC协议来高效地实现一致性。首先，我们展示如何在故障恢复的时候，避免使用昂贵的REDO日志重放。其次，我们介绍了一些常规操作，以及我们能如何保持运行时和复制状态。最后，我们介绍故障恢复过程的细节。</p><h2 id="4-1、方案概览：异步处理（Solution-sketch-Asynchronous-Processing）"><a href="#4-1、方案概览：异步处理（Solution-sketch-Asynchronous-Processing）" class="headerlink" title="4.1、方案概览：异步处理（Solution sketch: Asynchronous Processing）"></a>4.1、方案概览：异步处理（Solution sketch: Asynchronous Processing）</h2><p>由于我们将数据库建模为日志流，这样日志的不断滚动的过程可以看作一连串顺序的变更。在实现上，每一条日志记录都有一个由数据库产生单调递增的日志编号LSN。</p><p>这让我们可以使用<strong>异步</strong>的思路简化用来维护状态的一致性协议，而不是使用2PC这种沟通复杂且对错误容忍度低的协议。从上层来看，我们维护一致性和可持久性的状态点，并随着我们收到发出去请求的确认消息，不断地推进这些点。由于任何单个的存储节点都有可能丢失一个或者多个日志记录，这些节点与节点相互之间交流，找到并填补丢失的信息。数据库维护的运行时状态可以让我们用单个数据段的读来代替大多数读，除非是在故障恢复的时候，状态丢失了必须通过重建。</p><p>数据库可能同时发起了多个独立的事务，这些事务完成的顺序与发起的顺序是不一致的。假如这时数据库崩溃了重启，每个事务决定是否需要回滚是相互独立的。跟踪未完成的时候并回滚的逻辑还是在数据库引擎中完成，就如同它在写单个盘一样。不过，在数据库重启的时候，在它被允许访问存储之前，存储服务需要进行自己的故障恢复流程，然而重点不在用户级的事务上，而是确保数据库能看到存储的一致性视图，尽管存储本身是分布式的。</p><p>存储服务首先确定VCL（Volume Complete LSN），能确保之前日志记录都可用最大的LSN。在存储恢复的过程中，大于VCL的日志就都必须被截断。数据库可以通过找到CPL（Consistency Point LSN），并使用这些点进行进一步的日志截断。这样我们可以定义VDL（Volume Durable LSN）为所有副本中最大的CPL，CPL必须小于或者等VCL，所有大于VDL的日志记录都可以被截断丢掉。举个例子，即使我们有到LSN 1007的完整数据，数据库发现只有900、1000和1100是CPL点，那么，我们必须在1000处截断。我们有到1007的完整数据，不过我们只有到1000的可持久性。</p><blockquote><p>VCL表示当前已提交到存储服务的最高LSN。CPL表示在某个时间点上，所有数据都已经被写入到存储服务，并且可以被认为是一致的LSN。VDL表示小于或等于VCL的最高CPL，并且用于确定哪些日志记录可以被截断以确保数据持久性。</p></blockquote><p>因而，完整性和可持久性是不同的。一个CPL可以看作描述带某种形式限制的存储系统事务，这些事务本身必须按序确认。如果客户端认为这些区分没用，它可以将每个日志记录看作一个CPL。在实现中，数据库和存储必须如下交互：</p><ul><li>每个数据库层的事务会被划分为多个mini事务，这些事务是有序的，并且被原子的执行</li><li>每个mini事务由多个连续的日志记录组成</li><li>mini事务的最后一个日志记录就是一个CPL</li></ul><p>在故障恢复的时候，数据库告诉存储服务建立每个PG的可持久化点，并使用这些来确认VDL，然后发送命令截断所有大于VDL的日志记录。</p><h2 id="4-2、常规操作（Normal-Operation）"><a href="#4-2、常规操作（Normal-Operation）" class="headerlink" title="4.2、常规操作（Normal Operation）"></a>4.2、常规操作（Normal Operation）</h2><p>我们现在介绍数据库的常规操作，重点依次介绍写，读，事务提交，副本。</p><h3 id="4-2-1、写（Writes）"><a href="#4-2-1、写（Writes）" class="headerlink" title="4.2.1、写（Writes）"></a>4.2.1、写（Writes）</h3><p>在Aurora中，数据库不断的与存储服务交互，维护状态来保持大多数派，持久化日志记录，并将事务标记为已提交。比如，在正常/前台路径中，如果数据库收到写大多数派的写确认回复，它会将VDL往前推进。在任意一个时间点，数据库中都会存在着大量并发的事务，每个事务产生自己的REDO日志。数据库为每个记录分配一个唯一有序的LSN，这些LSN不能大于VDL加上LAL（LSN Allocation Limit）（目前被设为10m）。这个限制保证数据库不会领先存储服务太多，以至于导致后台处理的压力过大（如网络或者存储跟不上）阻塞写请求。</p><p>注意到每个PG中的每个数据段只会看到整体的一部分日志记录。每个日志记录含有一个反向的指针指向这个PG中的前一个日志记录。这些反向指针可以用来追踪每个数据段的完整性点，来确认SCL（Segment Complete LSN），SCL是PG收到的连续日志的最大LSN值。SCL被数据库节点用来与其他节点交流，找到缺失的日志记录并添补它们。</p><h3 id="4-2-2、提交（Commits）"><a href="#4-2-2、提交（Commits）" class="headerlink" title="4.2.2、提交（Commits）"></a>4.2.2、提交（Commits）</h3><p>在Aurora中，事务的提交是异步完成的。当客户端提交一个事务，处理这个提交请求的线程将事务放在一边，并将COMMIT LSN记录在一个单独的事务队列中等待被确认提交，然后就去做其他事情了。这等同于实现了WAL协议：确认一个事务提交完成了，当且仅当最新的VDL大于或者等于这个事务的COMMIT LSN。当VDL不断的增加，数据库找到哪些事务等待被确认，用一个单独的线程给等待的客户端返回事务完成的确认。Worker线程不会等待事务提交完成，它们会继续处理等待着的请求。</p><blockquote><p>WAL协议指的是Write-Ahead Logging Protocol，是一种常见的数据库恢复协议。在WAL协议中，所有的数据修改操作都必须先写入一个称为WAL的日志文件中，然后再将其写入数据库本身。这样可以确保在发生故障时，可以使用WAL日志文件来恢复数据库状态。</p></blockquote><h3 id="4-2-3、读（Reads）"><a href="#4-2-3、读（Reads）" class="headerlink" title="4.2.3、读（Reads）"></a>4.2.3、读（Reads）</h3><p>在Aurora中，与大多数数据库一样，数据页是从buffer cache中读取，只有在被请求的页不在cache中时，才会发起一次存储IO请求。</p><p>如果buffer cache满了，系统会找到一个页并将其踢出缓存。在传统的数据库中，如果这个被踢出的页是脏页，它在被替换之前会被刷新到数据盘中。这是为了保证接下来读取的数据页永远是最新的数据。不过Aurora在踢出页的时候不会写磁盘，它提供了一个类似的保证：buffer cache中的数据页永远是最新的数据。这个保证通过踢出page LSN（数据页上应用的最新的日志记录的LSN）大于或者等于VDL的数据页来实现。这个协议确保：（a）所有对数据页的变更都已经持久化在日志中了，（b）如果缓存失效，可以通过获取最新页来构造当前VDL所对应的页面。</p><p>数据库在通常情况下都不要通过多数派读来获得一致性。当从盘里面读一个页的时候，数据库建一个读取点，代表请求发生时的VDL。数据库可以选择一个对这个读取点是完整的存储节点，这样读取的数据肯定是最新的版本。从存储节点返回的数据页必须与数据库中mini事务的语义一致。由于数据库直接将日志记录发送给存储节点，并跟进日志处理的进程（也就是，每个数据段的SCL），通常它知道哪些数据段是可以满足一个读请求的（SCL大于读取点的数据段），因而可以直接将请求发送给有足够数据的数据段。</p><p>考虑到数据库记录了所有的当前读操作，因而可以计算出在任意时间点每个PG的最小读取点LSN。如果有读副本，写副本会与它们沟通获取所有存储节点上每个PG的最小读取点LSN。这个值称作PG最小读取点LSN（PGMRPL），代表低水位点。在此以下的PG的所有的日志记录都是不必要的。换句话说，存储节点中数据段确认不会再有读取请求的读请求点小于PGMRPL。每个存储节点都能通过数据库获取到这个值，并且能合并老的日志记录并继续生产新的数据页，然后放心的将这些日志记录回收掉。</p><p>跟传统的MySQL数据库一样，实际的并发控制协议在数据库引擎中执行，就像数据页和UNDO段在本地存储一般。</p><h3 id="4-2-4、副本（Replicas）"><a href="#4-2-4、副本（Replicas）" class="headerlink" title="4.2.4、副本（Replicas）"></a>4.2.4、副本（Replicas）</h3><p>在Aurora中，一个写副本和多至15个读副本可以挂载同一个共享的存储空间。因而，读副本不会增加任何的存储和写开销。为了减少延时，写副本产生的日志流发送到存储节点的同时，也会发送到所有的读副本。在读副本中，数据库会依次消耗每一个日志记录。如果日志记录指向的是一个buffer cache中存在的页，它就用log applicator应用日志的变更到数据页上。否则的话，它就直接丢掉这条日志。注意，从写副本的角度来看，读副本是异步的消耗这些日志，而写副本确认用户事务的完成是与读副本无关的。读副本在应用这些日志的时候遵守两条重要的规则：（a）只有SDL小于或者等于VDL的日志记录会被应用，（b）一个mini事务中的日志记录会原子的被应用，确保副本可以看到所有数据库对象的一致性视图。在实际中，每个读副本滞后写副本一小段时间（20ms或以内）。</p><h2 id="4-3、故障恢复（Recovery）"><a href="#4-3、故障恢复（Recovery）" class="headerlink" title="4.3、故障恢复（Recovery）"></a>4.3、故障恢复（Recovery）</h2><p>大多数传统的数据库使用类似ARIES的恢复协议，这些协议依赖可以代表所有已提交事务的WAL。这些系统也会粗粒度的为数据库周期性的，通过刷新脏页和将检查点写入日志，来建立检查点。在重启的时候，一个数据页可能丢失一些已经提交的数据，或者包含未提交的数据。因而，在故障恢复的时候，系统重放自上一个检查点其的所有REDO日志到相关的数据页。这个过程将数据库的页重新置为在故障发生那个时间点的一致性状态，之后通过执行相关的UNDO日志可以将正在执行的事务回滚。故障恢复是一个代价昂贵的操作。降低建立检查点的时间间隔会有所帮助，不过是以干扰前台事务为代价的。在Aurora中不需要做这样的折中。</p><p>传统数据库的一个简化规则是，在前台处理和故障恢复同步使用的REDO日志applicator，也会在数据库离线在后台服务中使用。在Aurora中，我们也依赖于同样的规则，只不过这里REDO applicator是与数据库解耦的，一直并行的在后台运行在存储节点上。当数据库启动的时候，它会与存储服务协助进行数据恢复，因而Aurora数据库可以恢复非常快（通常在10s以内），即使在崩溃的时候正在执行100K TPS的写入。</p><p>数据库在故障重启的时候仍然需要重建运行时状态。在这种情况下，数据库连接每一个PG，数据段的读多数派如果能确认发现其他数据，也可以形成一个写多数派。一旦数据库为每一个PG建立了读多数派，它可以计算出REDO可以截断的范围，这个范围是新的VDL到当前数据库已经分配的最大的LSN。数据库能推导出这个上限值，是因为它分配LSN，并且限制了最大的LSN为VDL+LAL（之前已经介绍过的，值为10m）。这些截断范围是用时间戳来标记的并且写到存储服务中，因而在截断的时候并没有任何歧义，即使恢复过程被打断或者重启。</p><p>数据库仍然需要执行UNDO恢复来回滚在故障时间点正在进行的事务。不过，UNDO恢复可以在系统启动后通过UNDO段来获取正在进行的事务之后再进行。</p><h1 id="5、整体来看（PUTTING-IT-ALL-TOGETHER）"><a href="#5、整体来看（PUTTING-IT-ALL-TOGETHER）" class="headerlink" title="5、整体来看（PUTTING IT ALL TOGETHER）"></a>5、整体来看（PUTTING IT ALL TOGETHER）</h1><p>在这一节中，我们从整体来描述构成Aurora的组件，如图5所示。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051052717.png"></p><p>数据库引擎是社区版MySQL/InnoDB的分支，主要区别是InnoDB如何从数据盘读取或者写入数据。在社区版InnoDB中，一个写操作的执行包括:数据页在buffer中被修改，REDO日志按LSN有序写入到WAL的buffer中。在事务提交的时候，WAL协议只要求事务的REDO日志写入到数据盘。真正被修改的数据页最终会写入数据盘，这里使用了双写技术来避免数据写盘不完整。这些数据页的写入可能发生在后台，可能由于cache的踢出，也有可能由于建立检查点。除了IO子系统之外，InnoDB还有事务子系统，通过B+树和mini事务实现的锁管理器。Mini事务是只在InnoDB中使用的结构，描述的是一组必须原子执行的操作（比如，分裂或者合并B+树的页）。</p><p>在Aurora版本的InnoDB中，每个Mini事务中的REDO日志会按所属的PG分组打包，然后批量写入存储服务中。每个Mini事务的最后一个日志记录被标记为一个一致性点。Aurora写副本支持社区版MySQL相同的隔离级别。Aurora的读副本会不断的从写副本中获取事务开始和提交的信息，并使用这些信息来支持本地只读事务的快照隔离级别。注意到并发控制完全在数据库引擎中实现，不会影响存储服务。存储服务为数据提供一个一致性的视图，在逻辑上等价于社区版InnoDB写数据到本地存储。</p><p>Aurora使用Amazon RDS来作为它的控制面板。RDS在数据实例上部署Agent来监控集群的健康状况，是否需要做故障切换，或者实例是否应该被替换掉。每个数据库集群包括一个写副本，0个或者多个读副本。集群中所有的实例都在一个地理上的区域（Region）中，通常会位于不同的可用区，连接到相同区域里面的存储服务。为安全性考虑，我们隔离了数据库，应用以及存储之间的通信。在实际中，每个数据库实例可以与三个Amazon虚拟网络VPC通信：用户应用与数据库引擎交互的用户VPC，数据库引擎与RDS控制面板交互的RDS VPC，数据库与存储服务交互的存储VPC。</p><p>存储服务部署在一个EC2虚拟机集群上，集群最少会跨同一个Region的三个可用区AZ，共同为多个用户提供存储，读取或者写入数据，备份或者恢复用户数据。存储节点操作本地的SSD盘，与数据库实例、其他存储节点、备份/恢复服务交互，持续地将<a href="https://cloud.tencent.com/solution/backup?from=20065&from_column=20065">数据备份</a>到S3或者从S3恢复数据。存储服务的控制面板用Amazon DynamoDB作为持久存储，存放数据库容量配置、元数据以及备份到S3上的数据的详细信息。为了支持长时间的操作，比如由故障导致的数据库恢复或者复制操作，存储服务的控制面板使用Amazon Simple Workflow Service SWF。为了保证高质量的可用性，需要在用户发现之前积极的、自动的监控和探测真实的和潜在的问题。所有存储服务的关键操作都被持续的监控起来，如果发现性能或者可用性方面的潜在问题会及时告警。</p><h1 id="6、性能测试结果（PERFORMANCE-RESULTS）"><a href="#6、性能测试结果（PERFORMANCE-RESULTS）" class="headerlink" title="6、性能测试结果（PERFORMANCE RESULTS）"></a>6、性能测试结果（PERFORMANCE RESULTS）</h1><p>在这一节中，我们分享自2015年7月Aurora GA之后在生产环境运营的经验。首先介绍标准的工业基准测试的结果，接着是一些来自客户的性能测试结果。</p><h2 id="6-1、标准基准测试的结果（Results-with-Standard-Benchmarks）"><a href="#6-1、标准基准测试的结果（Results-with-Standard-Benchmarks）" class="headerlink" title="6.1、标准基准测试的结果（Results with Standard Benchmarks）"></a>6.1、标准基准测试的结果（Results with Standard Benchmarks）</h2><p>我们使用标准的基准测试工具SysBench和TPC-C类似测试工具来进行测试，对比了Aurora和MySQL在不同场景下的性能表现。我们在带有20K IOPS EBS的EC2实例上进行测试，除非特殊说明，这些实例的规格为32 vCPU,244G内存，Intel Xeon E5-2670 v2（Ivy bridge）处理器。实例上的buffer cache设为170G。</p><h3 id="6-1-1、随实例规格扩展（Scaling-with-instance-sizes）"><a href="#6-1-1、随实例规格扩展（Scaling-with-instance-sizes）" class="headerlink" title="6.1.1、随实例规格扩展（Scaling with instance sizes）"></a>6.1.1、随实例规格扩展（Scaling with instance sizes）</h3><p>在这个测试中，我们发现Aurora的吞吐量可以随着实例规格线性增长，在最高实例规格上吞吐量是MySQL5.6或者MySQL5.7的5倍。而Aurora目前是基于MySQL5.6的代码库的。我们在EC2 r3系列实例（large，xlarge，2xlarge，4xlarge，8xlarge）上运行1GB数据量大小（250张表）的只读或者只写的基准测试。R3系列的每个实例的vCPU和内存数量是下一个比它大的规格的一半。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051112208.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051112766.png"></p><p>在这个测试中，我们发现Aurora的吞吐量可以随着实例规格线性增长，在最高实例规格上吞吐量是MySQL5.6或者MySQL5.7的5倍。而Aurora目前是基于MySQL5.6的代码库的。我们在EC2 r3系列实例（large，xlarge，2xlarge，4xlarge，8xlarge）上运行1GB数据量大小（250张表）的只读或者只写的基准测试。R3系列的每个实例的vCPU和内存数量是下一个比它大的规格的一半。</p><h3 id="6-1-2、不同数据集大小下的吞吐量（Throughput-with-varying-data-sizes）"><a href="#6-1-2、不同数据集大小下的吞吐量（Throughput-with-varying-data-sizes）" class="headerlink" title="6.1.2、不同数据集大小下的吞吐量（Throughput with varying data sizes）"></a>6.1.2、不同数据集大小下的吞吐量（Throughput with varying data sizes）</h3><p>在这个测试中，我们发现Aurora的吞吐量远大于MySQL，即使使用更大的数据集且包括cache之外的数据。表2展示使用SysBench的纯写入测试，使用100GB大小数据集Aurora可以比MySQL快67倍。即使是使用1TB包含Cache外数据的测试集，Aurora也比MySQL快34倍。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051113493.png"></p><h3 id="6-1-3、随用户连接数扩展（Scaling-with-user-connections）"><a href="#6-1-3、随用户连接数扩展（Scaling-with-user-connections）" class="headerlink" title="6.1.3、随用户连接数扩展（Scaling with user connections）"></a>6.1.3、随用户连接数扩展（Scaling with user connections）</h3><p>在这个测试中，我们发现Aurora的吞吐量可以随着客户端的连接数量而扩展。表3展示了运行SysBench OLTP基准测试的writes/sec结果，测试中连接数从50到500再到5000。Aurora可以从40K writes/sec扩展到110K writes/sec，MySQL的吞吐量在500个连接左右时达到峰值，然后随着连接数扩展到5000而急速下降。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051114784.png"></p><h3 id="6-1-4、随副本数扩展（Scaling-with-Replicas）"><a href="#6-1-4、随副本数扩展（Scaling-with-Replicas）" class="headerlink" title="6.1.4、随副本数扩展（Scaling with Replicas）"></a>6.1.4、随副本数扩展（Scaling with Replicas）</h3><p>在这个测试中，我们发现Aurora读副本的延时比MySQL低很多，即使Aurora处在更高的负载情况下。表4展示了，随着负载从1K writes/sec到10K writes/sec，Aurora读副本的延时从2.62ms增长到5.38ms。相反，MySQL读副本的延时从1s增长到300s。在10K负载情况下，Aurora的副本延时比MySQL低几个数量级。副本延时通过一个被提交的事务在副本上可见所需要的时间来度量的。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051115710.png"></p><h3 id="6-1-5、热点行争用时的吞吐量（Throughput-with-hot-row-contention）"><a href="#6-1-5、热点行争用时的吞吐量（Throughput-with-hot-row-contention）" class="headerlink" title="6.1.5、热点行争用时的吞吐量（Throughput with hot row contention）"></a>6.1.5、热点行争用时的吞吐量（Throughput with hot row contention）</h3><blockquote><p>“hot row contention”表示热点行争用，即多个事务同时尝试修改同一行数据时发生的竞争和冲突。</p></blockquote><p>在这个测试中，我们发现相对于MySQL，Aurora在像TPC-C基准测试中有hot row contention的负载下也能表现的很好。我们在Aurora、MySQL5.6、MySQL5.7上运行Percona TPC-C类似工具，运行实例规格为r3.8xlarge挂载IOPS为30K的EBS。表5展示了Aurora可以保持相对MySQL5.7 的2.3倍到16.3倍的吞吐量，负载从10GB数量、500个连接，到100GB数据、5000个连接。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051118095.png"></p><h2 id="6-2、客户端真实负载的测试结果（Results-with-Real-Customer-Workloads）"><a href="#6-2、客户端真实负载的测试结果（Results-with-Real-Customer-Workloads）" class="headerlink" title="6.2、客户端真实负载的测试结果（Results with Real Customer Workloads）"></a>6.2、客户端真实负载的测试结果（Results with Real Customer Workloads）</h2><p>在这一小节中，我们分享一些客户在生产环境从MySQL迁移到Aurora的测试结果。</p><h3 id="6-2-1、应用程序在Aurora的响应时间（Application-response-time-with-Aurora）"><a href="#6-2-1、应用程序在Aurora的响应时间（Application-response-time-with-Aurora）" class="headerlink" title="6.2.1、应用程序在Aurora的响应时间（Application response time with Aurora）"></a>6.2.1、应用程序在Aurora的响应时间（Application response time with Aurora）</h3><p>一个互联网游戏公司将生产环境的服务从MySQL迁移到r3.4xlarge实例的Aurora上。在迁移之前，网络事务的平均响应时间为15ms。与之对应的，迁移之后的平均响应时间为5.5ms，差不多有了3倍的提升，如图8所示。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051125307.png"></p><h3 id="6-2-2、Aurora中执行语句的延时（Statement-Latencies-with-Aurora）"><a href="#6-2-2、Aurora中执行语句的延时（Statement-Latencies-with-Aurora）" class="headerlink" title="6.2.2、Aurora中执行语句的延时（Statement Latencies with Aurora）"></a>6.2.2、Aurora中执行语句的延时（Statement Latencies with Aurora）</h3><p>一个教育公司主要业务是帮助学校管理学生的笔记本电脑，将他们的服务从MySQL迁移到了Aurora。Select和单条记录insert语句在迁移前的中位点和95分位点如图9和图10所示。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051126121.png"></p><p>在迁移之前，95分位延时在40ms到80ms之间，比中位点1ms差得远了。本文之前介绍了，应用程序会遇到这种少数性能极差的情况。在迁移之后，95分位的延时显著降低，接近中位点延时。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051126823.png" alt="、"></p><h3 id="6-2-3、多个副本下的复制延时（Replica-Lag-with-Multiple-Replicas）"><a href="#6-2-3、多个副本下的复制延时（Replica-Lag-with-Multiple-Replicas）" class="headerlink" title="6.2.3、多个副本下的复制延时（Replica Lag with Multiple Replicas）"></a>6.2.3、多个副本下的复制延时（Replica Lag with Multiple Replicas）</h3><p>如Pinterest的Weiner所指出的，MySQL副本经常远落后于他们的写副本，会引起非常奇怪的bug。对于上面提到的那个教育公司，副本延时有时可能飙升到12分钟而影响到应用程序的正确性，所以这些副本只能作为一个备机。与之相对的，在迁移到Aurora之后，4个副本集的复制延时从未超过20ms，如图11所示。复制延时的显著改善让这家公司转移了一大部分应用程序的负载到只读副本上，既节约了成本又提高了可用性。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051131889.png"></p><h1 id="7、心得（LESSONS-LEARNED）"><a href="#7、心得（LESSONS-LEARNED）" class="headerlink" title="7、心得（LESSONS LEARNED）"></a>7、心得（LESSONS LEARNED）</h1><p>我们遇到过运行各种各样的应用的客户，从小的互联网公司到大型的组织机构。他们很多的使用场景都是标准的，这里我们重点放在在云服务中比较常见的场景和期望，而这些导致我们走向了新的方向。</p><h2 id="7-1、多客户和数据库聚合（Multi-tenancy-and-database-consolidation）"><a href="#7-1、多客户和数据库聚合（Multi-tenancy-and-database-consolidation）" class="headerlink" title="7.1、多客户和数据库聚合（Multi-tenancy and database consolidation）"></a>7.1、多客户和数据库聚合（Multi-tenancy and database consolidation）</h2><p>很多我们的客户都经营SaaS服务，自己使用或者为他们自己的客户提供SaaS模型的服务。我们发现这些客户依赖的应用程序很难被改变。因而，他们通常将自己的很多客户集中在某一个实例上，使用库或者表来作为租赁的基本单位。这种模式可以节约成本：由于他们自己的客户不太可能同时使用，这样可以避免为每个客户申请一个单独的实例。举个例子，我们有些客户称他们自己有超过50K的客户。</p><p>这个模型与Salesforce.com著名的多客户应用场景有很大的不同，他们将数据打包到一个统一的表中，按行来租赁。因而，我们发现很多客户有很多张表。生产环境中数据库表超过150K是非常常见的。这给一些管理元数据的组件，如字典cache，带来很大压力。更重要的是，这些客户需要（a）保持高吞吐量和连接数，（b）存储容量按使用扩展和收费，因为很难提前预知需要多大的存储，（c）减少抖动，这样一个客户的峰值对其他客户的影响很小。Aurora支持所有的这些特性，而且很适合SaaS应用。</p><h2 id="7-2、高并发自动扩展的负载（Highly-concurrent-auto-scaling-workloads）"><a href="#7-2、高并发自动扩展的负载（Highly-concurrent-auto-scaling-workloads）" class="headerlink" title="7.2、高并发自动扩展的负载（Highly concurrent auto-scaling workloads）"></a>7.2、高并发自动扩展的负载（Highly concurrent auto-scaling workloads）</h2><p>互联网的负载通常需要应对突发事件引起的网络流的尖峰。我们有个重要客户在一个很火的全国电视节目时，遇到过一次远超过平时负载吞吐量高峰的流量，不过没有对数据库构成压力。为了支持这样的突发流量，数据库需要同时能处理很多并发的请求。Aurora在这种场景下也能处理的很好，因为它的底层存储系统扩展性极好。我们有很多客户每秒钟的连接数超过8000次。</p><h2 id="7-3、Schema演进（Schema-evolution）"><a href="#7-3、Schema演进（Schema-evolution）" class="headerlink" title="7.3、Schema演进（Schema evolution）"></a>7.3、Schema演进（Schema evolution）</h2><p>现代Web应用程序框架如Ruby on Rails深入集成了ORM工具。因而，应用程序可以很方便的改变数据库的schema，然而却让DBA们很难把握schema会如何演进。在Rails应用程序中，这些称之为DB迁移，我们听到一线的DBA称他们一周可能会有几十次DB迁移，或者会提前准备好策略来让未来的变更会比较容易。这些问题在MySQL中被放大，因为MySQL提供自由的schema变更语义，使用整表拷贝的方式来实现大多数变更。既然频繁的DDL是一个现实问题，我们在Aurora中实现了高效的在线DDL，（a）为每一个数据页关联一个schema版本，通过schema的变更历史来解码单个数据页，（b）用modify-on-write的方式按需将单个数据页更新到最新的schema。</p><blockquote><p>DDL：数据库定义语言Data Definition Language</p></blockquote><h2 id="7-4、可用性和软件更新（Availability-and-Software-Upgrades）"><a href="#7-4、可用性和软件更新（Availability-and-Software-Upgrades）" class="headerlink" title="7.4、可用性和软件更新（Availability and Software Upgrades）"></a>7.4、可用性和软件更新（Availability and Software Upgrades）</h2><p>客户对云上的数据库的一些迫切的期待与我们如何运营系统和如何给服务器升级可能是相互矛盾的。由于我们的客户主要用Aurora来作为一个OLTP服务支撑线上应用程序，任何的干扰都可能导致严重的后果。因而，很多客户对我们更新数据库软件的容忍度是非常低的，即使在六周内只计划30s的服务暂停时间也不行。我们近期发布了一个Zero Downtime Patch ZDP特性，使得我们可以在保证已有的数据库连接不受干扰的情况下，更新服务器。</p><blockquote><p>ZDP指的是Zero-Downtime Patching，即零停机补丁。它是一种用于在不中断服务的情况下对数据库引擎进行升级和修补的技术。</p></blockquote><p>如图12所示，ZDF的原理是，首先找到一个没有活动连接的实例，将实例的应用程序状态导出到持久化存储中，给引擎升级，然后导入应用程序状态。在这个过程中，用户的session不受影响，对引擎的升级是无感知的。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305051142833.png"></p><h1 id="8、相关工作（RELATED-WORK）"><a href="#8、相关工作（RELATED-WORK）" class="headerlink" title="8、相关工作（RELATED WORK）"></a>8、相关工作（RELATED WORK）</h1><p>在本节中，我们介绍其他人的贡献以及它们如何Aurora中采用的方案关联的。</p><p><strong>存储计算分离。</strong></p><p>尽管传统的数据库系统都会被构造成一个庞然大物，近期有一些数据库方面的工作将内核解耦为不同的组件。举个例子，Deuteronomy10就是这样的系统，它分离了提供并发控制的事务组件，和提供恢复功能构建在LLAMA34的数据组件，其中LLAMA是一个无锁、日志结构的缓存和存储管理器。Sinfonia39和Hyder40这些系统将事务的方法抽象成一个可扩展的服务，数据库系统的实现可以使用这些抽象。Yesquel36实现了一个多版本的分布式平衡树，将并发控制和查询处理器分开。Aurora比Deuteronomy、Sinfonia、Hyder和Yesquel在更低的层次将存储解耦出来。在Aurora中，查询处理器、事务、并发控制、buffer cache和访问方式是与日志、存储、故障恢复解耦的，后者被实现为可扩展的服务。</p><p><strong>分布式系统。</strong></p><p>在CAP理论中，人们早已知道正确性和可用性的权衡，以及面对分区的条件下，one-copy序列化是不可能的。最近，Brewer的CAP理论得到结论：一个高度可用的数据库系统在网络隔离的情况下不可能提供强一致性。这些结论以及我们对云级别规模的复杂且相互关联故障的经验，促使我们定下即使在一个AZ不可用的条件下仍然保持一致性的设计目标。</p><p>Bailies等人研究了高可用事务HATs，HAT既不会受网络分区导致的不可用的影响，又不会导致高的网络延时。他们的工作说明了Serializability,Snapshot Isolation, Repeatable Isolation不是HTA兼容的。Aurora提供所有这些隔离级别，基于一个简化的前提：在任意一个时间点，只有一个写副本在生成日志，这些日志的LSN在同一个有序空间里分配。</p><p>Google的Spanner提供外部一致的读和写，全局一致的指定时间点的读。这些特性可以让Spanner提供全局的一致的备份，全局的一致的分布式查询处理，全局的原子的schema更新，即使是在有事务正在执行的情况下。就像Bailis所描述的，Spanner是为Google读负载高的场景定制的，在读和写的时候依赖于两阶段提交和两阶段锁。</p><p><strong>并发控制。</strong> </p><p>弱一致性以及隔离模型在分布式数据库中是广为人知的，也导致了乐观复制技术和最终一致性系统的出现。集中式系统的一些方案包括，经典的悲观锁方式，如Hekaton中的MVCC的乐观锁方式，如VoltDB中的分片模式，Hyper中的时间戳序列模式，还有Deuteronomy。Aurora的存储服务为数据库引擎提供了一个本地磁盘的抽象，让引擎来决定隔离级别和并发模式。</p><p><strong>日志结构的存储。</strong></p><p>日志结构的存储在1992年首先出现在LFS中。最近的Deuteronomy以及LLAMA中的相关工作，还有Bw-Tree在存储引擎栈中以多种形式使用了日志结构的技术，像Aurora一样，它们通过只写数据页的变更来减少写放大。Deuteronomy和Aurora实现的都是纯粹的REDO日志方式，并跟踪事务确认回复的最大的LSN。</p><p><strong>故障恢复。</strong></p><p>传统的数据库都依赖于类似ARIES5的恢复协议来实现故障恢复，近期很多系统为性能的考虑选择了其他的路径。举个例子，Hekaton和VoltDB使用某种更新日志来重建它们的内存状态。类似Sinfonia的系统，使用process pairs和状态机复制技术来避免故障恢复。Graefe介绍了使用每页的日志记录链来加快按需的page-by-page的REDO以加快恢复速度。跟Aurora一样，Deuteronomy不需要REDO恢复，这是因为Deuteronomy只会将已经提交的更新写入存储。因而，不像Aurora，Deuteronomy里的事务数量是受限制的。</p><h1 id="9、结论（Conclusion）"><a href="#9、结论（Conclusion）" class="headerlink" title="9、结论（Conclusion）"></a>9、结论（Conclusion）</h1><p>我们在云环境下将Aurora设计为一个高吞吐量的OLTP数据库，不牺牲可用性和可持久性。主要的思想是避免传统数据库庞大复杂的结构，将存储和计算解耦。具体来说，我们将数据库内核最下面一小部分移到一个独立可扩展分布式的负责日志记录和存储数据的存储服务中。由于这时所有的IO都通过网络，我们最根本的限制变成了网络。因而，我们将重点放在缓解网络开销、增加吞吐量的技术上。我们依赖的技术有：<strong>多数派模型</strong>，可以处理在大规模云服务环境下复杂关联的故障，避免最差性能点的惩罚，通过<strong>日志处理</strong>来减少整体的IO负担，<strong>异步的一致性</strong>来避免沟通复杂且代价昂贵的多阶段同步协议，离线故障恢复，在分布式存储中建立检查点。我们的方案能得出一个简化的复杂度降低的系统，可以很方便的扩展，并为以后的演进奠定基础。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Aurora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRAQ</title>
      <link href="/2023/050563813.html"/>
      <url>/2023/050563813.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>大型存储系统通常会在许多可能出故障的组件上进行数据复制和数据分区，从而保证可靠性和可扩展性。但是许多商业部署系统为了实现更高的可用性和吞吐量，牺牲了强一致性，特别是那些实时交互系统。</p><p>本论文介绍了CRAQ的设计、实现和评估。CRAQ是一个挑战上述不灵活的权衡的<strong>分布式对象存储系统</strong>。我们的基本方法是对链式复制进行改进，在保证强一致性的同时，大幅提高读取吞吐量。通过在所有对象副本上分配负载，CRAQ可以随链的大小线性扩展，而无需增加一致性协调。同时，为了满足某些应用程序的需求，CRAQ提供了弱一致性保证，这在系统处于高故障时期尤其有用。本文探讨了为跨多个数据中心进行地理复制的CRAQ存储而进行的额外设计和实现，从而提供优化局部性的操作。本文也讨论了多对象原子更新和大对象更新的多播优化。</p><h1 id="1、引言（Introduction）"><a href="#1、引言（Introduction）" class="headerlink" title="1、引言（Introduction）"></a>1、引言（Introduction）</h1><p>许多在线服务需要基于对象的存储，将数据作为整个单元呈现给应用程序。对象存储支持两个基本原语：<em>读</em>（或查询）操作返回以对象名称存储的数据块，<em>写</em>（或更新）操作修改单个对象的状态。这一类基于对象的存储由键值数据库（例如BerkeleyDB或Apache的CouchDB）支持，并部署到商业数据中心（例如Amazon的Dynamo，Facebook的Cassandra以及Memcached）。为了在这类系统中实现可靠性、负载平衡和可扩展性，对象命名空间在许多机器上进行了分区，每个数据对象都被复制了几次。</p><p>当应用程序具有某些需求时，基于对象的系统比文件系统更有吸引力。与层次目录结构相反，对象存储更适合水平命名空间，例如键值数据库。对象存储简化了支持整个对象修改的过程。而且，他们通常只需要推理对特定对象的修改顺序，而不是整个存储系统；为每个对象提供一致性保证要比为所有操作和/或对象提供一致性保证代价要低得多。</p><blockquote><p>水平命名空间(Flat namespace)指没有层次结构的命名空间，其中所有对象都处于同一级别。如键值数据库</p><p>层次目录结构(hierarchical directory structures)将对象组织成树形结构，每个节点都有一个唯一的路径。如文件系统</p></blockquote><p>在构建作为众多应用程序基础的存储系统时，商业站点将高性能和高可用的需求放在首位。复制数据是为了承受单个节点甚至整个数据中心的故障带来的威胁，无论这个故障是计划内的还是计划外的。确实在新闻媒体中处处可见数据中心离线导致期间整个网站都被关闭了的例子。对可用性和性能的高度关注，导致许多商业系统由于感知成本而牺牲了强一致性语义（例如Google、Amazon、eBay、Facebook等）。</p><p>Van Renesse和Schneider近期提出了一种为对象存储在故障停止服务器上的链式复制方法，该方法旨在提供强一致性的同时提高吞吐量。基本方法是将所有存储对象的节点组织在一条链中，其中链的尾节点处理所有读取请求，而链的头节点处理所有写入请求。在客户端收到确认之前，写操作沿链向下传播，因此尾节点可以得到所有对象操作的执行顺序，具有强一致性。该方法没有任何复杂或多轮通信的协议，但是提供了简单、高吞吐量和容易故障恢复的特性。</p><p>不幸的是，基础的链复制方法有一些局限性。对一个对象的所有读取都在头节点，从而导致潜在的热点问题。虽然可以通过一致性哈希方法或更中心化的目录方法将集群中的节点组织到多个链中，以实现更好的负载均衡，但是如果特定对象访问较少，这些算法仍然可能会负载不平衡，这在实践中是一个真实的问题。当尝试跨多个数据中心构建链式，甚至可能出现更严重的问题，因为所有的读取操作都可能会由一个远距离节点（链的尾节点）处理。</p><p>本文介绍了CRAQ的设计、实现和评估，CRAQ是一个对象存储系统，在保持链式复制的强一致性特性的同时，通过支持分配查询为读取操作提供了较低的延迟和较高的吞吐量；分配查询指的是将读取操作分配给链中的所有节点执行，而不是所有操作都由单个主节点处理。本文的主要贡献如下：</p><ol><li>CRAQ使任何链节点都能在保持强一致性的同时处理读操作，从而支持存储对象在所有节点之间的负载平衡。此外，当大多数工作负载是读取操作时，（例如GFS和Memcached系统中做的假设），CRAQ的性能可以和仅提供最终一致性的系统相媲美。</li><li>除了强一致性外，CRAQ的设计还自然支持读操作之间的最终一致性，从而降低写操作期间的等待时间，并在短暂的分区期间降级为只读。CRAQ允许应用程序指定读取操作可接受的最大过期时间。</li><li>利用负载均衡的特性，我们介绍了一种广域系统设计，用于在跨地理位置的集群中构建CRAQ链，并保留了强局部性。具体而言，读操作可以由本地集群进行处理，在最坏情况下（高写争用的时候），需要在广域网中传输简短的元数据信息。我们还介绍了使用Zookeeper（一种类似于PAXOS的组成员系统）来管理部署。</li></ol><p>最后，我们讨论了CRAQ的其他扩展，包括将微事务集成到多对象原子更新中，以及使用多播来提高大对象更新的写入性能。但是，我们尚未完成这些优化的实现。</p><p>CRAQ的初步性能评估显示，与基础的链式复制方法相比，它具有更高的吞吐量，在大多数负载都是读操作的情况下，吞吐量与节点的数量成正比：三节点的链可以提升约200%的吞吐量，七节点的链可以提升约600%的吞吐量。在高写争用的情况下，CRAQ在三节点的链中的读取吞吐量仍然比基础的链式复制高出两倍，并且读取延迟较低。我们总结了CRAQ在各种工作负载和故障情况下的性能。最后，我们评估了CRAQ在跨地域复制方面的性能，证明其延迟远低于基础链式复制方法的延迟。</p><p>本文的剩余部分安排如下，第2节介绍了基础链式复制与CRAQ协议之前的对比，以及CRAQ的最终一致性支持。第3节介绍了CRAQ在单数据中心和跨数据中心扩展到多条链的方法，以及管理链和节点的组成员服务。第4节涉及到诸如多对象更新和利用多播等扩展。第5节介绍了CRAQ的实现，第6节展示了CRAQ的性能评估，第7节回顾了相关工作，第8节进行总结。</p><h1 id="2、基础系统模型（Basic-System-Model）"><a href="#2、基础系统模型（Basic-System-Model）" class="headerlink" title="2、基础系统模型（Basic System Model）"></a>2、基础系统模型（Basic System Model）</h1><p>本节介绍了我们基于对象的接口和一致性模型，简要概述了标准的链式复制模型，然后介绍了强一致的CRAQ模型及其变体。</p><h2 id="2-1、接口和一致性模型（Interface-and-Consistency-Model）"><a href="#2-1、接口和一致性模型（Interface-and-Consistency-Model）" class="headerlink" title="2.1、接口和一致性模型（Interface and Consistency Model）"></a>2.1、接口和一致性模型（Interface and Consistency Model）</h2><p>基于对象的存储系统为用户提供了两个简单的原语：</p><ul><li><code>write(objID,V)</code>：写（更新）操作存储与对象标识符<code>objID</code>关联的值V</li><li><code>V &lt;- read(objID)</code>：读（查询）操作检索与对象标识符<code>objID</code>关联的值V</li></ul><p>我们将讨论关于单个对象的两种主要的一致性类型</p><ul><li><strong>强一致性</strong> 我们系统中的强一致性保证对于单个对象的所有的读和写操作均按一定顺序执行，并且对于单个对象的读始终能看到最新的值。</li><li><strong>最终一致性</strong> 我们系统中的最终一致性意味着对单个对象的写入仍然按一定顺序应用于所有的节点，但是对于不同的节点，最终一致性读可能在一段时间内返回旧数据（即在写入被应用到所有节点之前）。但是，一旦所有的副本接收到写入请求后，读操作将永远不会返回比最近提交的写入版本更旧的版本。实际上，如果客户端保持与一个特定节点的会话（尽管不是与不同的节点的会话），则会看到单调的读一致性（注：即对于一个对象的读取将返回相同的先前的值或一个更新的值，但是绝不会返回旧版本的值）。</li></ul><p>接下来，我们介绍一下链式复制和CRAQ是如何提供强一致性的。</p><h2 id="2-2、链式复制（Chain-Replication）"><a href="#2-2、链式复制（Chain-Replication）" class="headerlink" title="2.2、链式复制（Chain Replication）"></a>2.2、链式复制（Chain Replication）</h2><p>链式复制（CR）是一种在多节点之间复制数据的方法，提供了强一致性的存储接口。节点组成一条长度为C的<em>链</em>。链的<em>头节点</em>处理来自客户端的所有<em>写</em>操作。当节点收到写操作的请求时，他会继续传播给链中的下一个节点。一旦写操作请求到达尾节点，该操作就已经被应用到了链中的所有副本中，此时认为该写操作<em>已提交</em>。尾节点处理所有的读操作，因此只有已提交的值才会被返回。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021711409.png"></p><p>图1提供了一个长度为四的链的实例。所有读请求的到达和处理都在尾节点。写请求到达链的头部，并向下传播到尾部。当尾节点提交写操作后，向客户端发送回复。CR论文中介绍由尾节点直接向客户端发送消息；由于我们使用TCP，因此我们的实现实际由头部节点复用之前与客户端的连接，在收到尾节点的确认后直接进行响应。确认回传在图中用虚线表示。</p><p>CR简单的拓扑结构使写操作比其他提供强一致性的协议成本更低。多个并发写入可以在链中进行流水线传输，传输成本平摊在所有节点上。之前工作的模拟结果显示，与主/备复制相比，CR具有更高的吞吐量，同时还能更快、更容易地恢复。</p><p>链式复制实现了强一致性：由于所有的读都在尾部进行，并且所有的写入只有当到达尾部后才提交，因此链的尾部可以按序应用所有的操作。然而，这的确要付出一些代价，因为只有一个节点处理读操作，因此降低了读操作的吞吐量，无法随着链的长度增加而进行扩展。但是这是有必要的，因为查询中间节点可能为违反强一致性保证；特别是，在传播过程中，对不同节点的并发读取可能会看到不同的写入值。</p><p>尽管CR专注于提供存储服务，但也可以将其查询/更新协议视为复制状态机的接口。尽管本文的剩余部分仅从读/写对象存储接口两个角度考虑问题，但可以用类似的角度看待CRAQ。</p><h2 id="2-3、分摊查询的链式复制（Chain-Replication-with-Apportioned-Queries）"><a href="#2-3、分摊查询的链式复制（Chain-Replication-with-Apportioned-Queries）" class="headerlink" title="2.3、分摊查询的链式复制（Chain Replication with Apportioned Queries）"></a>2.3、分摊查询的链式复制（Chain Replication with Apportioned Queries）</h2><p>受到只读工作负载环境的流行的推动，CRAQ试图通过允许链中的任意节点都来处理读操作，同时仍提供强一致性保证，来提高吞吐量。CRAQ主要的扩展如下：</p><ol><li>CRAQ中的单个节点允许存储对象的多个版本，每个版本都包含一个单调递增的版本号以及一个附加属性：该版本是脏的还是干净的。所有的版本初始化标记为干净。</li><li>当节点收到对象的新版本时（通过沿链路向下传播的写操作），该节点将此最新版本附加到该对象的列表中。<ul><li>如果该节点不是尾节点，则将该版本标记为脏，并将写操作传播到后继节点。</li><li>如果该节点是尾节点，则将版本标记为干净，此时我们将对象版本称为<em>已提交</em>。然后，尾节点可以通过在链中反向传播确认来通知所有其他节点此次提交。</li></ul></li><li>当节点接收到某个对象版本的<em>确认</em>消息时，该节点会将该对象版本标记为干净。然后，该节点就可以删除该对象的所有先前版本。</li><li>当节点收到对对象的读取请求时：<ul><li>如果最新已知的版本是干净的，则节点将返回该值。</li><li>如果最新已知的版本是脏的，该节点会与尾节点进行通信，查询尾节点最后提交的版本号。然后节点返回该对象的版本；按照规则，可以确保该节点存储了该版本的对象。我们注意到，尽管尾节点可以在它回复版本请求和中间节点向客户端发送回复之前提交新版本，但是这不违反强一致性的定义，因为读操作从尾节点来说是序列化的。</li></ul></li></ol><p>请注意，如果节点收到写提交的确认后立即删除旧版本，则也可以隐式确定节点上的对象的状态是脏还是干净。也就是说如果节点中的对象只有一个版本，那么该对象是干净的；否则，对象是脏的，必须从尾节点检索正确的版本。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021725394.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021725880.png"></p><p>图2显示了处于初始干净状态的CRAQ链。每个节点都存储对象的相同副本，因此到达链中任何节点的任何读请求都将返回相同的值。除非收到写请求，否则所有节点都将保持在干净状态。</p><p>图3显示了写操作的传播过程（由紫色虚线显示）。头节点收到写入该对象的新版本（V2）的初始消息，因此头节点的对象状态是脏的。然后，头节点将写消息沿着链向下传播到第二个节点，该节点也将该对象标记为脏（对象K有多个版本[V1,V2]）。如果一个处于干净状态的节点收到读请求，它们将立即返回该对象的旧版本：这是正确的，因为新版本尚未在尾节点提交新版本。但是，如果两个脏节点中的其中一个收到读请求，它们会向尾节点发送版本查询请求（图中使用蓝色的虚线箭头显示），尾节点将返回被请求对象的已知版本号。然后，脏节点返回与指定版本号相关联的旧对象值（V1）。因此，即使有多个未完成的写操作在链中传播，链中的所有节点仍将返回同一版本的对象。</p><p>当尾节点收到并接受写入请求时，它会在链上发送包含此写入版本号的确认消息。每个前继节点收到确认后，将此版本号标记为干净（可能删除所有较旧的版本）。当其最新的版本状态变成干净后，节点就可以在本地处理读请求了。这种方式利用了写操作是串行传播的事实，因此尾节点总是最后一个收到写入请求的节点。</p><p>CRAQ在以下两种场景下吞吐量会比CR有所提升：</p><ul><li><strong>Read-Mostly Workloads</strong> 该场景下大多数都是读请求，这些读取请求由C−1个非尾节点进行处理。因此，在这类场景下吞吐量与链长度C呈线性关系。</li><li><strong>Write-Heavy Workloads</strong> 该场景下有许多对非尾节点的大多数读请求数据为脏，因此需要对尾节点进行版本查询。但是，我们认为这些版本查询并完整读取更轻量，允许尾节点在它饱和之前以更高的速率处理它们。这使得总的读取吞吐量仍高于CR。</li></ul><p>第六节中的性能数据可以支持以上两个主张，即使对于小对象也是如此。对于持续写请求繁重的较长链，即使我们不评估这种优化，也可以想象通过使尾部结点仅处理版本查询而不是处理所有的读请求的方式，可以优化读取吞吐量。</p><h2 id="2-4、CRAQ上的一致性模型（Consistency-Models-on-CRAQ）"><a href="#2-4、CRAQ上的一致性模型（Consistency-Models-on-CRAQ）" class="headerlink" title="2.4、CRAQ上的一致性模型（Consistency Models on CRAQ）"></a>2.4、CRAQ上的一致性模型（Consistency Models on CRAQ）</h2><p>某些应用程序或许可以以较弱的一致性保证来运行，并且它们可能会试图避免版本查询的性能开销（根据3.3节，在广域部署中是很重要的），或者它们可能希望当系统无法提供强一致性时继续运行（例如在分区期间）。为了支持这类需求的变化，CRAQ同时支持三种不同的一致性模型。读取操作使用哪一类一致性模型是可选的。</p><ul><li><strong>强一致性</strong>（默认）上面的模型中描述了强一致性。所有对象读取都与最后一次提交的写入一致。</li><li><strong>最终一致性</strong> 允许对链中的节点的读操作返回已知的最新对象版本。因此，另一个点的后续读取操作可能返回比先前返回的对象更旧的版本。因此，尽管对单个链节点的读取操作的确在本地，但它不满足单调读一致性。</li><li><strong>最大范围不一致的最终一致性</strong> 允许读操作在写操作提交前将存储的新对象返回，但只允许在某些条件下这样做。施加的条件可以基于时间或是基于绝对版本号。在该模型中，保证读操作返回的值具有最大的不一致性周期。如果链仍然是可用的，这种不一致性实际上是因为返回的版本比上次提交的版本新。如果系统被分区，并且节点无法参与写入，那么版本可能比当前提交的版本旧。</li></ul><h2 id="2-5、CRAQ中的故障恢复（Failure-Recovery-in-CRAQ）"><a href="#2-5、CRAQ中的故障恢复（Failure-Recovery-in-CRAQ）" class="headerlink" title="2.5、CRAQ中的故障恢复（Failure Recovery in CRAQ）"></a>2.5、CRAQ中的故障恢复（Failure Recovery in CRAQ）</h2><p>由于CRAQ的基本结构与CR相似，因此CRAQ使用相同的技术进行故障恢复。每个链节点需要知道它的前继节点和后继节点，以及链的头部和尾部。当头部节点故障了，它的后继节点将接任新的链的头部。同样，当尾节点出现故障时，它的前继节点也会接任成为新的尾节点。需要加入到链中间的节点要像双链表一样插入到两个节点之间。处理系统故障的正确性证明与CR相似；由于篇幅所限，这里不展开说明。第5节介绍了CRAQ中故障恢复的细节以及协作服务的集成。特别是CRAQ允许节点加入到链中的任何位置（而不是仅在尾部），以在恢复过程中正确处理故障的选择都需要详细介绍。</p><h1 id="3、CRAQ的扩展（Scaling-CRAQ）"><a href="#3、CRAQ的扩展（Scaling-CRAQ）" class="headerlink" title="3、CRAQ的扩展（Scaling CRAQ）"></a>3、CRAQ的扩展（Scaling CRAQ）</h1><p>在本节中，我们讨论应用程序如何在单数据中心以及跨多数据中心的条件下，设计CRAQ中链的布局方案。然后，我们讨论如何使用协作服务来存储链的元信息和组成员身份信息。</p><h2 id="3-1、链布局策略（Chain-Placement-Strategies）"><a href="#3-1、链布局策略（Chain-Placement-Strategies）" class="headerlink" title="3.1、链布局策略（Chain Placement Strategies）"></a>3.1、链布局策略（Chain Placement Strategies）</h2><p>使用分布式存储服务的应用程序的要求可能会有所不同。一些常见的情况如下：</p><ul><li>对对象的大部分或全部的写入操作可能源自单个数据中心</li><li>一些对象可能只存放在一个数据中心的某些节点中</li><li>热点对象可能需要大量复制，而非热点对象可能较少</li></ul><p>CRAQ提供了灵活的链配置策略，通过使用对象的两级命名结构来满足这些变化的需求。对象的标识符包括<strong>链标识符</strong>和<strong>键标识符</strong>。链标识符决定CRAQ中的哪些节点将存储该链中的所有键，而键标识符为每条链提供唯一命名。我们介绍了多种满足应用程序定制化需求的方法：</p><p><strong>1、隐式数据中心和全局链长度</strong></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021757844.png"></p><p>此方法中定义了存储链的数据中心的数量，但没有显式地定义存储在哪些数据中心。为了准确地确定哪个数据中心存储链，使用一致性哈希结合唯一的数据中心标识符。</p><p><strong>2、显示数据中心和全局链长度</strong></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021757044.png"></p><p>该方法中每个数据中心使用同样的链长度在数据中心中存储副本。链的头节点位于数据中心dc1中，链的尾节点位于数据中心dcn中，链基于数据中心列表进行排序。为了确定数据中心中的哪些节点存储分配给链的对象，对链标识符做一致性哈希。每个数据中心dci都有一个连接到数据中心dci−1尾节点的节点和一个连接到数据中心dci+1头节点的节点。另一个额外的功能是允许chain_size为0，表示该链使用每个数据中心内的所有节点。</p><p><strong>3、显示数据中心和不同链长度</strong></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305021758836.png"></p><p>这里每个数据中心的链长度是独立的。这允许链负载均衡是非均匀的。每个数据中心的链节点的选择方式与之前的方式相同，并且chain_size也可以设置为0。</p><p>在上述方法2和方法3中，dc1可以设置为<strong>主数据中心</strong>。如果一个数据中心是链的主数据中心，那么对于链的写入将仅在短暂故障期间被该数据中心接受。否则，如果dc1与链的其他节点断开连接，则dc2可能会成为新的头节点，并接管写操作，直到dc1恢复在线。如果未设置主节点，写操作将仅在包含全局链中大多数节点的分区中继续进行。否则，如第2.4节中定义的那样，对于最大范围不一致的读取操作，该分区会变成只读。</p><p>CRAQ可以轻松支持其他更复杂的链配置方法。例如可能需要指定一个显式备份数据中心，仅当另一个数据挂了的时候开始加入链中。还可以设置一组数据中心（例如东海岸数据中心），其中的任意一个都可以填充到上述方法2的有序列表中。为简便起见，我们不再详细介绍更复杂的方法。</p><p>可以写入单个链的键标识符的数量没有限制，这样可以根据应用需求对链进行灵活的配置。</p><h2 id="3-2、单个数据中心的CRAQ（CRAQ-within-a-Datacenter）"><a href="#3-2、单个数据中心的CRAQ（CRAQ-within-a-Datacenter）" class="headerlink" title="3.2、单个数据中心的CRAQ（CRAQ within a Datacenter）"></a>3.2、单个数据中心的CRAQ（CRAQ within a Datacenter）</h2><p>在最初的链式复制工作中，已经研究了如何在多个数据中心分布多个链。在CRAQ的当前实现中，我们使用<strong>一致性哈希</strong>将链放置在数据中心内，将潜在的链标识符映射到头节点上。这类似于基于数据中心的对象存储。GFS采用并在CR中推广的另一种方式是在分配和存储随机链成员时，使用成员管理服务作为目录服务，即每个链可以包含一些随机服务器的集合。这种方式提高了并行系统恢复的能力。但是，这是以增加集中度为代价的。CRAQ可以轻松的使用这种设计，但是它将需要在协作服务中存储更多的元信息。</p><h2 id="3-3、跨多个数据中心的CRAQ（CRAQ-Across-Multiple-Datacenters）"><a href="#3-3、跨多个数据中心的CRAQ（CRAQ-Across-Multiple-Datacenters）" class="headerlink" title="3.3、跨多个数据中心的CRAQ（CRAQ Across Multiple Datacenters）"></a>3.3、跨多个数据中心的CRAQ（CRAQ Across Multiple Datacenters）</h2><p>当链延伸到广域网时，CRAQ能够从任何节点进行读取的能力可以降低它的延迟：客户端在选择节点时具有灵活性，它们可以选择物理距离较近的节点（或者轻负载的节点）。只要链的状态是干净的，那么节点可以直接返回本地副本的值，而不用发送任何广域请求。而在传统的CR中，所有读取都需要由可能距离较远的尾节点处理。实际上，由于对象可能处于不同的位置，因此多种设计可能会基于数据中心在链中选择头结点和/或尾节点。实际上雅虎的新<a href="https://www.zhihu.com/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22222860778%22%7D">分布式数据库</a>PNUTS就是受其数据中心中的高写入局部性的影响而进行设计的。</p><p>也就是说应用程序可能会进一步优化广域网下链的选择，从而最大程度地减少写入延迟，降低网络成本。当然，在所有节点集合中使用一致性哈希这种朴素的方式来构建链可能会导致链的前继和后继是随机的，前继和后继可能距离很远。此外，一条链可能会多次跨入和跨出一个数据中心。而通过我们的链优化，应用程序可以通过谨慎选择组成链的数据中心的顺序来最小化写延迟，并且可以确保一条链只单向跨越数据中心的网络边界一次。</p><p>即使使用优化后的链，随着越来越多的数据中心被添加到链中，广域网中的链的写操作延迟也会增加。尽管与以并行方式分发写操作的主/备方法相比，这种方式显著地增加了延迟，但是它允许将写操作在链中流水线进行，这极大的提高了写操作的吞吐量。</p><h2 id="3-4、ZooKeeper-协作服务（ZooKeeper-Coordination-Service）"><a href="#3-4、ZooKeeper-协作服务（ZooKeeper-Coordination-Service）" class="headerlink" title="3.4、ZooKeeper 协作服务（ZooKeeper Coordination Service）"></a>3.4、ZooKeeper 协作服务（ZooKeeper Coordination Service）</h2><p>众所周知，为分布式应用程序构建一个容错的协作服务很容易出错。CRAQ的早期版本包含一个非常简单、集中控制的协作服务，用于维护成员管理。后来，我们选择利用Zookeeper为CRAQ提供一种健壮的、分布式的、高性能的方式来管理组成员，并提供一种简单的方式来存储链的元数据。通过Zookeeper，当组内添加节点或删除节点时，CRAQ节点一定会收到通知。同样当节点关注的元数据发送变化时，该节点也可以收到通知。</p><p>Zookeeper为客户端提供类似于文件系统的分层命名空间。文件系统存储在内存中，并且在日志中为每个Zookeeper实例进行备份，文件系统状态会在多个Zookeeper节点之间进行复制，从而提高可靠性和可扩展性。为了达成一致，Zookeeper使用类似两阶段提交的原子广播协议。经过优化后，Zookeeper能够为大量读的小型工作负载提供出色的性能，因为它可以直接在内存中响应大部分的服务请求。</p><p>与传统的文件系统命名空间类似，Zookeeper客户端可以罗列目录的内容、读取文件、写入文件以及在文件或目录被修改或删除时收到通知。Zookeeper的原始操作允许客户端实现许多更高级别的语义，例如组成员、领导选举、事件通知、锁和队列。</p><p>跨多数据中心进行管理成员和链的元信息的确带来了一些挑战。实际上，Zookeeper并未针对在多数据中心环境中运行进行优化：将多个Zookeeper节点放在单个数据中心，可以提高Zookeeper在该数据中心的读取可扩展性，但是在广域网下的性能会受损。因为原始实现并不知道数据中心的拓扑和层次结构，所以Zookeeper节点之间进行消息交换会通过广域网进行传输。尽管如此，我们当前的实现仍然确保了CRAQ节点总是能收到本地Zookeeper节点的通知，并且与它们相关的关于链和节点列表的消息也会进行通知。我们在第5.1节使用Zookeeper进行了扩展。</p><p>为了消除Zookeeper在跨数据中心时产生的流量冗余，可以构建一个<strong>Zookeeper实例的层次结构</strong>：每个数据中心可以拥有自己本地的Zookeeper实例（由多个节点组成），并拥有一个全局Zookeeper实例的代表（可以通过本地实例的领导选举选出）。然后独立的功能可以协调两者之间的数据共享。一种替代设计是修改Zookeeper本身，就像CRAQ一样让节点知道网络拓扑结构。我们尚未重复研究这两种方法，将其留给以后的工作。</p><h1 id="4、扩展（Extensions）"><a href="#4、扩展（Extensions）" class="headerlink" title="4、扩展（Extensions）"></a>4、扩展（Extensions）</h1><p>本节讨论对CRAQ的一些其他扩展，包括微事务功能、使用多播优化写操作。我们目前正在实现这些扩展。</p><h2 id="4-1、CRAQ上的微事务（Mini-Transactions-on-CRAQ）"><a href="#4-1、CRAQ上的微事务（Mini-Transactions-on-CRAQ）" class="headerlink" title="4.1、CRAQ上的微事务（Mini-Transactions on CRAQ）"></a>4.1、CRAQ上的微事务（Mini-Transactions on CRAQ）</h2><p>在一些应用程序中，对于对象存储中的整个对象的读/写接口可能会受限。例如BitTorrent或其他目录服务可能需要支持列表的添加或删除。分析服务可能需要存储计数器。或者应用程序可能希望提供对某些对象的条件访问。这些需求都不是仅仅提供纯粹的对象存储接口就可以满足的，但是CRAQ提供了支持事务操作的关键扩展。</p><h3 id="4-1-1、单键操作（Single-Key-Operations）"><a href="#4-1-1、单键操作（Single-Key-Operations）" class="headerlink" title="4.1.1、单键操作（Single-Key Operations）"></a>4.1.1、单键操作（Single-Key Operations）</h3><p>单键操作很容易实现，CRAQ已经支持以下操作：</p><ul><li><strong>前置/追加：(Prepend/Append)</strong> 将数据添加到当前对象值的开头或结尾。</li><li><strong>增加/减小：(Increment/Decrement)</strong> 在键的对象上增加或减少，以整数形式表示。</li><li><strong>测试并设置：(Test-and-Set)</strong> 仅在键的当前版本号等于操作中执行的版本号时，才更新键的对象。</li></ul><p>对于前置/追加和增加/减小操作，存储键对象的链的头节点可以简单地将操作应用于对象的最新版本，即使最新的版本是不干净的，然后在链中向后传播替换写操作。此外，如果这些操作很频繁，则头节点可以缓存请求然后批量更新。如果使用传统的两阶段提交协议，实现这些功能付出的代价会很高。</p><p>对于测试并设置操作，链的头节点检查其最近提交的版本号是否等于操作中执行的版本号，如果没有该对象最近未提交的版本，头节点接受该操作并在链中传播更新。如果有未完成的写操作，则拒绝该操作，并且如果连续被拒绝，客户端需要考虑降低请求速度。还有另一种方案，头节点可以通过禁止写入直到对象干净为止并重新检查最新的版本号来锁定对象，但是由于未提交的写入被中止是非常少见的，以及锁定对象会显著影响性能，因此我们选择不采用该方案。</p><p>测试并设置操作也可以设计为接受值而不是版本号，但是当存在未提交的版本时，会引入额外的复杂性。如果头节点与对象的最新提交版本（通过与尾节点通信）比较发现不同，则当前进行中的任何写入都将被拒绝。而如果头节点与最新未提交版本比较，就违反了一致性保证。为了实现一致性，头节点将需要通过禁止写入直到对象干净为止来暂时地锁住对象。这不会违反一致性保证，并确保不会丢失任何更新，但是会显著影响写入性能。</p><h3 id="4-1-2、单链操作（Single-Chain-Operations）"><a href="#4-1-2、单链操作（Single-Chain-Operations）" class="headerlink" title="4.1.2、单链操作（Single-Chain Operations）"></a>4.1.2、单链操作（Single-Chain Operations）</h3><p>Sinfonia最近提出的“微事务”提供了一种具有吸引力方法，它能够较为轻量地在单个链的多个键上执行事务。微事务由比较、读取和写入集合定义；Sinfonia提出了一种跨越多个内存节点的线性地址空间。比较集测试指定地址位置的值，如果它们与提供的值匹配，则执行读取和写入操作。Sinfonia提出的微事务使用乐观的两阶段提交协议，专为较低的写争用的情况而设计。准备消息尝试在指定的内存地址上获取锁。如果所有的地址都被锁了，则协议提交；否则，参与者释放所有的锁并稍后重试。</p><p>CRAQ的链拓扑结构对于支持类似微事务有特殊的优势，因为应用程序可以指定多个对象存储在同一条链上，从而保持了局部性。共享同一个<em>chainid</em>的对象被分配在同一个链头节点上，由于只有一个头节点，因此可以避免在一次通信中发生两阶段提交。CRAQ的独特之处在于，在涉及单个链的微事务中就可以仅使用头节点来接受访问，因为头节点控制对链所有键的写访问。唯一的缺点就是如果头节点需要等待事务中的所有节点变干净（如4.1.1节所述），那么写吞吐量会收到影响。但是这个问题在Sinfonia中更为严重，因为它需要等待跨多个节点的键解锁。同样，在CRAQ中从故障恢复也很容易。</p><h3 id="4-1-3、多链操作（Multi-Chain-Operations）"><a href="#4-1-3、多链操作（Multi-Chain-Operations）" class="headerlink" title="4.1.3、多链操作（Multi-Chain Operations）"></a>4.1.3、多链操作（Multi-Chain Operations）</h3><p>即使在多对象更新涉及到多个链时，乐观两阶段提交协议也仅需使用链头节点来实现，而不是所有涉及的节点。链头节点可以锁住任何微事务中涉及的键，直到事务完全提交为止。</p><p>当然，应用程序写进程在使用昂贵的锁和微事务时需要小心：由于写同一个对象无法再流水线化执行（链式复制极其重要的优势），CRAQ的写吞吐量会被降低。</p><h2 id="4-2、多播降低写入延迟（Lowering-Write-Latency-with-Multicast）"><a href="#4-2、多播降低写入延迟（Lowering-Write-Latency-with-Multicast）" class="headerlink" title="4.2、多播降低写入延迟（Lowering Write Latency with Multicast）"></a>4.2、多播降低写入延迟（Lowering Write Latency with Multicast）</h2><p>CRAQ可以利用多播协议来提高写入性能，特别是对于大规模的更新或是长链而言。由于链成员在节点成员修改期间是稳定的，因此可以为每个链创建一个多播组。在一个数据中心内，可以采用网络层多播协议的形式，而应用程序层多播可能更适用于广域网中的链。这些多播协议不需要顺序或可靠性保证。</p><blockquote><p>多播协议（multicast protocols）指的是一种网络协议，可以将数据包从一个源节点发送到多个目标节点。这种协议可以提高写入性能，特别是对于大型更新或长链。</p></blockquote><p>然后，实际的值可以多播到整个链，而不是在链上顺序传播完整写入，增加与链长度成正比的延迟。与此同时，只有较小的元数据信息需要在链中传播，以确保所有尾节点前的副本都能收到写操作。如果节点因为任何原因而未收到多播的消息，节点可以在接收到写提交消息之后和向下传播提交消息之前，与它的前继节点进行通信获取对象。</p><p>此外，当尾节点收到传播的写请求时，多播确认信息可以发送到多播组中，而不是将其沿链向后传播。这样既减少了节点对象在写入后等待重新进入干净状态的时间，又减少了客户端感知的写入延迟。同样，在多播确认时不需要顺序或可靠性保证——如果链中的节点没收到确认消息，它会在下一个读取操作要求它查询尾节点时重新进入干净状态。</p><h1 id="5、管理与实施（Management-and-Implementation）"><a href="#5、管理与实施（Management-and-Implementation）" class="headerlink" title="5、管理与实施（Management and Implementation）"></a>5、管理与实施（Management and Implementation）</h1><p>我们链复制和CRAQ的原型实现是用大约3000行c++编写的，使用Tame扩展[31]到SFS异步I/O和RPC库[38]。CRAQ节点之间的所有网络功能都是通过Sun RPC接口公开的。</p><h2 id="5-1、ZooKeeper集成（Integrating-ZooKeeper）"><a href="#5-1、ZooKeeper集成（Integrating-ZooKeeper）" class="headerlink" title="5.1、ZooKeeper集成（Integrating ZooKeeper）"></a>5.1、ZooKeeper集成（Integrating ZooKeeper）</h2><p>如§3.4所述，CRAQ需要一种组成员服务的功能。我们使用ZooKeeper文件结构来维护每个数据中心中的节点列表成员。当客户端在ZooKeeper中创建一个文件时，它可以被标记为临时文件。如果创建临时文件的客户端与ZooKeeper断开连接，临时文件将被自动删除。在初始化过程中，CRAQ节点在<code>/nodes/dc_name/node_id</code>中创建一个临时文件，其中<code>dc_name</code>是其数据中心的唯一名称(由管理员指定)，node_id是对于节点数据中心的唯一的节点标识符。该文件的内容包含节点的IP地址和端口号。</p><p>CRAQ节点可以通过查询<code>/nodes/dc_name</code>来确定其数据中心的成员列表，但是ZooKeeper为进程提供了在文件上创建watch的能力，而不必定期检查列表是否有变化。CRAQ节点在创建临时文件以通知其他节点它已加入系统之后，在<code>/nodes/dc_name</code>的子列表上创建一个watch，从而保证在添加或删除节点时接收到通知。</p><p>当CRAQ节点接收到创建新链的请求时，在<code>/chains/chain_id</code>中创建一个文件，其中<code>echain_id</code>是链的160位唯一标识符。链的放置策略(在§3.1中定义)决定了文件的内容，但它只包括这个链的配置信息，不包括链的当前节点列表。参与链的任何节点都将查询链文件，并在其上创建一个watch，以便在链元数据发生变化时得到通知。</p><p>尽管这种方法要求节点跟踪整个数据中心的CRAQ节点列表，我们依然选择了这种方法，而不是另一种方法，在这种方法中，节点为它们所属的每个链注册它们的成员(即，链元数据显式地命名链的当前成员)。我们假设链的数量通常至少比系统中的节点数量大一个数量级，或者链的动态性可能比加入或离开系统的节点大得多(回想一下，CRAQ是为托管数据中心而不是点对点设置设计的)。采用替代假设的部署可以采用在协调服务中显式跟踪每个链成员关系的另一种方法。如果有必要，当前方法的可伸缩性还可以通过让每个节点只跟踪数据中心节点的一个子集来提高:我们可以根据<code>node_id</code>前缀将节点列表划分到<code>/nodes/dc_name/</code>中的单独目录中，节点只监视自己的和相近的前缀。</p><p>值得注意的是，我们能够利用类 tame 技术的包装器函数（注：tame不好翻译，指的是将异步代码转换为同步代码的一种编程技术）将ZooKeeper的异步API函数集成到我们的代码库中。这允许我们等待ZooKeeper包装器函数，这极大地降低了代码的复杂性。</p><h2 id="5-2、链节点功能（Chain-Node-Functionality）"><a href="#5-2、链节点功能（Chain-Node-Functionality）" class="headerlink" title="5.2、链节点功能（Chain Node Functionality）"></a>5.2、链节点功能（Chain Node Functionality）</h2><p>我们的chainnode程序实现了CRAQ的大部分功能。由于Chain Replication和CRAQ的大部分功能是相似的，因此该程序基于运行时配置设置作为Chain Replication节点或CRAQ节点操作。</p><p>节点在加入系统时会生成一个随机标识符，每个数据中心内的节点使用这些标识符组织成一个一跳DHT [29, 45]。一个节点的链前驱和后继被定义为其在DHT环中的前驱和后继。链也由160位标识符命名。对于链Ci，Ci的DHT后继节点被选为该数据中心中该链的第一个节点。接下来，这个节点的SDHT后继形成数据中心子链，其中S在链元数据中指定。（注：这句话的意思是，这个链的第一个节点在该数据中心内被选为DHT环上的第一个节点。然后，这个节点的SDHT后继被选为DHT环上的下一个节点，并负责存储该链的下一个副本。接着，这个SDHT后继节点的SDHT后继被选为DHT环上的下一个节点，并负责存储该链的下一个副本。以此类推，直到所有存储该链副本的节点都被组织成了一个子链。其中，S是在链元数据中指定的参数，用于指定每个数据中心内子链包含多少个副本。）如果这个数据中心是该链的第一个（或最后一个），那么这个第一个（或最后一个）节点就是该链的最终头（或尾）。</p><p>目前，所有节点之间或节点与客户端之间基于rpc的通信都是通过TCP连接进行的(Nagle的算法被关闭)。每个节点维护一个连接的TCP连接池，其中包含其链的前一个节点、后一个节点和尾节点。请求在这些连接之间被流水线化和循环处理。所有对象目前都只存储在内存中，尽管我们的存储抽象非常适合使用进程内键值存储，例如BerkeleyDB[40]，我们正在对它进行集成。</p><p>对于跨越多个数据中心的链，一个数据中心的最后一个节点维护到其后续数据中心的第一个节点的连接。任何维护到其数据中心外部节点的连接的节点还必须在外部数据中心的节点列表上放置一个监视。但是请注意，当外部数据中心的节点列表发生变化时，订阅更改的节点只会收到来自本地ZooKeeper实例的通知，避免了额外的跨数据中心流量。</p><h2 id="5-3、解决成员变更（Handling-Memberships-Changes）"><a href="#5-3、解决成员变更（Handling-Memberships-Changes）" class="headerlink" title="5.3、解决成员变更（Handling Memberships Changes）"></a>5.3、解决成员变更（Handling Memberships Changes）</h2><p>对于正常的写入传播，CRAQ 节点遵循第 2.3 节中的协议。在恢复期间有时需要第二种传播，称为反向传播，但是：它有助于保持响应节点添加和故障的一致性。例如，如果一个新节点将 CRAQ 连接为现有链的头部（给定其在 DHT 中的位置），则链的前一个头部需要向后传播其状态。但是系统在恢复过程中也需要对后续故障具有鲁棒性（注：健壮性），这可能会级联对链更远的向后传播的需求（例如，如果现在的第二个链节点在完成到当前头节点的反向传播之前发生故障）。最初Chain Replication论文没有考虑这样的恢复问题，这可能是因为它只描述了更集中控制和静态配置的链成员版本，其中新节点总是添加到链的尾部。</p><p>由于这些可能的故障条件，当一个新节点加入系统时，新节点既要接收来自其前身的传播消息，也要接收来自其后继节点的反向传播消息，以确保其正确性。新节点拒绝客户端对特定对象的读请求，直到它与后继节点达成协议。在这两种传播方法中，节点都可以使用集合协调算法（注：集合协调算法是一种用于比较两个集合之间差异的算法。在CRAQ系统中，节点使用集合协调算法来比较它们各自拥有的对象，并仅传播缺失或更新的对象。）来确保在恢复期间只传播需要的对象。</p><p>反向传播消息总是包含节点关于对象的完整状态。这意味着不只是发送最新版本，而是将最新的干净版本与所有未完成的(更新的)脏版本一起发送。这对于使刚刚加入系统的新节点能够响应未来的确认消息是必要的。前向传播支持这两种方法。对于沿链传播的正常写操作，只发送最新版本，但当从故障中恢复或添加新节点时，将传输完整状态对象。</p><p>现在让我们从节点N的角度考虑以下情况，其中LC是N负责的链C的长度。</p><p><strong>节点添加（Node Additions）</strong>系统中增加了一个新节点A</p><ul><li>如果 A 是 N 的后继，N 将 C 中的所有对象传播到 A。如果 A 之前已经在系统中，N 可以首先执行对象集和协调，以标识达到与链其余部分一致性所需的指定对象版本。</li><li>如果 A 是 N 的前驱：<ul><li>N 将 C 中的所有对象反向传播到 N 不是头部的 A。</li><li>如果 N 是前一个尾部，则 A 将超过 C 的尾部。</li><li>如果 N 的后继者之前是尾部，则 N 变为 C 的尾部。</li><li>如果 N 之前是头部，并且 A 的标识符落在 DHT 中的 C 和 N 的标识符之间，则 A 成为 C 的新头部。</li></ul></li><li>如果 A 在 N 的 LC 前驱中：<ul><li>如果 N 是 C 的尾部，它会放弃尾部职责并停止参与链。N现在可以将其 C 对象的本地副本标记为可删除，尽管它只有在稍后重新连接链 C 时才惰性地恢复这个空间以支持更快的状态协调。</li><li>如果 N 的后继是 C 的尾部，N 承担尾部职责。</li></ul></li></ul><p><strong>节点删除（Node Deletions）</strong>节点D从系统中移除。</p><ul><li>如果 D 是 N 的后继，N 将 C 中的所有对象传播到 N 的新后继对象（同样，最小化仅转移到未知、新的对象版本）。N 必须传播其对象，即使该节点已经属于链，因为 D 在传播未完成的写操作之前可能会失败。</li><li>如果 D 是 N 的前驱：<ul><li>N 将所有所需的对象反向传播到 N 的新前驱，因为它不是头部。N需要反向传播它的键，因为D在向其前身发送未完成的确认之前可能会失败，或者在完成自己的反向传播之前失败。</li><li>如果D是C的头部，N承担头部职责。</li><li>如果N是C的尾部，它会放弃尾部职责，并将C中的所有对象传播到N的新后继者。</li></ul></li><li>如果 D 在 N 的 LC 前驱中，N 是 C 的尾部，N 放弃尾部职责并将 C 中的所有对象传播到 N 的新后继者。</li><li>如果上述任何一个都成立，则不需要行动。</li></ul><h1 id="6、评估（Evaluation）"><a href="#6、评估（Evaluation）" class="headerlink" title="6、评估（Evaluation）"></a>6、评估（Evaluation）</h1><p>本节评估我们的链复制(CR)和CRAQ实现的性能。在高层次上，我们感兴趣的是量化CRAQ分配读的能力所带来的读吞吐量收益。另一方面，对于脏对象，版本查询仍然需要分派到尾部，因此我们也对评估工作负载混合变化时的渐近行为感兴趣。我们还简要地评估了CRAQ对广域部署的优化。</p><p>所有评估均在 Emulab（受控网络测试平台）上执行。实验使用具有 3GHz 处理器和 2GB RAM 的 pc3000 类型机器运行。节点在 100MBit 网络上连接。对于以下测试，除非另有说明，否则我们使用三个节点的链大小，存储单个对象连接在一起，而不增加任何合成延迟。此设置旨在更好地隔离单链的性能特征。除非另有说明，所有图的数据点都是中值；目前，误差条对应于第 99 个百分位值。</p><p>为了确定这两个系统中的最大只读吞吐量，我们首先改变图4中的客户机数量，图4显示了CR和CRAQ的总读吞吐量。由于CR必须从单个节点读取，因此吞吐量保持不变。CRAQ能够从链中的所有三个节点读取数据，因此CRAQ吞吐量增加到CR的三倍。在这些实验中，客户端保持了未完成请求的最大窗口(50)，因此系统从未进入潜在的活锁场景。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031617691.png" alt="image-20230503161705844"></p><p>图5显示了读、写和test-and-set操作的吞吐量。在这里，我们将CRAQ链从3个节点更改为7个节点，同时保持只读、只写和只处理事务的工作负载。我们看到，读吞吐量与预期的链节点数量呈线性增长。写吞吐量随着链长度的增加而下降，但幅度很小。一次只能执行一个test-and-set操作，因此吞吐量远低于写操作。test-and-set吞吐量也会随着链长度的增加而降低，因为单个操作的延迟会随着链长度的增加而增加。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031619859.png"></p><p>Chain Replication不受写操作的影响，因为所有读请求都由tail处理。尽管CRAQ的吞吐量开始时大约是CR速率的三倍(中位数为59,882 reads/s vs. 20,552 reads/s)，但正如预期的那样，这个速率逐渐降低并趋于平缓，大约是CR速率的两倍(39,873 reads/s vs. 20,430 reads/s)。为了了解CRAQ在混合读/写工作负载期间的性能，我们设置了10个客户端连续地从链中读取一个500字节的对象，而单个客户端改变其对同一对象的写速率。图6显示了总的读吞吐量相对于写速率的函数。请注意，链非尾部节点总是脏的，要求它们总是首先向尾部执行版本请求。但是，在这种情况下，CRAQ仍然享有性能优势，因为尾部的读和版本请求组合的饱和点仍然高于单独读请求的饱和点。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031621298.png"></p><p>图7重复了相同的实验，但是使用了一个5 KB的对象而不是一个500字节的对象。这个值被选为小型Web图像等对象的常用大小，而500字节可能更适合较小的数据库条目(例如，博客评论、社会网络状态信息等)。同样，CRAQ在只读设置中的性能明显优于链大小为3的CR(6,808对2,275读/秒)，即使在高写速率下(4,416对2,259读/秒)，它也保持了良好的性能。该图还包括七节点链的CRAQ性能。在这两种情况下，即使尾部的请求已经饱和，它响应小版本查询的速度也比发送大版本的读响应要快得多，这使得总读吞吐量明显高于CR。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031621444.png"></p><p>图 8 隔离了构成图 6 的脏读和干净读。随着写入的增加，干净请求的数量下降到其原始值的 25.4%，因为当写操作使链饱和时，只有尾部是干净的。尾部不能保持自己的最大仅读取吞吐量（即总共 33.3%），因为它现在还处理来自其他链节点的版本查询。另一方面，如果总吞吐量保持不变，脏请求的数量将接近原始干净读取率的三分之二，但由于脏请求速度较慢，此脏请求的数量在42.3%时趋于平缓。这两个速率重建了观察到的总读取率，在链上的高写争用期间，它收敛到只读吞吐量的67.7%。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031624472.png"></p><p>图9中的表显示了干净读取、脏读取、向3节点链写入和向6节点链写入的延迟(以毫秒为单位)，所有这些都在单个数据中心内。当操作是唯一的未完成请求(无负载)和当我们用许多请求使CRAQ节点饱和(高负载)时，显示500字节和5 KB对象的延迟。正如预期的那样，在高负载下延迟会更高，并且延迟会随着键大小而增加。由于产生了额外的往返时间，脏读取总是比干净读取慢，并且写入延迟随着链的大小大致呈线性增加。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031625822.png"></p><p>图10展示了CRAQ从故障中恢复的能力。我们将显示长度为3、5和7的链随时间的只读吞吐量损失。每次测试15秒后，链中的一个节点被杀死。几秒钟后，节点超时并被ZooKeeper认为死亡的时间，一个新节点加入链，吞吐量恢复到原始值。图上绘制的水平线对应于长度为1到7的链的最大吞吐量。这有助于说明故障期间的吞吐量损失大致等于1/C，其中C是链的长度。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031626956.png"></p><p>为了测量故障对读写操作延迟的影响，图11和图12显示了长度为3的链发生故障时这些操作的延迟。在尝试读取对象时收到错误的客户端会选择一个新的随机副本进行读取，因此失败对读取的影响很小。但是，在副本失败和由于超时从链中删除之间的时间段内，不能提交写操作。这导致写入延迟会增加完成故障检测所需的时间。我们注意到，这与任何其他需要所有活动副本参与提交的主/备份复制策略中的情况相同。此外，客户端可以选择配置写请求，一旦链头接受并将请求传播到链中，就立即返回，而不是等待它提交。这减少了不需要强一致性的客户端的延迟。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031630128.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031631292.png"></p><p>最后，图13演示了CRAQ在跨数据中心的广域部署中的实用程序。在这个实验中，在三个节点上构建了一个链，每个节点之间的往返延迟为80ms(大约是美国沿海地区之间的往返时间)，使用Emulab的合成延迟进行控制。读客户端不是链尾的本地客户端(否则可能会像以前一样只有本地性能)。该图评估了随着工作负载组合的变化而产生的读取延迟；平均延迟现在以标准偏差显示为误差条(而不是其他位置的中位数和第99%)。因为尾部不是本地的，所以CR的延迟一直很高，因为它总是会引起广域读请求。另一方面，当没有发生写入时，CRAQ几乎不会产生延迟，因为读取请求可以在本地得到满足。然而，随着写入速率的提高，CRAQ读取变得越来越脏，因此平均延迟也会增加。一旦写入速率达到约15次写入/秒，沿广域链向下传播写入消息所涉及的延迟会导致客户端的本地节点100%处于脏状态，从而导致广域版本查询。(CRAQ的最大延迟一直如此-略低于CR，因为只有元数据在大范围内传输，这种差异只会随着较大的对象而增加，特别是在启动缓慢的情况下。)尽管这种收敛到 100% 的脏状态发生的写入率远低于之前，我们注意到仔细的进行链布局可以使得尾部数据中心中的任何客户端享受本地区域性能。此外，非尾部数据中心的客户端可以满足一定程度的最大边界不一致(参见§2.4)，也可以避免广域请求。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305031631713.png"></p><h1 id="7、相关工作（Related-Work）"><a href="#7、相关工作（Related-Work）" class="headerlink" title="7、相关工作（Related Work）"></a>7、相关工作（Related Work）</h1><p><strong>分布式系统的强一致性</strong></p><p>分布式系统的强一致性。分布式服务器之间的强一致性可以通过使用主/备份存储[3]和两阶段提交协议[43]来提供。该领域的早期工作没有提供面对故障(例如，事务管理器的故障)时的可用性，这导致引入视图更改协议(例如，通过领导者共识[33])来协助恢复。在这一领域有大量的后续工作;最近的例子包括Chain Replication和Guerraoui et al.[25]的基于环的协议，后者使用两阶段写入协议，并在未提交的写入期间延迟读取。与其到处复制内容，不如在强一致性仲裁系统中探索重叠读写集之间的其他权衡[23,28]。共识协议也被扩展到恶意设置，包括状态机复制[10,34]和仲裁系统[1,37]。这些协议为系统的所有操作提供了线性一致性。本文没有考虑拜占庭式故障——并且很大程度上限制了对影响单个对象的操作的考虑——尽管将链复制扩展到恶意设置是未来有趣的工作。</p><p>有很多分布式文件系统提供了强大的一致性保证，比如早期基于主/备份的Harp文件系统[35]。最近，Boxwood[36]探索了各种更高层的数据抽象，比如b树，同时提供严格的一致性。Sinfonia[2]提供轻量级的“微事务”，允许对存储节点中暴露的内存区域进行原子更新，这是一种优化的两阶段提交协议，非常适合低写争用的设置。CRAQ对多链多对象更新的乐观锁的使用受到sinonia的严重影响。</p><p>CRAQ和Chain Replication[47]都是基于对象的存储系统的例子，它们公开整个对象的写(更新)和平面对象命名空间。该接口类似于键值数据库[40]提供的接口，将每个对象视为这些数据库中的一行。因此，CRAQ和Chain Replication侧重于对每个对象的操作排序的强一致性，但通常不描述对不同对象的操作排序。(我们在§4.1中对多对象更新的扩展是一个明显的例外。)因此，它们可以被看作是极端的偶然一致性，只有对同一对象的操作是因果相关的。本文研究了数据库[7]的乐观并发控制和分布式系统[8]的有序消息传递层的因果一致性。YaHoo!新的数据托管服务PNUTs[12]也提供了每个对象的写序列化(他们称之为每个记录的线性一致性)。在单个数据中心内，它们通过具有完全有序交付的消息传递服务实现一致性;为了提供跨数据中心的一致性，所有更新都被发送到本地记录主服务器，然后由本地记录主服务器按照提交的顺序将更新交付给其他数据中心的副本。</p><p>我们使用的链自组织技术是基于DHT社区开发的技术[29,45]。专注于点对点设置，CFS在DHT[14]之上提供了一个只读文件系统;Carbonite探索了如何提高可靠性，同时最大限度地减少在瞬态故障[11]下的副本维护。强一致性可变数据由OceanStore[32]（在核心节点使用BFT复制）和Etna[39]（使用Paxos将DHT划分为更小的副本组和用于一致性的仲裁协议）考虑。CRAQ的广域解决方案更侧重于数据中心，因此比这些系统具有拓扑意识。Coral[20]和Canon[21]都考虑了分层DHT设计。</p><p><strong>降低一致性而保证可用性</strong></p><p>TACT[49]考虑一致性和可用性之间的权衡，认为当系统约束不那么严格时，可以支持较弱的一致性。eBay使用了类似的方法:在拍卖还远未结束时，消息传递和存储最终是一致的，但在拍卖结束前使用强一致性——即使是以可用性为代价。</p><p>许多文件系统和对象存储为了分区下的可伸缩性或操作而放弃了一致性。谷歌文件系统(GFS)[22]是一个基于集群的对象存储，在设置上类似于CRAQ。然而，GFS牺牲了强一致性:GFS中的并发写不序列化，读操作也不与写操作同步。采用较弱一致性语义设计的文件系统包括Sprite[6]、Coda[30]、Ficus[27]和Bayou[42]，后者使用epidemic协议执行数据协调。在Amazon的Dynamo对象服务[15]中使用了类似的疏散式反熵协议(gossip-style antientropy protocol)，以支持“始终在线”的写入和分区时的继续操作。Facebook的新Cassandra存储系统[16]也只提供最终的一致性。在关系数据库中使用memcached[18]并不提供任何一致性保证，而是依赖于正确的程序员实践;在多个数据中心之间保持松散的缓存一致性一直是个问题[44]。</p><blockquote><p>Gossip-style antientropy protocol是一种用于分布式系统中数据同步的协议。它通过随机选择节点之间进行信息交换，从而实现数据的分发和同步。具体来说，每个节点都会定期向其他随机选择的节点发送自己拥有的数据摘要信息，同时接收其他节点发送过来的数据摘要信息。如果两个节点之间存在数据不一致，它们将交换缺失或更新的数据块，以使它们保持同步。Gossip-style antientropy protocol可以提高系统的可靠性和可扩展性，并减少网络带宽和存储开销。在分布式数据库、分布式文件系统等应用场景中，Gossip-style antientropy protocol被广泛应用于数据同步和备份。</p></blockquote><p>CRAQ的强一致性协议不支持分区操作下的写操作，尽管分区链段可以退回到只读操作。BASE[19]和Brewer的CAP猜想[9]考虑了一致性、可用性和分区容忍性之间的权衡。</p><h1 id="8、结论（Conclusions）"><a href="#8、结论（Conclusions）" class="headerlink" title="8、结论（Conclusions）"></a>8、结论（Conclusions）</h1><p>本文介绍了CRAQ的设计和实现，它是强一致性链复制方法的接替。CRAQ侧重于扩展对象存储的读吞吐量，特别是对于以读为主的工作负载。它通过支持分配查询来实现这一点:也就是说，将读取操作划分到链的所有节点上，而不是要求它们全部由单个主节点处理。虽然看起来很简单，但CRAQ展示了具有显著可伸缩性改进的性能结果:与链长度成正比，几乎没有写争用。三节点链的吞吐量提高了200%，七节点链的吞吐量提高了600%，令人惊讶的是，当对象更新很常见时，吞吐量仍然有显著提高。</p><p>除了这种改进链式复制的基本方法之外，本文还重点介绍了在各种高级应用程序中使用链式复制作为基础的实际设置和需求。随着我们继续开发用于多站点部署和多对象更新的CRAQ，我们正在努力将CRAQ集成到我们正在构建的其他几个需要可靠对象存储的系统中。其中包括支持动态服务迁移的DNS服务、对等辅助CDN[5]的集合服务器以及大型虚拟世界环境。探索这些应用程序在使用CRAQ的基本对象存储、广域优化和用于单键和多对象更新的高级原语方面的功能仍然是未来有趣的工作。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRAQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper</title>
      <link href="/2023/050148434.html"/>
      <url>/2023/050148434.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p>在本文中，我们描述了一种用于协调分布式应用程序的服务ZooKeeper。 作为关键基础设施的一部分，ZooKeeper旨在提供一个简单和高性能的内核，使得客户端可以构建更复杂的协调原语。 它将组消息传递、共享寄存器和分布式锁等服务整合到一个重新分配的、集中的服务中。 由ZooKeeper暴露出来的接口在共享寄存器方面具有无等待的特性，使用类似于分布式文件系统缓存失效的事件驱动机制来提供简单但是强大的协调服务。</p><p>ZooKeeper接口支持高性能的服务实现。 除了无等待属性之外，ZooKeeper 还为每个客户端提供 <strong>FIFO 执行请求的保证</strong>。将所有改变ZooKeeper 状态的请求线性化。 这些设计使得实现高性能处理流水线成为可能，满足了本地服务器读的请求。 我们显示了目标工作负载，2:1到100:1读取写入比率，ZooKeeper可以每秒处理数以十万计的事务。这个性能使得ZooKeeper可以被客户端应用程序广泛使用。</p><h1 id="1、简介（Introduction）"><a href="#1、简介（Introduction）" class="headerlink" title="1、简介（Introduction）"></a>1、简介（Introduction）</h1><p>大规模分布式应用需要不同形式的协调。 配置是最基本的协调形式之一。 在这种简单形式的协调中，配置只是系统进程的操作参数列表，而更复杂的系统需要具有动态配置参数。 群组的成员关系和领导选举在分布式系统中也很常见：通常进程需要知道哪些其他进程是有效的。锁构成了一个强大的<strong>协调原语（coordination primitive）</strong>，它实现了对关键资源的互斥访问。</p><blockquote><p>注：primitive，翻译为原语，在系统设计中经常会出现这样的术语，指的是系统对外提供的服务中，不可分割的最小部分，类似于API。例如对于OS而言，read、write函数操作都是系统原语（System Primitive）。对zk而言也是如此。</p></blockquote><p>一种协调办法是为每个不同的协调需要开发服务。 例如，Amazon Simple Queue Service[3]专门用于排队。 其他服务专门用于领导选举 [25] 和配置 [27]。 可以通过使用实现更强大的原语的服务来实现较弱的原语。 例如，chubby [6] 是一个具有强同步保证的锁定服务。 然后锁可以用来实现领导选举、群组的成员关系等。</p><p>在设计我们的协调服务时，我们没有在服务器端实现特定的原语，而是选择了暴露特定的 API，使应用程序开发人员能够实现自己的原语。 这样的选择导致了一个协调内核的实现，<strong>使得新的原语的实现不需要对服务核心的改变</strong>。 这种方式使得多种形式的协调能够适应应用的需求，而不是将开发者约束到固定的原语集合。</p><p>在设计ZooKeeper的 API 时，我们<strong>放弃了阻塞原语</strong>，比如锁。 除其他问题外，协调服务的阻塞原语可能导致，较慢或有故障的客户端对快速客户端的性能造成负面影响。如果处理请求依赖于其他客户端的响应和失败检测，则服务本身的实现变得更加复杂。我们的系统 ZooKeeper，因此实现了一个 API，<strong>它可以操作像文件系统那样分层组织的简单的无等待数据对象</strong>。 实际上，ZooKeeper API 类似于任何其他文件系统，并且如果只看API函数签名，ZooKeeper似乎是没有锁的Chubby 然而，实现无等待数据对象的ZooKeeper与基于锁定原语(如lock)的系统显著区分开来。</p><blockquote><p>注、</p><p>1：”wait free objects”无等待数据对象，指的是可以被多个客户端并发访问的数据结构，而无需任何形式的同步或协调</p><p>在无等待系统中，每个客户端都保证向其目标取得进展，而不管其他客户端正在做什么。这意味着客户端可以在有限的时间内完成其操作，而不管访问相同数据结构的其他客户端的数量。这与其他形式的并发控制（如锁或信号量）形成对比，在那里客户端可能被阻塞或必须等待其他客户端完成其操作才能继续。</p><p>2：Chubby是一种高可用性分布式锁服务，用于确保享资源在任何时候只有一个客户端可以访问。</p></blockquote><p>虽然无等待特性对性能和容错是很重要的，但对于<strong>协调（coordination）</strong>是不够的。 我们还必须提供操作的顺序保证。特别地，我们发现，保证所有操作的 FIFO 客户端顺序和可线性化的写入能够有效地实现这个服务，并且足够实现我们应用程序感兴趣的协调原语。借助api，事实上我们可以对任何数量进程达成共识，根据 Herlihy 的层次结构，ZooKeeper 实现了一个通用对象 [14]</p><p>ZooKeeper 服务是一个服务器集群，<strong>使用复制来实现高可用性和高性能</strong>，其高性能使得包含大量进程的应用能够使用这样的协调内核来管理协调的方方面面。 我们能够实现一个简单的流水线架构的ZooKeeper ，允许我们有成百上千的请求，仍然低延迟。 这样的流水线自然能够以 FIFO 顺序从单个client执行操作。 确保 FIFO 客户端顺序使客户端能够异步提交操作。 通过异步操作，客户端一次能够有多个未完成的操作。 <strong>这个功能是合乎需要的，当一个新的客户机成为leader时，它必须对元数据进行处理并相应地更新元数据</strong>。 没有多个未完成的操作的可能性，初始化时间可以是秒的数量级而不是毫秒。</p><p>在客户端缓存数据是提高读取性能的一项重要技术。 例如，在每次需要了解leader时，对当前leader的标识符进行缓存而不是探查ZooKeeper 的过程是有用的。 <strong>ZooKeeper 使用监视机制使客户端能够缓存数据，而无需直接管理客户端缓存。</strong> 通过这种机制，客户端可以监视给定数据对象的更新，并在更新时接收通知。 Chubby直接管理客户端缓存。 它阻塞更新来使所有客户端缓存无效并缓存被改变的新数据。 在此设计下，如果这些客户端中的任何一个是缓慢或有故障的，更新被延迟。 chubby 使用租约来防止一个错误的客户端对该系统进行无限期的阻塞。 然而，租约只约束了缓慢或有缺陷的客户的影响，而ZooKeeper 则完全避免了问题。</p><p>本文讨论了ZooKeeper的设计与实现。 使用 ZooKeeper ，我们能够实现我们的应用程序所需要的所有协调原语，即使只有写入是可线性化的。 为了验证我们的方法，我们展示了如何用ZooKeeper实现一些协调原语。</p><p>综上所述，本文的主要贡献如下：</p><p><strong>协调内核：</strong>我们提出了一种具有宽松一致性保证的无等待协调服务用于分布式系统。 特别地，我们描述了协调内核的设计和实现，我们已经在许多关键应用中使用该协调内核来实现各种协调技术。</p><p><strong>协调方法：</strong>我们展示了 ZooKeeper 如何用于构建更高级的协调原语，甚至是阻塞和强一致性原语，这些原语经常在分布式应用中使用。</p><p><strong>协调经验：</strong>我们分享了我们使用ZooKeeper 的方法，并评估了它的性能。</p><h1 id="2、Zookeeper服务（The-ZooKeeper-service）"><a href="#2、Zookeeper服务（The-ZooKeeper-service）" class="headerlink" title="2、Zookeeper服务（The ZooKeeper service）"></a>2、Zookeeper服务（The ZooKeeper service）</h1><p>客户端使用 ZooKeeper 客户端库通过客户端 API 向ZooKeeper提交请求。 除了通过客户端 API 发布ZooKeeper服务接口以外，客户端库还管理客户端和ZooKeeper服务器之间的网络连接。</p><p>在本节中，我们首先提供了ZooKeeper服务的高级视图。 然后我们讨论客户端用来与管理员交互的 API。</p><p><strong>术语：</strong>在本文中，我们使用客户端(client)来表示ZooKeeper服务的用户，服务端(server)表示提供ZooKeeper服务的进程，Znode 表示ZooKeeper数据中的内存数据节点，该数据节点被组织在称为数据树的分级命名空间中。 我们还使用术语 “更新 ”(update)和“ 写入”(write) 来指代任何修改数据树状态的操作。 客户端在连接到ZooKeeper时建立一个会话(session)，并获得他们发出请求的会话句柄。</p><h2 id="2-1、服务概述（Service-overview）"><a href="#2-1、服务概述（Service-overview）" class="headerlink" title="2.1、服务概述（Service overview）"></a>2.1、服务概述（Service overview）</h2><p>ZooKeeper 向其客户端提供了一组数据节点（Znode）的抽象，这些节点根据层次结构名称空间组织。 这个层次结构中的 Znode 是客户端通过 ZooKeeper API 操作的数据对象。 分层名称空间通常用于文件系统中。 这是组织数据对象的理想方式，因为用户习惯于这个抽象，并且它能够更好地组织应用程序元数据。 为了引用给定的 Znode，我们使用了标准的 UNIX 表示法用于文件系统路径。 例如，我们使用 <code>/ A / B / C</code> 来表示到 Znode C 的路径，其中 C 以 B 为其双亲，B 以 A 为其双亲。 所有 Znode 都可以存储数据，并且除了临时性 Znode 之外，所有 Znode 都可以有子节点。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304301816359.png"></p><p>客户端可以创建两种类型的 Znode:</p><p><strong>普通节点</strong> ： 客户机通过<strong>显式地</strong>创建和删除来操作普通 Znode；</p><p><strong>临时节点</strong> ： 客户机创建这样的 Znode之后，要么显式地删除它们，要么当创建它们的会话终止时让系统自动删除它们 (有意的或意外)。</p><p>另外，当创建新的 Znode 时，客户端可以设置顺序标志。 用序列标记集创建的节点具有附加到其名称的单调递增计数器的值。 如果 N 是新的 Znode 并且 P 是父 Znode，那么 N 的序列值决不会小于在 P 下创建的任何其他顺序 Znode 的名称中的值。</p><p>ZooKeeper 实现了<strong>watch机制</strong>，允许客户在不需要轮询的情况下及时收到更改通知。当一个客户端使用一个watch标志集进行读取操作时，操作将正常完成，并且服务器承诺在返回的信息发生更改时通知客户机。Watches 是与会话相关联的<strong>一次性触发器</strong>，一旦被触发或会话关闭，它们就被注销。 watches会通知发生了一个更改，但不会告知具体的更改内容。 例如，如果一个客户机在“/ foo”发生两次更改之前发出getData(“/ foo”，true)，那么客户机将得到一个watch事件，告诉客户机“/ foo”的数据发生了更改。 会话事件，例如连接丢失事件，也会被发送到监视回调函数，以便客户知道（已注册的其他）watches事件可能被延迟。</p><p><strong>数据模型：</strong>ZooKeeper的数据模型本质上是一个具有简化 API 和仅完整数据读取和写入的文件系统，或是一个<strong>具有层次键的key/value表</strong>。 分层命名空间对于定位不同应用程序的命名空间子树和对这些子树设置访问权限是有用的。 我们还利用客户端的目录概念来构建更高级的原语，正如我们将在 2.4 节中看到的。</p><p>与文件系统中的文件不同，Znode 不是为通用数据存储设计的。 相反，Znode 是客户端应用程序的抽象，即用来协调应用的<strong>元数据（meta-data）</strong>。 在图 1 中，我们有两个子树，一个用于应用程序 1（/ app1），另一个用于应用程序 2（/ app2）。 应用程序 1 的子树实现了一个简单的组成员身份协议 ： 每个客户端进程 pi 在/ app1下创建一个 Znode p_i，它在进程运行的时候一直会存在。</p><p>虽然 Znode 还没有设计用于一般的数据存储，但是 ZooKeeper 确实允许客户端存储一些可以用于分布式计算中的元数据或配置信息。 例如，在主从架构（leader-based）的应用中，知道哪个服务器是leader对应用服务器是有用的。 为了实现这个目标，我们可以让当前的leader在 Znode 空间中的已知位置写入这个信息。 Znode 还具有与时间戳和版本计数器相关的元数据，它允许客户端跟踪 Znode 的改变，并基于 Znode 的版本执行进行有条件的更新。</p><p><strong>会话：</strong>客户端连接到ZooKeeper之后会启动会话。 会话有关联的超时时间。 如果ZooKeeper在一定时间内没有从收到会话消息，ZooKeeper会认为客户有故障。 当客户端显式地关闭会话句柄或 ZooKeeper 检测到客户端有故障时，会话结束。 在会话中，客户观察一系列反映其运行执行情况的状态变化。 会话使客户端能够在 ZooKeeper集群中从一个物理服务器透明地移动到另一个物理服务器上，因此会话能在 ZooKeeper 集群上持续存在。</p><h2 id="2-2、客户端API（Client-API）"><a href="#2-2、客户端API（Client-API）" class="headerlink" title="2.2、客户端API（Client API）"></a>2.2、客户端API（Client API）</h2><p>下面我们将介绍ZooKeeper API的相关子集，并讨论每个请求的语义:</p><p> **<code>create(path, data, flags)</code>**：创建在路径path下的znode，data是要存放的数据，并返回新znode的名称。标志flag可以让客户端选择znode的类型：普通的、临时的，并设置顺序标志。</p><p>**<code>delete(path, version)</code>**： 删除给定路径和版本下的znode。</p><p>**<code>exists(path, watch)</code>**：如果有路径名路径的znode存在，返回true，否则返回false。watch参数允许客户端在znode上设置监视器。</p><p>**<code>getData(path, watch)</code>**：返回与znode相关的数据和元数据，如版本信息。watch标志的工作方式与exists()相同()，但是如果znode不存在的话，ZooKeeper就不会设置监视器。</p><p>**<code>setData(path, data, version)</code>**： 如果版本号是version，写入数据data[]到znode路径。</p><p>**<code>getChildren(path, watch)</code>**：返回一个znode的子节点集。</p><p>**<code>sync(path)</code>**：把所有在sync之前的更新操作都进行同步，达到每个请求都在半数以上的 ZooKeeper 服务器上生效。path参数目前没有用。</p><p>所有方法都有<strong>同步版本和异步版本</strong>，可通过 API 获得。 应用程序在执行单个ZooKeeper操作且没有并发任务时往往会使用同步 API，因此让ZooKeeper阻塞是必要的。 但是，异步 API 可以使应用程序进行多个未完成的 ZooKeeper 操作和其他并行任务。 ZooKeeper 客户端保证每个操作的相应回调函数是按顺序被调用的。</p><p>注意，ZooKeeper不使用句柄来访问 Znode，而是通过完整路径来访问。 这个选择不仅简化了 API（没有 open () 或 close () 方法），而且还消除了服务器需要维护的额外状态。</p><p>每个更新方法都采用预期的版本号，这使得可以实现条件更新。 如果 znode 的实际znode与预期版本号不匹配，则更新失败，报版本不一致的错误。 如果版本号为 -1，则不执行版本检查。</p><h2 id="2-3、Zookeeper的保证（Zookeeper-guarantees）"><a href="#2-3、Zookeeper的保证（Zookeeper-guarantees）" class="headerlink" title="2.3、Zookeeper的保证（Zookeeper guarantees）"></a>2.3、Zookeeper的保证（Zookeeper guarantees）</h2><p>ZooKeeper有两个基本的顺序保证： <strong>线性写</strong>：所有更新ZooKeeper状态的操作是串行的，先来先服务； <strong>FIFO客户端顺序</strong>：来自客户端的所有请求按客户端发送的顺序依次执行。</p><p>注意，我们的线性定义不同于 Herlihy [15] 最初提出的线性，我们称之为A-linearizability （异步线性化，asynchronous linearizability）。 在它对于的 “线性”的原始定义中，一个客户端只能一次有一个未完成的操作（客户端是一个线程）。 我们允许客户有多个未完成的操作，因此我们可以选择<strong>不保证同一客户的未完成操作的特定顺序</strong>，或者不保证 FIFO 顺序。 我们选择后者作为我们的特性 重要的是，我们观察到，对于可线性化对象的所有结果也适用于A-linearizable 对象，因为满足A-linearizable 的系统也具有线性化。 因为只有更新请求是A-linearizable的，ZooKeeper在每个副本上本地读取请求。 这使得系统通过添加服务器而线性扩展。</p><p>要了解这两个保证如何交互，请考虑以下场景。 包括多个进程的系统选举leader来命令worker进程。 当新的leader负责该系统时，它必须改变大量的配置参数，并且一旦它完成就会通知其他进程。 我们有两个重要的要求：</p><ol><li>当新的leader进行更改时，我们不希望其他进程使用正在被改变的配置；</li><li>如果新的leader在配置被完全更新之前宕机，我们不希望其他进程使用这个被部分更新的配置。</li></ol><p>注意，分布式锁，如 Chubby 提供的锁，将有助于满足第一个要求，但满足不了第二个。 在 ZooKeeper 中，新的leader可以指定一个路径作为<strong>Ready Znode</strong>；其他进程只在Ready Znode 存在时才使用这个配置。新的leader通过删除Ready Znode、更新各种配置 Znode 和创建Ready Znode来使配置改变。 所有这些更改都可以流水线化并异步发布以快速更新配置状态。尽管改变操作的等待时间是 2 毫秒，但是如果请求被一个接一个地发布，则更新 5000 个不同的 Znode 的leader将必须花费 10 秒；通过异步地发出请求将花费少于一秒。 由于有顺序的保证，如果一个进程看到Ready Znode，它也必须看到新leader所做的所有配置更改。 如果新的Leader在创建Ready Znode 之前宕机，其他进程知道配置尚未完成并且不使用它。（Hades注：Ready Znode相当于一个分布式锁）</p><p>上述方案仍然存在问题 ： 如果一个进程在新的leader开始进行改变之前已经看到ready存在，并且在改变正在进行时开始读取配置，会发生什么。 该问题由通知的顺序来保证：如果客户端正在监视变更事件，则客户端将在做出改变之后、看到系统的新状态之前收到通知事件。<strong>因此，如果读取Ready Znode的进程同时也监听了在该Znode上发生的更改，它将在读取任何新配置之前，收到Ready Znode被更改的通知。</strong></p><p>另一个问题可能出现在客户除了ZooKeeper还有自己的通信渠道。 例如，考虑在ZooKeeper中具有共享配置的两个客户端 A 和 B，并且通过共享信道进行通信。 如果 A 更改了 ZooKeeper 中的共享配置并通过共享信道告知 B 更改，则 B 将会在重新读取配置时看到更改。 如果 B 的ZooKeeper 副本稍微落后于 A，则可能看不到新的配置。 通过上述保证，B可以确保在重新读取配置之前，它可以通过发出一个写来查看最新的信息。 为了更有效地处理这个场景，ZooKeeper 提供<strong>sync请求</strong>：当sync之后有一个read操作时，它俩会构成一个慢读取操作。sync使一个服务器在执行read操作之前会执行所有被挂起的write请求，而没有一个完整写的开销。 这种原语的思想与 ISIS [5] 的原语相似。</p><p>ZooKeeper 还具有以下两个可用性和持久性保证：</p><ul><li>如果半数以上的 ZooKeeper 服务器是活跃的，则集群服务是可用的；</li><li>如果ZooKeeper 服务成功地响应了改变状态的请求，那么只要失败的服务器是可恢复的，则该变更就会在任何数量的故障服务器中被持久化。</li></ul><h2 id="2-4、原语的例子（Examples-of-primitives）"><a href="#2-4、原语的例子（Examples-of-primitives）" class="headerlink" title="2.4、原语的例子（Examples of primitives）"></a>2.4、原语的例子（Examples of primitives）</h2><p>在本节中，我们展示了如何使用 ZooKeeper API 来实现更强大的原语。 ZooKeeper 服务对这些更强大的原语一无所知，因为它们完全是在 ZooKeeper客户端 API 上实现的。 一些常见的原语，如组成员身份和配置管理，也是无等待的。 对于其他的人，如集合点，客户需要等待事件。 即使ZooKeeper 是免等待的，我们可以使用ZooKeeper实现有效的阻塞原语 ZooKeeper的顺序保证允许有效的推理系统状态，watches 允许有效等待。</p><p><strong>配置管理（Configuration Management）</strong> </p><p>在分布式应用中，可以使用ZooKeeper 来实现动态配置。 在其最简单的形式中，配置被存储在 Znode Zc 中。 进程以 Zc 的完整路径名开始。 启动进程通过读取 Zc 而获得它们的配置，其中watch设置为 True。 如果更新了 Zc 中的配置，则通知进程处理并读取新配置，再次将watch标志设置为True。</p><p>注意，在这个方案中，在使用watches的大多数其他方案中，使用watches来确保进程具有最新的信息。 例如，如果监视 Zc 的进程被通知Zc有改变，并且在读取新的 Zc 之前存在对 Zc 的三个或者更多改变，则该进程不会接收三个或者更多通知的事件。 这并不影响进程的行为，因为这三个事件只是简单地通知进程它已经知道的事情 ： 它对于 Zc 的信息是陈旧的。</p><p><strong>汇合（Rendezvous）</strong></p><p>有时在分布式系统中，最终的系统配置将看起来是什么样子并不总是清楚的。 例如，客户机可能想要启动主进程和几个工作进程，但是启动进程是由调度程序完成的，因此客户机不知道在时间之前的信息，诸如地址和端口，这些用来给予worker进程连接到主设备的信息。 我们用ZooKeeper来处理这个场景，Znode Zr 是由客户端创建的节点。 客户机将 Zr 的完整路径名作为master和worker进程的启动参数传递。 当主控器开始填充 Zr 时，它就会使用关于地址和端口的信息。 当worker开始工作时，他们读了 Zr，watch设置为真。 如果尚未填写 Zr，则在 Zr 更新时，worker会被通知。 如果 Zr 是短暂节点，则主进程和worker进程可以在客户端结束时监视 Zr 被删除并清除自己。</p><p><strong>群组关系（Group Membership）</strong></p><p>我们利用临时节点来实现组成员身份。 具体而言，我们使用临时节点基于它允许我们看到创建节点的会话状态的事实。我们开始设计一个 Znode，Zg 来代表这个组。 当组的进程成员开始时，它在Zg 下创建临时子 Znode。 如果每个进程都有唯一名称或标识符，则该名称被用作子 Znode 的名称；否则，进程将创建带有顺序标志的 Znode，以获得唯一名称分配。 进程可以将进程信息放入进程所使用的子 Znode、地址和端口的数据中。</p><p>在 Zg 下创建子 Znode 之后，进程正常开始。 它不需要做任何别的事情。如果进程失败或结束，则自动删除表示它的 Znode。</p><p>进程可以通过简单列出 Zg 的孩子来获得群组的信息。 如果进程想要监视组成员身份的改变，则该进程可以在接收到改变通知时将watch标志设置为True，并且刷新群组信息 (watch标志总是被置为True)。</p><p><strong>简单锁（Simple Locks）</strong></p><p>虽然ZooKeeper 不提供锁服务，它可以用来实现锁。 使用ZooKeeper的应用程序通常使用针对其需要定制的同步原语，如上面所示。 在这里，我们演示如何使用 ZooKeeper 实现锁，以显示它可以实现广泛的各种通用同步原语。</p><p>最简单的锁实现使用 “锁文件 ”。锁由一个 Znode 表示。 为了获取锁，客户端尝试创建具有短暂标志的指定 Znode。 如果创建成功，则客户端持有锁。 否则，客户端使用watch标志来读取 Znode以得到通知，如果当前的leader死亡，客户端在其死亡或非法删除 Znode 时释放锁。 其他正在等待锁的客户端一旦观察到被删除的 Znode，就会再次尝试获取锁。</p><p>虽然这种简单的锁定协议工作，但确实存在问题。 首先，它受到<strong>羊群效应</strong>的影响。 如果有许多客户端等待获取锁，即使只有一个客户端可以获取锁，它们都会在释放锁的时候争夺锁。 第二，它<strong>只实现了排他锁</strong>。 下面的两个原语说明如何克服这两个问题。</p><p><strong>无羊群效应的简单锁（Simple Locks without Herd Effect）</strong>我们定义一个锁znode l来实现这样的锁。直观上，我们排列所有请求锁的客户端，每个客户端都按请求到达的顺序获得锁。因此，希望获得锁的客户如下:</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305011557124.png"></p><p>在锁定操作的第一行中使用SEQUENTIAL标志，使得客户端的请求与其他的请求<strong>按顺序请求锁</strong>。 如果客户端的 Znode 在第 3 行具有最低序列号，则客户端持有锁。 否则，客户端要么等待具有锁的 Znode 被删除，要么将在该客户端的znode之前接收到该锁。<strong>通过只监视客户端的znode之前的znode，我们只在释放锁或放弃锁请求时唤醒一个进程，从而避免了羊群效应</strong>。 一旦客户端监视的 Znode 消失，客户端必须检查它现在是否持有锁。 (先前的锁定请求可能已经被放弃，并且存在具有较低序列号的 Znode 仍然等待或持有锁)。</p><p>释放锁与删除 表示锁请求的 Znode N 一样简单。 通过使用创建时的EPHEMERAL标志，崩溃的进程将自动清除任何锁请求或释放他们可能拥有的任何锁。 总之，这种锁定方案具有以下优点 ：</p><ol><li>Znode 的移除仅导致一个客户端醒来，因为每个 Znode 被恰好另一个客户端监视，所以我们没有羊群效应；</li><li>没有轮询或超时；</li><li>我们实现锁的方式，使得我们可以通过浏览 ZooKeeper的 数据来查看锁竞争、中断锁并debug锁中存在的问题。</li></ol><p><strong>读写锁（Read/Write Locks）</strong>为了实现读写锁，我们稍微改变了锁相关的程序代码，并有独立的读锁和写锁过程。解锁过程与普通锁的情况相同。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305011612276.png"></p><p>这段锁程序代码与先前的代码稍有不同。 写锁只在命名方面不同。 由于读锁可以被共享，所以第三行和第四行稍稍有改变，只有较早的写锁 Znode 才能阻止客户端获取读锁。 如果有几个客户端等待读锁，并且在删除具有较低序列号的 “write - ”znode 时得到通知，这似乎出现会“惊群效应 ”；实际上，这是我们所需要的行为，所有读操作的客户端都应该被释放，因为它们现在有了锁。</p><p><strong>双重屏障（Double Barrier）</strong>双重屏障使客户端能够同步一个计算的开始和结束。当由屏障阈值定义的足够多的进程加入屏障时，进程开始计算，并在完成后离开屏障。 我们用 Znode 来表示ZooKeeper的屏障，称为 B。 每一个进程 P 都在 B 通过创建一个 Znode 作为 B 的孩子来注册，在它准备好离开时取消注册。 当 B 的子 Znode 的数目超过屏障阈值时，进程可以进入屏障。 进程可以在所有的进程都已移除其孩子时离开屏障。 我们使用监视器高效地等待进入和退出条件得到满足。 如果要进入屏障的话，进程需要监视 B 的准备好的子节点，当子节点数量超过屏障阈值时，该进程才可以进入。 如果要离开屏障，进程监视某个特定的孩子消失，并且只有在这个特定的 Znode 被删除后才检查退出条件。</p><h1 id="3、ZooKeeper的应用（ZooKeeper-Applications）"><a href="#3、ZooKeeper的应用（ZooKeeper-Applications）" class="headerlink" title="3、ZooKeeper的应用（ZooKeeper Applications）"></a>3、ZooKeeper的应用（ZooKeeper Applications）</h1><p>现在我们描述一些使用ZooKeeper的应用程序，并简要说明它们的使用。 我们以粗体显示每个例子的原型。</p><p><strong>爬取服务（The Fetching Service）</strong></p><p> 爬虫是搜索引擎的一个重要组成部分，而 Yahoo! 抓取数十亿的 Web 文档。 获取服务（FS）是 Yahoo! 爬虫的一部分，目前正在生产环境中。 本质上，它有一个主进程，来指挥页面抓取进程。 主节点为抓取器（fetcher）提供配置，抓取器将其状态和健康状况写回来。使用 ZooKeeper for FS 的主要优点是从主机的故障恢复，尽管失败了，但仍然保证可用性，并且将客户端与服务器分离，从而允许他们通过从ZooKeeper中读取他们的状态来引导他们重新搜索健康服务器。 因此，FS 使用ZooKeeper 主要是管理配置元数据，虽然它还使用ZooKeeper 选举master（leader选举）。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305011717411.png"></p><p>图 2 显示了 FS 使用的ZooKeeper服务器的读取和写入流量，为期三天。 为了生成这个图，我们计算周期期间每秒的次数，每个点对应于那一秒操作的次数。 我们观察到，读取流量比写入流量高得多。 在速率高于每秒 1, 000 次操作的时段期间，读取 ： 写入比率在 10∶1 到 100∶1 之间变化。 在此工作负载中的读取操作是 GetData ()、GetPages () 和 Exists ()，以增加的顺序。</p><p><strong>Katta</strong> </p><p>Katta [17] 是一个使用 ZooKeeper协调的分布式索引器，它是一个非雅虎应用程序的例子。 Katta 通过使用碎片划分了索引的工作。 master将碎片分配给slaves并跟踪进度。 slave可能失败，所以这时master必须重新分配负荷。 master也可能失败，因此其他服务器必须准备好在故障的情况下接管。 <strong>Katta 使用ZooKeeper跟踪slave服务器和master服务器的状态（组成员身份），并处理master故障转移（leader选举）</strong>。 Katta 还使用ZooKeeper跟踪和分配数据分片给slave服务器（配置管理）。</p><p><strong>Yahoo! Message Broker</strong> </p><p>雅虎消息代理 (YMB) 是分布式发布 - 订阅系统。 该系统管理数千个主题，客户端可以发布消息并接收消息。 主题分布在一组服务器中以提供可扩展性。 使用主备份方案复制每个主题，确保将消息复制到两个机器中以确保可靠的消息传递。 组成 YMB 的服务器使用无共享的分布式体系结构，这使得协调对于正确操作至关重要。 YMB <strong>使用ZooKeeper来管理主题的分布（配置元数据），处理系统中机器的故障 (故障检测和组成员身份)，以及控制系统操作</strong>。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305011724131.png"></p><p>图 3 显示了 YMB 的 Znode 数据布局的一部分。 每个broker domain都有一个 Znode，称为节点，节点具有组成 YMB 服务的每个活动服务器的临时 Znode。 每个 YMB 服务器节点下创建一个短暂 Znode，它具有负载和状态信息，<strong>通过 ZooKeeper 提供组成员资格和状态信息</strong>。 所有组成服务的服务器都对禁用的节点（如禁用和迁移）进行了维护，并允许对 YMB 进行集中控制。 每个主题在topics下都有一个子节点。这些 Znode 指示了每个主题的主服务器和备份服务器和该主题的订阅者。 主服务器和备份服务器 Znode 不仅允许服务器发现那个负责某一个主题的服务器，而且还管理<strong>领导选举</strong>和服务器崩溃。</p><h1 id="4、ZooKeeper的实现（ZooKeeper-Implementation）"><a href="#4、ZooKeeper的实现（ZooKeeper-Implementation）" class="headerlink" title="4、ZooKeeper的实现（ZooKeeper Implementation）"></a>4、ZooKeeper的实现（ZooKeeper Implementation）</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305011729546.png"></p><p>ZooKeeper通过在构成服务的每个服务器上复制 ZooKeeper 数据提供高可用性。 我们假设服务器崩溃，服务器可能会恢复。 图 4 显示了ZooKeeper 服务的高级组件。 接收请求后，服务器将准备执行（请求处理器）。 如果这样的请求需要服务器之间的协调 (写请求)，那么它们使用一致性协议 (原子广播的实现，即ZAB协议)，并且最终服务器将更改提交到ZooKeeper集群的所有服务器的数据库上。 在读取请求的情况下，服务器简单地读取本地数据库的状态并生成对请求的响应。</p><p><strong>复制数据库（replicated database）</strong>是包含整个数据树的内存数据库。 树中的每个 Znode 默认存储最多 <strong>1MB</strong> 的数据，但是这个最大值是在特定情况下可变的配置参数。 对于可恢复性，我们有效地将更新记录到磁盘上，并且在磁盘介质被应用到内存数据库之前，我们强制写入磁盘介质。 事实上，与 chubby [8]相比，我们保留了提交的操作的重放日志（在我们这里是预写日志），并生成内存中数据库的定期快照。</p><p>每个ZooKeeper 服务器都能服务客户端。 客户端连接一个服务器来提交请求。 正如我们前面提到的，使用每个服务器数据库的本地副本来服务读取请求。 改变服务状态的请求，即写请求，由ZAB协议处理。</p><p>作为协议的一部分，写请求被转发到一个称为 leader 的服务器。 其余的ZooKeeper服务器，称为Follower，它们从leader接收消息（主要是状态），并商定状态更改。</p><h2 id="4-1、请求处理器（Request-Processor）"><a href="#4-1、请求处理器（Request-Processor）" class="headerlink" title="4.1、请求处理器（Request Processor）"></a>4.1、请求处理器（Request Processor）</h2><p>由于消息层是原子的，我们保证本地副本从不偏离，尽管在任何时间点，一些服务器可能比其他服务器应用更多的事务。 与从客户端发送的请求不同，事务是幂等的。 当leader接收到写请求时，它计算当应用写入时系统的状态将是什么，并且将它转换成捕获这个新状态的事务。 由于可能存在尚未应用于数据库的可能存在的事务，因此必须计算该状态。 例如，如果一个客户端在请求中的条件 setData 且其版本号能够与正在更新的 Znode 的未来的版本号相匹配，则该服务生成一个 SetDataTxN，该 SetDataTxN 包含新数据、新版本号和更新的时间戳。 如果出现错误，如不匹配版本号或要更新的 Znode 不存在，则改为生成 ErrorTXN。</p><h2 id="4-2、原子广播（Atomic-Broadcast）"><a href="#4-2、原子广播（Atomic-Broadcast）" class="headerlink" title="4.2、原子广播（Atomic Broadcast）"></a>4.2、原子广播（Atomic Broadcast）</h2><p>所有更新ZooKeeper状态的请求都被转发到leader。 leader执行这个请求并通过 一个原子广播协议ZAB [24] 向ZooKeepeer广播变更。接收客户端请求的服务器，在传递其对应的状态改变时，响应客户端。 ZAB 用大多数的意见来决定一个建议，所以只有大多数服务器是正确的， Zab 和 ZooKeeper 才能工作（即，用 2f + 1 个服务器我们可以容忍 f 个服务器的故障）。（<em>注：这里关于半数的描述与Raft协议极为相似，或者说ZooKeeper是构建在Raft协议之上的一个应用程序</em>）</p><p>为了获得高吞吐量，ZooKeeper 试图保持请求处理流水线化。 它可能会处理成千上万个位于管道不同部分的请求。 由于状态改变依赖于应用先前状态改变，所以 ZAB 提供比常规原子广播更强的次序保证。 更具体地，<strong>ZAB 保证由leader广播的改变按照它们被发送的顺序递送</strong>，并且来自先前leader的所有改变在广播其自身改变之前被递送到一个已经建立的leader。</p><p>有一些实现细节简化了我们的实现并给我们出色的性能。我们使用 TCP 为我们的传输层协议，所以消息顺序由网络主导，这允许我们简化我们的实现。我们使用由 ZAB 选举出的leader作为ZooKeeper的leader，以便与创建事务相同的进程也提出。 我们使用日志来跟踪提议，<strong>作为内存中数据库的预写日志（write-ahead log，WAL）</strong>，这样我们就不必两次将信息写入磁盘。</p><blockquote><p>Write-ahead log（WAL）是一种常见的技术，用于在数据库或其他应用程序中记录事务性操作。在WAL中，所有的写操作都首先被记录到一个日志文件中，然后再被写入到磁盘或内存中。</p></blockquote><h2 id="4-3、复制数据库（Replicated-Database）"><a href="#4-3、复制数据库（Replicated-Database）" class="headerlink" title="4.3、复制数据库（Replicated Database）"></a>4.3、复制数据库（Replicated Database）</h2><p>每个副本都有一个在内存里的ZooKeeper 状态的副本。 当管理员服务器从崩溃中恢复时，它需要恢复此内部状态。 在运行服务器一段时间后，重放所有日志来恢复状态将非常耗时，所以 ZooKeeper 使用定期快照，只需要自快照开始后重新发送消息。 我们称ZooKeeper的快照为<em>模糊快照（fuzzy snapshots）</em>，因为我们不锁定 ZooKeeper 状态来获取快照；相反，我们首先进行树的深度扫描，以原子读取每个znode 的数据和元数据并将它们写入磁盘。 由于所得到的模糊快照可能已经应用了在生成快照期间所传递的状态改变的一些子集，所以结果可能不对应于在任何时间点的ZooKeeper 的状态。 然而，由于状态变化是幂等的，所以只要我们按顺序应用状态改变，我们就可以应用两次。（<em>Hades注：在大多数分布式系统中经常采用的两种复制策略，增量复制和全量复制，全量复制可能需要日志压缩</em>）</p><blockquote><p>具体来说，第一次应用状态更改是在恢复快照后，将快照包含的状态更改应用到ZooKeeper状态中；第二次应用状态更改是将快照之后未包含在快照中的状态更改重新应用到ZooKeeper状态中。通过这种方式，可以确保所有状态更改都被应用，并恢复完整的ZooKeeper状态。</p></blockquote><p>例如，假设在ZooKeeper 数据树中，两个节点 /foo 和 /goo 分别具有值 f1 和 g1，并且当开始应用模糊快照时，两个节点都处于版本 1，并且下面的状态改变流具有形式 <code>(transactionType, path, value, new-version)</code></p><pre class="line-numbers language-none"><code class="language-none">(SetDataTXN, &#x2F;foo, f2, 2)(SetDataTXN, &#x2F;goo, g2, 2)(SetDataTXN, &#x2F;foo, f3, 3)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在处理这些状态改变之后，/foo 和 /goo 分别具有版本 3 和 2 的值 f3 和 g2。 然而，模糊快照可能已经记录了 /foo 和 /goo 分别具有版本 3 和 1 的值 f3 和 g1，这不是ZooKeeper 数据树的有效状态。 如果服务器在此快照中崩溃并恢复，且 ZAB 重新传递状态更改，则<strong>生成的状态对应于崩溃前的服务状态</strong>。</p><h2 id="4-4、客户端与服务器端的交互"><a href="#4-4、客户端与服务器端的交互" class="headerlink" title="4.4、客户端与服务器端的交互"></a>4.4、客户端与服务器端的交互</h2><p>当服务器处理写请求时，它还发送并清除与该更新相对应的任何watch相关的通知。Servers 按顺序处理写入, 并且不同时处理其他写入或读取。 这确保了通知的严格连续。 注意服务器只处理本地通知。 只有客户端所连接到的服务器才跟踪并触发该客户端的通知。（<em>Hades注：所有的写操作都会转发到leader上处理，因此也就能保证串行化了</em>）</p><p>Read 请求在每个服务器上<strong>本地处理</strong>。 每个读请求都被处理并标记有一个 <em>zxid</em>，该 <em>zxid</em> 对应于服务器看到的最后一个事务。 此 <em>zxid</em> 定义读取请求的部分顺序，并重新检查写入请求。 通过本地处理读取，我们获得了优异的读取性能，因为它只是本地服务器上的内存操作，并且没有读的磁盘的操作或者协议去运行。 这样设计是实现具有读为主要工作负载的优良性能的目标的关键。</p><p>使用快速读取的一个缺点是不能保证读取操作的优先顺序。 也就是说，即使已经提交了对同一 Znode 的最近更新，读操作也可以返回旧值。 并不是所有的应用程序都需要优先顺序，但是对于需要优先顺序的应用程序，我们实现了 sync。 此原语异步执行, 并由领导在所有挂起的写入其本地副本之后对其进行排序。 为了保证给定的读操作返回最新的更新值，client在每次读操作之前调用一个sync操作。 客户端操作的 FIFO 顺序保证以及同步的全局保证使得读取操作的结果能够反映在调用同步之前发生的任何改变。 在我们的实现中，我们不需要原子广播同步，因为我们使用基于leader的算法，并且我们<strong>简单地将同步操作放置在请求队列的末端</strong>，在leader和follower之间进行调用。 为了实现这一目标，follower必须确保leader仍然是leader。如果存在提交的挂起事务，则服务器不会怀疑leader。 如果挂起的队列为空，领导需要发出一个空事务来提交，并把sync排在该事务之后同步。这具有良好的特性，即当leader处于高负载之下时，集群不会生成额外的广播流量。 在我们的实现中，设置超时可以使得leader在follower放弃他们之前意识到他们不是leader，因此我们不发布空事务。</p><p>ZooKeeper 服务器以 FIFO 顺序处理来自客户端的请求，并响应与之相关的 <em>zxid</em>。 甚至在没有活动的间隔期间的心跳消息，也包括了客户端连接到的服务器看到的最后一个 <em>zxid</em>。 如果客户端连接到新服务器，则该新服务器通过对照客户端的最后 <em>zxid</em> 检查客户端的最后 <em>zxid</em> 来确保其对 ZooKeeper 数据的状态视图至少与客户端的状态视图一样新。 <strong>如果客户端具有比服务器更新的状态视图，则服务器直到追赶上才与客户端建立连接</strong>。 由于客户端只看到已经复制到大多数 ZooKeeper 服务器的更改，因此保证客户端能够找到具有系统最新视图的另一服务器。 这种行为对保证持久性很重要。</p><p>为了检测客户端会话失败，ZooKeeper 使用<strong>超时机制</strong>。 如果在会话超时内没有其他服务器从客户端接收到任何信息, leader将确定发生了故障。 如果客户端发送的请求足够频繁，则不需要发送任何其他消息。 否则，客户端在低活动期间发送<strong>心跳消息</strong>。 如果客户端无法与服务器发送请求或心跳的服务器通信，则它将连接到不同的 ZooKeeper 服务器以重新建立其会话。 为了防止会话超时，ZooKeeper 客户端库在会话空闲 <em>s</em> / 3ms 之后发送心跳，如果没有在2<em>s</em> / 3ms时间内收到服务器的消息，则切换到新服务器。这里的 <em>s</em> 代表会话超时时间，单位是ms。</p><h1 id="5、评估（Evaluation）"><a href="#5、评估（Evaluation）" class="headerlink" title="5、评估（Evaluation）"></a>5、评估（Evaluation）</h1><p>我们在 50 个服务器的集群上进行了所有的评估。每个服务器有一个 Xeon 双核 2. 1GHz 处理器，4GB 的 RAM，千兆以太网，和两个 SATA 硬盘。 我们将下面的讨论分为两部分：请求的<strong>吞吐量和延迟</strong>。</p><h2 id="5-1、吞吐量（Throughput）"><a href="#5-1、吞吐量（Throughput）" class="headerlink" title="5.1、吞吐量（Throughput）"></a>5.1、吞吐量（Throughput）</h2><p>为了评估我们的系统，我们测试了系统饱和时的吞吐量和各种故障时的吞吐量变化。我们改变了组成 ZooKeeper 服务的服务器的数量，但是总是保持客户端的数量相同。 为了模拟大量的客户端，我们使用 35 台机器来模拟 250 个同时的客户端。</p><p>我们有Java 实现的 ZooKeeper 服务器，Java 和 C 实现的客户端。 基于经验，我们使用Java 服务器配置日志记录到专用磁盘，并在另一个磁盘上获取快照 。 我们的基准测试客户端使用异步 Java 客户端 API，每个客户端至少有 100 个待完成的请求。每个请求由 1K 数据的读或写组成。我们不显示其他操作的benchmark，因为修改状态的所有操作的性能近似相同，而不包括sync的非状态修改操作的性能近似相同（ 同步的性能与轻量级写入的性能一致，因为请求必须传递给leader，但不能广播）。 客户每 300ms 发送完成操作次数的计数，我们每 6s 采样一次。 为了防止内存溢出，服务器限制了系统中并发请求的数量。 ZooKeeper 对请求进行限流来防止服务器被淹没。 对于这些示例，我们将 ZooKeeper 服务器配置为在进程中具有最多 2000 个请求。</p><blockquote><p>Benchmark是一种测试方法，用于评估计算机系统或组件的性能。它通常涉及运行一系列标准化的测试，以测量系统在不同负载下的响应时间、吞吐量、延迟等指标。Benchmark可以帮助开发人员和系统管理员了解系统的性能瓶颈，并确定如何优化系统以提高性能。在计算机科学中，Benchmark也可以用于比较不同系统或组件之间的性能差异。</p></blockquote><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012157437.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012157204.png"></p><p>在图 5 ，我们显示了当我们改变读与写的比率时的吞吐量，每个曲线对应于提供 ZooKeeper 服务的服务器的不同数量。 表 1 显示了读操作的负载上限。 读取吞吐量高于写入吞吐量，因为读取不使用原子广播。 该图还示出了服务器的数量也对广播协议的性能具有<strong>负面影响</strong>。 从这些图表中，我们观察到系统中服务器的数量不仅影响服务能够处理的故障的数量，而且影响服务能够处理的工作负载。 注意，3 servers 曲线与其他数量服务器的曲线在横轴约 60% 的时候交叉。这种情况下包括三服务器配置，并且由于启用了并行本地读取，所以配置变化会发生在所有配置中。但是，对于图中的其他配置，这是不可见的，因为我们为了可读性设置了最大 y 轴吞吐量的上限。</p><p>写入请求比读取请求花费更长的时间有两个原因。 首先，写请求必须经过<strong>原子广播</strong>，这需要一些额外的处理并增加请求的延迟。 对写请求进行更长的处理的另一个原因，是服务器必须确保在将ACK发送回leader之前将事务日志记录到非易失性存储介质。 在实际应用中，这种要求是过度的，但是对于我们的生产系统，我们<strong>用性能来换取可靠性</strong>，因为我们使用 ZooKeeper 构成应用基础。 我们使用更多服务器来保证容错。 我们通过将 ZooKeeper 数据划分成多个 ZooKeeper 整体来增加写入吞吐量。 Gray 等人先前已经观察到复制和分区之间的这种性能折衷。 [12].</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012204427.png"></p><p>ZooKeeper 能够通过在服务器集群上分配负载来实现高吞吐量。 之所以可以分配负载，是因为我们降低了一致性保证。Chubby中的客户端将所有请求定向到leader。 图 6 显示了如果我们不利用这种弱一致性，并强迫客户只连接到leader会发生什么。 <strong>正如预期的，对于以读为主的工作负载，吞吐量要低得多，但即使对于以写为主的工作负载，吞吐量也较低</strong>。 给客户端提供服务引起的额外 CPU 和网络负载，影响了leader协调选举的广播能力，这反过来也会对总体写入性能产生坏影响。</p><p>原子广播协议完成系统的大部分工作，因此比任何其他组件更多地限制了 ZooKeeper 的性能。 图 7 显示了原子广播组件的吞吐量。 为了评估其性能，我们通过直接在leader处生成事务来模拟客户端，因此没有客户端连接或客户端请求和回复。 在最大吞吐量，原子广播组件变为 CPU 绑定。 理论上，图 7 的性能将与具有 100％写入的 ZooKeeper 的性能相匹配。 但是，ZooKeeper 客户端通信、 ACL 检查和请求事务转换都需要 CPU。 CPU 的争用使得 ZooKeeper 吞吐量比单独的原子广播组件小。 由于 ZooKeeper 是一个关键的生产组件，到目前为止我们对 ZooKeeper 的开发重点是正确性和健壮性。通过消除额外副本、同一对象的多个序列化、更高效的内部数据结构等，有大量的机会显著提高性能。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012208954.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012208383.png"></p><p>为了显示系统在注入故障时的行为，我们运行了一个由 5 台机器组成的 ZooKeeper 服务。我们运行了与以前相同的饱和基准测试，但这次我们将写入百分比保持在恒定的 30%，这是我们预期的工作负载的保守比例。我们定期地杀死一些服务器进程。图 8 示出了随着时间变化的系统吞吐量。 图中标出的事件如下 ：</p><ol><li>follower的故障和恢复；</li><li>另一个不同的follower的故障和恢复；</li><li>leader故障；</li><li>在前两个标记下两个follow (a，b) 的故障，并且在第三标记 (c) 处恢复；</li><li>leader故障。</li><li>leader恢复。</li></ol><p>这幅图中有一些重要的观察结果。</p><ul><li>首先，如果follower失败并快速恢复，则 ZooKeeper 能够维持高吞吐量，尽管失败。一个follower的失败并不能阻止服务器集群对外提供服务，并且仅粗略地通过服务器在失败之前正在处理的读请求来减少吞吐量。</li><li>第二，我们的leader选择算法能够足够快地恢复，以防止吞吐量大幅下降。 在我们的工作中，ZooKeeper 需要不到 200ms 的时间来选举新的leader。 因此，尽管服务器在几分之一秒内停止服务请求，但是由于我们的采样周期的缘故（大约为秒），我们没有观察到零吞吐量。</li><li>第三，即使follower需要更多的时间来重新恢复，ZooKeeper 也能够在他们开始处理请求时再次提高吞吐量。 在事件 1、2 和 4 之后，我们没有恢复到完全吞吐量水平的一个原因，是客户端仅在与follower的连接中断时切换follower。 因此，在事件 4 之后，直到leader在事件 3 和 5 处失败，client才重新分配它们自己的请求。 实际上，随着客户端连接的建立与释放，这种不平衡随着时间的推移而起作用。</li></ul><h2 id="5-2、请求延迟（Latency-of-requests）"><a href="#5-2、请求延迟（Latency-of-requests）" class="headerlink" title="5.2、请求延迟（Latency of requests）"></a>5.2、请求延迟（Latency of requests）</h2><p>为了评估请求的延迟，我们创建了一个以 Chubby benchmark [6] 为模型的benchmark。 我们创建了一个工作进程，它简单地发送一个 create，等待它完成，发送一个新节点的异步删除，然后启动下一个 create。 我们相应地改变worker的数量，并且对于每次运行，我们使每个worker创建 50, 000 个节点。 我们通过将完成的创建请求的数量除以所有worker完成的总时间来计算吞吐量。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012211696.png"></p><p>表 2 显示了benchmark的结果。 创建请求包括 1K 的数据，而不是 Chubby benchmark中的 5 个字节，以更好地符合我们的预期使用。 即使有了这些更大的请求，ZooKeeper 的吞吐量也比 Chubby 发布的吞吐量高出 3 倍以上。 单个 ZooKeeper worker benchmark的吞吐量显示三个服务器的平均请求延迟为 1.2ms，9 个服务器的平均请求延迟为 1.4ms。</p><h2 id="5-3、性能屏障（Performance-of-barriers）"><a href="#5-3、性能屏障（Performance-of-barriers）" class="headerlink" title="5.3、性能屏障（Performance of barriers）"></a>5.3、性能屏障（Performance of barriers）</h2><p>在本实验中，我们执行多个屏障来评估使用 ZooKeeper 原本的性能。 对于给定数量的屏障 b，每个客户端首先进入所有的 b 屏障，然后它连续地离开所有的 b 屏障。 当我们使用第 2. 4 节的双屏障算法时，client首先等待所有其他client执行 <code>enter ()</code> 过程之后才进行下一个调用（类似于 <code>leave ()</code>）。</p><p>我们在表 3 中报告了我们的实验结果。 在这个实验中，我们有 50、100 和 200 个客户相继进入数量为 b 的屏障，b属于集合 {200, 400, 800, 1600} 虽然应用程序可以有数以千计的 ZooKeeper 客户端，但通常有小得多的子集参与每个协调操作，因为客户端通常根据应用程序的特性进行分组。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305012213857.png"></p><p>本实验的两个有趣的观察结果是，处理所有屏障的时间与屏障的数量大致成正比，表明对数据树的相同部分的并发访问不会增加任何意外延迟。延迟的增长和客户端的数量成正比。 这是没使 ZooKeeper 服务饱和的结果。 事实上，我们观察到，即使在客户在锁定的步骤下下，屏障操作 (进入和离开) 的吞吐量在所有情况下都在每秒 1, 950 到 3, 100 个操作之间。 在 ZooKeeper 操作中，这对应于每秒 10, 700 到 17, 000 次操作之间的吞吐量值。 在我们的实现中，我们的读取与写入的比率为 4∶1（读取操作占 80%），与 ZooKeeper 可以实现的原始吞吐量相比，我们的benchmark代码使用的吞吐量要低得多（超过图 5 的 40, 000）。 这是由于客户端需要等待其他客户端。</p><h1 id="6、相关工作（Related-work）"><a href="#6、相关工作（Related-work）" class="headerlink" title="6、相关工作（Related work）"></a>6、相关工作（Related work）</h1><p>ZooKeeper 的目标是提供一种服务，该服务解决了分布式应用程序中协调进程的问题。 为了实现这个目标，它的设计使用了之前的协调服务、容错系统、分布式算法和文件系统的思想。</p><p>我们并不是第一个提出一个用于分布式应用程序协作的系统。 一些早期的系统提出了用于事务性应用的分布式锁服务 [13]，以及用于在计算机集群中共享信息 [19]。 最近，Chubby 提出了一种为分布式应用程序管理咨询锁的系统 [6]。 Chubby 和 ZooKeeper 有几个共同的目标。 它也具有类似文件系统的接口，并且它使用协议来保证副本的一致性。 但是，ZooKeeper 不是锁定服务。客户端可以使用它来实现锁，但是在其 API 中没有锁操作。 与 Chubby 不同，ZooKeeper 允许客户端连接到任何 ZooKeeper 服务器，而不仅仅是leader。 ZooKeeper 客户端可以使用他们的本地副本提供数据和管理watch，因为它的一致性模型比 Chubby 宽松得多。 这使得 ZooKeeper 能够提供比 Chubby 更高的性能，允许应用程序更广泛地使用 ZooKeeper。</p><p>在文献中已经提出了容错系统，其目的是<strong>减轻构建容错分布式应用程序</strong>的问题。 一个早期的系统是 ISIS [5]。 ISIS 系统将抽象的类型规范转换为容错的分布式对象，从而使容错机制对用户透明。 Horus [30] 和Ensemble [31] 是由 ISIS 进化而来的系统。 ZooKeeper 支持 ISIS 的虚拟同步概念。 最后，Totem 保证在利用局域网的硬件广播的体系结构中的消息传递的总顺序 [22]。 ZooKeeper 使用各种各样的网络拓扑，这些拓扑促使我们依赖于服务器进程之间的 TCP 连接，而不是假定任何特殊的拓扑或硬件特性。 我们也不公开在 ZooKeeper 中内部使用的任何集成通信。</p><p>构建容错服务的一项重要技术是<strong>状态机复制</strong> [26]，而 Paxos [20] 是一种能够有效实现异步系统的复制状态机的算法。 我们使用 Paxos 的某些特性的算法，但是将达成共识所需的事务日志记录与数据树恢复所需的提前写入日志记录结合起来，以实现高效的实现。 已经提出了用于拜占庭容忍复制状态机的实际实现的协议 [7、10、18、1、28]。 ZooKeeper 并不假设服务器可以是拜占庭，但是我们确实使用诸如<strong>校验和和理智检查之类的机制</strong>来捕捉非恶意的拜占庭错误。 Clement et al等人讨论了在不修改当前服务器代码库的情况下使 ZooKeeper 完全容忍拜占庭错误的方法 [9]。 到目前为止，我们还没有观察到使用完全 Byzantine 容错协议可以防止的生产中的故障。 [29].</p><p>Boxwood [21] 是一个使用分布式锁服务器的系统。 Boxwood 为应用程序提供了更高级的抽象，它依赖于一种基于 Paxos 的分布式锁服务。 ZooKeeper 和 Boxwood 一样，是构建分布式系统的重要工具。 然而，ZooKeeper 具有高性能要求，并且更广泛地用于客户端应用程序。 ZooKeeper 暴露了应用程序用于实现高级原语的低级原语。（<em>Hades注：即提供了更基础的功能模块的API</em>）</p><p>ZooKeeper 类似于小型文件系统，但它只提供文件系统操作的一小部分，并添加大多数文件系统中不存在的功能，例如排序保证和条件写入。 然而，ZooKeeper watch在本质上类似于 AFS 的缓存回调 [16]。</p><p>Sinfonia [2] 介绍了 <em>微事务（mini-transactions）</em>，一种用于构建可伸缩分布式系统的新范式。 Sinfonia 被设计为存储<strong>应用程序数据</strong>，而 ZooKeeper 存储<strong>应用程序元数据</strong>。 ZooKeeper保持其状态全复制，同时为了高性能和一致的延迟，状态会在内存中。 我们使用的文件系统（如操作和排序）功能上类似于mini-transactions。 Znode 是一个便捷的抽象，我们在上面添加了监视器watch，这是 Sinfonia 缺少的功能。 dynamo [11] 允许客户端在分布式键值存储中获得和放置相对少量 (小于 1M) 的数据。 与 ZooKeeper 不同，Dynamo 中的键空间不是分层的。 Dynamo 也不能为写入提供强大的持久性和一致性保证，但是解决了读取上的冲突。</p><p>DepSpace [4] 使用元组空间来提供 Byzantine 容错服务。 像 ZooKeeper一样，DepSpace使用简单的服务器接口在客户端实现强同步原语。 虽然 DepSpace 的性能比 ZooKeeper 低得多，但它提供了更强的容错和保密性保证。</p><h1 id="7、结论（Conclusions）"><a href="#7、结论（Conclusions）" class="headerlink" title="7、结论（Conclusions）"></a>7、结论（Conclusions）</h1><p>ZooKeeper 采用了一种无等待的方法来解决分布式系统中的进程协调问题，方法是向客户端暴露无等待的对象。 我们发现 ZooKeeper 对于 Yahoo! 内外的一些应用是有用的。 ZooKeeper 通过使用带有 watch 的快速读取实现了<strong>每秒几十万次操作的吞吐量</strong>，这些 watch 都由本地副本提供服务。 尽管我们对读取和watch的一致性保证似乎很弱，但是我们已经用我们的用例表明，这种组合允许我们在客户端实现高效和复杂的协调协议，即使读不是先后顺序的，数据对象的实现是无需等待的。 已经证明，无等待属性对于高性能是必不可少的。</p><p>虽然我们只描述了几个应用程序，但还有许多其他应用程序使用 ZooKeeper。 我们相信这样的成功是由于它的简单的接口，通过这个接口，更强大的抽象可以被实现。 此外，由于 ZooKeeper 的高吞吐量，应用程序可以广泛地使用它，而不仅仅是粗粒度锁。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vm-ft</title>
      <link href="/2023/042259758.html"/>
      <url>/2023/042259758.html</url>
      
        <content type="html"><![CDATA[<h1 id="摘要（Abstract）"><a href="#摘要（Abstract）" class="headerlink" title="摘要（Abstract）"></a>摘要（Abstract）</h1><p> 我们已经实现了一个基于容错虚拟机的商业化企业级系统，该系统通过运行在不同服务器上的备份虚拟机，将主虚拟机的运行情况进行了“复制”。我们已经在虚拟环境上设计了一个完整易上手的系统，它运行在商用服务器上，仅仅减少了真实应用不到10%的性能。此外，对于绝大多数真实应用，为了保证主从虚拟机运行协调，数据带宽不能超过20Mbit/s，这使得远距离实现容错成为了可能。一个容易使用的、能够在发生错误后自动地恢复冗余的商用系统需要许多额外运行在VM上的组件。我们已经设计并实现了这些额外的组件，并处理在使得VM能够支持运行企业级应用时所遇到的许多问题。在这篇论文中，我们描述了我们的基本设计，讨论了替代设计选项，以及一些实现细节，还提供了若干方面和真实应用的性能数据。</p><h1 id="1、介绍（Introduction"><a href="#1、介绍（Introduction" class="headerlink" title="1、介绍（Introduction)"></a>1、介绍（Introduction)</h1><p> 一个实现容错服务器的常见方法是<strong>主从复制</strong>，从属服务器总能够在主服务器出现错误的时候，及时地接管工作。从属服务器的状态必须一直与主服务器保持几乎一致，这样当主服务器退出的时候，从属服务器才能立即接管工作，让主服务器发生的错误对外部的用户不可见，并且不丢失数据。在从属服务器上复制主服务器状态的一个方法是连续不断地传输所有主服务器状态的变化给自己，包括CPU,存储，I/O设备。然而，这样要求传输的带宽会很高，尤其是在传输存储相关的状态变化的时候。</p><p> 另外一个能够使用较少的带宽复制服务器的方法是<strong>状态机方法</strong>。状态机方法将服务器建模成确定性状态机，在启动是时候保证初始状态相同，以及之后它们收到相同顺序的相同输入请求，那么它们就能够保持同步。然而，绝大多数服务器或者设备都有一些不确定性操作，所以必须要使用额外的协作来保证主从同步。尽管如此，额外需要保持的信息也比状态机本身的状态更新信息要小得多。</p><p> 实现能够确保物理服务器的确定性运行的协作是十分困难的，尤其是在处理器频率增加的情况下。与之对照的是，虚拟机运行在虚拟监视器上，是一个非常好的平台来实现状态机方法。一个VM其实是一个well_defined 的状态机，它的操作都是实际被虚拟化的物理机器的操作。和物理服务器一样，虚拟机有一些不确定性操作，所以额外的写作信息必须要发送给从属服务器以确保双方同步。因为虚拟监视器完全掌控着虚拟机的运行，包括输入的传递。所以一个虚拟监视器能够捕捉主VM上所有关于非确定性操作的必要信息，并且能够在从属VM上重新正确实现这些操作。</p><p> 因此，状态机方法可以通过在商用硬件上运行虚拟机来实现，而无需硬件级别的特殊修正，并且允许在最新的微处理器上也能实现(容错)。此外，低带宽使得状态机方法让主从服务器物理隔离很远成为了可能。比如说，被复制的虚拟机们可以运行在分布在整个校园的物理机上，而不是仅仅分布在一座大楼里。</p><p>我们已经在Vmware vSphere 4.0上实现了基于状态机的容错虚拟机，该容错虚拟机是x86虚拟机。因为Vmware vSphere 实现了一个完整的 x86 虚拟机，我们自动地能够提供容错服务给所有的x86架构的应用和系统。允许我们记录主VM运行并确保从属VM能够以一致运行的技术是**确定性重放(Deterministic Replay)**。Vmware vSphere Fault Tolerance 基于确定性replay,但是添加了额外必须的协议以及功能来支持建立一个完整的容错系统。除了提供硬件容错，我们的系统在一次失败后，通过在局部集群中任何可接受的服务器上开始一个新的备份虚拟机，进行自动地存储备份。到目前为止，确定性重放和Vmware FT的产品版本 只支持 单处理器VMs。多处理器VM的操作记录和重放还在开发中，因为每个共享内存的操作都是一个非确定性的操作，因此还有重要的性能问题待解决。</p><p> Bressoud 和 Schneiderr 描述了一个协议版本 的HP PA-RISC平台上容错虚拟机的实现。我们的方法是相似的，但是我们因为性能原因进行了一些底层改变，并尝试了大量的替代设计。此外，我们已经在系统中设计并实现许多额外组件并且处理了大量的实际问题来建立完整、高效、能够运行企业级应用的系统。和许多物理系统类似的是，我们仅仅尝试处理<strong>fail-stop类型的服务器错误</strong>，这类错误能够在服务器做出外部可见的错误之前被系统察觉到。</p><blockquote><p>Fail-stop failures（故障停止）是指在计算机系统中，当某个组件发生故障时，系统能够停止该组件的运行，以避免错误的输出或行为。也就是说，当发生故障时，系统会立即停止运行，并且不会继续执行任何操作，以防止出现更严重的问题。</p><p>这种类型的故障通常是由硬件故障或软件错误引起的。当硬件组件发生故障时，例如内存或CPU，系统会立即停止运行以避免出现错误的计算结果。同样，当软件组件出现故障时，例如操作系统或应用程序，系统也会立即停止运行以防止出现更多的错误。</p><p>在分布式系统中，Fail-stop failures 是指当节点发生故障时，该节点完全停止工作，不再发送或接收任何消息或请求，以避免系统中的其他节点出现不一致的状态。</p></blockquote><p> 本文剩余部分主要内容如下。首先，我们描述了 VM-FT的基本设计和基本协议的细节，这些设计和协议确保了如果一个从属VM从主服务器发生错误后进行接管，将不会导致数据损失。而后，我们描述了许多必须要处理的实际问题。此外，我们也阐述了多种实现VM-FT的设计选择，并对这些选择进行了相关讨论。然后，我们给出了我们实现的系统在一些实际企业应用上的性能数据。最后，我们阐述了相关工作和结论。</p><h1 id="2、基本的FT设计（Basic-FT-Design）"><a href="#2、基本的FT设计（Basic-FT-Design）" class="headerlink" title="2、基本的FT设计（Basic FT Design）"></a>2、基本的FT设计（Basic FT Design）</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304191646501.png"></p><p>图一展示了VM-FT系统的基本设置。对于某个希望能够支持容错的VM（主VM),我们在另外一个物理机上运行从属VM，该从属VM与主VM保持同步，并且相比主VM能够同步地运行着，尽管会有些时延。我们把这叫做虚拟同步。VMs的虚拟硬盘都是建立<strong>在共享存储</strong>上的（例如一个Fibre Channel或者iSCSI磁盘阵列），因此可以接受主备服务器的输入和输出。（我们将在4.1节中讨论带有分隔的非共享虚拟磁盘的主备VM的设计） 只有主VM在网络中宣告自己的存在，所以所有的网络输入都会去往主VM，相似的，所有的其他输入（例如键盘和鼠标）也仅仅是去往主VM。</p><p>所有主VM接收到的输入都会通过名为logging channel的网络连接，被发送到备份VM上。对于服务器负载而言，主要的输入瓶颈是网络和磁盘。为了保证备份VM和主VM使用相同的方式执行非确定性操作，下面2.1节讨论的额外的信息也需要发送。结果备份VM总是执行和主VM一致的操作。然而，备份VM的输出会被管理程序扔掉，因此只有主VM产生实际输出，并被返回给客户端。和2.2节中描述的一样，为了确保主VM失败后没有数据丢失，主备VM遵循一个具体的协议，包括备份VM明确的确认信息。</p><p> 为了检测主、从属VM是否出现故障，我们的系统在相关的服务器间使用了心跳通信，并且监视了logging channel 上的网络情况（是否发送网络拥堵）。此外，我们必须确保仅有一台主或者从属VM接管运行，即使存在脑裂（split brain）的场景，在这种场景中主备服务器互相之间会失去通信。</p><p>在下面的小节中，我们在几个重要的方面提供更多的细节。在2.1节中，我们给出一些确定性重放技术的细节，保证主备VMs通过 logging channel 上的信息保持一致。在2.2节中，我们描述了我们的FT协议中的一个基础规则，保证了主VM失败后没有数据丢失。在2.3节中，我们描述我们的方法，它能够通过正确的方式检测及响应故障。</p><h2 id="2-1、确定性重放实现（Deterministic-Replay-Implementation"><a href="#2-1、确定性重放实现（Deterministic-Replay-Implementation" class="headerlink" title="2.1、确定性重放实现（Deterministic Replay Implementation)"></a>2.1、确定性重放实现（Deterministic Replay Implementation)</h2><p>正如我们所提到的，复制服务器运行 可以被抽象成 复制一个确定性状态机。如果两个确定性状态机开始在相同状态，之后它们经历相同的状态序列，将产生相同的输出序列。一个虚拟机有着各种形式的输入，包括网络数据包，硬盘读取的数据，来自键盘和数据的数据等。不确定性事件（比如虚拟中断）以及不确定性操作（比如读取cpu 的时钟计数器）也会影响VM的状态。这揭示了复制任何运行任何操作系统和工作负载的VM的运行，都需要面临三大挑战：(1) 正确地捕捉所有输入和必要的不确定性行为来保证从属VM的确定性运行。(2) 正确地把输入和必要的不确定行为应用到从属VM上。(3) 以不影响性能的前提下实现(1)(2)。除了这三点以外，许多在x86微处理器上复杂的操作都有未定义的边际影响。捕捉这些边际影响并重现它们，来达到相同的状态（对于从属VM而言），仍然是一个挑战。</p><p>针对在VMare vSphere平台上的x86虚拟机，VMware确定性地重放恰好提供了这个功能。确定性重放记录了 VM 的输入以及与 VM执行相关的所有可能的不确定性的日志条目流，这些条目会被写入日志文件。在读取日志文件中的条目后，VM 操作会被精确地重放。 对于非确定性操作，为了允许操作以相同的状态变化和输出再现，需要记录足够的信息。 对于非确定性事件，例如定时器或 IO 完成中断，事件发生的确切指令也会被记录下来。 在重播期间，事件被传递在指令流中的同一位置。 VMware 确定性重放采用各种技术，<strong>实现了高效的事件记录和事件传递机制</strong>，包括使用AMD [2] 和英特尔 [8] 联合开发的硬件性能计数器。</p><p>Bressoud 和 Schneider [3] 提到将VM执行切分成不同的<strong>时期（epoch）</strong>，其中非确定性事件，例如中断仅在一个epoch结束时传递。 epoch的概念似乎被用作批处理机制，因为在它发生的确切指令处单独传递每个中断的成本太高。然而，我们的事件传递机制足够高效，以至于 VMware确定性重放<strong>不需要使用epochs</strong>。 每次中断在发生时被记录，并且在重放时有效地传递到适当的指令处。</p><h2 id="2-2、FT协议（FT-Protocol）"><a href="#2-2、FT协议（FT-Protocol）" class="headerlink" title="2.2、FT协议（FT Protocol）"></a>2.2、FT协议（FT Protocol）</h2><p>对于 VMware FT而言，我们使用确定性重放来生成必要的日志条目来记录主VM的执行情况，但是不是将日志条目写入磁盘，而是<strong>通过日志通道将它们发送到备份 VM</strong>。备份 VM 实时重放日志条目，因此与主 VM 的执行保持一致。 然而，我们必须在日志通道中使用严格的 FT 协议以增强日志条目，从而确保我们实现容错。 我们的基本要求如下：</p><p><strong>输出要求</strong>：如果备份VM在主VM发生故障后接管，那么备份VM将继续以一种与主虚拟机发送到外部世界的所有输出<strong>完全一致</strong>的方式执行。</p><p>请注意，在发生故障转移后（即备份 VM 需要在主VM故障后接管），备份VM开始执行的方式可能与主 VM 相当不同，因为在执行期间发生了许多非确定性事件。但是，只要备份VM满足输出要求，在故障转移到备份 VM期间<strong>没有外部可见状态或数据的丢失</strong>，客户端将注意到他们的服务没有中断或不一致。</p><p>可以通过延迟任何外部输出（通常是网络数据包）直到备份VM 已收到重放的所有信息来确保输出要求，这些信息允许它至少执行到该输出操作的点。一个必要条件是备份 VM 必须接收到输出操作之前生成的所有日志条目。这些日志条目将允许它执行到最后一个日志条目的点。但是，假设失败是在主VM执行输出操作后立即发生。备份 VM 必须知道它必须继续重播到输出操作点，并且到那时只能“上线”（停止重播并作为主VM接管，如2.3 节所述）。如果备份将在输出操作之前的最后一个日志条目点上线，一些非确定性事件（例如计时器传递给 VM 的中断）可能会在执行输出操作之前改变其执行路径。</p><p>给定上述的限制，强制满足输入要求的最容易的方式是在每个输出操作时创建一个特殊的日志条目。然后，输入要求一定被下面特殊的规则限制：</p><p><strong>输出规则</strong>：主VM可能不发送一个输出到外部世界，直到备份VM <strong>已收到并确认</strong>与产生输出的操作相关的日志条目。</p><p>如果备份 VM 已收到所有日志条目，包括生成输出操作的日志条目，然后备份 VM 将能够准确地重现主 VM在输出点的状态，所以如果主VM死了，<strong>备份将正确地达到一个与输出一致的状态</strong>。相反，如果备份 VM在没有收到所有必要的日志条目的情况下接管，那么它的状态可能会<strong>迅速分歧</strong>，以至于与主服务器的输出不一致。输出规则在某些方面类似于 [11] 中描述的方法，其中“外部同步” IO 实际上可以被缓存，只要它在下一次外部通信之前确实被写入磁盘了。</p><p>请注意，输出规则没有说明关于停止主VM执行的任何事。我们只需要延迟输出发送，但 VM 本身可以继续执行。由于操作系统通过异步中断来指示完成，因此可以执行非阻塞的网络和磁盘输出，VM可以轻松地继续执行并且不一定会立即受到输出延迟的影响。相比之下，以前的工作 [3, 9] 通常必须在执行输出之前完全停止主VM，直到备份 VM 已确认来自主 VM 的所有必要信息。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304191731880.png"></p><p>作为一个例子，我们在图2中展示了 FT 协议的需求。该图显示了一个主VM和备份VM上的事件时间线。从主线到备份线的箭头表示<strong>日志条目的传输</strong>，从备份线路到主线路的箭头表示<strong>确认</strong>。有关异步事件、输入和输出操作的信息必须作为日志条目发送到备份VM并确认。如图所示，到外部世界的输出被延迟，直到主VM收到来自备份 VM 的确认，它已经收到与输出操作相关的日志条目。<strong>鉴于遵循输出规则，备份VM将能够以这样一种状态接管，即与主VM最后的输出一致。</strong></p><p>我们不能保证一旦出现故障转移情况，所有输出都准确地产生一次。当主VM打算发送输出时，<strong>没有使用两阶段提交事务</strong>，备份VM无法确定主VM是在发送它的最后一个输出之前还是之后立即崩溃。 <strong>幸运的是，网络基础设施（包括常用的TCP）旨在处理丢失的数据包和相同（重复）的数据包</strong>。 请注意传入到主VM的数据包也可能在其故障的期间丢失，因此不会被传递给备份VM。 但是，传入的数据包可能会由于与服务器故障无关的任何原因被丢弃，因此网络基础设施、操作系统和应用程序都被写入，以确保他们可以弥补丢失的数据包。</p><h2 id="2-3、检测与故障响应（Detecting-and-Responding-to-Failure）"><a href="#2-3、检测与故障响应（Detecting-and-Responding-to-Failure）" class="headerlink" title="2.3、检测与故障响应（Detecting and Responding to Failure）"></a>2.3、检测与故障响应（Detecting and Responding to Failure）</h2><p>如上所述，如果另一个 VM 出现故障，主备VMs必须快速响应。如果备份VM出现故障，主VM将上线，即离开记录模式（因此停止发送条目到日志通道）并开始正常执行。如果主VM失败，备份VM应该同样上线（go live），但过程更为复杂。由于其执行的滞后，备份 VM 可能会有许多它已收到并确认，但尚未消耗的日志条目，因为备份 VM 尚未达到执行的适当点。<strong>备份VM必须继续重放日志条目，直到它消耗了最后一个日志条目</strong>。此时，备份 VM 将停止重放模式并开始作为正常VM执行。本质上备份VM被提升为主VM（现在缺少备份VM）。由于它不再是备份 VM，当操作系统执行输出操作时，新的主VM现在将向外部世界生产输出。在过渡到正常模式期间，可能会有一些特定设备的操作需要允许正确地发送输出。特别是，<strong>出于联网目的，VMware FT 自动在网络上通告新的主VM的MAC 地址，以便物理网络交换机知道新的主 VM 所在的服务器</strong>。此外，新提升的主VM可能需要重做一些磁盘 IO（如第 3.4 节所述）。</p><p>有许多可能的方法来尝试检测主备VMs的故障。VMware FT在运行容错VMs的服务器之间使用 <strong>UDP心跳</strong>，来检测服务器何时崩溃。此外，VMware FT 监控日志流量，包括从主到备的发送以及从备到主的确认。因为定时器中断，日志流量应该是有规律的，并且永远不会停止。因此，在日志条目或确认流中的中断可能表明VM故障。如果心跳或记录流量已停止超过特定超时时间（大约几秒钟），就可能发生故障了。</p><p><strong>但是，任何此类故障检测方法都容易受到脑裂（split brain）问题的影响</strong>。如果备份服务器停止接收来自主服务器的心跳，这可能表明主服务器出现故障，或者可能只是意味着所有仍在运行的服务器之间的网络连接丢失。如果备份VM随后上线，而主VM也仍然在运行，对于与VM通信的客户端而言可能会有数据损坏以及其他问题。因此，我们必须确保当检测到故障时，主VM和备份VM只有一个在线。为了避免脑裂问题，我们利用共享存储，来存储VM的虚拟磁盘。 <strong>当任一主或备份VM想要上线时，它会在共享存储中执行一个原子性的测试设置操作</strong>。 如果操作成功，VM 被允许上线。 如果操作失败，那么另一个 VM 一定已经上线，所以当前虚拟机实际上停止了自己（“自杀”）。 如果尝试执行此原子操作时，VM 无法访问共享存储，然后它只是等待，直到可以访问。 注意如果由于存储网络上的某些故障而无法访问共享存储时，那么虚拟机可能无法做有用的工作，因为虚拟磁盘在同样的共享存储中，因此，为了解决脑裂问题而使用共享存储不会引入任何额外的不可接受性。（<em>注：使用共享存储这种解决方案本身使得主备又得以通信了，只不过是通过信号量，而非socket。</em>）</p><p>这个设计的一个最终方面是一旦故障发生并且一个VM已经上线，VMware FT自动地通过在另一个主机上开始一个新的备份VM，来恢复备份。虽然这个过程不能覆盖过去大部分的工作，但是对容错的VM有用，它是基础，需要仔细设计。 更多细节是在第 3.1 节中给出。</p><h1 id="3、FT的实际执行（Practical-Implementation-Of-FT）"><a href="#3、FT的实际执行（Practical-Implementation-Of-FT）" class="headerlink" title="3、FT的实际执行（Practical Implementation Of FT）"></a>3、<strong>FT的实际执行（Practical Implementation Of FT）</strong></h1><p>第二节描述了我们基础的设计以及FT协议。然而，为了创建一个有用的、健壮的以及自动化的系统，有许多其他组件必须设计实现。</p><h2 id="3-1、启动与重启-FT-VMs（Starting-and-Restarting-FT-VMs）"><a href="#3-1、启动与重启-FT-VMs（Starting-and-Restarting-FT-VMs）" class="headerlink" title="3.1、启动与重启 FT VMs（Starting and Restarting FT VMs）"></a>3.1、启动与重启 FT VMs（Starting and Restarting FT VMs）</h2><p>对于 VMware FT而言，我们调整了VMware vSphere上现有的 <strong>VMotion</strong> 功能。 VMware VMotion [10] 允许以最少中断的方式，将正在运行的 VM 从一台服务器迁移到另一台服务器，VM的暂停时间通常不到一秒钟。我们创建了一个VMotion的修改形式，可在远程服务器上创建准确的 VM 运行副本，但不会破坏本地服务器的虚拟机。也就是说，我们修改后的 FT VMotion 将VM克隆到远程主机上而不是迁移它。 FT VMotion还设置了一个日志记录通道，并导致源VM作为主VM进入日志记录模式，而目的VM 作为备份进入重放模式。像平常的VMotion一样，FT VMotion 通常会中断主VM的执行不到一秒。因此，启用 FT在正在运行的 VM 上是一个简单的、无中断的操作。</p><p>启动备份 VM 的另一个方面是选择一个运行它的服务器。容错 VM 在服务器集群中运行，可以访问共享存储，因此所有 VM通常可以运行在集群上的任何服务器中。这种灵活性允许VMware vSphere恢复FT冗余，即使一个或多个服务器失效。<strong>VMware vSphere 实现了一种集群服务，用于维护管理以及资源信息</strong>。 当发生故障并且主VM 现在需要一个新的备份 VM 来重新建立冗余时，主 VM 通知集群服务它需要一个新的备份。 集群服务基于资源利用率以及其他约束，决定运行备份VM最好的服务器，并调用 FT VMotion 以创建新的备份 VM。 结果是 VMware FT通常可以在几分钟内重新建立VM冗余，在一个容错VM的执行上，所有这些都没有任何明显的中断。</p><h2 id="3-2、管理日志通道（Managing-the-Logging-Channel）"><a href="#3-2、管理日志通道（Managing-the-Logging-Channel）" class="headerlink" title="3.2、管理日志通道（Managing the Logging Channel）"></a>3.2、管理日志通道（Managing the Logging Channel）</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304191753798.png"></p><p>在管理日志通道上的流量时，有许多有趣的实现细节。在我们的实现中，管理程序为主备 VM 的日志记录条目维持了一个大的<strong>缓冲区</strong>。当主 VM 执行时，它生成日志条目到缓冲区中，类似地，备份VM从它的日志缓冲区中消耗日志条目。主日志缓冲区的内容会被尽快刷新到日志记录通道，这些日志条目一到日志通道，就会被读取到备份的日志缓冲区。备份每次从网络上读取一些日志条目到它的日志缓冲区时，都会发送确认返回给主VM。这些确认允许 VMware FT 确定一个被输入规则延迟的输出何时可以被发送。图3说明了这个过程。</p><p>如果备份 VM 在需要读取下一个日志条目时，遇到空的日志缓冲区，它将停止执行直到有新的日志条目可用。由于备份 VM 是不与外部通信的，此暂停不会影响任何VM 的客户端。同样地，当主VM需要写入一个日志条目时，如果主VM遇到一个满的日志缓冲区，它必须停止执行，直到可以刷新日志条目。这种执行的停止是一种自然的流控制机制，当主VM生产日志条目太快了，它会减慢主VM。但是，此暂停可能会影响VM的客户端，因为主 VM 将完全停止并且无响应，直到它可以记录其条目并继续执行。因此，我们的实现必须设计为尽量减少主日志缓冲区填满的可能性。</p><p>主日志缓冲区可能填满的原因之一是备份 VM 执行速度太慢，因此消耗日志条目太慢。<strong>一般来说，备份VM必须能够以与正在记录执行的主VM大致相同的速度重放执行</strong>。幸运的是，在 VMware 确定性重放中，记录和重放的开销大致相同。然而，如果由于其他VMs，托管备份 VM 的服务器负载很重（因此过度使用资源），备份VM 可能无法获得足够的 CPU 和内存资源，来与主 VM 一样快地执行，尽管备份管理程序的VM调度器已经尽了最大努力。</p><p>如果日志缓冲区填满，除了避免意外暂停，还有另一个原因是我们不希望滞后变得太大。如果主VM出现故障，备份VM 必须通过重放它在上线和开始与外部世界交流之前已经确认的所有日志条目来“赶上”。完成重放的时间基本上是失败点的执行延迟时间，所以<strong>备份上线的时间大约等于故障检测时间加上当前执行时差</strong>。因此，我们不希望执行滞后时间太大（超过一秒），因为这将显著地增加故障转移时间。</p><p>因此，我们有一个额外的机制减慢主VM，以防止备份 VM 获取太滞后了。在我们的发送和确认日志条目的协议中，我们发送附加信息来确定主备VM之间的实时执行滞后。通常执行滞后小于 100 毫秒。<strong>如果备份 VM 有一个显著的执行滞后（例如，超过 1 秒），VMware FT 通过通知调度程序给它稍微少一点的CPU（最初只是百分之几）来减慢主 VM</strong>。我们使用一个缓慢的反馈循环，这将尝试逐步确定适当的 CPU 限制，将允许主备 VM同步执行。如果备份 VM 继续滞后，我们继续逐步降低主VM的 CPU 限制。反之，如果备份VM赶上，我们逐渐增加主VM的 CPU 限制，直到备份虚拟机恢复轻微的滞后。</p><p>请注意，主VM的这种减速很少见，通常只在系统处于低压力时发生。第 5 节的所有性能编号包括任何此类放缓的成本。</p><h2 id="3-3、FT-VMs上的操作（Operation-on-FT-VMs）"><a href="#3-3、FT-VMs上的操作（Operation-on-FT-VMs）" class="headerlink" title="3.3、FT VMs上的操作（Operation on FT VMs）"></a>3.3、FT VMs上的操作（Operation on FT VMs）</h2><p>另一个实际问题是处理各种控制操作，它们可以应用于主 VM 。例如，如果主VM明确关闭电源，备份 VM 也应该停止，而不是尝试上线。 再举一个例子，任何主VM上的资源管理更改（例如增加 CPU 份额）应该 也适用于备份。 对于此类操作，为了影响备份进行合适的操作，特殊的控制条目通过日志通道从主发送到备份。</p><p>一般来说，VM 上的大部分操作都应该仅在主 VM 上初始化。 VMware FT 然后发送任何必要的控制条目以造成备份VM上适当的更改。 唯一可以独立在主VM和备份VM上完成的操作是 VMotion。 即主VM和备份VM可以独立被 VMotioned到其他主机。 请注意，VMware FT 确保两个 VM 都不会移动到另一个 VM 所在的服务器，因为这种场景将不再提供容错。</p><p>主VM的VMotion增加了比普通VM更多的复杂性，因为备份VM一定会与源主VM失去连接以及在适当的时间重连。备份VM的VMotion有一个相似的问题，但是只增加了一个额外的复杂性。对于一个正常的VMotion而言，我们需要当VMotion上最后的切换发生时，所有的磁盘IO停止（或完成）。对于一个主VM而言，这种停顿是容易应付的，通过等待直到物理IO完成并将这些完成信息发送给VM。然而，对于一个备份VM而言，没有容易的方式来使得所有IO在任何需要的时刻完成，因为备用VM必须重放主VM的执行过程，并在相同的执行点完成IO。主VM可能正运行在一个工作负载上，在正常执行过程中总是有磁盘IO。VMware FT有一个独一无二的方法来解决这个问题。当<strong>一个备份VM是在VMotion最后的切换点时，它需要通过日志通道来告知主VM临时停止所有IO。备份VM的IO将自然地被停止在一个单独的执行点，因为它需要重放主VM的停止操作的过程。</strong></p><h2 id="3-4、磁盘IO的实现问题（Implementation-Issues-for-Disk-IOs）"><a href="#3-4、磁盘IO的实现问题（Implementation-Issues-for-Disk-IOs）" class="headerlink" title="3.4、磁盘IO的实现问题（Implementation Issues for Disk IOs）"></a>3.4、磁盘IO的实现问题（Implementation Issues for Disk IOs）</h2><p>有许多与磁盘IO相关的微小的实现问题。首先，假设磁盘操作是非阻塞的，因此访问相同磁盘位置的并行、同时执行的磁盘操作将引起非确定性。此外，我们的磁盘 IO 实现使用DMA 直接from/to虚拟机的内存，所以同时访问相同内存页的磁盘操作也可能导致不确定性。我们的解决方案是<strong>经常检测任何此类 IO 竞争</strong>（很少见），以及强制此类竞争磁盘操作在主备VM上按顺序执行。</p><p>第二， VM 中的应用程序（或操作系统）中，<strong>磁盘操作与内存访问</strong>也会存在竞争，因为磁盘操作通过 DMA 直接访问 VM 的内存。例如，如果一个VM 中的应用程序/操作系统正在读取内存块，同时对该块进行磁盘读取。（<em>这里的意思应该是，该块内存作为DMA操作的目的地址。</em>）这个情况也不太可能发生，但如果它发生，我们必须检测它并处理它。一种解决方案是临时设置页保护，在作为磁盘操作目标的页面上。如果VM 碰巧访问一个页，同时该页面也是磁盘操作的目标，页保护将导致一个陷阱（<em>trap，陷入系统调用</em>），VM将暂停直到磁盘操作完成。<strong>因为改变页上的MMU 保护是一项昂贵的操作，所以我们选择使用弹跳缓冲区（Bounce Buffer）代替</strong>。bounce buffer是临时缓冲区，与正在被磁盘操作访问的内存大小相同。磁盘读取操作被修改为读取指定数据到bounce buffer，并在IO完成时将数据复制到内存中。相似地，对于磁盘写操作，首先将要发送的数据复制到bounce buffer，磁盘写入修改为向bounce buffer写入数据。bounce buffer的使用会减慢磁盘操作，但我们还没有看到它会导致任何明显的性能损失。（<em>bounce buffer存在的意义是在内存访问这个操作之前加了一个拦截器，其最本质的意义是为了supervisor监控DMA操作，使得数据从bounce buffer拷贝到到内存和系统中断这两个步骤，能够同时在backup VM上被复制，<strong>否则网卡直接将网络数据包DMA到Primary虚机中这个操作是无法通过log channel进行复制的</strong>。</em>）</p><p>第三，有一些与故障发生并且备份VM接管时，主VM未完成的磁盘 IO 相关的问题。对于新上线的主VM，没有办法确定磁盘IO是有问题的还是成功完成了。另外，由于磁盘IO没有从外部发布到备用VM上，而是通过主备传递，因此对于继续运行的新上任的主VM来说，将没有明确的IO完成信息，最终将导致VM上的操作系统开始中止或者重调度程序。我们能够发送一个错误完成，表示每个IO失败，因为即使IO成功完成了，它可以接受返回一个错误。然而，操作系统可能不能对这些来自本地磁盘的错误有很好的响应。反之，我们在备份VM上线的过程中，重新发送这些悬挂着的IO。因为我们已经限制了所有的竞争和所有的直接指定内存和磁盘的IO，这些磁盘操作可以被重新发送，即使它们已经成功完成了（即他们是<strong>幂等的</strong>）。</p><blockquote><p>idempotent 幂等 ，指一个操作可以重复执行多次，但只会产生一次结果</p></blockquote><h2 id="3-5、网络IO的实现问题（Implementation-Issues-for-Network-IO）"><a href="#3-5、网络IO的实现问题（Implementation-Issues-for-Network-IO）" class="headerlink" title="3.5、网络IO的实现问题（Implementation Issues for Network IO）"></a>3.5、网络IO的实现问题（Implementation Issues for Network IO）</h2><p>VMware vSphere针对VM网络提供了很多性能优化。一些优化是基于管理程序（supervisor）<strong>异步更新虚拟机的网络设备状态</strong>。例如，当VM正在执行时，接收缓冲区可以由管理程序直接更新。不幸的是这些对 VM 状态的<strong>异步更新会增加不确定性</strong>。除非我们可以保证所有更新都发生在主备指令流上的同一点，否则备份VM的执行可能与主VM的执行不同。</p><p>对于FT而言，网络仿真代码的最大变化是<strong>禁用异步网络优化</strong>。异步更新带有传入数据包的VM环形缓冲区的代码已被修改，以强制管理程序捕获到操作系统，它可以在其中记录更新然后将它们应用到 VM。同样，异步地将数据包从传输队列中拉出也被修改了，取而代之的是通过管理程序traps来完成传输（如下所述）。</p><p>网络设备异步更新的消除结合第 2.2 节中描述的发送数据包的延迟带来了一些网络性能的挑战。我们采取了两种方法在运行 FT 时提高 VM 的网络性能。第一，我们实施了<strong>集群优化</strong>以减少 VM 的陷阱和中断。当 VM 以足够的比特率流式传输数据时，管理程序可以对每组数据包做一个传输trap，在最好的情况下零trap，因为它可以传输所接收新数据包的一部分数据包。同样地，通过仅对于一组数据包发布中断，管理程序可以将接收包的中断数量减少。</p><p>我们对网络的第二个性能优化涉及<strong>减少传输数据包的延迟</strong>。如前所述，管理程序必须延迟所有发送的包直到它得到备份VM对于某些日志条目的确认。减少发送延迟的关键在于减少发送/接收备份VM信息的所需时间。我们的主要优化包括<strong>保证收发信息在无需任何线程上下文切换的情形下就可以被执行</strong>。VMware vSphere管理程序允许函数被注册到TCP栈中，只要TCP数据被接收到了，函数就会被一个延期执行的上下文调用（和Linux中的tasklet类似）。这允许我们快速处理备份VM上任何即将到来的日志消息，以及主VM接收的任何确认消息，而不需要任何线程上下文的切换。另外，当主VM有一个包要寄出去时，我们强制一次相关输出日志条目的日志刷出（正如2.2节中所描述的），通过调度一个延迟执行的上下文来执行这次刷出。</p><h1 id="4-替代设计（DESIGN-ALTERNATIVES）"><a href="#4-替代设计（DESIGN-ALTERNATIVES）" class="headerlink" title="4. 替代设计（DESIGN ALTERNATIVES）"></a>4. 替代设计（DESIGN ALTERNATIVES）</h1><p>在我们VMware FT的实现中，我们已经探索了许多有趣的替代设计。在这节中，我们探索一些替代设计。</p><h2 id="4-1、共享-vs-非共享磁盘（Shared-vs-Non-shared-Disk）"><a href="#4-1、共享-vs-非共享磁盘（Shared-vs-Non-shared-Disk）" class="headerlink" title="4.1、共享 vs. 非共享磁盘（Shared vs. Non-shared Disk）"></a>4.1、共享 vs. 非共享磁盘（Shared vs. Non-shared Disk）</h2><p>在我们默认的设计中，主备VM共享相同的虚拟磁盘。因此，如果一次故障转移发生，共享磁盘的内容自然是正确、可接受的。必要地，对于主备VM来说，共享磁盘被认为是外部的，因此任何共享磁盘的写入被认为是一次与外部世界的沟通。因此，只有主VM做这种实际的磁盘写入，并且为了遵循输出规则，这种写入必须被延迟。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304201423529.png"></p><p>对于主备VM而言，一种可替代的选择是分隔的虚拟磁盘。在这种设计中，备份VM要执行所有虚拟磁盘的写入操作。而且这样做的话自然要保持它的虚拟磁盘内容与主VM虚拟磁盘内容一致。图4阐述了这种配置。在非共享磁盘的情况下，虚拟磁盘必须被认为是每个VM的内部状态。因此，依据输出规则，<strong>主VM的磁盘写入不必延迟</strong>。在共享存储不能被主备VM接受的情况下，非共享的设计是相当有用的。这种情况可能是由于共享存储不可接受或者太昂贵，或者由于运行主备VM的服务器相隔太远（“长距离FT”）。非共享设计的一个缺点是在首次启动故障容错时，虚拟磁盘的两个复制必须以相同的方式进行显示同步。另外，发生故障后磁盘<strong>可能会不同步</strong>，因此当在一次失败后备份VM重启的时候，他们必须再显式地同步。FT VMotion必须不止同步主备VM的运行状态，还要同步他们的磁盘状态。</p><p>在这种非共享磁盘的配置中，他们也能应付脑裂场景。在这种场景中，系统能够<strong>使用一些其他的外部决策者</strong>，例如所有服务器可以沟通的一个第三方服务。如果服务器是超过两个节点的集群的一部分，这个系统能够基于集群关系使用一种majority算法。在这个例子中，一个VM能够被允许上线，如果它正在一个服务器上运行，这个服务器是包含大多数原始节点的正在通信的子集群的一部分。</p><h2 id="4-2-在备份VM上执行磁盘读（Executing-Disk-Reads-on-the-Backup-VM）"><a href="#4-2-在备份VM上执行磁盘读（Executing-Disk-Reads-on-the-Backup-VM）" class="headerlink" title="4.2 在备份VM上执行磁盘读（Executing Disk Reads on the Backup VM）"></a>4.2 在备份VM上执行磁盘读（Executing Disk Reads on the Backup VM）</h2><p>在我们默认的设计中，备份的VM从不会从它自己的虚拟磁盘上读取（无论共享还是非共享）。<strong>因为磁盘读取被认为是一个输入</strong>，它是自然地通过日志通道将磁盘读取的结果发送到备份VM上。</p><p>一种替代的设计是<strong>让备份VM执行磁盘读取</strong>，因此消除了磁盘读取的日志。对于大多数时候都做磁盘读取的工作负载而言，这种方法可以很好地降低日志通道上的流量。然而，这种方法有很多小问题。它可能会减慢备份VM的执行速度，因为备份VM必须执行所有的磁盘读取，当到达VM执行中主VM已经完成的位置时，如果备份上的磁盘读取还没完成就必须等待。</p><p>同样地，<strong>为了处理失败的磁盘读取操作，必须做一些额外的工作</strong>。如果一个主VM的磁盘读取成功了，但是相应的备份VM磁盘读取失败了，备份VM的磁盘读取必须重试直到成功。因为备份VM必须获得和主VM一样的数据到内存中。相反地，如果一个主VM的磁盘读取失败了，目标内存的内容必须通过日志通道发送给备份服务器，因此内存的内容将被破坏，不能被备份VM成功的磁盘读取复制。</p><p>最后，如果这种磁盘读取被用于共享磁盘配置的话，还有一个小问题。如果主VM做了一次对具体磁盘位置的读取，然后紧跟相同磁盘位置的写入，然后这个磁盘写必须被延迟到备份VM已经执行了第一次磁盘读取。这种依赖可以被检测和正确处理，但是需要增加实现上额外的复杂性。</p><p>在5.1节中，对于实际的应用而言，我们给出一些性能结果以表示在备份VM上执行磁盘读取会造成一些轻微的吞吐量减少(1-4%)，因此在日志通道的带宽被限制的情况下，在备份VM上执行磁盘读取可能是有用的。</p><h1 id="5、性能评估（PERFORMANCE-EVALUATION）"><a href="#5、性能评估（PERFORMANCE-EVALUATION）" class="headerlink" title="5、性能评估（PERFORMANCE EVALUATION）"></a>5、性能评估（PERFORMANCE EVALUATION）</h1><p>在这节中，我们做了一次VMware FT性能的基础评估，针对许多应用负载以及网络基准。为了得到这些结果，我们在一样的服务器上运行主备VM，每个都带9个Intel Xeon 2.8Ghz CPUs and 8Gbytes of RAM。服务器间通过10 Gbit/s的交换机连接，但是在所有的例子中都能看到被使用的网络带宽远远少于1Gbit/s。从一个通过标准的4Gbit/s的光纤通道网络连接的EMC Clariion中，服务器可以连接他们的共享虚拟磁盘。客户端通过1 Gbit/s的网络来驱动一些连接服务器的工作负载。</p><p>我们评估性能结果的应用如下所示。SPECJbb2005是工业标准的Java应用基准，非常耗费CPU和内存，但是IO非常少。Kernel Compile是一种运行Linux核编译的工作负载。由于许多编译过程的创建和毁灭，这个工作负载做很多磁盘读取和写入，是非常耗费CPU和MMU的。Oracle Swingbench是被Swingbench OLTP工作负载（在线事务处理）驱动的一个Oracle 11g的数据库。这个工作负载做连续的磁盘和网络IO，有80个同时在线的数据库会话。MS-SQL DVD Store是一种工作负载，运行了一个Microsoft SQL Server 2005的数据库，有60个同时在线的客户端。</p><h2 id="5-1、基本性能结果（Basic-Performance-Results）"><a href="#5-1、基本性能结果（Basic-Performance-Results）" class="headerlink" title="5.1、基本性能结果（Basic Performance Results）"></a>5.1、基本性能结果（Basic Performance Results）</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304201434206.png"></p><p>表 1 列出了基本的性能结果。对于每个应用程序，第二列给出了应用程序的性能比例，运行服务器工作负载的虚拟机上启用和未启用FT的情况。性能比小于 1 表示带FT的工作负载更慢。显然，这些有代表性的工作负载上启用FT 的开销小于10%。 SPECJbb2005 完全受计算限制，没有空闲时间，但其表现性能良好，因为它具有最小的除定时器中断以外的不确定性事件。另一个工作负载做磁盘 IO 有一些空闲时间，所以一些FT 开销可能被 FT虚拟机的空闲时间更少的真实情况隐藏。然而，一般的结论是VMware FT 能够支持容错VM，并且具备相当低的性能开销。</p><p>在表的第三列中，我们给出了当应用程序正在运行时，在日志通道上发送数据的平均带宽。对于这些应用程序，日志带宽相当合理，1 Gbit/s的网络就能满足 。事实上，低带宽要求表明多个 FT 工作负载可以共享相同的 1 Gbit/s网络，同时没有任何负面的性能影响。</p><p>对于运行常见操作系统的 VM，例如Linux 和 Windows，我们发现当操作系统空闲时，通常的日志记录带宽为 0.5-1.5 Mbits/sec。”空闲”带宽主要是记录定时器中断发送的结果。对于具有活动中工作负载的 VM而言，日志带宽由网络和必须发送到备份的磁盘输入主导—网络收到的数据包和从磁盘读取的磁盘块。因此，对于非常高的网络接收或者磁盘读取带宽的应用而言，日志带宽高于表1中的测量值。对于这类应用而言，日志通道的带宽可能是瓶颈，特别是日志通道还有其他使用时。</p><p>对于许多实际应用程序而言，<strong>日志记录所需的带宽相对较低，这使得基于重放的容错对于使用非共享磁盘的长距离配置非常有吸引力</strong>。对于远距离配置而言，其主备VM可能相隔1-100公里，光纤可以轻松地支持延迟小于 10 毫秒的100-1000 Mbit/s带宽。对于表 1 中的应用而言，主备之间的额外往返延迟，可能会导致网络和磁盘输出最多延迟 20 毫秒。远距离配置仅适用于这类应用程序：他的客户端可以容忍每个请求的额外延迟。</p><p>对于两个最占用磁盘空间的应用程序，我们测量了在备份 VM上执行磁盘读取（如第 4.2 节所述）与通过日志记录通道发送磁盘读取数据相比，对于性能的影响。对于 Oracle Swingbench来说，在备份VM上执行磁盘读取时的吞吐量降低约 4%；对于 MS-SQL DVD 存储，吞吐量约降低 1%。同时，Oracle Swingbench的日志带宽从 12 Mbits/sec 降低到 3 Mbits/sec，MS-SQL DVD 存储从 18 Mbits/sec 降低到 8 Mbits/sec。显然，对于具有更大磁盘读取带宽的应用程序，带宽可能会节省很多。如第 4.2 节所述，预计在备份 VM 上执行磁盘读取时，性能可能会更差。但是，对于日志通道的带宽是有限的（例如，远程配置）情况下，在备份 VM 上执行磁盘读取可能有用。</p><h2 id="5-2、-网络基准测试（Network-Benchmarks）"><a href="#5-2、-网络基准测试（Network-Benchmarks）" class="headerlink" title="5.2、 网络基准测试（Network Benchmarks）"></a>5.2、 网络基准测试（Network Benchmarks）</h2><p>出于多种原因。网络基准测试对我们的系统来说非常具有挑战性。第一，高速网络会有一个非常高的<strong>中断率</strong>，这需要以非常高的速度记录和重放异步事件。 第二，以高速率接收数据包的基准将导致<strong>高速率的日志流量</strong>，因为所有这些数据包必须通过日志通道发送到备份。第三，发送数据包的基准测试将<strong>受制于输出规则</strong>，延迟网络数据包的发送直到已收到来自备份VM的确认。 此延迟会增加对客户端测量的延迟。这种延迟还可能会降低到客户端的网络带宽，因为网络协议（如 TCP）由于往返延迟增加，可能不得不降低网络传输速率。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304201438823.png"></p><p>表 2 给出了我们通过标准的netperf 基准测试，多次测量的结果。在所有这些测量中，客户端 VM 和主 VM 通过 1 Gbit/s 网络连接。前两行给出了主备主机间通过1 Gbit/s 的日志通道连接时，发送和接收的性能。第三行和第四行给出当主备服务器通过10 Gbit/s的日志通道连接时，发送和接收的性能，不仅带宽更高，延迟也低于 1 Gbit/s。作为一个粗略的测量，在1 Gbit/s 网络连接的管理程序之间， ping 时间约为 150 微秒，而对于 10 Gbit/s 连接，ping时间大约需要 90 微秒。</p><p>未启用 FT 时，主 VM 对于接收和发送，可以实现接近 (940 Mbit/s) 1 Gbit/s 的线路传输速率。当为接收工作负载启用 FT 时，日志记录带宽非常大，因为所有传入的网络数据包必须在日志通道上发送。因此，日志记录通道可能成为瓶颈，正如1 Gbit/s 日志网络的结果。对于 10 Gbit/s 的日志网络，影响则小了很多。当为上传工作负载启用 FT 时，上传数据包的数据不会记录，但仍必须记录网络中断。日志带宽要低得多，因此可实现的网络上传带宽高于网络接收带宽。<strong>总的来说，我们看到 FT 在非常高的上传和接收速率情况下，可以显著地限制网络带宽，但仍然可以实现很高的速率</strong>。</p><h1 id="6、相关工作（RELATED-WORK）"><a href="#6、相关工作（RELATED-WORK）" class="headerlink" title="6、相关工作（RELATED WORK）"></a>6、相关工作（RELATED WORK）</h1><p>Bressoud 和 Schneider [3] 描述了实施的最初想法，通过完全包含在管理程序级别的软件对虚拟机进行容错。他们展示了保持一个备份虚拟机的可行性，该备份通过配备 HP PA-RISC 处理器的服务器原型与主虚拟机同步。但是，由于PA-RISC 架构的限制，他们无法实现完全安全、隔离的虚拟机。此外，他们没有实现任何故障检测方法，也没有尝试解决第 3 节中描述的任何实际问题。更重要的是，他们对他们的 FT 协议提出的很多限制是不必要的。首先，他们强加了epoch的概念，其中异步事件被延迟到设定的时间间隔结束。一个epoch的概念是不必要的—他们可能强加了它，因为他们无法足够有效地重放单个异步事件。其次，他们要求主虚拟机基本上停止执行，直到备份收到并且确认所有以前的日志条目。然而，只有输出本身（例如网络数据包）必须延迟 –主 VM 本身可能会继续执行。</p><p>Bressoud [4] 描述了一个在操作系统（Unixware）中实现容错的系统，因此为在该操作系统上运行的所有应用程序提供容错。系统调用接口变成了必须确定性地复制的一组操作。这项工作与基于管理程序的工作有着相似的限制与设计选择。</p><p>纳珀等人 [9] 以及 Friedman 和 Kama [7] 描述了容错 Java 虚拟机的设计。他们在日志通道中发送输入与非确定性操作时遵循与我们类似的设计。像 Bressoud 一样，他们似乎并不专注于检测故障并在故障后重新建立容错。此外，它们的实现仅限于对在 Java 虚拟机中运行的应用程序提供容错。这些系统试图处理多线程Java 应用程序的问题，但要求所有数据都正确地受锁保护或强制执行序列化到共享内存。</p><p>邓拉普等 [6] 描述了确定性重放的实现，主要针对在半虚拟化系统上调试应用软件。我们的工作支持在虚拟机内运行的任何操作系统并实现了对这些 VM 的容错支持，这需要更高水平的稳定性和性能。</p><p>库利等人[5] 描述了一种支持容错VMs的替代方法，并且在一个名为Remus的项目里实现了。通过这种方法，在执行期间主VM的状态被反复检查，并且被发送到备份服务器，该服务器收集检查点信息。检查点必须非常频繁地执行（每秒多次），因为外部输出必须延迟到下一个检查点被发送和确认。这种方法的优点是它同样适用于单处理器和多处理器 VM。</p><p>这种方法的主要问题是有非常高的网络带宽需要，以将每个检查点内存状态的增量更改发送出去。 Remus 的结果[5] 显示，对于发送内存状态的改变，当使用一个1 Gbit/s 网络连接尝试每秒做40个检查点时，内核编译与SPECweb 基准测试减速 100% 到 225%。有许多优化可能有助于减少所需的网络带宽，但不清楚1 Gbit/s 连接是否可以实现合理的性能。相比之下，我们基于确定性重放的方法可以实现低于 10% 的开销，在几个真实应用中主备主机所需的带宽远远少于 20 Mbit/s。</p><h1 id="7、结论与今后的工作（CONCLUSION-AND-FUTURE-WORK）"><a href="#7、结论与今后的工作（CONCLUSION-AND-FUTURE-WORK）" class="headerlink" title="7、结论与今后的工作（CONCLUSION AND FUTURE WORK）"></a>7、结论与今后的工作（CONCLUSION AND FUTURE WORK）</h1><p>我们在VMware vSphere 中设计并实施了一个高效完整的系统(FT) ，用于为服务器上运行的虚拟机提供容错。我们的设计基于复制主VM中的执行，再通过另一台主机上的备份VM执行VMware确定性重放。如果运行主 VM的服务器出现故障，备份 VM 能立即接管且不会中断或丢失数据。</p><p>总体而言，在商业硬件上运行VMware FT时，故障容错VM的性能非常出色，并且对于某些典型应用程序，其开销低于 10%。大多数 VMware FT 的性能成本来自于使用 VMware 确定性重放来保持主备VM同步。因此，VMware FT 的低开销源自 VMware 确定性重放的效率。此外，保持主备同步所需的日志带宽非常小，通常小于 20 Mbit/s。因为日志带宽在大多数情况下很小，主备相隔很长的距离（1-100公里）似乎也是可行的实施配置。因此，VMware FT 可用于这种场景：可以防止整个站点发生故障的灾难。值得注意的是，日志流通常是可压缩的，因此简单的压缩技术可以显著地减少日志带宽，虽然有少量额外的 CPU 开销。</p><p>我们对 VMware FT 的结果表明，<strong>一个高效的故障容错VM的实现可以建立在确定性重放的基础上</strong>。<strong>这样的系统可以透明地为运行任何操作系统和应用的虚拟机提供容错能力，仅会带来极小的开销</strong>。然而，对客户有用的故障容错VM系统而言，它必须还具有强大、易于使用和高度自动化的特点。一个可用的系统除了复制虚拟机执行之外，还需要许多其他组件。特别是VMware FT 故障后自动地恢复冗余，通过在本地集群中找到合适的服务器并在其上创建一个新的备份VM。通过解决所有必要的问题，我们已经展示了一个在客户的数据中心可用于实际应用的系统。</p><p>通过确定性重放实现容错的权衡之一是当前确定性重放仅针对单处理器VM 。然而，单处理器虚拟机足够应付各种各样的工作负载，特别是因为物理处理器不断变得更加强大。此外，许多工作负载可以通过使用许多单处理器的虚拟机来扩展，而不是通过使用一个更大的多处理器虚拟机来扩展。多处理器 VM 的高性能重放是一种活跃的研究领域，并且可以潜在地被微处理器中的一些额外硬件支持。一个有趣的方向可能是扩展事务内存模型以促进多处理器重放。</p><p>将来，我们也有兴趣扩展我们的系统处理部分硬件故障。通过部分硬件故障，我们的意思是服务器上功能或冗余的部分丢失，不会导致损坏或丢失数据。一个例子是到 VM所有网络连接的丢失，或在物理服务器中备用电源丢失。如果在运行主 VM 的服务器上发生部分硬件故障，在许多情况下（但不是all) 故障转移到备份 VM 将是有利的。这样的故障转移对于关键VM而言，可以立即恢复完整服务，并确保虚拟机从可能不可靠的服务器上快速地移走。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vm-ft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce</title>
      <link href="/2023/041764376.html"/>
      <url>/2023/041764376.html</url>
      
        <content type="html"><![CDATA[<h1 id="Absract"><a href="#Absract" class="headerlink" title="Absract"></a>Absract</h1><p>​    MapReduce是一种用于处理、生成大型数据集的编程模型和实现方式。用户可以指定一个map函数用于处理key/value键值对，输出基于key/value 对的中间数据集合；然后再使用一个reduce函数用来合并上一步中间数据集合具有相同key值的中间value值。</p><p>​    程序以函数式的风格构建，可以在大规模集群中自动地并行计算。整个系统主要关注数据的分区、集群作业的调度、容错处理以及集群内的通信管理问题。因此使用者不需要任何与并行计算、分布式系统相关的经验就可以很容易地利用分布式系统资源。</p><p>​    MapReduce可以运行在大型的服务器集群上，并且具有高可扩展性：一个典型的MapReduce 系统可以在数千台机器上处理很多 PB 的数据。用户可以发现整个系统非常容易使用：上百个MapReduce程序已经被实现并且有超过1000个MapReduce的作业每天都在Google的集群上运行。</p><h1 id="1、Introduction"><a href="#1、Introduction" class="headerlink" title="1、Introduction"></a>1、Introduction</h1><p>​    在过去的5年里，包括本文作者在内的Google的很多程序员，为了处理海量的原始数据，已经实现了数以百计的、专用的计算方法。这些计算方法用来处理大量的原始数据，比如，文档抓取（类似网络爬虫的程序）、Web请求日志等等；也为了计算处理各种类型的衍生数据，比如倒排索引、Web文档的图结构的各种表示形式、每台主机上网络爬虫抓取的页面数量的汇总、每天被请求的最多的查询的集合等等。大多数这样的数据处理运算在概念上很容易理解。然而由于输入的数据量巨大，因此要想在可接受的时间内完成运算，只有将这些计算分布在成百上千的主机上。如何处理并行计算、如何分发数据、如何处理错误？所有这些问题综合在一起，需要大量的代码处理，因此也使得原本简单的运算变得难以处理。</p><p>​    为了解决上述复杂的问题，我们设计一个新的抽象模型，使用这个抽象模型，我们只要表述我们想要执行的简单运算即可，而不必关心并行计算、容错、数据分布、负载均衡等复杂的细节，这些问题都被封装在了一个库里面。设计这个抽象模型的灵感来自Lisp和许多其他函数式语言的<em>Map</em>和<em>Reduce</em>的原语。我们意识到我们大多数的运算都包含这样的操作：在输入数据的每个逻辑记录上应用Map操作得出一个中间key/value pair集合，然后在所有具有相同key值的value值上应用reduce操作，从而恰当的合并中间的数据。使用MapReduce模型，再结合用户实现的Map和Reduce函数，我们就可以非常容易的实现大规模并行化计算；通过MapReduce模型自带的“再次执行”（re-execution）功能，也提供了初级的容灾实现方案。</p><p>​    这个工作(实现一个MapReduce框架模型)的主要贡献是通过简单又强大的接口来实现自动并行化和大规模的分布式计算，通过使用MapReduce模型接口实现在以普通PC机为基础的大规模集群服务器上进行高性能计算。</p><p>​    section2描述了mapreduce的基础编程模型和一些使用案例。section3描述了一个经过裁剪的、适合我们的基于集群的计算环境的MapReduce实现。section4描述我们认为在MapReduce编程模型中一些实用的技巧。section5测量我们实现的MapReduce对于各种不同的任务的性能。section6揭示了在Google内部如何使用MapReduce作为基础重写我们的索引系统产品，包括其它一些使用MapReduce的经验。section7讨论相关的和未来的工作。</p><h1 id="2、Programming-Model"><a href="#2、Programming-Model" class="headerlink" title="2、Programming Model"></a>2、Programming Model</h1><p>​    MapReduce编程模型的原理是：利用一个输入key/value pair集合来产生一个输出的key/value pair集合。MapReduce库的用户用两个函数表达这个计算：<strong>Map和Reduce</strong>。</p><p>​    用户自定义的<em>Map</em>函数接受一个key/value pair的输入值，然后产生一个中间key/value pair值的集合。MapReduce库把所有具有相同中间key值<em>I</em>的中间value值集合在一起后传递给<em>reduce</em>函数。</p><p>​    用户自定义的Reduce函数接受一个中间key的值<em>I</em>和相关的一个value值的集合。Reduce函数合并这些value值，形成一个较小的value值的集合。通常来说，每次Reduce函数调用只产生0或1个输出value值。通常我们通过一个迭代器把中间value值提供给Reduce函数，这样我们就可以处理无法全部放入内存中的大量的value值的集合(迭代器可看为一个容器,所有数据放入一个容器中，reduce函数就从这个容器中取数据即可)。</p><h2 id="2-1、Example"><a href="#2-1、Example" class="headerlink" title="2.1、Example"></a>2.1、Example</h2><p>思考一个问题：计算一个大的文档集合中每个单词出现的次数，程序可能会写出类似下面的伪代码：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">map(String key, String value):     // key: document name     // value: document contents     for each word w in value:      EmitIntermediate(w, “1″);       reduce(String key, Iterator values):     // key: a word     // values: a list of counts     int result = 0;     for each v in values:       result += ParseInt(v);     Emit(AsString(result));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​    map函数输出文档中的每个词、以及这个词的出现次数(在这个简单的例子里就是1)。reduce函数把Map函数产生的每一个特定的词的计数累加起来。</p><p>​    另外，用户编写代码，使用输入和输出文件的名字、可选的调节参数来完成一个符合MapReduce模型规范的对象，然后调用MapReduce函数，并把这个规范对象传递给它。用户的代码和MapReduce库链接在一起(用C++实现)。附录A包含了这个实例的全部程序代码。</p><h2 id="2-2、Type"><a href="#2-2、Type" class="headerlink" title="2.2、Type"></a>2.2、Type</h2><p>尽管在前面例子的伪代码中使用了以字符串表示的输入输出值，但是在概念上，用户定义的Map和Reduce函数都有相关联的类型：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">map     (k1,v1)       ->list(k2,v2) reduce  (k2,list(v2)) ->list(v2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>比如，输入的key和value值与输出的key和value值在类型推导的域不同。此外，中间key和value值与输出key和value值在类型上推导的域相同。(原文中这个domain的含义不是很清楚，我参考Hadoop、KFS等实现，map和reduce都使用了泛型，因此，我把domain翻译成类型推导的域)。</p><p>我们的C++中使用字符串类型作为用户自定义函数的输入输出，用户在自己的代码中对字符串进行适当的类型转换。</p><h2 id="2-3、More-Examples"><a href="#2-3、More-Examples" class="headerlink" title="2.3、More Examples"></a>2.3、More Examples</h2><p><strong>分布式的Grep</strong>：Map函数输出匹配某个模式的一行，Reduce函数是一个恒等函数，即把中间数据复制到输出。</p><p><strong>计算URL访问频率</strong>：Map函数处理日志中web页面请求的记录，然后输出(URL,1)。Reduce函数把相同URL的value值都累加起来，产生(URL,记录总数)结果。</p><p><strong>倒转网络链接图</strong>：Map函数在源页面（source）中搜索所有的链接目标（target）并输出为(target,source)。Reduce函数把给定链接目标（target）的链接组合成一个列表，输出(target,list(source))。</p><p><strong>每个主机的检索词向量</strong>：检索词向量用一个(词,频率)列表来概述出现在文档或文档集中的最重要的一些词。Map函数为每一个输入文档输出(主机名,检索词向量)，其中主机名来自文档的URL。Reduce函数接收给定主机的所有文档的检索词向量，并把这些检索词向量加在一起，丢弃掉低频的检索词，输出一个最终的(主机名,检索词向量)。</p><p><strong>倒排索引</strong>：Map函数分析每个文档输出一个(词,文档号)的列表，Reduce函数的输入是一个给定词的所有（词，文档号），排序所有的文档号，输出(词,list（文档号）)。所有的输出集合形成一个简单的倒排索引，它以一种简单的算法跟踪词在文档中的位置。</p><p><strong>分布式排序</strong>：Map函数从每个记录提取key，输出(key,record)。Reduce函数不改变任何的值。这个运算依赖分区机制(在4.1描述)和排序属性(在4.2描述)。</p><h1 id="3、Implementation"><a href="#3、Implementation" class="headerlink" title="3、Implementation"></a>3、Implementation</h1><p>MapReduce模型可以有多种不同的实现方式。如何正确选择取决于具体的环境。例如，一种实现方式适用于小型的共享内存方式的机器，另外一种实现方式则适用于大型NUMA架构的多处理器的主机，而有的实现方式更适合大型的网络连接集群。</p><blockquote><p>NUMA（Non-Uniform Memory Access，非均匀内存访问）是一种多处理器计算机架构，它在物理上上由多个处理器和多个内存模块组成，每个处理器都有自己的本地内存，但也可以访问其他处理器的内存。</p><p>NUMA 架构中，每个处理器可以访问整个系统中的所有内存，但由于不同的内存模块可能距离不同的处理器更近，因此访问不同内存模块的延迟可能会不同。因此，NUMA 架构中的内存访问速度是不均匀的。</p></blockquote><p>本章节描述一个适用于Google内部广泛使用的运算环境的实现：用以太网交换机连接、由普通PC机组成的大型集群。在我们的环境里包括：</p><ol><li>x86架构、运行Linux操作系统、双处理器、2-4GB内存的机器。</li><li>普通的网络硬件设备，每个机器的带宽为百兆或者千兆，但是远小于网络的平均带宽的一半。</li><li>集群中包含成百上千的机器，因此，机器故障是常态。</li><li>存储为廉价的内置IDE硬盘。一个内部分布式文件系统用来管理存储在这些磁盘上的数据。文件系统通过数据复制来在不可靠的硬件上保证数据的可靠性和有效性。</li><li>用户提交工作（job）给调度系统。每个工作（job）都包含一系列的任务（task），调度系统将这些任务调度到集群中多台可用的机器上。</li></ol><h2 id="3-1、Execution-Overview"><a href="#3-1、Execution-Overview" class="headerlink" title="3.1、Execution Overview"></a>3.1、Execution Overview</h2><p>通过将Map调用的输入数据自动分割为M个数据片段的集合，Map调用被分布到多台机器上执行。输入的数据片段能够在不同的机器上并行处理。使用分区函数将Map调用产生的中间key值分成R个不同分区（例如，hash(key) mod R），Reduce调用也被分布到多台机器上执行。分区数量（R）和分区函数由用户来指定。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304141533053.png"></p><p>图1展示了我们的MapReduce实现中操作的全部流程。当用户调用MapReduce函数时，将发生下面的一系列动作（下面的序号和图1中的序号一一对应）：</p><p>1.用户程序首先调用的MapReduce库将输入文件分成M个数据片度，每个数据片段的大小一般从 16MB到64MB(可以通过可选的参数来控制每个数据片段的大小)。然后用户程序在机群中创建大量的程序副本。</p><p>2.这些程序副本中的有一个特殊的程序–master。副本中其它的程序都是worker程序，由master分配任务。有M个Map任务和R个Reduce任务将被分配，master将一个Map任务或Reduce任务分配给一个空闲的worker。</p><p>3.被分配了map任务的worker程序读取相关的输入数据片段，从输入的数据片段中解析出key/value pair，然后把key/value pair传递给用户自定义的Map函数，由Map函数生成并输出的中间key/value pair，并缓存在内存中。</p><p>4.缓存中的key/value pair通过分区函数分成R个区域，之后周期性的写入到本地磁盘上。缓存的key/value pair在本地磁盘上的存储位置将被回传给master，由master负责把这些存储位置再传送给Reduce worker。</p><p>5.当Reduce worker程序接收到master程序发来的数据存储位置信息后，使用RPC从Map worker所在主机的磁盘上读取这些缓存数据。当Reduce worker读取了所有的中间数据后，通过对key进行排序后使得具有相同key值的数据聚合在一起。由于许多不同的key值会映射到相同的Reduce任务上，因此必须进行排序。如果中间数据太大无法在内存中完成排序，那么就要在外部进行排序。</p><p>6.Reduce worker程序遍历排序后的中间数据，对于每一个唯一的中间key值，Reduce worker程序将这个key值和它相关的中间value值的集合传递给用户自定义的Reduce函数。Reduce函数的输出被追加到所属分区的输出文件。</p><p>7.当所有的Map和Reduce任务都完成之后，master唤醒用户程序。在这个时候，在用户程序里的对MapReduce调用才返回。</p><p>在成功完成任务之后，MapReduce的输出存放在R个输出文件中（对应每个Reduce任务产生一个输出文件，文件名由用户指定）。一般情况下，用户不需要将这R个输出文件合并成一个文件–他们经常把这些文件作为另外一个MapReduce的输入，或者在另外一个可以处理多个分割文件的分布式应用中使用。</p><h2 id="3-2、Master-Data-Structures"><a href="#3-2、Master-Data-Structures" class="headerlink" title="3.2、Master Data Structures"></a>3.2、Master Data Structures</h2><p>Master持有一些数据结构，它存储每一个Map和Reduce任务的状态（空闲、工作中或完成)，以及Worker机器(非空闲任务的机器)的标识。</p><p>Master就像一个数据管道，中间文件存储区域的位置信息通过这个管道从Map传递到Reduce。因此，对于每个已经完成的Map任务，master存储了Map任务产生的R个中间文件存储区域的大小和位置。当Map任务完成时，Master接收到位置和大小的更新信息，这些信息被逐步递增的推送给那些正在工作的Reduce任务。</p><h2 id="3-3、Fault-Tolerance"><a href="#3-3、Fault-Tolerance" class="headerlink" title="3.3、Fault Tolerance"></a>3.3、Fault Tolerance</h2><p>因为MapReduce库的设计初衷是使用由成百上千的机器组成的集群来处理超大规模的数据，所以，这个库必须要能很好的处理机器故障。</p><h4 id="Worker-Failure"><a href="#Worker-Failure" class="headerlink" title="Worker Failure"></a>Worker Failure</h4><p>master周期性的ping每个worker。如果在一个约定的时间范围内没有收到worker返回的信息，master将把这个worker标记为失效。所有由这个失效的worker完成的Map任务被重设为初始的空闲状态，之后这些任务就可以被安排给其他的worker。同样的，worker失效时正在运行的Map或Reduce任务也将被重新置为空闲状态，等待重新调度。</p><p>当worker故障时，由于已经完成的Map任务的输出存储在这台机器上，Map任务的输出已不可访问了，因此必须重新执行。而已经完成的Reduce任务的输出存储在全局文件系统上，因此不需要再次执行。</p><p>当一个Map任务首先被worker A执行，之后由于worker A失效了又被调度到worker B执行，这个“重新执行”的动作会被通知给所有执行Reduce任务的worker。任何还没有从worker A读取数据的Reduce任务将从worker B读取数据。</p><p>MapReduce可以处理大规模worker失效的情况。比如，在一个MapReduce操作执行期间，在正在运行的集群上进行网络维护引起80台机器在几分钟内不可访问了，MapReduce master只需要简单的再次执行那些不可访问的worker完成的工作，之后继续执行未完成的任务，直到最终完成这个MapReduce操作。</p><h4 id="Master-Failure"><a href="#Master-Failure" class="headerlink" title="Master Failure"></a>Master Failure</h4><p>一个简单的解决办法是让master周期性的将上面描述的数据结构（指3.2节）写入磁盘，即检查点（checkpoint）。如果这个master任务失效了，可以从最后一个检查点（checkpoint）开始启动另一个master进程。然而，由于只有一个master进程，master失效后再恢复是比较麻烦的，因此我们现在的实现是如果master失效，就中止MapReduce运算。客户可以检查到这个状态，并且可以根据需要重新执行MapReduce操作。</p><h4 id="Semantics-in-the-Presene-of-Failures"><a href="#Semantics-in-the-Presene-of-Failures" class="headerlink" title="Semantics in the Presene of Failures"></a>Semantics in the Presene of Failures</h4><p>故障时处理的机制</p><p>当用户提供的Map和Reduce操作是输入确定性函数（即相同的输入产生相同的输出）时，我们的分布式实现在任何情况下的输出都和所有程序没有出现任何错误、顺序的执行产生的输出是一样的。</p><p>我们依赖对Map和Reduce任务的输出是原子提交的来完成这个特性。每个工作中的任务把它的输出写到私有的临时文件中。每个Reduce任务生成一个这样的文件，而每个Map任务则生成R个这样的文件（一个Reduce任务对应一个文件）。当一个Map任务完成的时，worker发送一个包含R个临时文件名的完成消息给master。如果master从一个已经完成的Map任务再次接收到到一个完成消息，master将忽略这个消息；否则，master将这R个文件的名字记录在数据结构里。</p><blockquote><p>automic commit 原子提交，要么都成功要么都失败</p></blockquote><p>当Reduce任务完成时，Reduce worker进程以原子的方式把临时文件重命名为最终的输出文件。如果同一个Reduce任务在多台机器上执行，针对同一个最终的输出文件将有多个重命名操作执行。我们依赖底层文件系统提供的重命名操作的原子性来保证最终的文件系统状态仅仅包含一个Reduce任务产生的数据。</p><p>使用MapReduce模型的程序员可以很容易的理解他们程序的行为，因为我们绝大多数的Map和Reduce操作是确定性的，而且存在这样的一个事实：我们的失效处理机制等价于一个顺序的执行的操作。当Map或/和Reduce操作是不确定性的时候，我们提供虽然较弱但是依然合理的处理机制。当使用非确定操作的时候，一个Reduce任务R1的输出等价于一个非确定性程序顺序执行产生时的输出。但是，另一个Reduce任务R2的输出也许符合一个不同的非确定顺序程序执行产生的R2的输出。</p><p>考虑Map任务M和Reduce任务R1、R2的情况。我们设定e(Ri)是Ri已经提交的执行过程（有且仅有一个这样的执行过程）。当e(R1)读取了由M一次执行产生的输出，而e(R2)读取了由M的另一次执行产生的输出，导致了较弱的失效处理。</p><h2 id="3-4、Locality"><a href="#3-4、Locality" class="headerlink" title="3.4、Locality"></a>3.4、Locality</h2><p>在我们的计算运行环境中，网络带宽是一个相当匮乏的资源。我们通过尽量把输入数据(由GFS管理)存储在集群中机器的本地磁盘上来节省网络带宽。GFS把每个文件按64MB一个Block分隔，每个Block保存在多台机器上，环境中就存放了多份拷贝(一般是3个拷贝)。MapReduce的master在调度Map任务时会考虑输入文件的位置信息，尽量将一个Map任务调度在包含相关输入数据拷贝的机器上执行；如果上述努力失败了，master将尝试在保存有输入数据拷贝的机器附近的机器上执行Map任务(例如，分配到一个和包含输入数据的机器在一个switch里的worker机器上执行)。当在一个足够大的cluster集群上运行大型MapReduce操作的时候，大部分的输入数据都能从本地机器读取，因此消耗非常少的网络带宽。</p><h2 id="3-5、Task-Granularity"><a href="#3-5、Task-Granularity" class="headerlink" title="3.5、Task Granularity"></a>3.5、Task Granularity</h2><p>任务粒度</p><p>如前所述，我们把Map拆分成了M个片段、把Reduce拆分成R个片段执行。理想情况下，M和R应当比集群中worker的机器数量要多得多。在每台worker机器都执行大量的不同任务能够提高集群的动态的负载均衡能力，并且能够加快故障恢复的速度：失效机器上执行的大量Map任务都可以分布到所有其他的worker机器上去执行。</p><p>但是实际上，在我们的具体实现中对M和R的取值都有一定的客观限制，因为master必须执行O(M+R)次调度，并且在内存中保存O(M<em>R)个状态（对影响内存使用的因素还是比较小的：O(M</em>R)块状态，大概每对Map任务/Reduce任务1个字节就可以了）。</p><p>更进一步，R值通常是由用户指定的，因为每个Reduce任务最终都会生成一个独立的输出文件。实际使用时我们也倾向于选择合适的M值，以使得每一个独立任务都是处理大约16M到64M的输入数据（这样，上面描写的输入数据本地存储优化策略才最有效），另外，我们把R值设置为我们想使用的worker机器数量的小的倍数。我们通常会用这样的比例来执行MapReduce：M=200000，R=5000，使用2000台worker机器。</p><h2 id="3-6、Backup-Tasks"><a href="#3-6、Backup-Tasks" class="headerlink" title="3.6、Backup Tasks"></a>3.6、Backup Tasks</h2><p>任务备份</p><p>影响一个MapReduce的总执行时间最通常的因素是“落伍者”：在运算过程中，如果有一台机器花了很长的时间才完成最后几个Map或Reduce任务，导致MapReduce操作总的执行时间超过预期。出现“落伍者”的原因非常多。比如：如果一个机器的硬盘出了问题，在读取的时候要经常的进行读取纠错操作，导致读取数据的速度从30M/s降低到1M/s。如果cluster的调度系统在这台机器上又调度了其他的任务，由于CPU、内存、本地硬盘和网络带宽等竞争因素的存在，导致执行MapReduce代码的执行效率更加缓慢。我们最近遇到的一个问题是由于机器的初始化代码有bug，导致关闭了的处理器的缓存：在这些机器上执行任务的性能和正常情况相差上百倍。</p><p>我们有一个通用的机制来减少“落伍者”出现的情况。当一个MapReduce操作接近完成的时候，master调度备用（backup）任务进程来执行剩下的、处于处理中状态（in-progress）的任务。无论是最初的执行进程、还是备用（backup）任务进程完成了任务，我们都把这个任务标记成为已经完成。我们调优了这个机制，通常只会占用比正常操作多几个百分点的计算资源。我们发现采用这样的机制对于减少超大MapReduce操作的总处理时间效果显著。例如，在5.3节描述的排序任务，在关闭掉备用任务的情况下要多花44%的时间完成排序任务。</p><h1 id="4、Refinements"><a href="#4、Refinements" class="headerlink" title="4、Refinements"></a>4、Refinements</h1><p>完善</p><p>虽然简单的Map和Reduce函数提供的基本功能已经能够满足大部分的计算需要，我们还是发掘出了一些有价值的扩展功能。本节将描述这些扩展功能。</p><h2 id="4-1、Partitioning-Function"><a href="#4-1、Partitioning-Function" class="headerlink" title="4.1、Partitioning Function"></a>4.1、Partitioning Function</h2><p>分割功能</p><p>MapReduce的使用者通常会指定Reduce任务和Reduce任务输出文件的数量（R）。我们在中间key上使用分区函数来对数据进行分区，之后再输入到后续任务执行进程。一个默认的分区函数是使用hash方法(比如，hash(key) mod R)进行分区。hash方法能产生非常平衡的分区。然而，有的时候，其它的一些分区函数对key值进行的分区将非常有用。比如，输出的key值是URLs，我们希望每个主机的所有条目保持在同一个输出文件中。为了支持类似的情况，MapReduce库的用户需要提供专门的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数就可以把所有来自同一个主机的URLs保存在同一个输出文件中。</p><h2 id="4-2、Ordering-Guarantees"><a href="#4-2、Ordering-Guarantees" class="headerlink" title="4.2、Ordering Guarantees"></a>4.2、Ordering Guarantees</h2><p>排序保证</p><p>我们确保在给定的分区中，中间key/value pair数据的处理顺序是按照key值增量顺序处理的。这样的顺序保证对每个分成生成一个有序的输出文件，这对于需要对输出文件按key值随机存取的应用非常有意义，对在排序输出的数据集也很有帮助。</p><h2 id="4-3、Combiner-Function"><a href="#4-3、Combiner-Function" class="headerlink" title="4.3、Combiner Function"></a>4.3、Combiner Function</h2><p>合并函数</p><p>在某些情况下，Map函数产生的中间key值的重复数据会占很大的比重，并且，用户自定义的Reduce函数满足结合律和交换律。在2.1节的词数统计程序是个很好的例子。由于词频率倾向于一个zipf分布(齐夫分布)，每个Map任务将产生成千上万个这样的记录&lt;the,1&gt;.所有的这些记录将通过网络被发送到一个单独的Reduce任务，然后由这个Reduce任务把所有这些记录累加起来产生一个数字。我们允许用户指定一个可选的combiner函数，combiner函数首先在本地将这些记录进行一次合并，然后将合并的结果再通过网络发送出去。</p><p>Combiner函数在每台执行Map任务的机器上都会被执行一次。一般情况下，Combiner和Reduce函数是一样的。Combiner函数和Reduce函数之间唯一的区别是MapReduce库怎样控制函数的输出。Reduce函数的输出被保存在最终的输出文件里，而Combiner函数的输出被写到中间文件里，然后被发送给Reduce任务。</p><p>部分的合并中间结果可以显著的提高一些MapReduce操作的速度。附录A包含一个使用combiner函数的例子。</p><h2 id="4-4、Input-and-Output-Types"><a href="#4-4、Input-and-Output-Types" class="headerlink" title="4.4、Input and Output Types"></a>4.4、Input and Output Types</h2><p>输入输出格式</p><p>MapReduce库支持几种不同的格式的输入数据。比如，文本模式的输入数据的每一行被视为是一个key/value pair。key是文件的偏移量，value是那一行的内容。另外一种常见的格式是以key进行排序来存储的key/value pair的序列。每种输入类型的实现都必须能够把输入数据分割成数据片段，该数据片段能够由单独的Map任务来进行后续处理(例如，文本模式的范围分割必须确保仅仅在每行的边界进行范围分割)。虽然大多数MapReduce的使用者仅仅使用很少的预定义输入类型就满足要求了，但是使用者依然可以通过提供一个简单的<em>Reader</em>接口实现就能够支持一个新的输入类型。</p><p><em>Reader</em>并非一定要从文件中读取数据，比如，我们可以很容易的实现一个从数据库里读记录的Reader，或者从内存中的数据结构读取数据的Reader。</p><p>类似的，我们提供了一些预定义的输出数据的类型，通过这些预定义类型能够产生不同格式的数据。用户采用类似添加新的输入数据类型的方式增加新的输出类型。</p><h2 id="4-5、Side-effects"><a href="#4-5、Side-effects" class="headerlink" title="4.5、Side-effects"></a>4.5、Side-effects</h2><p>副作用</p><p>在某些情况下，MapReduce的使用者发现，如果在Map和/或Reduce操作过程中增加辅助的输出文件会比较省事。我们依靠程序writer把这种“副作用”变成原子的和幂等的（幂等的指一个总是产生相同结果的数学运算）。通常应用程序首先把输出结果写到一个临时文件中，在输出全部数据之后，在使用系统级的原子操作rename重新命名这个临时文件。</p><p>如果一个任务产生了多个输出文件，我们没有提供类似两阶段提交的原子操作支持这种情况。因此，对于会产生多个输出文件、并且对于跨文件有一致性要求的任务，都必须是确定性的任务。但是在实际应用过程中，这个限制还没有给我们带来过麻烦。</p><h2 id="4-6、Skipping-Bad-Records"><a href="#4-6、Skipping-Bad-Records" class="headerlink" title="4.6、Skipping Bad Records"></a>4.6、Skipping Bad Records</h2><p>跳过“不好”的记录</p><p>有时候，用户程序中的bug导致Map或者Reduce函数在处理某些记录的时候crash掉，MapReduce操作无法顺利完成。惯常的做法是修复bug后再次执行MapReduce操作，但是，有时候找出这些bug并修复它们不是一件容易的事情；这些bug也许是在第三方库里边，而我们手头没有这些库的源代码。而且在很多时候，忽略一些有问题的记录也是可以接受的，比如在一个巨大的数据集上进行统计分析的时候。我们提供了一种执行模式，在这种模式下，为了保证保证整个处理能继续进行，MapReduce会检测哪些记录导致确定性的crash，并且跳过这些记录不处理。</p><p>每个worker进程都设置了信号处理函数捕获内存段异常（segmentation violation）和总线错误（bus error）。在执行Map或者Reduce操作之前，MapReduce库通过全局变量保存记录序号。如果用户程序触发了一个系统信号，消息处理函数将用“最后一口气”通过UDP包向master发送处理的最后一条记录的序号。当master看到在处理某条特定记录不止失败一次时，master就标志着条记录需要被跳过，并且在下次重新执行相关的Map或者Reduce任务的时候跳过这条记录。</p><h2 id="4-7、Local-Execution"><a href="#4-7、Local-Execution" class="headerlink" title="4.7、Local Execution"></a>4.7、Local Execution</h2><p>本地执行</p><p>调试Map和Reduce函数的bug是非常困难的，因为实际执行操作时不但是分布在系统中执行的，而且通常是在好几千台计算机上执行，具体的执行位置是由master进行动态调度的，这又大大增加了调试的难度。为了简化调试、profile和小规模测试，我们开发了一套MapReduce库的本地实现版本，通过使用本地版本的MapReduce库，MapReduce操作在本地计算机上顺序的执行。用户可以控制MapReduce操作的执行，可以把操作限制到特定的Map任务上。用户通过设定特别的标志来在本地执行他们的程序，之后就可以很容易的使用本地调试和测试工具（比如gdb）。</p><h2 id="4-8、Status-Information"><a href="#4-8、Status-Information" class="headerlink" title="4.8、Status Information"></a>4.8、Status Information</h2><p>状态信息</p><p>master使用嵌入式的HTTP服务器（如Jetty）显示一组状态信息页面，用户可以监控各种执行状态。状态信息页面显示了包括计算执行的进度，比如已经完成了多少任务、有多少任务正在处理、输入的字节数、中间数据的字节数、输出的字节数、处理百分比等等。页面还包含了指向每个任务的stderr和stdout文件的链接。用户根据这些数据预测计算需要执行大约多长时间、是否需要增加额外的计算资源。这些页面也可以用来分析什么时候计算执行的比预期的要慢。</p><p>另外，处于最顶层的状态页面显示了哪些worker失效了，以及他们失效的时候正在运行的Map和Reduce任务。这些信息对于调试用户代码中的bug很有帮助。</p><h2 id="4-9、Counters"><a href="#4-9、Counters" class="headerlink" title="4.9、Counters"></a>4.9、Counters</h2><p>计数器</p><p>MapReduce库使用计数器统计不同事件发生次数。比如，用户可能想统计已经处理了多少个单词、已经索引的多少篇German文档等等。</p><p>为了使用这个特性，用户在程序中创建一个命名的计数器对象，在Map和Reduce函数中相应的增加计数器的值。例如：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Counter* uppercase; uppercase = GetCounter(“uppercase”); map(String name, String contents):   for each word w in contents:      if (IsCapitalized(w)):        uppercase->Increment();      EmitIntermediate(w, “1″);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这些计数器的值周期性的从各个单独的worker机器上传递给master（附加在ping的应答包中传递）。master把执行成功的Map和Reduce任务的计数器值进行累计，当MapReduce操作完成之后，返回给用户代码。计数器当前的值也会显示在master的状态页面上，这样用户就可以看到当前计算的进度。当累加计数器的值的时候，master要检查重复运行的Map或者Reduce任务，避免重复累加（之前提到的备用任务和失效后重新执行任务这两种情况会导致相同的任务被多次执行）。</p><p>有些计数器的值是由MapReduce库自动维持的，比如已经处理的输入的key/value pair的数量、输出的key/value pair的数量等等。</p><p>用户发现计数器机制对于MapReduce操作的完整性检查非常有用。比如，在某些MapReduce操作中，用户需要确保输出的key value pair精确的等于输入的key value pair，或者处理的German文档数量在处理的整个文档数量中属于合理范围。</p><h1 id="5、Performance"><a href="#5、Performance" class="headerlink" title="5、Performance"></a>5、Performance</h1><p>本节我们用在一个大型集群上运行的两个计算来衡量MapReduce的性能。一个计算在大约1TB的数据中进行特定的模式匹配，另一个计算对大约1TB的数据进行排序。</p><p>这两个程序在大量的使用MapReduce的实际应用中是非常典型的 — 一类是对数据格式进行转换，从一种表现形式转换为另外一种表现形式；另一类是从海量数据中抽取少部分的用户感兴趣的数据。</p><h2 id="5-1、Cluster-Configuration"><a href="#5-1、Cluster-Configuration" class="headerlink" title="5.1、Cluster Configuration"></a>5.1、Cluster Configuration</h2><p>所有这些程序都运行在一个大约由1800台机器构成的集群上。每台机器配置2个2G主频、支持超线程的Intel Xeon处理器，4GB的物理内存，两个160GB的IDE硬盘和一个千兆以太网卡。这些机器部署在一个两层的树形交换网络中，在root节点大概有100-200GBPS的传输带宽。所有这些机器都采用相同的部署（对等部署），因此任意两点之间的网络来回时间小于1毫秒。</p><p>在4GB内存里，大概有1-1.5G用于运行在集群上的其他任务。测试程序在周末下午开始执行，这时主机的CPU、磁盘和网络基本上处于空闲状态。</p><h2 id="5-2、Grep"><a href="#5-2、Grep" class="headerlink" title="5.2、Grep"></a>5.2、Grep</h2><p>筛选</p><p>这个分布式的筛选程序需要扫描大概10的10次方个由100个字节组成的记录，查找出现概率较小的3个字符的模式（这个模式在92337个记录中出现）。输入数据被拆分成大约64M的Block（M=15000），整个输出数据存放在一个文件中（R=1）。</p><p>figure2显示了这个运算随时间的处理过程。其中Y轴表示输入数据的处理速度。处理速度随着参与MapReduce计算的机器数量的增加而增加，当1764台worker参与计算的时，处理速度达到了30GB/s。当Map任务结束的时候，即在计算开始后80秒，输入的处理速度降到0。整个计算过程从开始到结束一共花了大概150秒。这包括了大约一分钟的初始启动阶段。初始启动阶段消耗的时间包括了是把这个程序传送到各个worker机器上的时间、等待GFS文件系统打开1000个输入文件集合的时间、获取相关的文件本地位置优化信息的时间。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304141718140.png"></p><h2 id="5-3、Sort"><a href="#5-3、Sort" class="headerlink" title="5.3、Sort"></a>5.3、Sort</h2><p>排序程序处理10的10次方个100个字节组成的记录（大概1TB的数据）。这个程序模仿TeraSort benchmark[10]。</p><p>排序程序由不到50行代码组成。只有三行的Map函数从文本行中解析出10个字节的key值作为排序的key，并且把这个key和原始文本行作为中间的key/value pair值输出。我们使用了一个内置的恒等函数作为Reduce操作函数。这个函数把中间的key/value pair值不作任何改变输出。最终排序结果输出到两路复制的GFS文件系统（也就是说，程序输出2TB的数据）。</p><p>如前所述，输入数据被分成64MB的Block（M=15000）。我们把排序后的输出结果分区后存储到4000个文件（R=4000）。分区函数使用key的原始字节来把数据分区到R个片段中。</p><p>在这个benchmark测试中，我们使用的分区函数知道key的分区情况。通常对于排序程序来说，我们会增加一个预处理的MapReduce操作用于采样key值的分布情况，通过采样的数据来计算对最终排序处理的分区点。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304141720330.png"></p><p>图三（a）显示了这个排序程序的正常执行过程。左上的图显示了输入数据读取的速度。数据读取速度峰值会达到13GB/s，并且所有Map任务完成之后，即大约200秒之后迅速滑落到0。值得注意的是，排序程序输入数据读取速度小于分布式grep程序。这是因为排序程序的Map任务花了大约一半的处理时间和I/O带宽把中间输出结果写到本地硬盘。相应的分布式grep程序的中间结果输出几乎可以忽略不计。</p><p>左边中间的图显示了中间数据从Map任务发送到Reduce任务的网络速度。这个过程从第一个Map任务完成之后就开始缓慢启动了。图示的第一个高峰是启动了第一批大概1700个Reduce任务（整个MapReduce分布到大概1700台机器上，每台机器1次最多执行1个Reduce任务）。排序程序运行大约300秒后，第一批启动的Reduce任务有些完成了，我们开始执行剩下的Reduce任务。所有的处理在大约600秒后结束。</p><p>左下图表示Reduce任务把排序后的数据写到最终的输出文件的速度。在第一个排序阶段结束和数据开始写入磁盘之间有一个小的延时，这是因为worker机器正在忙于排序中间数据。磁盘写入速度在2-4GB/s持续一段时间。输出数据写入磁盘大约持续850秒。计入初始启动部分的时间，整个运算消耗了891秒。这个速度和TeraSort benchmark[18]的最高纪录1057秒相差不多。</p><p>还有一些值得注意的现象：输入数据的读取速度比排序速度和输出数据写入磁盘速度要高不少，这是因为我们的输入数据本地化优化策略起了作用 — 绝大部分数据都是从本地硬盘读取的，从而节省了网络带宽。排序速度比输出数据写入到磁盘的速度快，这是因为输出数据写了两份（我们使用了2路的GFS文件系统，写入复制节点的原因是为了保证数据可靠性和可用性）。我们把输出数据写入到两个复制节点的原因是因为这是底层文件系统的保证数据可靠性和可用性的实现机制。如果底层文件系统使用类似容错编码[14](erasure coding)的方式而不是复制的方式保证数据的可靠性和可用性，那么在输出数据写入磁盘的时候，就可以降低网络带宽的使用。</p><h2 id="5-4、Effect-of-Bakup-Task"><a href="#5-4、Effect-of-Bakup-Task" class="headerlink" title="5.4、Effect of Bakup Task"></a>5.4、Effect of Bakup Task</h2><p>备用任务的作用（对应3.6）</p><p>图三（b）显示了关闭了备用任务后排序程序执行情况。执行的过程和图3（a）很相似，除了输出数据写磁盘的动作在时间上拖了一个很长的尾巴，而且在这段时间里，几乎没有什么写入动作。在960秒后，只有5个Reduce任务没有完成。这些拖后腿的任务又执行了300秒才完成。整个计算消耗了1283秒，多了44%的执行时间。</p><h2 id="5-5、Machine-Failures"><a href="#5-5、Machine-Failures" class="headerlink" title="5.5、Machine Failures"></a>5.5、Machine Failures</h2><p>在图三（c）中演示的排序程序执行的过程中，我们在程序开始后几分钟有意的kill了1746个worker中的200个。集群底层的调度立刻在这些机器上重新开始新的worker处理进程（因为只是worker机器上的处理进程被kill了，机器本身还在工作）。</p><p>图三（c）显示出了一个“负”的输入数据读取速度，这是因为一些已经完成的Map任务丢失了（由于相应的执行Map任务的worker进程被kill了），需要重新执行这些任务。相关Map任务很快就被重新执行了。整个运算在933秒内完成，包括了初始启动时间（只比正常执行多消耗了5%的时间）。</p><h1 id="6、Experience"><a href="#6、Experience" class="headerlink" title="6、Experience"></a>6、Experience</h1><p>我们在2003年1月完成了第一个版本的MapReduce库，在2003年8月的版本有了显著的增强，这包括了输入数据本地优化、worker机器之间的动态负载均衡等等。从那以后，我们惊喜的发现，MapReduce库能广泛应用于我们日常工作中遇到的各类问题。它现在在Google内部各个领域得到广泛应用，包括：</p><p>1.大规模机器学习问题</p><p>2.Google News和Froogle产品的集群问题</p><p>3.从公众查询产品（比如Google的Zeitgeist）的报告中抽取数据。</p><p>4.从大量的新应用和新产品的网页中提取有用信息（比如，从大量的位置搜索网页中抽取地理位置信息）。</p><p>5.大规模的图形计算。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304141724117.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304141724798.png"></p><p>图四显示了在我们的源代码管理系统中，随着时间推移，独立的MapReduce程序数量的显著增加。从2003年早些时候的0个增长到2004年9月份的差不多900个不同的程序。MapReduce的成功取决于采用MapReduce库能够在不到半个小时时间内写出一个简单的程序，这个简单的程序能够在上千台机器的组成的集群上做大规模并发处理，这极大的加快了开发和原形设计的周期。另外，采用MapReduce库，可以让完全没有分布式和/或并行系统开发经验的程序员很容易的利用大量的资源，开发出分布式和/或并行处理的应用。</p><p>在每个任务结束的时候，MapReduce库统计计算资源的使用状况。在表1，我们列出了2004年8月份MapReduce运行的任务所占用的相关资源。</p><h2 id="6-1、large-scaling-indexing"><a href="#6-1、large-scaling-indexing" class="headerlink" title="6.1、large-scaling indexing"></a>6.1、large-scaling indexing</h2><p>到目前为止，MapReduce最成功的应用就是重写了Google网络搜索服务所使用到的index系统（索引系统）。索引系统的输入数据是网络爬虫抓取回来的海量的文档，这些文档数据都保存在GFS文件系统里。这些文档原始内容（raw contents，我认为就是网页中的剔除html标记后的内容、pdf和word等有格式文档中提取的文本内容等）的大小超过了20TB。索引程序是通过一系列的MapReduce操作（大约5到10次）来建立索引。使用MapReduce（替换上一个特别设计的、分布式处理的索引程序）带来这些好处：</p><p>1.实现索引部分的代码简单、小巧、容易理解，因为对于容错、分布式以及并行计算的处理都是MapReduce库提供的。比如，使用MapReduce库，计算的代码行数从原来的3800行C++代码减少到大概700行代码。</p><p>2.MapReduce库的性能已经足够好了，因此我们可以把在概念上不相关的计算步骤分开处理，而不是混在一起以期减少数据传递的额外消耗。概念上不相关的计算步骤的隔离也使得我们可以很容易改变索引处理方式。比如，对之前的索引系统的一个小更改可能要耗费好几个月的时间，但是在使用MapReduce的新系统上，这样的更改只需要花几天时间就可以了。</p><p>3.索引系统的操作管理更容易了。因为由机器失效、机器处理速度缓慢、以及网络的瞬间阻塞等引起的绝大部分问题都已经由MapReduce库解决了，不再需要操作人员的介入了。另外，我们可以通过在索引系统集群中增加机器的简单方法提高整体处理性能。</p><h1 id="7、Relate-work"><a href="#7、Relate-work" class="headerlink" title="7、Relate work"></a>7、Relate work</h1><p>很多系统都提供了严格的编程模式，并且通过对编程的严格限制来实现并行计算。例如，一个结合函数可以通过把N个元素的数组的前缀在N个处理器上使用并行前缀算法，在log N的时间内计算完。（???）。MapReduce可以看作是我们结合在真实环境下处理海量数据的经验，对这些经典模型进行简化和萃取的成果。更加值得骄傲的是，我们还实现了基于上千台处理器的集群的容错处理。相比而言，大部分并发处理系统都只在小规模的集群上实现，并且把容错处理交给了程序员。</p><p>Bulk Synchronous Programming和一些MPI原语提供了更高级别的并行处理抽象，可以更容易写出并行处理的程序。MapReduce和这些系统的关键不同之处在于，MapReduce利用限制性编程模式（Restricted programming model）实现了用户程序的自动并发处理，并且提供了透明的容错处理。</p><blockquote><p>“Restricted programming model”指的是受限的编程模型，即一种仅允许使用特定语言、库、API或编程范式等限制条件的编程模型。这种编程模型通常被用于特定领域的问题，如并行计算、分布式计算、图形处理、机器学习等。</p><p>受限的编程模型通常具有以下特点：</p><ul><li>易于并行化：该模型能够有效地利用多核处理器、分布式系统等并行计算资源，使得程序的计算能力得到提升。</li><li>易于优化：由于该模型的限制条件较为明确，因此编译器和系统可以针对这些限制条件进行更好的优化，提高程序的执行效率。</li><li>易于使用：由于限制条件较为明确，因此开发人员可以使用相对简单的工具和方法进行编程，减少编程的难度和出错的可能性。</li></ul><p>常见的受限编程模型包括数据流编程模型、MapReduce编程模型、SPMD（Single Program Multiple Data）编程模型等。</p></blockquote><p>我们数据本地优化策略的灵感来源于active disks等技术，在active disks中，计算任务是尽量推送到数据存储的节点处理，这样就减少了网络和IO子系统的吞吐量。我们在挂载几个硬盘的普通机器上执行我们的运算，而不是在磁盘处理器上执行我们的工作，但是达到的目的一样的。</p><p>我们的备用任务机制和Charlotte System提出的eager调度机制比较类似。Eager调度机制的一个缺点是如果一个任务反复失效，那么整个计算就不能完成。我们通过忽略引起故障的记录的方式在某种程度上解决了这个问题。</p><p>MapReduce的实现依赖于一个内部的集群管理系统，这个集群管理系统负责在一个超大的、共享机器的集群上分布和运行用户任务。虽然这个不是本论文的重点，但是有必要提一下，这个集群管理系统在理念上和其它系统，如Condor是一样。</p><p>MapReduce库的排序机制和NOW-Sort[1]的操作上很类似。读取输入源的机器（map workers）把待排序的数据进行分区后，发送到R个Reduce worker中的一个进行处理。每个Reduce worker在本地对数据进行排序（尽可能在内存中排序）。当然，NOW-Sort没有给用户自定义的Map和Reduce函数的机会，因此不具备MapReduce库广泛的实用性。</p><p>River提供了一个编程模型：处理进程通过分布式队列传送数据的方式进行互相通讯。和MapReduce类似，River系统尝试在不对等的硬件环境下，或者在系统颠簸的情况下也能提供近似平均的性能。River是通过精心调度硬盘和网络的通讯来平衡任务的完成时间。MapReduce库采用了其它的方法。通过对编程模型进行限制，MapReduce框架把问题分解成为大量的“小”任务。这些任务在可用的worker集群上动态的调度，这样快速的worker就可以执行更多的任务。通过对编程模型进行限制，我们可用在工作接近完成的时候调度备用任务，缩短在硬件配置不均衡的情况下缩小整个操作完成的时间（比如有的机器性能差、或者机器被某些操作阻塞了）。</p><p>BAD-FS采用了和MapReduce完全不同的编程模式，它是面向广域网的。不过，这两个系统有两个基础功能很类似。（1）两个系统采用重新执行的方式来防止由于失效导致的数据丢失。（2）两个都使用数据本地化调度策略，减少网络通讯的数据量。</p><p>TACC是一个用于简化构造高可用性网络服务的系统。和MapReduce一样，它也依靠重新执行机制来实现的容错处理。</p><h1 id="8、Conclusions"><a href="#8、Conclusions" class="headerlink" title="8、Conclusions"></a>8、Conclusions</h1><p>MapReduce编程模型在Google内部成功应用于多个领域。我们把这种成功归结为几个方面：首先，由于MapReduce封装了并行处理、容错处理、数据本地化优化、负载均衡等等技术难点的细节，这使得MapReduce库易于使用。即便对于完全没有并行或者分布式系统开发经验的程序员而言；其次，大量不同类型的问题都可以通过MapReduce简单的解决。比如，MapReduce用于生成Google的网络搜索服务所需要的数据、用来排序、用来数据挖掘、用于机器学习，以及很多其它的系统；第三，我们实现了一个在数千台计算机组成的大型集群上灵活部署运行的MapReduce。这个实现使得有效利用这些丰富的计算资源变得非常简单，因此也适合用来解决Google遇到的其他很多需要大量计算的问题。</p><p>我们也从MapReduce开发过程中学到了不少东西。首先，<strong>约束编程模式</strong>使得并行和分布式计算非常容易，也易于构造容错的计算环境；其次，<strong>网络带宽是稀有资源</strong>。大量的系统优化是针对减少网络传输量为目的的：<strong>本地优化策略</strong>使大量的数据从本地磁盘读取，中间文件写入本地磁盘、并且只写一份中间文件也节约了网络带宽；第三，<strong>备份服务器</strong>执行相同的任务可以减少性能缓慢的机器带来的负面影响（硬件配置的不平衡），同时解决了由于机器失效导致的数据丢失问题。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MapReduce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（六）贪心</title>
      <link href="/2023/04117610.html"/>
      <url>/2023/04117610.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><p>每次选取局部最优解，最终会得到全局最优解</p><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><h2 id="区间选点"><a href="#区间选点" class="headerlink" title="区间选点"></a>区间选点</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051405106.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;int n;struct Range&#123;    int l,r;    bool operator &lt; (const Range &amp;W ) const &#123;        return r &lt; W.r;    &#125;&#125;range[N];&#x2F;*    1、将每个区间按照右端点排序    2、从前往后依此枚举每个区间，若当前区间已经包含点，则直接pass；否则，选择当前区间的右端点        *&#x2F;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        range[i] &#x3D; &#123;l,r&#125;;    &#125;        sort(range, range+n);        int res &#x3D; 0 ,ed &#x3D; -2e9;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        if(range[i].l &gt; ed)        &#123;            res ++ ;            ed &#x3D; range[i].r;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Range</span> ranges<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">;</span>    l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ranges<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ed <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2e9</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span>  n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">></span> ed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res <span class="token operator">++</span> <span class="token punctuation">;</span>ed <span class="token operator">=</span> ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Range</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Range</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">-</span> o<span class="token punctuation">.</span>r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最大不相交区间的数量"><a href="#最大不相交区间的数量" class="headerlink" title="最大不相交区间的数量"></a>最大不相交区间的数量</h2><p>跟前一题代码相同</p><h2 id="区间分组"><a href="#区间分组" class="headerlink" title="区间分组"></a>区间分组</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051405536.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 100010;int n;struct Range&#123;    int l,r ;    bool operator &lt; (const Range &amp;W) const     &#123;        return l &lt; W.l;    &#125;&#125;range[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++)    &#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        range[i] &#x3D; &#123;a,b&#125;;    &#125;        sort(range,range+n);        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;&#x2F;&#x2F;小根堆        for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        auto it &#x3D; range[i];        if(heap.empty() || heap.top() &gt;&#x3D; it.l) heap.push(it.r); &#x2F;&#x2F;添加新的一组        else         &#123;            heap.pop();            heap.push(it.r);        &#125;    &#125;        cout &lt;&lt; heap.size() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Range</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ranges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">;</span>    l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ranges<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Range</span> it <span class="token operator">=</span> ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> pq<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> it<span class="token punctuation">.</span>l<span class="token punctuation">)</span> pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Range</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Range</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">-</span> o<span class="token punctuation">.</span>l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051546512.png"></p>  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;int n;struct Range&#123;    int l,r;    bool operator &lt; (const Range &amp;W) const     &#123;        return l &lt; W.l;    &#125;&#125;range[N];int main()&#123;    int st,ed;    cin &gt;&gt; st &gt;&gt; ed;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        range[i] &#x3D; &#123;a,b&#125;;    &#125;        sort(range,range+n);        int res &#x3D; 0;    bool success &#x3D; false;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int j &#x3D; i ,r &#x3D; -2e9;        while(j &lt; n &amp;&amp; range[j].l &lt;&#x3D; st) &#x2F;&#x2F;找到能覆盖st，且右端点最大的区间        &#123;            r &#x3D; max(r,range[j].r);            j ++ ;        &#125;                if(r &lt; st)&#x2F;&#x2F;找不到了，说明无解         &#123;            res &#x3D; -1;            break;        &#125;                res ++;        if(r &gt;&#x3D; ed) &#x2F;&#x2F;走到头了，可以结束了        &#123;            success &#x3D; true;            break;        &#125;                st &#x3D; r;        i &#x3D; j - 1;    &#125;        if(!success) res &#x3D; -1; &#x2F;&#x2F;若结束后所得的区间未能完全覆盖，也会无解    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Range</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ranges <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> st<span class="token punctuation">,</span> ed<span class="token punctuation">;</span>st <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ed <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">;</span>l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ranges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ranges<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">2e9</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> ranges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>l <span class="token operator">&lt;=</span> st<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>r <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> ranges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;</span> st<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>res<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">>=</span> ed<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>st <span class="token operator">=</span> r<span class="token punctuation">;</span>i <span class="token operator">=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Range</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Range</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> r<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Range</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Range</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>l <span class="token operator">-</span> o<span class="token punctuation">.</span>l<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Huffman树"><a href="#Huffman树" class="headerlink" title="Huffman树"></a>Huffman树</h1><h2 id="合并果子"><a href="#合并果子" class="headerlink" title="合并果子"></a>合并果子</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051546600.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;&#x2F;&#x2F;小根堆    while(n--)    &#123;        int x;        cin &gt;&gt; x;        heap.push(x);    &#125;        int res &#x3D; 0;    while(heap.size() &gt; 1)    &#123;        int a &#x3D; heap.top() ; heap.pop();        int b &#x3D; heap.top() ; heap.pop();        res +&#x3D; a + b;        heap.push(a+b);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">10010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pq<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> a <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> b <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">+=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>            pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="排序不等式"><a href="#排序不等式" class="headerlink" title="排序不等式"></a>排序不等式</h1><h2 id="排队打水"><a href="#排队打水" class="headerlink" title="排队打水"></a>排队打水</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051546956.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int N &#x3D; 100010;int n,t[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; t[i];    sort(t,t+n);    ll res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        res +&#x3D; t[i] * (n-i-1);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> t<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Long</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> t<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="绝对值不等式"><a href="#绝对值不等式" class="headerlink" title="绝对值不等式"></a>绝对值不等式</h1><h2 id="货仓选址"><a href="#货仓选址" class="headerlink" title="货仓选址"></a>货仓选址</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051546674.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;int n,a[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];    sort(a,a+n);    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        res +&#x3D; abs(a[i] - a[n&#x2F;2]);    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span>n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="推公式"><a href="#推公式" class="headerlink" title="推公式"></a>推公式</h1><h2 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title="耍杂技的牛"></a>耍杂技的牛</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304051546397.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;typedef pair&lt;int,int&gt; PII;int n;PII cow[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ;  i++ )    &#123;        int w,s;        cin &gt;&gt; w &gt;&gt; s;        cow[i] &#x3D; &#123;w+s,w&#125;;    &#125;        sort(cow,cow+n);    int res &#x3D; -2e9,sum &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int w &#x3D; cow[i].second , s &#x3D; cow[i].first - w;        res &#x3D; max(res,sum-s);        sum +&#x3D; w;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Cow</span> cows<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cow</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> s<span class="token punctuation">;</span>w <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cows<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cow</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>cows<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">2e9</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> w <span class="token operator">=</span> cows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">,</span> s <span class="token operator">=</span> cows<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>s <span class="token punctuation">;</span>res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum <span class="token operator">-</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>sum <span class="token operator">+=</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Cow</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Cow</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> s<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Cow</span><span class="token punctuation">(</span><span class="token keyword">int</span> w<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">=</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Cow</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>s <span class="token operator">-</span> o<span class="token punctuation">.</span>w <span class="token operator">-</span> o<span class="token punctuation">.</span>s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h1><p>C++中1s计算次数为10^7 ~ 10^8次</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202210292016484.png"></p><p>int 4Byte</p><p>char 1Byte</p><p>double,long long 8Byte</p><p>64MB = 2 ^ 26 Byte ，因此最大可以开2^24个int，即1600_0000</p>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（五）动态规划</title>
      <link href="/2023/04115211.html"/>
      <url>/2023/04115211.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础课"><a href="#基础课" class="headerlink" title="基础课"></a>基础课</h1><h2 id="DP问题总思想"><a href="#DP问题总思想" class="headerlink" title="DP问题总思想"></a>DP问题总思想</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111641001.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">for 物品    for 体积        for 决策<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>我们有一个背包容量是V，有N件物品，每个物品的占用空间是Vi，每个物体的权重（价值）是Wi</p><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111641305.png"></p><p>每个物品最多只用一次</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int v[N],w[N];int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            &#123;                f[i][j] &#x3D; f[i-1][j];&#x2F;&#x2F;不包含i时的状态转移                if(j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i-1][j-v[i]]+w[i]);&#x2F;&#x2F;当j大于v[i]时，说明能装下，则是包含i的状态转移，这里可以看成先整个去掉i，再加上i            &#125;                cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一维方法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N];int v[N],w[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; m ; j &gt;&#x3D; v[i] ; j -- )        &#123;            f[j] &#x3D; max(f[j], f[j-v[i]] + w[i]);            &#x2F;&#x2F;若仍为j++形式，则f[j-v[i]]与f[i][j-v[i]]相同，而这是不对的        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111642351.png"></p><p>每个物品有无限个</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N][N];int v[N],w[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )        &#123;            for(int k &#x3D; 0 ; k * v[i] &lt;&#x3D; j ; k ++ )            &#123;                f[i][j] &#x3D; max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">*</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> k <span class="token operator">*</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> k <span class="token operator">*</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111642536.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N][N];int v[N],w[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )        &#123;            f[i][j] &#x3D; f[i-1][j];            if(j&gt;&#x3D;v[i]) f[i][j] &#x3D; max(f[i][j],f[i][j-v[i]]+w[i]);        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一维优化</p><p><strong>当空间优化到1维时，只有完全背包问题的体积是从小到大的</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N];int v[N],w[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; v[i] ; j &lt;&#x3D; m ; j ++ )        &#123;            f[j] &#x3D; max(f[j], f[j-v[i]] + w[i]);        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token operator">-</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>每个物品的数量为Si</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111642224.png"></p><p><code>f[i][j] = max(f[i - 1][j - v[i] * k] + w[i] * k)</code></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110;int n,m;int v[N],w[N],s[N];int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )        &#123;            for(int k &#x3D; 0 ; k &lt;&#x3D; s[i] &amp;&amp; k*v[i] &lt;&#x3D; j ; k ++ )            &#123;                f[i][j] &#x3D; max(f[i][j], f[i-1][j-k*v[i]]+k*w[i]);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">*</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> k <span class="token operator">*</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> k<span class="token operator">*</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用二进制进行优化，将NVS时间复杂度优化为NVlogS</p><p>如S=200，可拆分成1,2,4,8，…，64,73（73是因为1加到64为127，因此不能再取128）</p><p>这样就转化为01背包问题</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 25000; &#x2F;&#x2F; 2000 * log2000int n,m;int v[N],w[N],s[N];int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    int cnt &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ )    &#123;        int a,b,s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        int k &#x3D; 1;        while(k&lt;&#x3D;s)        &#123;            cnt ++ ;            v[cnt] &#x3D; a * k;            w[cnt] &#x3D; b * k;            s -&#x3D; k;            k *&#x3D; 2;        &#125;        if(s &gt; 0)        &#123;            cnt ++;            v[cnt] &#x3D; a * s;            w[cnt] &#x3D; b * s;        &#125;    &#125;        n &#x3D; cnt ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; m ; j &gt;&#x3D; v[i] ; j -- )        &#123;            f[j] &#x3D; max(f[j] , f[j-v[i]] + w[i]);        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">25000</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> s<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;=</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> a <span class="token operator">*</span> k<span class="token punctuation">;</span>w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> b <span class="token operator">*</span> k<span class="token punctuation">;</span>s <span class="token operator">-=</span> k<span class="token punctuation">;</span>k <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>v<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> a <span class="token operator">*</span> s<span class="token punctuation">;</span>w<span class="token punctuation">[</span>cnt<span class="token punctuation">]</span> <span class="token operator">=</span> b <span class="token operator">*</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>n <span class="token operator">=</span> cnt <span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分组背包"><a href="#分组背包" class="headerlink" title="分组背包"></a>分组背包</h3><p>物品会分组，每个组里面只能选一个物品</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111642972.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110;int n,m;int v[N][N], w[N][N], s[N];int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        cin &gt;&gt; s[i];        for(int j &#x3D; 0 ; j &lt; s[i] ; j ++ )        &#123;            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        &#125;    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; m ; j &gt;&#x3D; 0 ; j -- )        &#123;            for(int k &#x3D; 0 ; k &lt; s[i] ; k ++ ) &#x2F;&#x2F;枚举从第i个组里选哪个            &#123;                if(v[i][k] &lt;&#x3D; j) f[j] &#x3D; max(f[j],f[j-v[i][k]] + w[i][k]);            &#125;        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> v<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> m<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> j<span class="token punctuation">)</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j <span class="token operator">-</span> v<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643309.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 510, INF &#x3D; 1e9;int n,m;int f[N][N]; &#x2F;&#x2F;存储状态int a[N][N]; &#x2F;&#x2F;存储三角形中的每个点int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )     &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; i ; j ++ )        &#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;        for(int i &#x3D; 0 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 0 ; j &lt;&#x3D; i + 1 ; j ++ )        &#123;            f[i][j] &#x3D; -INF;        &#125;    &#125;        f[1][1] &#x3D; a[1][1];    for(int i &#x3D; 2 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; i ; j ++ )        &#123;            f[i][j] &#x3D; max(f[i-1][j-1] , f[i-1][j]) + a[i][j];        &#125;    &#125;    int res &#x3D; -INF;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) res &#x3D; max(res,f[n][i]);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span>INF<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span>INF<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a>最长上升子序列</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643604.png"></p><p>dp问题的时间复杂度：状态数量*计算每个状态需要的时间</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n;int a[N];int f[N];int main()&#123;    cin &gt;&gt; n ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        f[i] &#x3D; 1; &#x2F;&#x2F;最坏的情况下也有它本身一个数        for(int j &#x3D; 1 ; j &lt; i ; j ++ )        &#123;            if(a[j] &lt; a[i])            &#123;                f[i] &#x3D; max(f[i], f[j] + 1);            &#125;        &#125;    &#125;    int res &#x3D; 0;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) res &#x3D; max(res, f[i]);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>存储最长子序列</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n;int a[N];int f[N];int g[N]; &#x2F;&#x2F;用于存储某个点的上一个点int main()&#123;    cin &gt;&gt; n ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        f[i] &#x3D; 1;         for(int j &#x3D; 1 ; j &lt; i ; j ++ )        &#123;            if(a[j] &lt; a[i])            &#123;                if(f[j] + 1 &gt; f[i])                &#123;                    f[i] &#x3D; f[j] + 1;                    g[i] &#x3D; j;                &#125;            &#125;        &#125;    &#125;    int k &#x3D; 1;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )     &#123;        if(f[k] &lt; f[i])        &#123;            k &#x3D; i;           &#125;    &#125;    cout &lt;&lt; f[k] &lt;&lt; endl;    for(int i &#x3D; 0 , len &#x3D; f[k] ; i &lt; len ; i ++ )    &#123;        cout &lt;&lt; a[k] &lt;&lt; &#39; &#39;;        k &#x3D; g[k];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> g<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    g<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>     f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        k <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> len <span class="token operator">=</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    k <span class="token operator">=</span> g<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长上升子序列II"><a href="#最长上升子序列II" class="headerlink" title="最长上升子序列II"></a>最长上升子序列II</h3><p>数据加强了，n2的时间复杂度太大</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;int n;int a[N];int q[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )  cin &gt;&gt; a[i] ;        int len &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        &#x2F;&#x2F;二分查找当前序列中小于当前数的最大值        int l &#x3D; 0 , r &#x3D; len;        while(l &lt; r)        &#123;            int mid &#x3D; l + r + 1 &gt;&gt; 1 ;            if(q[mid] &lt; a[i]) l &#x3D; mid;            else r &#x3D; mid - 1;        &#125;        len &#x3D; max(len, r + 1);        q[r + 1] &#x3D; a[i];    &#125;        cout &lt;&lt; len &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> len<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>q<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>l <span class="token operator">=</span> mid<span class="token punctuation">;</span><span class="token keyword">else</span>r <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>len <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>len<span class="token punctuation">,</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643441.png"></p><p>注意：四种集合中的元素包含重复的情况，但是因为求的是最大值，因此重复也无所谓</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n,m;char a[N],b[N];int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    cin &gt;&gt; a + 1 &gt;&gt; b + 1;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ;  j ++ )        &#123;            f[i][j] &#x3D; max(f[i-1][j],f[i][j-1]);            if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j],f[i-1][j-1] + 1);        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span> str <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chs <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>chs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>str <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>str <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><h3 id="石子合并"><a href="#石子合并" class="headerlink" title="石子合并"></a>石子合并</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643523.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643354.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 310;int n;int f[N][N];int s[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; s[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) s[i] +&#x3D; s[i-1];        for(int len &#x3D; 2; len &lt;&#x3D; n ; len ++ )    &#123;        for(int i &#x3D; 1 ; i + len - 1 &lt;&#x3D; n ; i ++ )        &#123;            int l &#x3D; i , r &#x3D; i + len - 1;            f[l][r] &#x3D; 1e8;            for(int k &#x3D; l ; k &lt; r ; k ++ )                f[l][r] &#x3D; min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l-1]);        &#125;    &#125;        cout &lt;&lt; f[1][n] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">310</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span> <span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> len <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l <span class="token operator">=</span> i<span class="token punctuation">,</span> r <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">1e8</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> l<span class="token punctuation">;</span>k <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> k <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="数位统计类dp"><a href="#数位统计类dp" class="headerlink" title="数位统计类dp"></a>数位统计类dp</h2><h3 id="计数问题"><a href="#计数问题" class="headerlink" title="计数问题"></a>计数问题</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111643505.png"></p><p>原题链接：<a href="https://www.acwing.com/problem/content/340/">https://www.acwing.com/problem/content/340/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D; 10;int get(vector&lt;int&gt; num,int l,int r) &#x2F;&#x2F;注：l是高位，r是低位&#123;    int res &#x3D; 0;    for(int i &#x3D; l ; i &gt;&#x3D; r ; i -- ) res &#x3D; res * 10 + num[i];    return res;&#125;int power10(int x) &#x2F;&#x2F;得到x^10&#123;    int res &#x3D; 1;    while(x--) res *&#x3D; 10;    return res;&#125;&#x2F;&#x2F;计算1~n上的x的出现位数int count(int n,int x) &#123;    if(!n) return 0;&#x2F;&#x2F;若n为0，则肯定为0        vector&lt;int&gt; num;&#x2F;&#x2F;存储n的每一位    while(n)    &#123;        num.push_back(n%10);        n&#x2F;&#x3D;10;    &#125;        n &#x3D; num.size();        int res &#x3D; 0;    &#x2F;&#x2F;若x为0，由于最高位不能是0，因此从倒数第二位n-2开始计数    for(int i &#x3D; n - 1 - !x ; i &gt;&#x3D; 0 ; i -- )    &#123;        if(i &lt; n - 1)        &#123;            res +&#x3D; get(num,n-1,i+1) * power10(i);            if(!x) res -&#x3D; power10(i); &#x2F;&#x2F;如果x为0时，x的前一位要从1开始记        &#125;                if(num[i] &#x3D;&#x3D; x) res +&#x3D; get(num,i-1,0) + 1;        else if(num[i] &gt; x) res +&#x3D; power10(i);    &#125;        return res;&#125;int main()&#123;    int a,b;    while(cin &gt;&gt; a &gt;&gt; b,a) &#x2F;&#x2F;a的意思是判断终止条件    &#123;        if(a &gt; b) swap(a,b);                for(int i &#x3D; 0 ; i &lt;&#x3D; 9 ; i ++ )        &#123;            cout &lt;&lt; count(b,i) - count(a-1, i) &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304041613402.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">*</span> i <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> k <span class="token operator">*</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%=</span> <span class="token class-name">M</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304041645480.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span> <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token class-name">M</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            res <span class="token operator">=</span> <span class="token punctuation">(</span>res <span class="token operator">+</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token class-name">M</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="状态压缩DP"><a href="#状态压缩DP" class="headerlink" title="状态压缩DP"></a>状态压缩DP</h2><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title="蒙德里安的梦想"></a>蒙德里安的梦想</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111644295.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;typedef long long ll;const int N &#x3D; 12 , M &#x3D; 1 &lt;&lt; N;ll f[N][M];bool st[M]; &#x2F;&#x2F; 存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。vector&lt;int&gt; state[M];&#x2F;&#x2F;二维数组记录合法的状态int n,m;int main()&#123;    while(cin &gt;&gt; n &gt;&gt; m , n || m) &#x2F;&#x2F;读入n和m，并且不是两个0即合法输入就继续读入    &#123;        &#x2F;&#x2F;第一部分：预处理1        &#x2F;&#x2F;枚举所有可能状态，先预处理每列不能有奇数个连续的0        for(int i &#x3D; 0 ; i &lt; (1 &lt;&lt; n) ; i ++ )        &#123;            int cnt &#x3D; 0;&#x2F;&#x2F;记录连续的0的个数            bool isValid &#x3D; true; &#x2F;&#x2F; 某种状态没有奇数个连续的0则标记为true            for(int j &#x3D; 0 ; j &lt; n ; j ++ ) &#x2F;&#x2F; 遍历这一列，从上到下            &#123;                 if((i &gt;&gt; j) &amp; 1)                &#123;                    &#x2F;&#x2F; i &gt;&gt; j位运算，表示i的二进制数的第j位，&amp;1表示该位是否为1                    if(cnt &amp; 1)                    &#123;                        &#x2F;&#x2F;这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法                        isValid &#x3D; false; break;                    &#125;                                        cnt &#x3D; 0; &#x2F;&#x2F; 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。                    &#x2F;&#x2F;其实清不清零没有影响                &#125;                else cnt ++ ;&#x2F;&#x2F;否则的话该位还是0，则统计连续0的计数器++。            &#125;            if(cnt &amp; 1) isValid &#x3D; false; &#x2F;&#x2F;该列最下面的那一段判断一下连续的0的个数            st[i] &#x3D; isValid;&#x2F;&#x2F;状态i是否有奇数个连续的0的情况,输入到数组st中        &#125;                &#x2F;&#x2F;第二部分：预处理2        &#x2F;&#x2F; 经过上面每种状态 连续0的判断，已经筛掉一些状态。        &#x2F;&#x2F;下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突        for(int j &#x3D; 0 ; j &lt; (1 &lt;&lt; n) ; j ++) &#x2F;&#x2F;枚举i列所有状态        &#123;            state[j].clear(); &#x2F;&#x2F;清空上次操作遗留的状态，防止影响本次状态。            for(int k &#x3D; 0 ; k &lt; (1 &lt;&lt; n) ; k ++ )&#123; &#x2F;&#x2F; 枚举i-1列所有状态                if((j &amp; k) &#x3D;&#x3D; 0 &amp;&amp; st[j|k])                 &#x2F;&#x2F;(j &amp; k) &#x3D;&#x3D; 0指的是i-1列的同一行不能既有i-2列插过来的，同时又有本身自己的1                &#x2F;&#x2F;j|k指的是i-1列到底有几个1，st[j|k]是看当前的状态是否合法                    state[j].push_back(k);            &#125;        &#125;                &#x2F;&#x2F;第三部分：dp开始        memset(f, 0, sizeof f);          &#x2F;&#x2F;全部初始化为0，因为是连续读入，这里是一个清空操作。        &#x2F;&#x2F;类似上面的state[j].clear()                        f[0][0] &#x3D; 1; &#x2F;&#x2F;初始状态由于没有从-1列插入该列状态，因此第0列只有竖着摆这一种状态        for(int i &#x3D; 1 ;i &lt;&#x3D; m ; i ++ ) &#x2F;&#x2F;枚举每一列        &#123;            for(int j &#x3D; 0 ; j &lt; (1 &lt;&lt; n) ; j++ ) &#x2F;&#x2F;枚举每种状态            &#123;                for(auto k : state[j]) &#x2F;&#x2F; 遍历上面已经预处理过的i-1列可转移的状态                    f[i][j] +&#x3D; f[i-1][k]; &#x2F;&#x2F; 当前列的方案数就等于之前的第i-1列所有状态k的累加。            &#125;        &#125;                &#x2F;&#x2F;f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。        &#x2F;&#x2F;即整个棋盘处理完的方案数        cout &lt;&lt; f[m][0] &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title="最短Hamilton路径"></a>最短Hamilton路径</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111644300.png"></p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 20 , M &#x3D; 1 &lt;&lt; N; &#x2F;&#x2F;M是状态压缩的二进制路径int n;int w[N][N];int f[M][N];&#x2F;&#x2F;所有从0走到j，走过的所有点是i的所有路径int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )        &#123;            cin &gt;&gt; w[i][j];        &#125;    &#125;        memset(f, 0x3f , sizeof f);    f[1][0] &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; 1 &lt;&lt; n ; i ++ )    &#123;        for(int j &#x3D; 0 ; j  &lt; n ; j ++ )        &#123;            if( i &gt;&gt; j &amp; 1 ) &#x2F;&#x2F;i要包含j的状态才有意义            &#123;                for(int k &#x3D; 0 ; k &lt; n ; k ++ )                &#123;                    if((i-(1&lt;&lt;j)) &gt;&gt; k &amp; 1) &#x2F;&#x2F;若要从k转移到j点，必须在删除j后，包含k点                    &#123;                        f[i][j] &#x3D; min(f[i][j],f[i-(1&lt;&lt;j)][k] + w[k][j]);                    &#125;                &#125;            &#125;        &#125;    &#125;    cout &lt;&lt; f[(1&lt;&lt;n) - 1][n-1] &lt;&lt; endl;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">M</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">M</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>f<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> k <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树形dp"><a href="#树形dp" class="headerlink" title="树形dp"></a>树形dp</h2><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title="没有上司的舞会"></a>没有上司的舞会</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111644519.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111645971.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 6010;int n;int happy[N];int h[N], e[N], ne[N], idx;int f[N][2];bool has_father[N];void add(int a,int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dfs(int u)&#123;    f[u][1] &#x3D; happy[u];    for(int i &#x3D; h[u] ; i !&#x3D; -1 ; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        dfs(j);                f[u][0] +&#x3D; max(f[j][0], f[j][1]); &#x2F;&#x2F;不选u这个点的方案        f[u][1] +&#x3D; f[j][0]; &#x2F;&#x2F; 选u这个点的方案    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; happy[i];    memset(h, -1, sizeof h);    for(int i &#x3D; 0 ; i &lt; n - 1 ; i ++ )    &#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b ;        has_father[a] &#x3D; true;        add(b,a);    &#125;        int root &#x3D; 1;    while(has_father[root]) root ++ ; &#x2F;&#x2F;找到根节点        dfs(root);        cout &lt;&lt; max(f[root][0],f[root][1]) &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">6010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> happy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> has_father<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> happy<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>happy<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>has_father<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> root <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>has_father<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>root<span class="token operator">++</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="滑雪"><a href="#滑雪" class="headerlink" title="滑雪"></a>滑雪</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111645412.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 310;int n,m;int h[N][N];int f[N][N];int dx[4] &#x3D; &#123;-1,0,1,0&#125; , dy[4] &#x3D; &#123;0,1,0,-1&#125;;int dp(int x,int y)&#123;    int &amp;v &#x3D; f[x][y]; &#x2F;&#x2F;指的是v是个引用，它就代替了f[x][y]    if(v !&#x3D; -1) return v; &#x2F;&#x2F;算过了则直接返回        v &#x3D; 1;    for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )    &#123;        int a &#x3D; x + dx[i], b &#x3D; y + dy[i];        if(a &gt;&#x3D; 1 &amp;&amp; a &lt;&#x3D; n &amp;&amp; b &gt;&#x3D; 1 &amp;&amp; b &lt;&#x3D; m &amp;&amp; h[a][b] &lt; h[x][y] )            v &#x3D; max(v,dp(a,b)+1);    &#125;        return v;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            cin &gt;&gt; h[i][j];                memset(f, -1, sizeof f);        int res &#x3D; 0;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            res &#x3D; max(res, dp(i,j));                cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">310</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> f<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> x <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> b <span class="token operator">=</span> y <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">&lt;=</span> n <span class="token operator">&amp;&amp;</span> b <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> b <span class="token operator">&lt;=</span> m <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">&lt;</span> h<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> f<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>h<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> <span class="token function">dp</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="提高课"><a href="#提高课" class="headerlink" title="提高课"></a>提高课</h1><h2 id="数字三角形模型"><a href="#数字三角形模型" class="headerlink" title="数字三角形模型"></a>数字三角形模型</h2><p><a href="https://www.acwing.com/activity/content/problem/content/1256/">摘花生</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110;int n,m;int f[N][N];int w[N][N];int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)    &#123;        cin &gt;&gt; n &gt;&gt; m;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )            for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )                cin &gt;&gt; w[i][j];                for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )            for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )                f[i][j] &#x3D; max(f[i-1][j], f[i][j-1]) + w[i][j];                        cout &lt;&lt; f[n][m] &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1020/">最低通行费</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110, INF &#x3D; 1e9;int n;int w[N][N];int f[N][N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )            cin &gt;&gt; w[i][j];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )            if(i &#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D; 1) f[i][j] &#x3D; w[i][j];            else             &#123;                f[i][j] &#x3D; INF;                if(i &gt; 1) f[i][j] &#x3D; min(f[i][j],f[i-1][j] + w[i][j]);                if(j &gt; 1) f[i][j] &#x3D; min(f[i][j],f[i][j-1] + w[i][j]);            &#125;    cout &lt;&lt; f[n][n] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1029/">方格取数</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211022200728.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 15;int n;int w[N][N];int f[N * 2][N][N];int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    int a, b, c;    while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, a || b || c) w[a][b] &#x3D; c;    for (int k &#x3D; 2; k &lt;&#x3D; n + n; k ++ )        for (int i1 &#x3D; 1; i1 &lt;&#x3D; n; i1 ++ )            for (int i2 &#x3D; 1; i2 &lt;&#x3D; n; i2 ++ )            &#123;                int j1 &#x3D; k - i1, j2 &#x3D; k - i2;                if (j1 &gt;&#x3D; 1 &amp;&amp; j1 &lt;&#x3D; n &amp;&amp; j2 &gt;&#x3D; 1 &amp;&amp; j2 &lt;&#x3D; n)                &#123;                    int t &#x3D; w[i1][j1];                    if (i1 !&#x3D; i2) t +&#x3D; w[i2][j2];                    int &amp;x &#x3D; f[k][i1][i2];                    x &#x3D; max(x, f[k - 1][i1 - 1][i2 - 1] + t);                    x &#x3D; max(x, f[k - 1][i1 - 1][i2] + t);                    x &#x3D; max(x, f[k - 1][i1][i2 - 1] + t);                    x &#x3D; max(x, f[k - 1][i1][i2] + t);                &#125;            &#125;    printf(&quot;%d\n&quot;, f[n + n][n][n]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最长上升子序列模型"><a href="#最长上升子序列模型" class="headerlink" title="最长上升子序列模型"></a>最长上升子序列模型</h2><p><a href="https://www.acwing.com/activity/content/code/content/112799/">怪盗基德的滑翔翼</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110;int n;int f[N];int a[N];&#x2F;*正反走各走一遍最长上升子序列*&#x2F;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)    &#123;        cin &gt;&gt; n;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];                int res &#x3D; 0;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        &#123;            f[i] &#x3D; 1;            for(int j &#x3D; 1 ; j &lt; i ; j ++ )            &#123;                if(a[i] &gt; a[j])                    f[i] &#x3D; max(f[i] , f[j] + 1);            &#125;            res &#x3D; max(res, f[i]);                    &#125;                for(int i &#x3D; n ; i ; i -- )        &#123;            f[i] &#x3D; 1;            for(int j &#x3D; n ; j &gt; i ; j -- )            &#123;                if(a[j] &lt; a[i])                    f[i] &#x3D; max(f[i] , f[j] + 1);            &#125;            res &#x3D; max(res, f[i]);                    &#125;        cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1016/">登山</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211032218275.png" alt="image-20221103221810191"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 1010;int n ;int a[N];int f[N],g[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];        for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        f[i] &#x3D; 1;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )        &#123;            if(a[j] &lt; a[i])                f[i] &#x3D; max(f[i], f[j] + 1);        &#125;    &#125;        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )    &#123;        g[i] &#x3D; 1;        for(int j &#x3D; n - 1; j &gt; i ; j -- )        &#123;            if(a[j] &lt; a[i])                g[i] &#x3D; max(g[i], g[j] + 1);        &#125;    &#125;        int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n  ; i ++ )    &#123;        res &#x3D; max(res , f[i] + g[i] - 1);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/activity/content/problem/content/1261/">合唱队形</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110;int n ;int a[N];int f[N],g[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];        for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        f[i] &#x3D; 1;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )        &#123;            if(a[j] &lt; a[i])                f[i] &#x3D; max(f[i], f[j] + 1);        &#125;    &#125;        for(int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )    &#123;        g[i] &#x3D; 1;        for(int j &#x3D; n - 1; j &gt; i ; j -- )        &#123;            if(a[j] &lt; a[i])                g[i] &#x3D; max(g[i], g[j] + 1);        &#125;    &#125;        int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n  ; i ++ )    &#123;        res &#x3D; max(res , f[i] + g[i] - 1);    &#125;        cout &lt;&lt; n - res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1014/">友好城市</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211032159608.png" alt="image-20221103215916329"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 5010;typedef  pair&lt;int,int&gt; PII;int n;int f[N];PII a[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i].first &gt;&gt; a[i].second;        sort(a,a+n);    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        f[i] &#x3D; 1;        for(int j &#x3D; 0 ; j &lt; i ; j ++ )        &#123;            if(a[j].second &lt; a[i].second)            &#123;                f[i] &#x3D; max(f[i], f[j] + 1);            &#125;        &#125;        res &#x3D; max(res, f[i]);    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1018/">最大上升子序列和</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n;int a[N];int f[N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        f[i] &#x3D; a[i];        for(int j &#x3D; 0 ; j &lt; i ; j ++ )        &#123;            if(a[j] &lt; a[i])            f[i] &#x3D; max(f[i], f[j] + a[i]);        &#125;                res &#x3D; max(res, f[i]);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/video/363/">拦截导弹</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211041708496.png" alt="image-20221104170817258"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n;int q[N];int f[N], g[N];int main()&#123;    while(cin &gt;&gt; q[n]) n ++ ;        int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        f[i] &#x3D; 1;        for(int j &#x3D; 0 ; j &lt; i ; j ++ )        &#123;            if(q[j] &gt;&#x3D; q[i])                f[i] &#x3D; max(f[i], f[j] + 1);        &#125;        res &#x3D; max(res, f[i]);    &#125;    cout &lt;&lt; res &lt;&lt; endl;        int cnt &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int k &#x3D; 0 ;        while(k &lt; cnt &amp;&amp; g[k] &lt; q[i]) k ++ ;        g[k] &#x3D; q[i];        if(k &gt;&#x3D; cnt) cnt ++ ;    &#125;    cout &lt;&lt; cnt &lt;&lt; endl;    return 0;        &#x2F;*        组一：389 207 155                65        组二：           300 299 170 158 &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/189/">导弹防御系统</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211041730638.png" alt="image-20221104173030186"></p><p>1、用全局最优解并不断更新的方式得到最小值</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 55;int n;int h[N];int up[N],down[N]; &#x2F;&#x2F;up[N]存储的是每个上升子序列的结尾数，其本身是递减的，down[N]同理int res;&#x2F;&#x2F;dfs参数：u为枚举的当前数，su为上升子序列个数，sd为下降子序列个数void dfs(int u, int su, int sd)&#123;    if(su + sd &gt;&#x3D; res ) return ;    if(u &#x3D;&#x3D; n)    &#123;        res &#x3D; min(res , su + sd);        return;    &#125;        int k &#x3D; 0;    while(k &lt; su &amp;&amp; up[k] &gt;&#x3D; h[u]) k ++ ;    if(k &lt; su)    &#123;        int t &#x3D; up[k];        up[k] &#x3D; h[u];        dfs(u+1, su, sd);        up[k] &#x3D; t;    &#125;    else     &#123;        up[k] &#x3D; h[u];        dfs(u+1, su+1, sd);    &#125;        k &#x3D; 0;    while(k &lt; sd &amp;&amp; down[k] &lt;&#x3D; h[u]) k ++ ;    if(k &lt; sd)    &#123;        int t &#x3D; down[k];        down[k] &#x3D; h[u];        dfs(u+1, su, sd);        down[k] &#x3D; t;    &#125;    else     &#123;        down[k] &#x3D; h[u];        dfs(u+1, su, sd+1);    &#125;&#125;int main()&#123;    while(cin &gt;&gt; n , n)    &#123;        for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; h[i];                res &#x3D; n;        dfs(0,0,0);        cout &lt;&lt; res &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2、迭代加深的方式得到最小值（有点没懂）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 60;int n;int h[N];int up[N], down[N];bool dfs(int depth, int u, int su, int sd)&#123;    if (su + sd &gt; depth) return false;    if (u &#x3D;&#x3D; n) return true;    &#x2F;&#x2F; 枚举放到上升子序列中的情况    bool flag &#x3D; false;    for (int i &#x3D; 1; i &lt;&#x3D; su; i ++ )        if (up[i] &lt; h[u])        &#123;            int t &#x3D; up[i];            up[i] &#x3D; h[u];            if (dfs(depth, u + 1, su, sd)) return true;            up[i] &#x3D; t;            flag &#x3D; true;            break;        &#125;    if (!flag)    &#123;        up[su + 1] &#x3D; h[u];        if (dfs(depth, u + 1, su + 1, sd)) return true;    &#125;    &#x2F;&#x2F; 枚举放到下降子序列中的情况    flag &#x3D; false;    for (int i &#x3D; 1; i &lt;&#x3D; sd; i ++ )        if (down[i] &gt; h[u])        &#123;            int t &#x3D; down[i];            down[i] &#x3D; h[u];            if (dfs(depth, u + 1, su, sd)) return true;            down[i] &#x3D; t;            flag &#x3D; true;            break;        &#125;    if (!flag)    &#123;        down[sd + 1] &#x3D; h[u];        if (dfs(depth, u + 1, su, sd + 1)) return true;    &#125;    return false;&#125;int main()&#123;    while (cin &gt;&gt; n, n)    &#123;        for (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; h[i];        int depth &#x3D; 0;        while (!dfs(depth, 0, 0, 0)) depth ++ ;        cout &lt;&lt; depth &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/activity/content/problem/content/1266/">最长公共上升子序列</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211041740762.png" alt="image-20221104174053020"></p><p>不加优化的n^3做法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 3010;int n;int a[N], b[N];int f[N][N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; b[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            f[i][j] &#x3D; f[i-1][j];            if(a[i] &#x3D;&#x3D; b[j])            &#123;                f[i][j] &#x3D; max(f[i][j], 1);                for(int k &#x3D; 1 ; k &lt; j ; k ++ )                &#123;                    if(b[k] &lt; b[j])                        f[i][j] &#x3D; max(f[i][j],f[i-1][k] + 1);                &#125;            &#125;        &#125;    &#125;    int res &#x3D; 0;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) res &#x3D; max(res, f[n][i]);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加优化的做法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 3010;int n;int a[N], b[N];int f[N][N];int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; b[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        int maxv &#x3D; 1;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            f[i][j] &#x3D; f[i-1][j];            if(a[i] &#x3D;&#x3D; b[j]) f[i][j] &#x3D; max(f[i][j], maxv);            if(b[j] &lt; a[i]) maxv &#x3D; max(maxv, f[i][j] + 1);        &#125;    &#125;    int res &#x3D; 0;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) res &#x3D; max(res, f[n][i]);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="背包模型"><a href="#背包模型" class="headerlink" title="背包模型"></a>背包模型</h2><h3 id="多重背包-1"><a href="#多重背包-1" class="headerlink" title="多重背包"></a>多重背包</h3><p><a href="https://www.acwing.com/problem/content/1021/">庆功会</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 6010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int v,w,s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        for(int j &#x3D; m ; j &gt;&#x3D; v ; j -- )        &#123;            for(int k &#x3D; 0 ; k &lt;&#x3D; s &amp;&amp; k * v &lt;&#x3D; j ; k ++ )            &#123;                f[j] &#x3D; max(f[j], f[j-k*v] + k*w);            &#125;        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="多重背包III"><a href="#多重背包III" class="headerlink" title="多重背包III"></a>多重背包III</h4><p><a href="https://www.acwing.com/problem/content/6/">多重背包问题III</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211062204505.png" alt="image-20221106220432294"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 20010;int n,m;int f[N],g[N],q[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m; &#x2F;&#x2F;物品、背包    for(int i &#x3D; 0 ; i &lt; n ; i ++)    &#123;        int v,w,s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        memcpy(g , f ,sizeof f);        for(int j &#x3D; 0 ; j &lt; v ; j ++ ) &#x2F;&#x2F;枚举余数r        &#123;            int hh &#x3D; 0 , tt &#x3D; -1;            for(int k &#x3D; j ; k &lt;&#x3D; m ; k +&#x3D; v) &#x2F;&#x2F; 枚举 r+?*v            &#123;                &#x2F;&#x2F; 去掉超出滑动窗口范围的元素                if (hh &lt;&#x3D; tt &amp;&amp; q[hh] &lt; k - s*v) hh ++;                                &#x2F;&#x2F;去掉单调队列末尾比当前元素小的, 根据两个元素相对j的位置算偏移量                &#x2F;&#x2F;同一窗口内, j, j+v, j+2v后面加的w数量依次递减，所以距离j越远，相对减去的w倍数越大                while (hh &lt;&#x3D; tt &amp;&amp; g[q[tt]] - (q[tt] - j) &#x2F; v * w &lt;&#x3D; g[k] - (k - j) &#x2F; v * w) tt --;                        q[ ++ tt] &#x3D; k;  &#x2F;&#x2F; 把当前元素下标插入单调队列                        &#x2F;&#x2F;计算f[k], max左边为不选,右边为单调队列最大值,加上相对k的偏移量                if (hh &lt;&#x3D; tt) f[k] &#x3D; max(f[k], g[q[hh]] + (k - q[hh]) &#x2F; v * w);              &#125;        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="01背包-1"><a href="#01背包-1" class="headerlink" title="01背包"></a>01背包</h3><p> <a href="https://www.acwing.com/problem/content/425/">采药</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) &#x2F;&#x2F;遍历物品    &#123;        int v,w;        cin &gt;&gt; v &gt;&gt; w;        for(int j &#x3D; m ; j &gt;&#x3D; v ; j -- ) &#x2F;&#x2F;遍历背包        &#123;            f[j] &#x3D; max(f[j], f[j-v] + w);        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1026/">装箱问题</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 20010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ;  i ++ )    &#123;        int v;        cin &gt;&gt; v;        for(int j &#x3D; m ; j &gt;&#x3D; v ; j -- )        &#123;            f[j] &#x3D; max(f[j], f[j-v] + v);        &#125;    &#125;    cout &lt;&lt; m - f[m] &lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/428/">开心的金明</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 30010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        int v, q;        cin &gt;&gt; v &gt;&gt; q;        q *&#x3D; v;        for(int j &#x3D; m ; j &gt;&#x3D; v ; j -- )        &#123;            f[j] &#x3D; max(f[j], f[j-v] + q);        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="与贪心结合"><a href="#与贪心结合" class="headerlink" title="与贪心结合"></a>与贪心结合</h4><p><a href="https://www.acwing.com/problem/content/736/">能量石</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211100029212.png" alt="image-20221110002959050"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 10010;int n;struct Stone&#123;    int s, e, l;    bool operator &lt;(const Stone &amp;W) const     &#123;        return s * W.l &lt; l * W.s ;    &#125;&#125;stone[N];int f[N];int main()&#123;    int T;    cin &gt;&gt; T;    for(int C &#x3D; 1; C &lt;&#x3D; T ; C ++ )    &#123;        int m &#x3D; 0;        cin &gt;&gt; n;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )        &#123;            int s,e,l;            cin &gt;&gt; s &gt;&gt; e &gt;&gt; l;            stone[i] &#x3D; &#123;s,e,l&#125;;            m +&#x3D; s;        &#125;                sort(stone,stone + n);                memset(f, -0x3f ,sizeof f);        f[0] &#x3D; 0;                for(int i &#x3D; 0 ; i &lt; n ; i ++)        &#123;            int s &#x3D; stone[i].s, e &#x3D; stone[i].e, l &#x3D; stone[i].l;            for(int j &#x3D; m ; j &gt;&#x3D; s ; j -- )            &#123;                f[j] &#x3D; max(f[j], f[j-s] + e - (j - s) * l);             &#125;        &#125;                int res &#x3D; 0;        for(int i &#x3D; 0 ; i &lt;&#x3D; m ;i ++ ) res &#x3D; max(res, f[i]);        printf(&quot;Case #%d: %d\n&quot;, C ,res);    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求方案数"><a href="#求方案数" class="headerlink" title="求方案数"></a>求方案数</h4><p><a href="https://www.acwing.com/problem/content/11/">背包问题求方案数</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211092312892.png" alt="image-20221109231215618"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 1010, mod &#x3D; 1e9 + 7;int n,m;int f[N]; &#x2F;&#x2F;体积为j的背包价值最大int g[N]; &#x2F;&#x2F;f[j]取最大值的时候的方案数int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(f, -0x3f, sizeof f);    f[0] &#x3D; 0;    g[0] &#x3D; 1;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int v,w;        cin &gt;&gt; v &gt;&gt; w;        for(int j &#x3D; m ; j &gt;&#x3D; v ; j -- )        &#123;            int maxv &#x3D; max(f[j], f[j - v] + w);            int cnt  &#x3D; 0 ;            if(maxv &#x3D;&#x3D; f[j]) cnt +&#x3D; g[j];            if(maxv &#x3D;&#x3D; f[j-v]+w) cnt +&#x3D; g[j - v];            g[j] &#x3D; cnt % mod;            f[j] &#x3D; maxv;        &#125;    &#125;        int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt;&#x3D; m ; i ++ ) res &#x3D; max(res, f[i]);    int cnt &#x3D; 0 ;    for(int i &#x3D; 0 ; i &lt;&#x3D; m ; i ++ )        if(res &#x3D;&#x3D; f[i]) &#x2F;&#x2F;每种最优选法的方案数都应包含在内            cnt &#x3D; (cnt + g[i]) % mod;                cout &lt;&lt; cnt &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/280/">数字组合</a></p><p>  <img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211071744120.png" alt="image-20221107174432609"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 10010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    f[0] &#x3D; 1;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int a;        cin &gt;&gt; a;        for(int j &#x3D; m ; j &gt;&#x3D; a ; j -- )        &#123;            f[j] +&#x3D; f[j-a];        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1023/">货币系统1021</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 3010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    f[0] &#x3D; 1;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int v;        cin &gt;&gt; v;        for(int j &#x3D; v ; j &lt;&#x3D; m ; j ++ )        &#123;            f[j] +&#x3D; f[j - v];        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/534/">货币系统532</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110, M &#x3D; 25010;int n;int a[N];int f[M];int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)    &#123;        int n;        cin &gt;&gt; n;        for(int i &#x3D; 0 ;i &lt; n; i ++) cin &gt;&gt; a[i];        sort(a, a+n);                int m &#x3D; a[n-1];        memset(f, 0, sizeof f);        f[0] &#x3D; 1;                int res &#x3D; 0;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )        &#123;            if(!f[a[i]]) res ++ ; &#x2F;&#x2F;当方案数为0的时候，说明不能由前面的面值组成            for(int j &#x3D; a[i]; j &lt;&#x3D; m ; j ++ )                f[j] +&#x3D; f[j - a[i]];        &#125;                cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="求具体方案"><a href="#求具体方案" class="headerlink" title="求具体方案"></a>求具体方案</h4><p><a href="https://www.acwing.com/problem/content/12/">背包问题求具体方案</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211082114030.png" alt="image-20221108211423919"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n, m;int v[N], w[N];int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) cin &gt;&gt; v[i] &gt;&gt; w[i];    for (int i &#x3D; n; i &gt;&#x3D; 1; i -- )        for (int j &#x3D; 0; j &lt;&#x3D; m; j ++ )        &#123;            f[i][j] &#x3D; f[i + 1][j];            if (j &gt;&#x3D; v[i]) f[i][j] &#x3D; max(f[i][j], f[i + 1][j - v[i]] + w[i]);        &#125;    int j &#x3D; m;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        if (j &gt;&#x3D; v[i] &amp;&amp; f[i][j] &#x3D;&#x3D; f[i + 1][j - v[i]] + w[i])        &#123;            cout &lt;&lt; i &lt;&lt; &#39; &#39;;            j -&#x3D; v[i];        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二维费用背包"><a href="#二维费用背包" class="headerlink" title="二维费用背包"></a>二维费用背包</h3><p><a href="https://www.acwing.com/problem/content/8/">二维费用的背包问题</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211072022211.png" alt="image-20221107202225014"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110;int n,M,V;int f[N][N];int main()&#123;    cin &gt;&gt; n &gt;&gt; V &gt;&gt; M;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int v,m,w;        cin &gt;&gt; v &gt;&gt; m &gt;&gt; w;        for(int j &#x3D; V ; j &gt;&#x3D; v ; j -- )        &#123;            for(int k &#x3D; M ; k &gt;&#x3D; m ; k -- )            &#123;                f[j][k] &#x3D; max(f[j][k], f[j-v][k-m] + w);            &#125;        &#125;    &#125;    cout &lt;&lt; f[V][M] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1024/">宠物小精灵之收服</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211062153495.png" alt="image-20221106215339700"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010, M &#x3D; 510;int n,V1,V2;int f[N][M];int main()&#123;    cin &gt;&gt; V1 &gt;&gt; V2 &gt;&gt; n; &#x2F;&#x2F; 背包1 、背包2 、物品    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int v1, v2;        cin &gt;&gt; v1 &gt;&gt; v2;        for(int j &#x3D; V1 ; j &gt;&#x3D; v1 ; j -- )        &#123;            for(int k &#x3D; V2 - 1 ; k &gt;&#x3D; v2 ; k -- ) &#x2F;&#x2F;V2 - 1是因为体力不能为0            &#123;                f[j][k] &#x3D; max(f[j][k], f[j - v1][k - v2] + 1);            &#125;        &#125;    &#125;        cout &lt;&lt; f[V1][V2 - 1] &lt;&lt; &#39; &#39;;     int k &#x3D; V2 - 1;    while(k &gt; 0 &amp;&amp; f[V1][k-1] &#x3D;&#x3D; f[V1][V2-1]) k -- ;    cout &lt;&lt; V2 - k &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="完全背包-1"><a href="#完全背包-1" class="headerlink" title="完全背包"></a>完全背包</h3><h4 id="求方案数-1"><a href="#求方案数-1" class="headerlink" title="求方案数"></a>求方案数</h4><p><a href="https://www.acwing.com/problem/content/1025/">买书</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1010;int v[4] &#x3D; &#123;10,20,50,100&#125;;int m;int f[N];int main()&#123;    cin &gt;&gt; m;    f[0] &#x3D; 1;    for(int i &#x3D; 0 ; i &lt; 4 ;  i ++ )    &#123;        for(int j &#x3D; 0 ; j &lt;&#x3D; m ; j ++ )        &#123;            if(j&gt;&#x3D;v[i]) f[j] +&#x3D; f[j-v[i]];        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="特殊：至少"><a href="#特殊：至少" class="headerlink" title="特殊：至少"></a>特殊：至少</h4><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211082107303.png" alt="image-20221108210656031"><a href="https://www.acwing.com/problem/content/1022/">潜水员</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 22 , M &#x3D; 80;int n,m,K;int f[N][M];int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; K;    memset(f,0x3f,sizeof f);    f[0][0] &#x3D; 0;    while(K--)    &#123;        int v1, v2, w;        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;        for(int j &#x3D; n ; j &gt;&#x3D; 0 ; j -- )        &#123;            for(int k &#x3D; m ; k &gt;&#x3D; 0 ; k -- )            &#123;                f[j][k] &#x3D; min(f[j][k], f[max(0, j - v1)][max(0, k - v2)] + w);            &#125;        &#125;    &#125;    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="分组背包-1"><a href="#分组背包-1" class="headerlink" title="分组背包"></a>分组背包</h3><h4 id="求方案数-2"><a href="#求方案数-2" class="headerlink" title="求方案数"></a>求方案数</h4><p><a href="https://www.acwing.com/problem/content/1015/">机器分配</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211082143561.png" alt="image-20221108214305452"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 11 , M &#x3D; 16;int n,m;int w[N][M];int f[N][M];int way[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )             cin &gt;&gt; w[i][j] ;                            for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) &#x2F;&#x2F;遍历每组    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )        &#123;            for(int k &#x3D; 0 ; k &lt;&#x3D; j ; k ++ ) &#x2F;&#x2F;遍历每组设备数                f[i][j] &#x3D; max(f[i][j], f[i-1][j-k] + w[i][k]);        &#125;    &#125;        cout &lt;&lt; f[n][m] &lt;&lt; endl;        int j &#x3D; m;    for(int i &#x3D; n ; i ; i -- )    &#123;        for(int k &#x3D; 0 ; k &lt;&#x3D; j ; k ++ )        &#123;            if(f[i][j] &#x3D;&#x3D; f[i-1][j-k] + w[i][k])            &#123;                way[i] &#x3D; k;                j -&#x3D; k;                break; &#x2F;&#x2F;因为每个组（公司）只会有一种情况，所以直接break            &#125;        &#125;    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cout &lt;&lt; i &lt;&lt;  &#39; &#39; &lt;&lt; way[i] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h4><p><a href="https://www.acwing.com/problem/content/489/">金明的预算方案</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N &#x3D; 65, M &#x3D; 32010;typedef pair&lt;int,int&gt; PII;PII master[N]; &#x2F;&#x2F;主件vector&lt;PII&gt; servent[N]; &#x2F;&#x2F;附件int n,m;int f[M];int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        int v,p,q;        cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;        p*&#x3D;v; &#x2F;&#x2F;价格*重要度        if(!q) master[i] &#x3D; &#123;v,p&#125;;        else servent[q].push_back(&#123;v,p&#125;);    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) &#x2F;&#x2F;遍历物品    &#123;        for(int u &#x3D; m ; u &gt;&#x3D; 0 ; u -&#x3D; 10 ) &#x2F;&#x2F;遍历背包（金钱）        &#123;            &#x2F;&#x2F;制做分组背包问题某类里每一个可选择的单元————打包            &#x2F;&#x2F;for循环里的servent[i].size()筛选了只有主件会进入循环，附件不能进入            &#x2F;&#x2F;二进制枚举物品组内的所有打包单元的状态，共2的n次方种，用j表示每一种，j的第k位1&#x2F;0表示第k个附件选&#x2F;不选            for(int j &#x3D; 0 ; j &lt; 1 &lt;&lt; servent[i].size() ; j ++ )            &#123;                &#x2F;&#x2F;当前这个打包单元的体积是v， 价值是w ，下面这几行代码就是在计算v和w                int v &#x3D; master[i].first, w &#x3D; master[i].second; &#x2F;&#x2F; 主件必选                for(int k &#x3D; 0 ; k &lt; servent[i].size() ; k ++ ) &#x2F;&#x2F;枚举状态j的每一位                    if(j &gt;&gt; k &amp; 1) &#x2F;&#x2F;如果j的第k位是i，说明包含第k个组件                    &#123;                        v +&#x3D; servent[i][k].first;                        w +&#x3D; servent[i][k].second;                    &#125;                                    &#x2F;&#x2F;已经计算出v和w，做分组背包问题的状态计算                if(u &gt;&#x3D; v) f[u] &#x3D; max(f[u], f[u - v] + w);            &#125;        &#125;    &#125;    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="混合背包"><a href="#混合背包" class="headerlink" title="混合背包"></a>混合背包</h3><p><a href="https://www.acwing.com/problem/content/7/">混合背包问题</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 1010;int n,m;int f[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0  ; i &lt; n ; i ++ )    &#123;        int v, w, s;        cin &gt;&gt; v &gt;&gt; w &gt;&gt; s;        if(s &#x3D;&#x3D; 0) &#x2F;&#x2F;完全背包        &#123;            for(int j &#x3D; v ; j &lt;&#x3D; m ; j ++ ) f[j] &#x3D; max(f[j], f[j - v] + w);        &#125;        else         &#123;            if(s &#x3D;&#x3D; -1) s &#x3D; 1; &#x2F;&#x2F;将01背包看成多重背包            for(int k &#x3D; 1 ; k &lt;&#x3D; s ; k *&#x3D; 2)            &#123;                for(int j &#x3D; m; j &gt;&#x3D; k * v ; j -- )                    f[j] &#x3D; max(f[j], f[j - k * v] + k * w);                s -&#x3D; k;            &#125;            if(s)            &#123;                for(int j &#x3D; m ; j &gt;&#x3D; s * v ; j -- )                    f[j] &#x3D; max(f[j], f[j - s * v] + s * w);            &#125;        &#125;    &#125;        cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="有依赖的背包问题"><a href="#有依赖的背包问题" class="headerlink" title="有依赖的背包问题"></a>有依赖的背包问题</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211100027719.png" alt="image-20221110002716521"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110;int n,m;int v[N], w[N];int h[N], e[N], ne[N], idx;int f[N][N];void add(int a,int b)&#123;    e[idx] &#x3D; b,ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dfs(int u)&#123;    for(int i &#x3D; h[u]; ~i ; i &#x3D; ne[i]) &#x2F;&#x2F;循环物品组    &#123;        int son &#x3D; e[i];        dfs(e[i]);        &#x2F;&#x2F;遍历背包的容积，因为我们是要遍历其子节点，所以当前节点我们是默认选择的。        &#x2F;&#x2F;分组背包，当前节点看成分组背包中的一个组，子节点的每种选择看成组内的一种物品        &#x2F;&#x2F;我们每一次都默认选择当前结点，因为到最后根节点是必选的。         for(int j &#x3D; m - v[u]; j &gt;&#x3D; 0 ; j -- ) &#x2F;&#x2F;循环体积            for(int k &#x3D; 0 ; k &lt;&#x3D; j ; k ++ ) &#x2F;&#x2F;循环决策                f[u][j] &#x3D; max(f[u][j], f[u][j-k] + f[son][k]);    &#125;        &#x2F;&#x2F;加上刚刚默认选择的父节点价值    for(int i &#x3D; m  ; i &gt;&#x3D; v[u] ; i -- )    &#123;        f[u][i] &#x3D; f[u][i-v[u]] + w[u];    &#125;        &#x2F;&#x2F;因为我们是从叶子结点开始往上做，所以如果背包容积不如当前物品的体积大，那就不能选择当前结点及其子节点，因此赋值为零     for(int i &#x3D; 0 ; i &lt; v[u] ; i ++ )    &#123;        f[u][i] &#x3D; 0;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    int root;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        int p;        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; p;        if(p &#x3D;&#x3D; -1) root &#x3D; i;        else add(p, i);    &#125;        dfs(root);        cout &lt;&lt; f[root][m] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（四）数学知识</title>
      <link href="/2023/041141030.html"/>
      <url>/2023/041141030.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法（四）数学知识"><a href="#算法（四）数学知识" class="headerlink" title="算法（四）数学知识"></a>算法（四）数学知识</h1><h2 id="1、素数"><a href="#1、素数" class="headerlink" title="1、素数"></a>1、素数</h2><h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool is_prime(int x)&#123;    if (x &lt; 2) return false;    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )        if (x % i &#x3D;&#x3D; 0)            return false;    return true;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/868/">试除法判定质数</a></p><h3 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void divide(int x)&#123;    for (int i &#x3D; 2; i &lt;&#x3D; x &#x2F; i; i ++ )        if (x % i &#x3D;&#x3D; 0)        &#123;            int s &#x3D; 0;            while (x % i &#x3D;&#x3D; 0) x &#x2F;&#x3D; i, s ++ ;            cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; s &lt;&lt; endl;        &#125;    if (x &gt; 1) cout &lt;&lt; x &lt;&lt; &#39; &#39; &lt;&lt; 1 &lt;&lt; endl;    cout &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/869/">分解质因数</a></p><h3 id="朴素筛法求素数"><a href="#朴素筛法求素数" class="headerlink" title="朴素筛法求素数"></a>朴素筛法求素数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉void get_primes(int n)&#123;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if (st[i]) continue;        primes[cnt ++ ] &#x3D; i;        for (int j &#x3D; i + i; j &lt;&#x3D; n; j +&#x3D; i)            st[j] &#x3D; true;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/870/">筛素数</a></p><h3 id="线性筛法求素数"><a href="#线性筛法求素数" class="headerlink" title="线性筛法求素数"></a>线性筛法求素数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int primes[N], cnt;     &#x2F;&#x2F; primes[]存储所有素数bool st[N];         &#x2F;&#x2F; st[x]存储x是否被筛掉void get_primes(int n)&#123;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] &#x3D; i;        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )        &#123;            st[primes[j] * i] &#x3D; true;            if (i % primes[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、约数"><a href="#2、约数" class="headerlink" title="2、约数"></a>2、约数</h2><h3 id="试除法求所有约数"><a href="#试除法求所有约数" class="headerlink" title="试除法求所有约数"></a>试除法求所有约数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; get_divisors(int x)&#123;    vector&lt;int&gt; res;    for (int i &#x3D; 1; i &lt;&#x3D; x &#x2F; i; i ++ )        if (x % i &#x3D;&#x3D; 0)        &#123;            res.push_back(i);            if (i !&#x3D; x &#x2F; i) res.push_back(x &#x2F; i);        &#125;    sort(res.begin(), res.end());    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/activity/content/problem/content/938/">试除法求约数</a></p><h3 id="约数个数和约数之和"><a href="#约数个数和约数之和" class="headerlink" title="约数个数和约数之和"></a>约数个数和约数之和</h3><pre class="line-numbers language-none"><code class="language-none">如果 N &#x3D; p1^c1 * p2^c2 * ... *pk^ck约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3、快速幂"><a href="#3、快速幂" class="headerlink" title="3、快速幂"></a>3、快速幂</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">求 m^k mod p，时间复杂度 O(logk)。int qmi(int m, int k, int p)&#123;    int res &#x3D; 1 % p, t &#x3D; m;    while (k)    &#123;        if (k&amp;1) res &#x3D; res * t % p;        t &#x3D; t * t % p;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><blockquote><p>费马定理：如果b和p互质，则b的p-1次方模p等于1</p></blockquote><pre class="line-numbers language-none"><code class="language-none">b的逆元&#x3D;qmi(b,p-2,p) &#x2F;&#x2F;b是p的倍数时无解<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4、求组合数"><a href="#4、求组合数" class="headerlink" title="4、求组合数"></a>4、求组合数</h2><h3 id="递推法求组合数"><a href="#递推法求组合数" class="headerlink" title="递推法求组合数"></a>递推法求组合数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; c[a][b] 表示从a个苹果中选b个的方案数for (int i &#x3D; 0; i &lt; N; i ++ )    for (int j &#x3D; 0; j &lt;&#x3D; i; j ++ )        if (!j) c[i][j] &#x3D; 1;        else c[i][j] &#x3D; (c[i - 1][j] + c[i - 1][j - 1]) % mod;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$$<br>C_{a}^{b}=C_{a-1}^{b}+C_{a-1}^{b-1}<br>$$</p><p>原题链接：<a href="https://www.acwing.com/problem/content/887/">求组合数I</a></p><h3 id="通过预处理逆元的方式求组合数"><a href="#通过预处理逆元的方式求组合数" class="headerlink" title="通过预处理逆元的方式求组合数"></a>通过预处理逆元的方式求组合数</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;首先预处理出所有阶乘取模的余数fact[N]，以及所有阶乘取模的逆元infact[N]&#x2F;&#x2F;如果取模的数是质数，可以用费马小定理求逆元int qmi(int a, int k, int p)    &#x2F;&#x2F; 快速幂模板&#123;    int res &#x3D; 1;    while (k)    &#123;        if (k &amp; 1) res &#x3D; (LL)res * a % p;        a &#x3D; (LL)a * a % p;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;&#x2F;&#x2F; 预处理阶乘的余数和阶乘逆元的余数fact[0] &#x3D; infact[0] &#x3D; 1;for (int i &#x3D; 1; i &lt; N; i ++ )&#123;    fact[i] &#x3D; (LL)fact[i - 1] * i % mod;    infact[i] &#x3D; (LL)infact[i - 1] * qmi(i, mod - 2, mod) % mod;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$$<br>C_{a}^{b}=\frac{a!}{(a-b)!b!}<br>$$</p><p>原题链接：<a href="https://www.acwing.com/problem/content/888/">求组合数II</a></p><h3 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;若p是质数，则对于任意整数 1 &lt;&#x3D; m &lt;&#x3D; n，有： C(n, m) &#x3D; C(n % p, m % p) * C(n &#x2F; p, m &#x2F; p) (mod p)int qmi(int a, int k, int p)  &#x2F;&#x2F; 快速幂模板&#123;    int res &#x3D; 1 % p;    while (k)    &#123;        if (k &amp; 1) res &#x3D; (LL)res * a % p;        a &#x3D; (LL)a * a % p;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;int C(int a, int b, int p)  &#x2F;&#x2F; 通过定理求组合数C(a, b)&#123;    if (a &lt; b) return 0;    LL x &#x3D; 1, y &#x3D; 1;  &#x2F;&#x2F; x是分子，y是分母    for (int i &#x3D; a, j &#x3D; 1; j &lt;&#x3D; b; i --, j ++ )    &#123;        x &#x3D; (LL)x * i % p;        y &#x3D; (LL) y * j % p;    &#125;    return x * (LL)qmi(y, p - 2, p) % p;&#125;int lucas(LL a, LL b, int p)&#123;    if (a &lt; p &amp;&amp; b &lt; p) return C(a, b, p);    return (LL)C(a % p, b % p, p) * lucas(a &#x2F; p, b &#x2F; p, p) % p;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>$$<br>C_{a}^{b}\equiv C_{amodp}^{bmodp}C_{a/p}^{b/p}(modp)<br>$$</p><h3 id="分解质因数法求组合数"><a href="#分解质因数法求组合数" class="headerlink" title="分解质因数法求组合数"></a>分解质因数法求组合数</h3><p>当我们需要求出组合数的真实值，而非对某个数的余数时，分解质因数的方式比较好用：<br>    1. 筛法求出范围内的所有质数<br>        2. 通过 C(a, b) = a! / b! / (a - b)! 这个公式求出每个质因子的次数。 n! 中p的次数是 n / p + n / p^2 + n / p^3 + …<br>        3. 用高精度乘法将所有质因子相乘</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int primes[N], cnt;     &#x2F;&#x2F; 存储所有质数int sum[N];     &#x2F;&#x2F; 存储每个质数的次数bool st[N];     &#x2F;&#x2F; 存储每个数是否已被筛掉void get_primes(int n)      &#x2F;&#x2F; 线性筛法求素数&#123;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if (!st[i]) primes[cnt ++ ] &#x3D; i;        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )        &#123;            st[primes[j] * i] &#x3D; true;            if (i % primes[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;int get(int n, int p)       &#x2F;&#x2F; 求n！中的次数&#123;    int res &#x3D; 0;    while (n)    &#123;        res +&#x3D; n &#x2F; p;        n &#x2F;&#x3D; p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)       &#x2F;&#x2F; 高精度乘低精度模板&#123;    vector&lt;int&gt; c;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; a.size(); i ++ )    &#123;        t +&#x3D; a[i] * b;        c.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    return c;&#125;get_primes(a);  &#x2F;&#x2F; 预处理范围内的所有质数for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 求每个质因数的次数&#123;    int p &#x3D; primes[i];    sum[i] &#x3D; get(a, p) - get(b, p) - get(a - b, p);&#125;vector&lt;int&gt; res;res.push_back(1);for (int i &#x3D; 0; i &lt; cnt; i ++ )     &#x2F;&#x2F; 用高精度乘法将所有质因子相乘    for (int j &#x3D; 0; j &lt; sum[i]; j ++ )        res &#x3D; mul(res, primes[i]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/890/">求组合数IV</a></p><h3 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h3><pre class="line-numbers language-none"><code class="language-none">给定n个0和n个1，它们按照某种顺序排成长度为2n的序列，满足任意前缀中0的个数都不少于1的个数的序列的数量为： Cat(n) &#x3D; C(2n, n) &#x2F; (n + 1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/891/">满足条件的01序列</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（三）图论</title>
      <link href="/2023/041126447.html"/>
      <url>/2023/041126447.html</url>
      
        <content type="html"><![CDATA[<h1 id="基础课"><a href="#基础课" class="headerlink" title="基础课"></a>基础课</h1><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><p>深度优先搜索</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111635535.png"></p><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int dfs(int u)&#123;    st[u] &#x3D; true; &#x2F;&#x2F; st[u] 表示点u已经被遍历过    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if (!st[j]) dfs(j);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/activity/content/problem/content/905/">排列数字</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 10;int n;      &#x2F;&#x2F;存储层数int path[N];  &#x2F;&#x2F;存储当前排列bool st[N];     &#x2F;&#x2F;存储状态数组，为true说明该位置有数，为false说明该位置无数，初始化后为falsevoid dfs(int u)&#123;    if(u &#x3D;&#x3D; n) &#x2F;&#x2F;达到最底层的时候即输出当前排列    &#123;        for (int i&#x3D;0;i &lt; n;i ++) printf(&quot;%d &quot;,path[i]);        puts(&quot;&quot;);        return;    &#125;        for (int i &#x3D; 1; i &lt;&#x3D; n;i ++ )  &#x2F;&#x2F;每一次深搜都要进行一次遍历        if (!st[i]) &#x2F;&#x2F;对于每一个为true的数，只寻找后面为false的数，如1为true,2、3为false，则队列变为12,13        &#123;            path[u] &#x3D; i; &#x2F;&#x2F;为当前深搜排列进行赋值            st[i] &#x3D; true; &#x2F;&#x2F;将搜到的数置为true            dfs(u+1); &#x2F;&#x2F;下一层进行深度搜索            st[i] &#x3D; false; &#x2F;&#x2F;，若下一层到了底层，则回溯节点        &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(0); &#x2F;&#x2F;从第0层开始搜索    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token comment">// 层数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> path<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 当前排列</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>path<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span>u <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/845/">n-皇后问题</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 10, M &#x3D; 2*N;bool col[N], dg[M], udg[M];char path[N];int n;char g[N][N];void dfs(int u)&#123;    if(u &#x3D;&#x3D; n)&#123;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;            for(int j &#x3D; 0; j &lt;n ; j ++ )&#123;                cout &lt;&lt; g[i][j] ;            &#125;            cout &lt;&lt; endl;        &#125;        cout &lt;&lt; endl;        return ;    &#125;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        if(!col[i] &amp;&amp; !dg[u + i] &amp;&amp; !udg[u - i + n])&#123;            g[u][i] &#x3D; &#39;Q&#39;;            col[i] &#x3D; dg[u+i] &#x3D; udg[u-i+n] &#x3D; true;            dfs(u + 1);            col[i] &#x3D; dg[u+i] &#x3D; udg[u-i+n] &#x3D; false;            g[u][i] &#x3D; &#39;.&#39;;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j  &#x3D; 0 ; j &lt; n ; j ++ )&#123;            g[i][j] &#x3D; &#39;.&#39;;        &#125;    &#125;    dfs(0);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p>能走最短路径</p><p>只有边权都是1时，才能用BFS求最短路径</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111635185.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111635581.png"></p><p><strong>注意这里的方向dx[4] = {-1, 0, 1, 0}, dy[4] = {0,1,0,-1}，分别是上、右、下、左</strong></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305252318902.png" alt="image-20230525231713519"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">queue&lt;int&gt; q;st[1] &#x3D; true; &#x2F;&#x2F; 表示1号点已经被遍历过q.push(1);while (q.size())&#123;    int t &#x3D; q.front();    q.pop();    for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if (!st[j])        &#123;            st[j] &#x3D; true; &#x2F;&#x2F; 表示点j已经被遍 历过            q.push(j);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/846/">https://www.acwing.com/problem/content/846/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 110;int n,m;int g[N][N]; &#x2F;&#x2F;存储原数据int d[N][N]; &#x2F;&#x2F;存储路径PII q[N*N]; &#x2F;&#x2F;模拟队列int bfs()&#123;    int hh &#x3D; 0, tt &#x3D; 0; &#x2F;&#x2F;hh为队头，tt为队尾    q[0] &#x3D; &#123;0,0&#125;;&#x2F;&#x2F;模拟队列    memset(d, -1 , sizeof d);    int dx[4] &#x3D; &#123;-1,0,1,0&#125; , dy[4] &#x3D; &#123;0,-1,0,1&#125;;&#x2F;&#x2F;用(-1,0),(0,1),(1,0),(0,-1)模拟点的上下移动     d[0][0] &#x3D; 0;    while(hh &lt;&#x3D; tt)    &#123;        auto t &#x3D; q[hh++];&#x2F;&#x2F;取出队头        for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )&#x2F;&#x2F;扩展队列        &#123;            int x &#x3D; t.first + dx[i], y &#x3D; t.second +  dy[i];            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)             &#123;                d[x][y] &#x3D; d[t.first][t.second] + 1;                q[++tt] &#x3D; &#123;x,y&#125;;            &#125;        &#125;    &#125;    return d[n-1][m-1];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ;  i ++ )        for(int j &#x3D; 0 ; j &lt; m ; j ++ )            cin &gt;&gt; g[i][j];                cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 110;int n,m;int g[N][N];int d[N][N];queue&lt;PII&gt; q;int bfs()&#123;    memset(d,-1,sizeof d);    q.push(&#123;0,0&#125;);    d[0][0] &#x3D; 0;    int dx[4] &#x3D; &#123;-1,0,1,0&#125; , dy[4] &#x3D; &#123;0,-1,0,1&#125;;    while(!q.empty())    &#123;        auto t &#x3D; q.front();        q.pop();        for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )        &#123;            int x &#x3D; t.first + dx[i] , y &#x3D; t.second + dy[i];            if(x&gt;&#x3D;0&amp;&amp;x&lt;n&amp;&amp;y&gt;&#x3D;0&amp;&amp;y&lt;m&amp;&amp;g[x][y]&#x3D;&#x3D;0&amp;&amp;d[x][y]&#x3D;&#x3D;-1)            &#123;                q.push(&#123;x,y&#125;);                d[x][y] &#x3D; d[t.first][t.second] + 1;            &#125;        &#125;    &#125;    return d[n-1][m-1];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ;  i ++ )        for(int j &#x3D; 0 ; j &lt; m ; j ++ )            cin &gt;&gt; g[i][j];                cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">110</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> g<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> dx<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">,</span> dy<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Pairs</span> p <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> p<span class="token punctuation">.</span>first <span class="token operator">+</span> dx<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> p<span class="token punctuation">.</span>second <span class="token operator">+</span> dy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> x <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> y <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> y <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>p<span class="token punctuation">.</span>first<span class="token punctuation">]</span><span class="token punctuation">[</span>p<span class="token punctuation">.</span>second<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> d<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> first<span class="token punctuation">;</span><span class="token keyword">int</span> second<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/847/">八数码</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;unordered_map&gt;#include&lt;cstring&gt;using namespace std;int bfs(string start)&#123;    string end &#x3D; &quot;12345678x&quot;;    int dx[4] &#x3D; &#123;-1,0,1,0&#125;, dy[4] &#x3D; &#123;0,1,0,-1&#125;;    queue&lt;string&gt; q;    unordered_map&lt;string,int&gt; d;    q.push(start);    d[start] &#x3D; 0;        while(!q.empty())&#123;        string s &#x3D; q.front();        q.pop();                int dis &#x3D; d[s];        if(s &#x3D;&#x3D; end) return dis;                int k &#x3D; s.find(&#39;x&#39;);        int x &#x3D; k &#x2F; 3;        int y &#x3D; k % 3;        for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )&#123;            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];            if(a &gt;&#x3D; 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 3)&#123;                swap(s[k], s[a * 3 + b]);                if(!d.count(s))&#123;                    d[s] &#x3D; dis + 1;                    q.push(s);                &#125;                swap(s[k], s[a * 3 + b]);            &#125;        &#125;    &#125;        if(d[end] &#x3D;&#x3D; 0) return -1;        return d[end];&#125;int main()&#123;    string start;    for(int i &#x3D; 0 ; i &lt; 9 ; i ++ )&#123;        char c;        cin &gt;&gt; c;        start +&#x3D; c;    &#125;        cout &lt;&lt; bfs(start) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树与图的深度优先遍历"><a href="#树与图的深度优先遍历" class="headerlink" title="树与图的深度优先遍历"></a>树与图的深度优先遍历</h2><p>原题链接：<a href="https://www.acwing.com/problem/content/848/">树的重心</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 1e5+10, M &#x3D; 2*N;int n;int idx,e[M],ne[M],h[N];bool st[N];int ans &#x3D; N;void add(int a,int b)&#123;    e[idx] &#x3D; b;    ne[idx] &#x3D; h[a];    h[a] &#x3D; idx ++ ;&#125;int dfs(int u)&#123;    st[u] &#x3D; true;    int size &#x3D; 0, sum &#x3D; 1;    for(int i &#x3D; h[u]; i !&#x3D; -1 ; i &#x3D; ne[i])&#123;        int j &#x3D; e[i];        if(!st[j]) &#123;            int s &#x3D; dfs(j);            size &#x3D; max(size, s); &#x2F;&#x2F;记录最大联通子图的节点数            sum +&#x3D; s; &#x2F;&#x2F;以j为根的树的节点数        &#125;    &#125;        size &#x3D; max(size , n - sum);    ans &#x3D; min(size, ans);    return sum;&#125;int main()&#123;    memset(h,-1,sizeof h);    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n - 1  ; i ++ )&#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        add(a,b);        add(b,a);    &#125;    dfs(1);     cout &lt;&lt; ans &lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token class-name">N</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token class-name">N</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>st<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">int</span> s <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>size <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>sum <span class="token operator">+=</span> s<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>size <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> n <span class="token operator">-</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> sum<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="树与图的广度优先遍历"><a href="#树与图的广度优先遍历" class="headerlink" title="树与图的广度优先遍历"></a>树与图的广度优先遍历</h2><p>原题链接：<a href="https://www.acwing.com/problem/content/849/">图中点的层次</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1e5 +10;int n,m;int idx,e[N],ne[N],h[N],d[N];void add(int a,int b)&#123;    e[idx] &#x3D; b;    ne[idx] &#x3D; h[a];    h[a] &#x3D; idx ++ ;&#125;int bfs()&#123;    memset(d,-1,sizeof d);    queue&lt;int&gt; q;    q.push(1);    d[1] &#x3D; 0;        while(!q.empty())&#123;        int t &#x3D; q.front();        q.pop();                for(int i &#x3D; h[t] ; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &#x3D;&#x3D; -1)&#123;                d[j] &#x3D; d[t] + 1;                q.push(j);            &#125;        &#125;    &#125;    return d[n];&#125;int main()&#123;    memset(h,-1,sizeof h);    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        add(a,b);    &#125;        cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">bfs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="拓扑序列"><a href="#拓扑序列" class="headerlink" title="拓扑序列"></a>拓扑序列</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111635726.png"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点，e[k]存储该边的目的节点,ne[N]存储所有的边，int h[N], e[N], ne[N], idx;&#x2F;&#x2F; 添加一条边a-&gt;bvoid add(int a, int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;&#x2F;&#x2F; 初始化idx &#x3D; 0;memset(h, -1, sizeof h);bool topsort()&#123;    int hh &#x3D; 0, tt &#x3D; -1;    &#x2F;&#x2F; d[i] 存储点i的入度，即存储所有入度为0的点    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        if (!d[i])            q[ ++ tt] &#x3D; i;    while (hh &lt;&#x3D; tt)    &#123;        int t &#x3D; q[hh ++ ];        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) &#x2F;&#x2F;遍历该点的所有边        &#123;            int j &#x3D; e[i];            if (-- d[j] &#x3D;&#x3D; 0)                q[ ++ tt] &#x3D; j;            &#x2F;&#x2F;遍历每个目的节点，若度数减1后为0，则将该点插入到拓扑队列中        &#125;    &#125;    &#x2F;&#x2F; 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。    return tt &#x3D;&#x3D; n - 1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>  i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ans<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">--</span> <span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt <span class="token operator">==</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/850/">有向图的拓扑序列</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 100010;int idx,h[N],e[N],ne[N];int n,m;int q[N],d[N];void add(int a,int b)&#123;    e[idx] &#x3D; b , ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;bool topsort()&#123;    int tt &#x3D; -1 , hh &#x3D; 0 ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        if(!d[i]) q[++tt] &#x3D; i;     while(hh&lt;&#x3D;tt)    &#123;        int t &#x3D; q[hh++];        for(int i &#x3D; h[t] ; i !&#x3D; -1 ; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            d[j] -- ;            if(!d[j]) q[++tt] &#x3D; j;        &#125;    &#125;    return tt &#x3D;&#x3D; n - 1;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h,-1,sizeof h);    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        add(a,b);        d[b]++;    &#125;    if(topsort())    &#123;        for(int i &#x3D; 0 ; i &lt; n ; i ++ ) printf(&quot;%d &quot;,q[i]);        puts(&quot;&quot;);    &#125;    else puts(&quot;-1&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> idx<span class="token punctuation">,</span> cnt<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ans<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span>  i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ans<span class="token punctuation">[</span>cnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">--</span> <span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt <span class="token operator">==</span> n<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">topsort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> cnt <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h2><h3 id="朴素Dijkstra"><a href="#朴素Dijkstra" class="headerlink" title="朴素Dijkstra"></a>朴素Dijkstra</h3><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111636456.png"></p><p>稀疏图：邻接矩阵 稠密图：邻接表</p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int g[N][N];  &#x2F;&#x2F; 存储每条边int dist[N];  &#x2F;&#x2F; 存储1号点到每个点的最短距离bool st[N];   &#x2F;&#x2F; 存储每个点的最短路是否已经确定&#x2F;&#x2F; 求1号点到n号点的最短路，如果不存在则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    for (int i &#x3D; 0; i &lt; n - 1; i ++ )    &#123;        int t &#x3D; -1;     &#x2F;&#x2F; 在还未确定最短路的点中，寻找距离最小的点        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))                t &#x3D; j;        &#x2F;&#x2F; 用t更新其他点的距离        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);        st[t] &#x3D; true;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/851/">https://www.acwing.com/problem/content/851/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 510;int n ,m ;int g[N][N];bool st[N];int d[N];int dijstra()&#123;    memset(d, 0x3f, sizeof d);    d[1] &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int t &#x3D; -1;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || d[t] &gt; d[j]))                t &#x3D; j ;        &#125;                for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            d[j] &#x3D; min(d[j], d[t] + g[t][j]);        &#125;                st[t] &#x3D; true;    &#125;        if(d[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return d[n];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m) ;    memset(g,0x3f,sizeof g);    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        int x, y, z;        scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z);        g[x][y] &#x3D; min(g[x][y], z);    &#125;        int t &#x3D; dijstra();        printf(&quot;%d&quot;,t);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆优化Dijkstra"><a href="#堆优化Dijkstra" class="headerlink" title="堆优化Dijkstra"></a>堆优化Dijkstra</h3><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef pair&lt;int, int&gt; PII;int n;      &#x2F;&#x2F; 点的数量int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边int dist[N];        &#x2F;&#x2F; 存储所有点到1号点的距离bool st[N];     &#x2F;&#x2F; 存储每个点的最短距离是否已确定&#x2F;&#x2F; 求1号点到n号点的最短距离，如果不存在，则返回-1int dijkstra()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);      &#x2F;&#x2F; first存储距离，second存储节点编号    while (heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();        int ver &#x3D; t.second, distance &#x3D; t.first;        if (st[ver]) continue;        st[ver] &#x3D; true;        for (int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (dist[j] &gt; distance + w[i])            &#123;                dist[j] &#x3D; distance + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 150010;int n,m;int idx,h[N],e[N],ne[N],w[N];int d[N];bool st[N]; void add(int a,int b,int c)&#123;    e[idx] &#x3D; b , w[idx] &#x3D; c , ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;      &#125;int dijstra()&#123;    memset(d, 0x3f , sizeof d);    d[1] &#x3D; 0;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap; &#x2F;&#x2F;小根堆，按first从小到大    heap.push(&#123;0,1&#125;);        while(heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second,distance &#x3D; t.first; &#x2F;&#x2F;first是距离，second是枚举的点                if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1 ; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(d[j] &gt; distance + w[i])            &#123;                d[j] &#x3D; distance + w[i];                heap.push(&#123;d[j],j&#125;);            &#125;        &#125;    &#125;        if(d[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return d[n];&#125;int main()&#123;    memset(h, -1 ,sizeof h);    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    while(m--)    &#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    &#125;        int t &#x3D; dijstra();        printf(&quot;%d&quot;,t);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">150010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">dijsktra</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> pq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PriorityQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>pq<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Pairs</span> t <span class="token operator">=</span> pq<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> ver <span class="token operator">=</span> t<span class="token punctuation">.</span>second<span class="token punctuation">,</span> distance <span class="token operator">=</span> t<span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">continue</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>ver<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>ver<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> distance <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>pq<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">dijsktra</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> first<span class="token punctuation">;</span> <span class="token comment">// 距离</span><span class="token keyword">int</span> second<span class="token punctuation">;</span> <span class="token comment">// 枚举的点</span><span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Pairs</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">!=</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">-</span> p<span class="token punctuation">.</span>first<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">-</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304022052890.png"></p><h2 id="bellman-ford"><a href="#bellman-ford" class="headerlink" title="bellman-ford"></a>bellman-ford</h2><p>不能存在负权回路</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111636275.png"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       &#x2F;&#x2F; n表示点数，m表示边数int dist[N];        &#x2F;&#x2F; dist[x]存储1到x的最短路距离struct Edge     &#x2F;&#x2F; 边，a表示出点，b表示入点，w表示边的权重&#123;    int a, b, w;&#125;edges[M];&#x2F;&#x2F; 求1到n的最短路距离，如果无法从1走到n，则返回-1。int bellman_ford()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    &#x2F;&#x2F; 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。    for (int i &#x3D; 0; i &lt; n; i ++ )    &#123;        for (int j &#x3D; 0; j &lt; m; j ++ )        &#123;            int a &#x3D; edges[j].a, b &#x3D; edges[j].b, w &#x3D; edges[j].w;            if (dist[b] &gt; dist[a] + w)                dist[b] &#x3D; dist[a] + w;        &#125;    &#125;    if (dist[n] &gt; 0x3f3f3f3f &#x2F; 2) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/855/">有边数限制的最短路</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int M &#x3D; 10010,N &#x3D; 510;int n,m,k;struct Edge&#123;    int a,b,w;&#125;edges[M];int d[N],backup[N];&#x2F;&#x2F;backup存在的意义是进行备份，防止dist数组出现串联更新的结果，简单来说就是在一次迭代时，前面的dist值发生变化，则后面的dist值会使用前面变化后的值，因此我们在每次迭代后都需要进行备份，从而使dist改变时是与备份的值相比较bool flag; &#x2F;&#x2F;判断答案是否正好为-1int bellman_ford()&#123;    memset(d,0x3f,sizeof d);        d[1] &#x3D; 0;        for(int i &#x3D; 0 ; i &lt; k ; i ++ )    &#123;        memcpy(backup, d, sizeof d);        for(int j &#x3D; 0 ; j &lt; m ; j ++ )        &#123;            int a &#x3D; edges[j].a, b &#x3D; edges[j].b , w &#x3D; edges[j].w;            d[b] &#x3D; min(d[b],backup[a]+w);        &#125;    &#125;        if(d[n] &gt; 0x3f3f3f3f &#x2F; 2)     &#123;        flag &#x3D; true;        return -1;    &#125;    return d[n];&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a,b,w;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);        edges[i] &#x3D; &#123;a,b,w&#125;;    &#125;        int t &#x3D; bellman_ford();        if(flag &amp;&amp; t &#x3D;&#x3D; -1) puts(&quot;impossible&quot;);     else printf(&quot;%d&quot;,t);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">10010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token comment">// n表示点数，m表示边数</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// d[x]存储1到x的最短路距离</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> backup<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Edge</span> edges<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span><span class="token comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>backup <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> d<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> w <span class="token operator">=</span> edges<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>d<span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> backup<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0x3f3f3f3f</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">bellman_ford</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="spfa"><a href="#spfa" class="headerlink" title="spfa"></a>spfa</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111636994.png"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      &#x2F;&#x2F; 总点数int h[N], w[N], e[N], ne[N], idx;       &#x2F;&#x2F; 邻接表存储所有边int dist[N];        &#x2F;&#x2F; 存储每个点到1号点的最短距离bool st[N];     &#x2F;&#x2F; 存储每个点是否在队列中&#x2F;&#x2F; 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1int spfa()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1] &#x3D; 0;    queue&lt;int&gt; q;    q.push(1);    st[1] &#x3D; true;    while (q.size())    &#123;        auto t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for (int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] &#x3D; dist[t] + w[i];                if (!st[j])     &#x2F;&#x2F; 如果队列中已存在j，则不需要将j重复插入                &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    if (dist[n] &#x3D;&#x3D; 0x3f3f3f3f) return -1;    return dist[n];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/853/">spfa求最短路</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 100010;int n,m;int h[N], w[N], e[N], ne[N], idx;int d[N];bool st[N],flag; &#x2F;&#x2F;st数组存储的是该点是否在队列当中void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c , ne[idx] &#x3D; h[a] , h[a] &#x3D; idx ++;&#125;int spfa()&#123;    memset(d, 0x3f, sizeof d);    d[1] &#x3D; 0;        queue&lt;int&gt; q;    q.push(1);    st[1] &#x3D; true;     while(q.size())    &#123;        int t &#x3D; q.front();        q.pop();                st[t] &#x3D; false;                for(int i &#x3D; h[t] ; i !&#x3D; -1 ; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(d[j] &gt; d[t] + w[i])            &#123;                d[j] &#x3D; d[t] + w[i];                if(!st[j])                &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;        if(d[n] &gt; 0x3f3f3f3f&#x2F;2)&#123;        flag &#x3D; true;        return -1;    &#125;     return d[n];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(h,-1,sizeof h);    while(m--)    &#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    &#125;        int t &#x3D; spfa();        if(flag &amp;&amp; t &#x3D;&#x3D; -1) puts(&quot;impossible&quot;);    else printf(&quot;%d&quot;,t);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0x3f3f3f3f</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> d<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">&amp;&amp;</span> t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/854/">spfa判断负环 </a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 100010;int n,m;int h[N], w[N], e[N], ne[N], idx;int d[N],cnt[N];bool st[N],flag;void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c , ne[idx] &#x3D; h[a] , h[a] &#x3D; idx ++;&#125;int spfa()&#123;    &#x2F;&#x2F;因为负环的存在，所以即使每个点距离虚拟原点距离为0，负权边的存在依然可以更新某个点为更小的负值    queue&lt;int&gt; q;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ;  i++ )    &#123;        st[i] &#x3D; true;        q.push(i);    &#125;    while(q.size())    &#123;        int t &#x3D; q.front();        q.pop();                st[t] &#x3D; false;                for(int i &#x3D; h[t] ; i !&#x3D; -1 ; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(d[j] &gt; d[t] + w[i])            &#123;                d[j] &#x3D; d[t] + w[i];                cnt[j] &#x3D; cnt[t] + 1;                                if(cnt[j] &gt;&#x3D; n) return  true;                if(!st[j])                &#123;                    q.push(j);                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(h,-1,sizeof h);    while(m--)    &#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        add(a,b,c);    &#125;        if(spfa()) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> flag<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> h<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> w<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>w<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> c<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> h<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>h<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Queue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>st<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">element</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> h<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> j <span class="token operator">=</span> e<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> w<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cnt<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> n<span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>q<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">spfa</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">初始化：    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (i &#x3D;&#x3D; j) d[i][j] &#x3D; 0;            else d[i][j] &#x3D; INF;&#x2F;&#x2F; 算法结束后，d[a][b]表示a到b的最短距离void floyd()&#123;    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/856/">https://www.acwing.com/problem/content/856/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 210, INF &#x3D; 1e9;int n,m,Q;int d[N][N];void floyd()&#123;    for(int k &#x3D; 1 ;k &lt;&#x3D; n ; k ++ )    &#123;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        &#123;            for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )            &#123;                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            if(i &#x3D;&#x3D; j) d[i][i] &#x3D; 0;            else d[i][j] &#x3D; INF;        &#125;    &#125;        while(m--)    &#123;        int a,b,w;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);        d[a][b] &#x3D; min(d[a][b],w);    &#125;        floyd();        while(Q--)    &#123;        int a,b;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        if(d[a][b] &gt; INF&#x2F;2) puts(&quot;impossible&quot;);        else printf(&quot;%d\n&quot;,d[a][b]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">210</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> <span class="token class-name">Q</span><span class="token punctuation">,</span> idx<span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token number">1e9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> d<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Q</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">else</span>d<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INF<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">floyd</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">Q</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">></span> INF <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111636232.png"></p><p>适用于<strong>稠密图</strong></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      &#x2F;&#x2F; n表示点数int g[N][N];        &#x2F;&#x2F; 邻接矩阵，存储所有边int dist[N];        &#x2F;&#x2F; 存储其他点到当前最小生成树的距离bool st[N];     &#x2F;&#x2F; 存储每个点是否已经在生成树中&#x2F;&#x2F; 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和int prim()&#123;    memset(dist, 0x3f, sizeof dist);    int res &#x3D; 0;    for (int i &#x3D; 0; i &lt; n; i ++ )    &#123;        int t &#x3D; -1;        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if (!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[t] &gt; dist[j]))                t &#x3D; j;        if (i &amp;&amp; dist[t] &#x3D;&#x3D; INF) return INF;        if (i) res +&#x3D; dist[t];        st[t] &#x3D; true;        for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ ) dist[j] &#x3D; min(dist[j], g[t][j]);    &#125;    return res;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/860/">Prim算法求最小生成树</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;const int N &#x3D; 510 , INF &#x3D; 0x3f3f3f3f;int g[N][N];int n,m;bool st[N];int d[N];int prim()&#123;    memset(d, 0x3f, sizeof d);    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int t &#x3D; -1;        for(int  j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || d[t] &gt; d[j]))                t &#x3D; j;        &#125;                if(i &amp;&amp; d[t] &#x3D;&#x3D; INF) return INF;        if(i) res +&#x3D; d[t];                for(int j &#x3D; 1; j &lt;&#x3D; n ; j ++ ) d[j] &#x3D; min(d[j],g[t][j]);        st[t] &#x3D; true;    &#125;    return res;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(g,0x3f,sizeof g);        while(m--)    &#123;        int a,b,c;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);        g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b],c);    &#125;        int t &#x3D; prim();        if(t &#x3D;&#x3D; INF) puts(&quot;impossible&quot;);    else printf(&quot;%d&quot;,t);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">510</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> g<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 邻接矩阵，存储所有边</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> d<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 存储其他点到当前最小生成树的距离</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> st<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 存储每个点是否已经在生成树中</span>    <span class="token comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">Prim</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">></span> d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>t <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">==</span> INF<span class="token punctuation">)</span><span class="token keyword">return</span> INF<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>res <span class="token operator">+=</span> d<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>d<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> g<span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>g<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">[</span>b<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token class-name">Prim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> INF<span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111637177.png"></p><p>适用于<strong>稀疏图</strong></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n, m;       &#x2F;&#x2F; n是点数，m是边数int p[N];       &#x2F;&#x2F; 并查集的父节点数组struct Edge     &#x2F;&#x2F; 存储边&#123;    int a, b, w;    bool operator&lt; (const Edge &amp;W)const    &#123;        return w &lt; W.w;    &#125;&#125;edges[M];int find(int x)     &#x2F;&#x2F; 并查集核心操作&#123;    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int kruskal()&#123;    sort(edges, edges + m);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 初始化并查集    int res &#x3D; 0, cnt &#x3D; 0;    for (int i &#x3D; 0; i &lt; m; i ++ )    &#123;        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;        a &#x3D; find(a), b &#x3D; find(b);        if (a !&#x3D; b)     &#x2F;&#x2F; 如果两个连通块不连通，则将这两个连通块合并        &#123;            p[a] &#x3D; b;            res +&#x3D; w;            cnt ++ ;        &#125;    &#125;    if (cnt &lt; n - 1) return INF;    return res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/861/">https://www.acwing.com/problem/content/861/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;cstring&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 200010;int n,m;int p[N];struct Edge&#123;    int a,b,w;    bool operator&lt; (const Edge &amp;W) const &#123;        return w &lt; W.w;    &#125;&#125;edges[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a,b,w;        scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;w);        edges[i] &#x3D; &#123;a,b,w&#125;;    &#125;        sort(edges,edges+m);        for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i;        int res &#x3D; 0 , cnt &#x3D; 0;    for(int i &#x3D; 0; i &lt; m ; i ++ )    &#123;        int a&#x3D;edges[i].a,b&#x3D;edges[i].b,w&#x3D;edges[i].w;        a&#x3D;find(a),b&#x3D;find(b);        if(a !&#x3D; b)         &#123;            p[a] &#x3D; b;            res +&#x3D; w;            cnt ++ ;        &#125;    &#125;        if(cnt &lt; n - 1) puts(&quot;impossible&quot;);    else printf(&quot;%d&quot;,res);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">200010</span><span class="token punctuation">,</span> INF <span class="token operator">=</span> <span class="token number">0x3f3f3f3f</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Edge</span> edges<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">Kruskal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>a<span class="token punctuation">,</span> b <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>b<span class="token punctuation">,</span> w <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>w<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">!=</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> b<span class="token punctuation">;</span>res <span class="token operator">+=</span> w<span class="token punctuation">;</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">return</span> INF<span class="token punctuation">;</span><span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>w <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token class-name">Kruskal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">==</span> INF<span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"impossible"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Edge</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Edge</span><span class="token punctuation">></span></span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> w<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Edge</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> w<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">=</span> w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Edge</span> o<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>w <span class="token operator">-</span> o<span class="token punctuation">.</span>w<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title="染色法判定二分图"></a>染色法判定二分图</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111637009.png"></p><p>一个图是二分图，当且仅当图中不含奇数环</p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int n;      &#x2F;&#x2F; n表示点数int h[N], e[M], ne[M], idx;     &#x2F;&#x2F; 邻接表存储图int color[N];       &#x2F;&#x2F; 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色&#x2F;&#x2F; 参数：u表示当前节点，c表示当前点的颜色bool dfs(int u, int c)&#123;    color[u] &#x3D; c;    for (int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if (color[j] &#x3D;&#x3D; -1)        &#123;            if (!dfs(j, !c)) return false;        &#125;        else if (color[j] &#x3D;&#x3D; c) return false;    &#125;    return true;&#125;bool check()&#123;    memset(color, -1, sizeof color);    bool flag &#x3D; true;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        if (color[i] &#x3D;&#x3D; -1)            if (!dfs(i, 0))            &#123;                flag &#x3D; false;                break;            &#125;    return flag;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/862/">https://www.acwing.com/problem/content/862/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 100010, M &#x3D; 200010;int idx,e[M],ne[M],h[N],color[N];int n,m;void add(int a,int b)&#123;    e[idx] &#x3D; b , ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;bool dfs(int u,int c)&#x2F;&#x2F;u是点，c是颜色&#123;    color[u] &#x3D; c;    for(int i &#x3D; h[u];i!&#x3D;-1;i&#x3D;ne[i])    &#123;        int j &#x3D; e[i];        if(!color[j])        &#123;            if(!dfs(j,3-c)) return false; &#x2F;&#x2F; 因为颜色从1变成2，从2变成1，所以是3-c        &#125;        else if(color[j] &#x3D;&#x3D; c) return false;    &#125;    return true;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    memset(h,-1,sizeof h);    while(m--)    &#123;        int a,b;        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);        add(a,b), add(b,a);    &#125;        bool flag &#x3D; true;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        if(!color[i])        &#123;            if(!dfs(i,1))            &#123;                flag &#x3D; false;                break;            &#125;        &#125;    &#125;    if(flag) puts(&quot;Yes&quot;);    else puts(&quot;No&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h2><p>原题链接： <a href="https://www.acwing.com/problem/content/863/">https://www.acwing.com/problem/content/863/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 510, M &#x3D; 100010;int idx,h[N],e[M],ne[M];int n1,n2,m;bool st[N];int match[N];void add(int a,int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;&#125;bool find(int x)&#123;    for(int i &#x3D; h[x] ; i !&#x3D; -1 ; i &#x3D; ne[i])    &#123;        int j &#x3D; e[i];        if(!st[j])        &#123;            st[j] &#x3D; true;            if(match[j] &#x3D;&#x3D; 0 || find(match[j]))            &#123;                match[j] &#x3D; x;                return true;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n1,&amp;n2,&amp;m);    memset(h,-1,sizeof h);        for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int u,v;        scanf(&quot;%d%d&quot;,&amp;u,&amp;v);        add(u,v);    &#125;        int res &#x3D; 0 ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n1 ; i ++ )    &#123;        memset(st,false,sizeof st);        if(find(i)) res ++ ;    &#125;        printf(&quot;%d&quot;,res);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="提高课（搜索）"><a href="#提高课（搜索）" class="headerlink" title="提高课（搜索）"></a>提高课（搜索）</h1><h1 id="BFS-1"><a href="#BFS-1" class="headerlink" title="BFS"></a>BFS</h1><h2 id="Flood-Fill"><a href="#Flood-Fill" class="headerlink" title="Flood Fill"></a>Flood Fill</h2><p><a href="https://www.acwing.com/problem/content/1099/">池塘计数</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1010;typedef pair&lt;int,int&gt; PII;int n,m;char g[N][N];bool st[N][N];int dx[8] &#x3D; &#123;-1,-1,-1,0,0,1,1,1&#125;, dy[8] &#x3D; &#123;-1,0,1,1,-1,0,1,-1&#125;;void bfs(int i,int j)&#123;    queue&lt;PII&gt; q;    q.push(&#123;i,j&#125;);    while(!q.empty())&#123;        auto t &#x3D; q.front();        q.pop();        st[t.first][t.second] &#x3D; true;        for(int i &#x3D; 0; i &lt; 8 ; i ++ )&#123;            int x &#x3D; t.first + dx[i], y &#x3D; t.second + dy[i];            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt;&#x3D; m &amp;&amp; g[x][y] &#x3D;&#x3D; &#39;W&#39; &amp;&amp; !st[x][y])&#123;                q.push(&#123;x,y&#125;);                st[x][y] &#x3D; true;            &#125;        &#125;    &#125;    return ;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        cin &gt;&gt; g[i];    &#125;    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; m ; j ++ )&#123;            if(!st[i][j] &amp;&amp; g[i][j] &#x3D;&#x3D; &#39;W&#39;)&#123;                res ++ ;                bfs(i, j);            &#125;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/activity/content/code/content/130772/">城堡问题</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 55, M &#x3D; N * N;int n,m;int g[N][N];PII q[M];bool st[N][N];int bfs(int sx,int sy)&#123;    int dx[4] &#x3D; &#123;0,-1,0,1&#125;, dy[4] &#x3D; &#123;-1,0,1,0&#125;;    int area &#x3D; 0;        int hh &#x3D; 0 , tt &#x3D; 0;    q[0] &#x3D; &#123;sx,sy&#125;;    st[sx][sy] &#x3D; true;    while(hh &lt;&#x3D; tt)    &#123;        PII t &#x3D; q[hh++];        area ++;        for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )        &#123;            int a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];            if(a&lt;0 || a&gt;&#x3D; m || b &lt; 0 || b &gt;&#x3D; n ) continue;            if(st[a][b]) continue;            if(g[t.x][t.y] &gt;&gt; i &amp; 1) continue;                        q[++tt] &#x3D; &#123;a,b&#125;;            st[a][b] &#x3D; true;        &#125;    &#125;    return area;&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )        for(int j &#x3D; 0 ; j &lt; n ; j ++ )            cin &gt;&gt; g[i][j];                int cnt &#x3D; 0, area &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )        for(int j &#x3D; 0 ; j &lt; n ; j ++ )            if(!st[i][j])            &#123;                area &#x3D; max(area, bfs(i,j));                cnt ++ ;            &#125;                cout &lt;&lt; cnt &lt;&lt; endl;    cout &lt;&lt; area &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1108/">山峰和山谷</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 1010, M &#x3D; N * N;int n;int h[N][N];PII q[M];bool st[N][N];void bfs(int sx,int sy,bool&amp; has_higher, bool&amp; has_lower)&#123;    int hh &#x3D; 0 , tt &#x3D; 0;    q[0] &#x3D; &#123;sx,sy&#125;;    st[sx][sy] &#x3D; true;        while(hh&lt;&#x3D;tt)    &#123;        PII t &#x3D; q[hh++];                for(int i &#x3D; t.x - 1 ; i &lt;&#x3D; t.x + 1 ; i ++ )            for(int j &#x3D; t.y - 1 ; j &lt;&#x3D; t.y + 1 ; j ++ )            &#123;                if(i &#x3D;&#x3D; t.x &amp;&amp; j &#x3D;&#x3D; t.y) continue;                if(i &lt; 0 || i &gt;&#x3D; n || j &lt; 0 || j &gt;&#x3D; n ) continue;                if(h[i][j] !&#x3D; h[t.x][t.y]) &#x2F;&#x2F;如果高度不同                &#123;                    if(h[i][j] &gt; h[t.x][t.y]) has_higher &#x3D; true;                    else has_lower &#x3D; true;                &#125;else if(!st[i][j])                &#123;                    q[++tt] &#x3D; &#123;i,j&#125;;                    st[i][j] &#x3D; true;                &#125;            &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;n);        for(int i &#x3D; 0 ; i &lt; n ; i ++ )        for(int j &#x3D; 0 ; j &lt; n ; j ++ )            scanf(&quot;%d&quot;,&amp;h[i][j]);                int peak &#x3D; 0, valley &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )        for(int j &#x3D; 0 ; j &lt; n ; j ++ )            if(!st[i][j])            &#123;                bool has_higher &#x3D; false, has_lower &#x3D; false;                bfs(i,j,has_higher,has_lower);                if(!has_higher) peak++; &#x2F;&#x2F;没有比它高的说明是山峰                if(!has_lower) valley++;            &#125;                cout &lt;&lt; peak &lt;&lt; &#39; &#39; &lt;&lt; valley &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最短路模型"><a href="#最短路模型" class="headerlink" title="最短路模型"></a>最短路模型</h2><p><a href="https://www.acwing.com/problem/content/1078/">迷宫问题</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1010;typedef pair&lt;int,int&gt; PII;int n;int maze[N][N];int dx[4] &#x3D; &#123;-1,0,1,0&#125;, dy[4] &#x3D; &#123;0,1,0,-1&#125;;PII pre[N][N];void bfs(int i,int j)&#123;    queue&lt;PII&gt; q;    q.push(&#123;i,j&#125;);    memset(pre, -1, sizeof pre);    pre[i][j] &#x3D; &#123;0,0&#125;;    while(!q.empty())&#123;        auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; 0; i &lt; 4 ; i ++ )&#123;            int x &#x3D; t.first + dx[i], y &#x3D; t.second + dy[i];            if(x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; n ) continue;            if(pre[x][y].first !&#x3D; -1 || maze[x][y] &#x3D;&#x3D; 1) continue;            q.push(&#123;x,y&#125;);            pre[x][y] &#x3D; t;        &#125;         &#125;&#125;int main()&#123;    cin &gt;&gt; n ;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;            cin &gt;&gt; maze[i][j];        &#125;    &#125;        bfs(n - 1, n - 1); &#x2F;&#x2F;从终点遍历，可使得最后输出的点为正向    PII end(0,0); &#x2F;&#x2F;起点        while(true)&#123;        cout &lt;&lt; end.first &lt;&lt; &#39; &#39; &lt;&lt; end.second &lt;&lt;endl;        if(end.first &#x3D;&#x3D; n - 1 &amp;&amp; end.second &#x3D;&#x3D; n - 1) break;        end &#x3D; pre[end.first][end.second];    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/190/">武士风度的牛</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define x first#define y second using namespace std;const int N &#x3D; 155;typedef pair&lt;int,int&gt; PII;int dx[8] &#x3D; &#123;-2,-2,-1,-1,1,1,2,2&#125;, dy[8] &#x3D; &#123;-1,1,2,-2,2,-2,1,-1&#125;;char g[N][N];int n, m;int d[N][N];void bfs(int sx,int sy)&#123;    memset(d, -1, sizeof d);    queue&lt;PII&gt; q;    q.push(&#123;sx, sy&#125;);    d[sx][sy] &#x3D; 0 ;    while(!q.empty())&#123;        auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; 0 ; i &lt; 8 ; i ++ )&#123;            int a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];            if(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; m) continue;            if(d[a][b] !&#x3D; -1 || g[a][b] &#x3D;&#x3D; &#39;*&#39;) continue;            &#x2F;&#x2F;if(g[a][b] &#x3D;&#x3D; &#39;H&#39;) return d[t.x][t.y] + 1;            q.push(&#123;a,b&#125;);            d[a][b] &#x3D; d[t.x][t.y] + 1;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    int kx,ky,hx,hy;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )        for(int j &#x3D; 0 ; j &lt; m ; j ++ )         &#123;            cin &gt;&gt; g[i][j];            if(g[i][j] &#x3D;&#x3D; &#39;K&#39;)             &#123;                kx &#x3D; i, ky &#x3D; j;            &#125;else if(g[i][j] &#x3D;&#x3D; &#39;H&#39;)&#123;                hx &#x3D; i, hy &#x3D; j;            &#125;                    &#125;    bfs(kx, ky);    cout &lt;&lt; d[hx][hy] &lt;&lt; endl;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1102/">抓住那头牛</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1e5 + 10;int n,k;int d[N];int bfs()&#123;    memset(d, -1, sizeof d);    queue&lt;int&gt; q;    q.push(n);    d[n] &#x3D; 0;    while(!q.empty())&#123;        auto t &#x3D; q.front();        q.pop();                if(t &#x3D;&#x3D; k) return d[k];        if(t + 1 &lt; N &amp;&amp; d[t + 1] &#x3D;&#x3D; -1)&#123;            d[t + 1] &#x3D; d[t] + 1;            q.push(t+1);        &#125;        if(t - 1 &gt;&#x3D; 0 &amp;&amp; d[t - 1] &#x3D;&#x3D; -1)&#123;            d[t - 1] &#x3D; d[t] + 1;            q.push(t-1);        &#125;        if(t * 2 &lt; N &amp;&amp; d[t * 2] &#x3D;&#x3D; -1)&#123;            d[t * 2] &#x3D; d[t] + 1;            q.push(t*2);        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多源bfs"><a href="#多源bfs" class="headerlink" title="多源bfs"></a>多源bfs</h2><p><a href="https://www.acwing.com/problem/content/175/">矩阵距离</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define x first#define y secondusing namespace std;const int N &#x3D; 1010;typedef pair&lt;int,int&gt; PII;int n,m;char A[N][N];queue&lt;PII&gt; q;int d[N][N];int dx[4] &#x3D; &#123;-1,0,1,0&#125; , dy[4] &#x3D; &#123;0,1,0,-1&#125;;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(d, -1, sizeof d);    for(int i &#x3D; 0 ; i &lt; n ; i++ )&#123;        for(int j &#x3D; 0 ; j &lt; m ; j ++ )&#123;            cin &gt;&gt; A[i][j];            if(A[i][j] &#x3D;&#x3D; &#39;1&#39;)&#123;                q.push(&#123;i,j&#125;);                d[i][j] &#x3D; 0;            &#125;        &#125;    &#125;        while(!q.empty())&#123;                auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )&#123;            int a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];            if(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; m) continue;            if(d[a][b] !&#x3D; -1) continue;                        q.push(&#123;a,b&#125;);            d[a][b] &#x3D;  d[t.x][t.y] + 1;        &#125;    &#125;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; m ; j ++)&#123;            cout &lt;&lt; d[i][j] &lt;&lt; &#39; &#39; ;        &#125;        cout &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小步数模型"><a href="#最小步数模型" class="headerlink" title="最小步数模型"></a>最小步数模型</h2><p><a href="https://www.acwing.com/activity/content/problem/content/1475/">魔板</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;map&gt;#include&lt;queue&gt;using namespace std;char a[10],b[10];map&lt;string,int&gt; dist;&#x2F;&#x2F;&#123;字符串，变化次数&#125;map&lt;string,pair&lt;char,string&gt;&gt; pre; &#x2F;&#x2F;&#123;新字符串，&#123;A&#x2F;B&#x2F;C，原字符串&#125;&#125;string eend;&#x2F;&#x2F;用end有歧义string get(string t, int op)&#123;    string k;    if( op &#x3D;&#x3D; 0 ) k &#x3D; &#123;t[7], t[6], t[5], t[4], t[3], t[2], t[1], t[0]&#125;;&#x2F;&#x2F;&#39;A&#39;    if( op &#x3D;&#x3D; 1 ) k &#x3D; &#123;t[3], t[0], t[1], t[2], t[5], t[6], t[7], t[4]&#125;;&#x2F;&#x2F;&#39;B&#39;    if( op &#x3D;&#x3D; 2 ) k &#x3D; &#123;t[0], t[6], t[1], t[3], t[4], t[2], t[5], t[7]&#125;;&#x2F;&#x2F;&#39;C&#39;    return k;&#125;int bfs()&#123;    string s &#x3D; &quot;12345678&quot;;    queue&lt;string&gt; q;    dist[s] &#x3D; 0;    q.push(s);        while(!q.empty())    &#123;        auto t &#x3D; q.front();        q.pop();        if(t &#x3D;&#x3D; eend) return dist[t];        for(int i &#x3D; 0 ; i &lt; 3 ; i ++ )        &#123;            string s &#x3D; get(t,i);            if(!dist.count(s))            &#123;                dist[s] &#x3D; dist[t] + 1;                pre[s] &#x3D; &#123;&#39;A&#39; + i, t&#125;;                q.push(s);            &#125;        &#125;    &#125;&#125;int main()&#123;    string start &#x3D; &quot;12345678&quot;, res;    for(int i &#x3D; 1 ; i &lt;&#x3D; 8 ; i ++ ) cin &gt;&gt; a[i];        for(int i &#x3D; 1 ; i &lt;&#x3D; 8 ; i ++ ) eend.push_back(a[i]);        cout &lt;&lt; bfs() &lt;&lt; endl;    while(eend !&#x3D; start)    &#123;        res +&#x3D; pre[eend].first;        eend &#x3D; pre[eend].second;    &#125;        reverse(res.begin(), res.end());    cout &lt;&lt; res ;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向广搜"><a href="#双向广搜" class="headerlink" title="双向广搜"></a>双向广搜</h2><p>一般用到最小步数模型里，而不是flood fill和最短路模型里</p><p><a href="https://www.acwing.com/problem/content/192/">字串变换</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;map&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 6;int n;string A,B; &#x2F;&#x2F;A是起始串，B是终止串string a[N], b[N];&#x2F;&#x2F;a存储A字串，b存储B字串int extend(queue&lt;string&gt;&amp; q, unordered_map&lt;string,int&gt;&amp; da, unordered_map&lt;string,int&gt;&amp; db, string a[N], string b[N])&#123;    int d &#x3D; da[q.front()];    while(q.size() &amp;&amp; da[q.front()] &#x3D;&#x3D; d)    &#123;        auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; 0; i &lt; n ; i ++ )&#x2F;&#x2F;遍历所有规则            for(int j &#x3D; 0 ; j &lt; t.size() ; j ++ ) &#x2F;&#x2F;遍历串                if(t.substr(j, a[i].size()) &#x3D;&#x3D; a[i]) &#x2F;&#x2F;如果能够转换                &#123;                    string r &#x3D; t.substr(0, j) + b[i] + t.substr(j + a[i].size()); &#x2F;&#x2F;a串换为b串                    if(db.count(r)) return da[t] + db[r] + 1;                    if(da.count(r)) continue;                    da[r] &#x3D; da[t] + 1;                    q.push(r);                &#125;    &#125;    return 11;&#125;int bfs()&#123;    &#x2F;&#x2F;BFS的扩展方式是：分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则。    if(A &#x3D;&#x3D; B) return 0;    queue&lt;string&gt; qa, qb;    unordered_map&lt;string, int&gt; da,db;&#x2F;&#x2F;分别存储转换到该串需要几次        qa.push(A), qb.push(B);    da[A] &#x3D; db[B] &#x3D; 0;        int step &#x3D; 0;    while(qa.size() &amp;&amp; qb.size())    &#123;        int t;        if(qa.size() &lt; qb.size()) t &#x3D; extend(qa, da, db, a, b); &#x2F;&#x2F;从前往后扩展是a-&gt;b        else t &#x3D; extend(qb, db, da, b ,a);&#x2F;&#x2F;从后往前扩展是b-&gt;a                if(t &lt;&#x3D; 10) return t;        if(++step &#x3D;&#x3D; 10) return -1;    &#125;        return -1;&#125;int main()&#123;    cin &gt;&gt; A &gt;&gt; B;    while(cin &gt;&gt; a[n] &gt;&gt; b[n]) n++;        int t &#x3D; bfs();    if(t &#x3D;&#x3D; -1) puts(&quot;NO ANSWER!&quot;);    else cout &lt;&lt; t &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双端队列广搜"><a href="#双端队列广搜" class="headerlink" title="双端队列广搜"></a>双端队列广搜</h2><p>只包含0和1的两种边权重类型的最短路问题</p><p><strong>若扩展出来的边权重是0，则插入到队头，若为1，则插入到队尾</strong></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304182235040.png"></p><p><a href="https://www.acwing.com/problem/content/177/">电路维修</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304182249391.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 510, M &#x3D; N * N;int n, m;char g[N][N];int dist[N][N];int bfs()&#123;    memset(dist, 0x3f, sizeof dist);    dist[0][0] &#x3D; 0;    deque&lt;PII&gt; q;    q.push_back(&#123;0,0&#125;);        char cs[] &#x3D; &quot;\\&#x2F;\\&#x2F;&quot; ; &#x2F;&#x2F;存储的是\&#x2F;\&#x2F;，因为\是转义，所以写两个    int dx[4] &#x3D; &#123;-1,-1,1,1&#125;, dy[4] &#x3D; &#123;-1,1,1,-1&#125;; &#x2F;&#x2F;枚举每个点的对角线上的点    int ix[4] &#x3D; &#123;-1,-1,0,0&#125;, iy[4] &#x3D; &#123;-1,0,0,-1&#125;; &#x2F;&#x2F;枚举某个点的邻边        while(q.size())    &#123;        PII t &#x3D; q.front();        q.pop_front();                for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )        &#123;            int a &#x3D; t.x + dx[i], b &#x3D; t.y + dy[i];            if(a &lt; 0 || a &gt; n || b &lt; 0 || b &gt; m) continue;                        int ca &#x3D; t.x + ix[i], cb &#x3D; t.y + iy[i];            int d &#x3D; dist[t.x][t.y] + (g[ca][cb] !&#x3D; cs[i]);                        if(d &lt; dist[a][b])            &#123;                dist[a][b] &#x3D; d;                if(g[ca][cb] !&#x3D; cs[i]) q.push_back(&#123;a,b&#125;);&#x2F;&#x2F;需要变化时插尾                else q.push_front(&#123;a,b&#125;); &#x2F;&#x2F;不需要变化时插头            &#125;        &#125;    &#125;        return dist[n][m];&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T--)    &#123;        cin &gt;&gt; n &gt;&gt; m;        for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; g[i];                if(n + m &amp; 1) puts(&quot;NO SOLUTION&quot;); &#x2F;&#x2F;奇数点一定无解        else cout &lt;&lt; bfs() &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h2><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211141558143.png" alt="image-20221114155831954"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211141558743.png" alt="image-20221114155854649"></p><p>f[state]是state到终点的估计距离，g[state]是state到终点的真实距离</p><p>d[state]是起点到state的距离</p><p>A*算法必须保证f[state] &lt;= g[state]</p><p><strong>一定保证有解才可以搜，否则不如普通bfs</strong></p><p><a href="https://www.acwing.com/problem/content/181/">八数码</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;unordered_map&gt;using namespace std;&#x2F;&#x2F;估价函数：当前状态中每个数与它的目标位置的曼哈顿距离之和int f(string state)&#x2F;&#x2F;求曼哈顿距离&#123;    int res &#x3D; 0;    for (int i &#x3D; 0; i &lt; state.size(); i ++ )        if (state[i] !&#x3D; &#39;x&#39;)        &#123;            int t &#x3D; state[i] - &#39;1&#39;;            res +&#x3D; abs(i &#x2F; 3 - t &#x2F; 3) + abs(i % 3 - t % 3);        &#125;    return res;&#125;string bfs(string start)&#123;    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;    char op[4] &#x3D; &#123;&#39;u&#39;, &#39;r&#39;, &#39;d&#39;, &#39;l&#39;&#125;;    string end &#x3D; &quot;12345678x&quot;;    unordered_map&lt;string, int&gt; dist; &#x2F;&#x2F;存储实际距离    unordered_map&lt;string, pair&lt;string, char&gt;&gt; prev;&#x2F;&#x2F; &#123;新串，&#123;源串，变换记录&#125;&#125;    priority_queue&lt;pair&lt;int, string&gt;, vector&lt;pair&lt;int, string&gt;&gt;, greater&lt;pair&lt;int, string&gt;&gt;&gt; heap;&#x2F;&#x2F;小根堆    heap.push(&#123;f(start), start&#125;);    dist[start] &#x3D; 0;    while (heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();        string state &#x3D; t.second;        if (state &#x3D;&#x3D; end) break;        int step &#x3D; dist[state];        int x, y;        for (int i &#x3D; 0; i &lt; state.size(); i ++ )            if (state[i] &#x3D;&#x3D; &#39;x&#39;)            &#123;                x &#x3D; i &#x2F; 3, y &#x3D; i % 3;&#x2F;&#x2F;找到x的横纵坐标                break;            &#125;        string source &#x3D; state;        for (int i &#x3D; 0; i &lt; 4; i ++ ) &#x2F;&#x2F;扩展x        &#123;            int a &#x3D; x + dx[i], b &#x3D; y + dy[i];            if (a &gt;&#x3D; 0 &amp;&amp; a &lt; 3 &amp;&amp; b &gt;&#x3D; 0 &amp;&amp; b &lt; 3)            &#123;                swap(state[x * 3 + y], state[a * 3 + b]);                if (!dist.count(state) || dist[state] &gt; step + 1)                 &#x2F;&#x2F;除了终点之外，当第一次搜到某个点的时候，距离不一定是最短的，其dist[]的值是不断变小的，所以要加后面一个判断                &#123;                    dist[state] &#x3D; step + 1;                    prev[state] &#x3D; &#123;source, op[i]&#125;;                    heap.push(&#123;dist[state] + f(state), state&#125;);&#x2F;&#x2F;实际距离加估算距离放入堆                &#125;                swap(state[x * 3 + y], state[a * 3 + b]);            &#125;        &#125;    &#125;    string res;    while (end !&#x3D; start)    &#123;        res +&#x3D; prev[end].second;        end &#x3D; prev[end].first;    &#125;    reverse(res.begin(), res.end());    return res;&#125;int main()&#123;    string g, c, seq;&#x2F;&#x2F;seq存储无x的字符串    while (cin &gt;&gt; c)    &#123;        g +&#x3D; c;        if (c !&#x3D; &quot;x&quot;) seq +&#x3D; c;    &#125;    int t &#x3D; 0;&#x2F;&#x2F;求逆序对个数    for (int i &#x3D; 0; i &lt; seq.size(); i ++ )        for (int j &#x3D; i + 1; j &lt; seq.size(); j ++ )            if (seq[i] &gt; seq[j])                t ++ ;    if (t % 2) puts(&quot;unsolvable&quot;);&#x2F;&#x2F;奇数个逆序对无解    else cout &lt;&lt; bfs(g) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/180/">第K短路</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef pair&lt;int, PII&gt; PIII;const int N &#x3D; 1010, M &#x3D; 200010;int n,m,S,T,K;int h[N],rh[N],e[M],w[M],ne[M],idx;int dist[N],cnt[N];bool st[N];void add(int h[],int a,int b,int c)&#123;    e[idx] &#x3D; b,w[idx] &#x3D; c,ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;&#125;&#x2F;&#x2F;估计距离：通过反向邻接表djkstra算法求出终点到所有点的最短距离void djsktra()&#123;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0,T&#125;);        memset(dist, 0x3f,sizeof dist);    dist[T] &#x3D; 0;        while(heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.y;        if(st[ver])  continue;        st[ver] &#x3D; true;                for(int i &#x3D; rh[ver]; ~i; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(dist[j] &gt; dist[ver] + w[i])            &#123;                dist[j] &#x3D; dist[ver] + w[i];                 heap.push(&#123;dist[j],j&#125;);            &#125;        &#125;    &#125;&#125;int astar()&#123;    priority_queue&lt;PIII,vector&lt;PIII&gt;,greater&lt;PIII&gt;&gt; heap;    heap.push(&#123;dist[S],&#123;0,S&#125;&#125;);        while(heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.y.y, distance &#x3D; t.y.x;        cnt[ver] ++ ;        if(cnt[T] &#x3D;&#x3D; K) return distance;                for(int i &#x3D; h[ver]; ~i ; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(cnt[j] &lt; K)                heap.push(&#123;distance + w[i] + dist[j], &#123;distance + w[i], j&#125;&#125;);        &#125;    &#125;        return -1;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h); &#x2F;&#x2F;正向邻接表    memset(rh, -1, sizeof rh); &#x2F;&#x2F;反向邻接表        for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a,b,c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(h, a, b, c);        add(rh, b, a, c);    &#125;        cin &gt;&gt; S &gt;&gt; T &gt;&gt; K;    if(S &#x3D;&#x3D; T)  K ++ ;        djsktra();    cout &lt;&lt; astar() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h1><h2 id="连通性模型"><a href="#连通性模型" class="headerlink" title="连通性模型"></a>连通性模型</h2><p><a href="https://www.acwing.com/problem/content/1114/">迷宫</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110;int Q;int dx[4] &#x3D; &#123;-1,0,1,0&#125;, dy[4] &#x3D; &#123;0,1,0,-1&#125;;bool st[N][N];char g[N][N];int n;int ha, la, hb, lb;bool dfs(int ha,int la)&#123;    if(g[ha][la] &#x3D;&#x3D; &#39;#&#39;) return false;    if(ha &#x3D;&#x3D; hb &amp;&amp; la &#x3D;&#x3D; lb)&#123;        return true;    &#125;    st[ha][la] &#x3D; true;    for(int i &#x3D; 0; i &lt; 4 ; i ++ )&#123;        int x &#x3D; ha + dx[i] , y &#x3D; la + dy[i];                if(x &lt; 0 || x &gt;&#x3D; n || y &lt; 0 || y &gt;&#x3D; n ) continue;        if(st[x][y]) continue;        if(dfs(x,y)) return true;    &#125;        return false;&#125;int main()&#123;    cin &gt;&gt; Q;    while(Q--)&#123;        memset (st,false,sizeof (st));        cin &gt;&gt; n;        for(int i &#x3D; 0; i &lt; n ; i ++ )&#123;            for(int j &#x3D; 0; j &lt; n ; j ++ )&#123;                cin &gt;&gt; g[i][j];            &#125;        &#125;        cin &gt;&gt; ha &gt;&gt; la &gt;&gt; hb &gt;&gt; lb;        if(dfs(ha,la)) cout &lt;&lt;&quot;YES&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1115/">红与黑</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 25;int w,h;char g[N][N];bool st[N][N];int dx[4] &#x3D; &#123;-1,0,1,0&#125;, dy[4] &#x3D; &#123;0,1,0,-1&#125;;int dfs(int x,int y)&#123;    int cnt &#x3D; 1;    st[x][y] &#x3D; true;    for(int i &#x3D; 0 ; i &lt; 4 ; i ++ )&#123;        int a &#x3D; x + dx[i], b &#x3D; y + dy[i];        if(a &lt; 0 || a &gt;&#x3D; h || b &lt; 0 || b &gt;&#x3D; w) continue;        if(st[a][b] || g[a][b] &#x3D;&#x3D; &#39;#&#39;) continue;        cnt +&#x3D; dfs(a,b);    &#125;        return cnt;&#125;int main()&#123;    while(cin &gt;&gt; w &gt;&gt; h , w || h)&#123;        int x,y;        for(int i &#x3D; 0 ; i &lt; h ; i ++ )            for(int j &#x3D; 0 ; j &lt; w ; j ++ )                &#123;                    cin &gt;&gt; g[i][j];                    if(g[i][j] &#x3D;&#x3D; &#39;@&#39;)                     &#123;                        x &#x3D; i, y &#x3D; j;                    &#125;                &#125;        memset(st, 0, sizeof st);        cout &lt;&lt; dfs(x,y) &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="搜索顺序"><a href="#搜索顺序" class="headerlink" title="搜索顺序"></a>搜索顺序</h2><p>当为内部搜索，比如一个棋盘它本身的状态进行改变时，需要用到中间状态，则需要回溯；当为外部搜索，比如一个棋盘某个点到另一个点的连通性，不用考虑中间状态，则不需要回溯</p><p><a href="https://www.acwing.com/problem/content/1118/">马走日</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 10;int T;int n,m;int x,y;int g[N][N];bool st[N][N];int dx[8] &#x3D; &#123;-2,-1,1,2,2,1,-1,-2&#125;, dy[8] &#x3D; &#123;1,2,2,1,-1,-2,-2,-1&#125;;int res;void dfs(int x,int y,int cnt)&#123;        if(cnt &#x3D;&#x3D; n * m)&#123;        res ++ ;        return ;    &#125;        st[x][y] &#x3D; true;        for(int i &#x3D; 0 ; i &lt; 8 ; i ++ )&#123;        int a &#x3D; x + dx[i], b &#x3D; y + dy[i];        if(a &lt; 0 || a &gt;&#x3D; n || b &lt; 0 || b &gt;&#x3D; m ) continue;        if(st[a][b]) continue;                dfs(a,b, cnt + 1);    &#125;         st[x][y] &#x3D; false;&#125;int main()&#123;    cin &gt;&gt; T;    while(T --)&#123;        cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;        res &#x3D; 0;        dfs(x, y, 1);        cout &lt;&lt; res  &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1119/">单词接龙</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 25;int n;string word[N];int g[N][N];&#x2F;&#x2F;g[i][j] 表示word[i]的后缀和word[j]的前缀的最小相同长度int used[N];int res;void dfs(string dragon,int last)&#123;&#x2F;&#x2F;last表示上个字符串下标    res &#x3D; max((int)dragon.size(), res);    used[last] ++ ;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        if(g[last][i] &amp;&amp; used[i] &lt; 2)&#123;            dfs(dragon + word[i].substr(g[last][i]), i);            &#x2F;&#x2F;substr()函数若只有一个参数，说明是从某个位置到末尾            &#x2F;&#x2F;该语句是将龙头加上新的拼接字符串作为新的龙头，进而不断递归        &#125;    &#125;        used[last] -- ;&#125; int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        cin &gt;&gt; word[i];    &#125;        char start;    cin &gt;&gt; start;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;            string a &#x3D; word[i], b &#x3D; word[j];            for(int k &#x3D; 1 ; k &lt; min(a.size(), b.size()); k ++ )&#123;                if(a.substr(a.size() - k, k) &#x3D;&#x3D; b.substr(0,k))&#123;                    g[i][j] &#x3D; k;                    break;                &#125;            &#125;        &#125;    &#125;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        if(word[i][0] &#x3D;&#x3D; start)            dfs(word[i], i);    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1120/">分成互质组</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 10;int n;int p[N];int group[N][N];&#x2F;&#x2F;group[i]表示第i组中下标对应的p数组中的数互质bool st[N];int res &#x3D; N; &#x2F;&#x2F;最坏情况分为N组int gcd(int a,int b)&#123; &#x2F;&#x2F;判断是否互质(求最大公因数)    return b ?gcd(b, a % b): a;&#125;bool check(int group[],int gc,int i)&#123;    for(int j &#x3D; 0 ; j &lt; gc ; j ++ )&#123;        if(gcd(p[group[j]], p[i]) &gt; 1)        return false;    &#125;    return true;&#125;&#x2F;&#x2F;g表示当前做到了哪一组，gc表示当前枚举到组内的第几个元素，tc表示当前一共处理多少个数，start表示组内从哪个数开始枚举void dfs(int g,int gc,int tc,int start)&#123;    if(g &gt;&#x3D; res) return ;    if(tc &#x3D;&#x3D; n) res &#x3D; g; &#x2F;&#x2F;所有数均处理完        bool flag &#x3D; true;    for(int i &#x3D; start ; i &lt; n ; i ++ ) &#123;        if(!st[i] &amp;&amp; check(group[g], gc, i))        &#123;            st[i] &#x3D; true;            group[g][gc] &#x3D; i;            dfs(g, gc + 1, tc + 1, i + 1);            st[i] &#x3D; false;            flag &#x3D; false;        &#125;    &#125;        if(flag) dfs(g + 1,0, tc, 0); &#x2F;&#x2F;如果没找到互质的，则开启下一组    return ;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; p[i];        dfs(1,0,0,0);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="剪枝与优化"><a href="#剪枝与优化" class="headerlink" title="剪枝与优化"></a>剪枝与优化</h2><p> <img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211152120432.png"></p><p><a href="https://www.acwing.com/problem/content/167/">小猫爬山</a></p><p>1 -&gt; 猫按照重量由大到小排序，先放重猫（优先考虑决策少的方案）</p><p>3 -&gt; 当前某个猫放到车上超出车承重，直接删去</p><p>4 -&gt; 某个方案大于res，直接剪枝</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 20;int cat[N], cab[N];int n, w;int res &#x3D; N;bool cmp(int a,int b)&#123;    return a &gt; b;&#125;&#x2F;&#x2F;第u条猫，第k辆车void dfs(int u, int k)&#123;    &#x2F;&#x2F;最优性剪枝    if(k &gt;&#x3D; res) return ;    if(u &#x3D;&#x3D; n)&#123;        res &#x3D; k;        return ;    &#125;         for(int i &#x3D; 0 ; i &lt; k ; i ++ )&#123;        if(cab[i] + cat[u] &lt;&#x3D; w)&#123;            cab[i] +&#x3D; cat[u];            dfs(u + 1, k);            cab[i] -&#x3D; cat[u];        &#125;    &#125;        &#x2F;&#x2F;新开一辆车    cab[k] &#x3D; cat[u];    dfs(u + 1, k + 1);    cab[k] &#x3D; 0;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; w;        for(int i &#x3D; 0 ; i &lt; n ; i++ ) cin &gt;&gt; cat[i];        sort(cat, cat + n, cmp);        dfs(0,0);        cout &lt;&lt; res &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/168/">数独</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 9, M &#x3D; 1 &lt;&lt; N;&#x2F;&#x2F;用一个二进制数表示当前行，或列或方格的状态，如100110010，则表示可填的是1,4,5,8int ones[M], map[M];&#x2F;&#x2F;ones保存每个状态有多少个1，map[i]保存lg(i)为多少int row[N], col[N], cell[3][3];char str[100];void init()&#123;    for (int i &#x3D; 0; i &lt; N; i ++ )        row[i] &#x3D; col[i] &#x3D; (1 &lt;&lt; N) - 1;    for (int i &#x3D; 0; i &lt; 3; i ++ )        for (int j &#x3D; 0; j &lt; 3; j ++ )            cell[i][j] &#x3D; (1 &lt;&lt; N) - 1;&#125;void draw(int x, int y, int t, bool is_set)&#x2F;&#x2F;若is_set是true，则是在(x,y)添加t，若is_set是false，则是删去(x,y)这个数 &#123;    if (is_set) str[x * N + y] &#x3D; &#39;1&#39; + t;    else str[x * N + y] &#x3D; &#39;.&#39;;    int v &#x3D; 1 &lt;&lt; t;    if (!is_set) v &#x3D; -v;    row[x] -&#x3D; v;    col[y] -&#x3D; v;    cell[x &#x2F; 3][y &#x2F; 3] -&#x3D; v;&#125;int lowbit(int x)&#x2F;&#x2F;返回二进制的最后一位1&#123;    return x &amp; -x;&#125;int get(int x, int y)&#x2F;&#x2F;找到所有可填的二进制状态&#123;    return row[x] &amp; col[y] &amp; cell[x &#x2F; 3][y &#x2F; 3];&#125;bool dfs(int cnt)&#123;    if (!cnt) return true;    int minv &#x3D; 10;    int x, y;    for (int i &#x3D; 0; i &lt; N; i ++ )        for (int j &#x3D; 0; j &lt; N; j ++ )            if (str[i * N + j] &#x3D;&#x3D; &#39;.&#39;)            &#123;                int state &#x3D; get(i, j);                if (ones[state] &lt; minv)                &#123;                    minv &#x3D; ones[state];                    x &#x3D; i, y &#x3D; j;                &#125;            &#125;    int state &#x3D; get(x, y);    for (int i &#x3D; state; i; i -&#x3D; lowbit(i))    &#123;        int t &#x3D; map[lowbit(i)];        draw(x, y, t, true);        if (dfs(cnt - 1)) return true;        draw(x, y, t, false);    &#125;    return false;&#125;int main()&#123;    for (int i &#x3D; 0; i &lt; N; i ++ ) map[1 &lt;&lt; i] &#x3D; i;    for (int i &#x3D; 0; i &lt; 1 &lt;&lt; N; i ++ )        for (int j &#x3D; 0; j &lt; N; j ++ )            ones[i] +&#x3D; i &gt;&gt; j &amp; 1;    while (cin &gt;&gt; str, str[0] !&#x3D; &#39;e&#39;)    &#123;        init();        int cnt &#x3D; 0;        for (int i &#x3D; 0, k &#x3D; 0; i &lt; N; i ++ )            for (int j &#x3D; 0; j &lt; N; j ++, k ++ )                if (str[k] !&#x3D; &#39;.&#39;)                &#123;                    int t &#x3D; str[k] - &#39;1&#39;;                    draw(i, j, t, true);                &#125;                else cnt ++ ;        dfs(cnt);        puts(str);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/168/">木棒</a></p><p>先从小到大枚举木棒的长度，对于每个长度，从前往后依此拼接木棍，从而找到合法方案</p><p>1 -&gt; 先枚举长度更长的木棍</p><p>2 -&gt; 排除等效冗余:（1）按照组合数的方式枚举（2）如果当前木棍加到当前棒中失败了，则直接略过后面所有长度相等的木棍</p><p>​        （3）如果木棒的第一根木棍失败了，则该方案一定失败（4）如果木棒的最后一根木棍失败了，则该方案一定失败</p><p>3 -&gt; 只枚举木棍长度和sum的约数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 70;int n;int w[N];int sum,length;bool st[N];bool dfs(int u,int cur,int start) &#x2F;&#x2F;u枚举木棒的个数，cur表示当前已经接上木棍的长度，start表示枚举的木棍下标&#123;    if(u * length &#x3D;&#x3D; sum) return true;    if(cur &#x3D;&#x3D; length) return dfs(u + 1, 0, 0);        &#x2F;&#x2F;剪枝3-1，i从start开始枚举    for(int i &#x3D; start; i &lt; n ; i ++ )    &#123;        if(st[i] || cur + w[i] &gt; length) continue; &#x2F;&#x2F;可行性剪枝                st[i] &#x3D; true;        if(dfs(u,cur + w[i], i + 1)) return true;        st[i] &#x3D; false;                &#x2F;&#x2F;剪枝3-3和3-4        if(!cur || cur + w[i] &#x3D;&#x3D; length) return false;                &#x2F;&#x2F;剪枝3-2        int j &#x3D; i;        while(j &lt; n &amp;&amp; w[j] &#x3D;&#x3D; w[i]) j ++ ;        i &#x3D; j - 1;    &#125;        return false;&#125;int main()&#123;    while(cin &gt;&gt; n, n)    &#123;        memset(st,0,sizeof st);        sum &#x3D; 0;                for(int i &#x3D; 0; i &lt; n ; i ++ )        &#123;            cin &gt;&gt; w[i];            sum +&#x3D; w[i];        &#125;                &#x2F;&#x2F;剪枝2，优化搜索顺序        sort(w,w+n);        reverse(w,w+n);                length &#x3D; 1;        while(true)        &#123;            &#x2F;&#x2F;剪枝1            if(sum % length &#x3D;&#x3D; 0 &amp;&amp; dfs(0,0,0))            &#123;                cout &lt;&lt; length &lt;&lt; endl;                break;            &#125;            length ++ ;        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/170/">生日蛋糕</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211161030094.png" alt="image-20221116103052877"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N &#x3D; 25, INF &#x3D; 1e9;int n,m;int minv[N],mins[N];&#x2F;&#x2F;前若干层的体积最小值和面积最小值int R[N], H[N];&#x2F;&#x2F;每一层的半径和高度int res &#x3D; INF;void dfs(int u,int v,int s) &#x2F;&#x2F;u枚举的层数，v当前枚举体积,s当前枚举表面积&#123;    if(v + minv[u] &gt; n) return;    if(s + mins[u] &gt;&#x3D; res) return;    if(s + 2 * (n - v) &#x2F; R[u + 1] &gt;&#x3D; res) return ;        if(!u)    &#123;        if(v &#x3D;&#x3D; n) res &#x3D; s;        return ;    &#125;        for(int r &#x3D; min(R[u+1] - 1,(int)sqrt(n-v)); r &gt;&#x3D; u; r --)        for(int h &#x3D; min(H[u+1] - 1,(n-v) &#x2F;r &#x2F;r ); h &gt;&#x3D; u;h -- )        &#123;            int t &#x3D; 0;            if(u &#x3D;&#x3D; m) t &#x3D; r * r;            R[u] &#x3D; r,H[u] &#x3D; h;            dfs(u - 1, v + r * r * h, s + 2 * r * h + t);        &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++ )    &#123;        minv[i] &#x3D; minv[i-1] + i * i * i;        mins[i] &#x3D; mins[i-1] + 2 * i * i;    &#125;    R[m + 1] &#x3D; H[m + 1] &#x3D; INF;        dfs(m, 0, 0);        if(res &#x3D;&#x3D; INF) res &#x3D; 0;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h2><p>适合于某些分支特别深，但是答案在比较浅的分支的问题</p><p><a href="https://www.acwing.com/problem/content/172/">加成序列</a></p><p>剪枝1：优先枚举较大的数</p><p>剪枝2：排除等效冗余，如果某两对数和相等，只需要枚举其中一对</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110;int path[N] ;int n;&#x2F;&#x2F;u当前迭代的点，k当前迭代的层数bool dfs(int u,int k)&#123;    if(u &#x3D;&#x3D; k) return path[u - 1] &#x3D;&#x3D; n;         bool st[N] &#x3D; &#123;0&#125;;    for(int i &#x3D; u - 1; i &gt;&#x3D; 0 ; i -- )&#123;        for(int j &#x3D; i ; j &gt;&#x3D; 0 ; j -- )&#123;            int s &#x3D; path[i] + path[j];            if(s &gt; n || s &lt;&#x3D; path[u - 1] || st[s]) continue;            st[s] &#x3D; true;            path[u] &#x3D; s;            if(dfs(u + 1, k)) return true;        &#125;    &#125;        return false;&#125;int main()&#123;    path[0] &#x3D; 1;    while(cin &gt;&gt; n , n)&#123;        int k &#x3D; 1;        while(!dfs(1, k)) k ++ ;        for(int i &#x3D; 0 ; i &lt; k ; i ++ )&#123;            cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="双向DFS"><a href="#双向DFS" class="headerlink" title="双向DFS"></a>双向DFS</h2><p><a href="https://www.acwing.com/problem/content/173/">送礼物</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211161937320.png"></p><p>其中k是指2^k与 2^(N-k)*k相接近最合适的数，这里取了n/2</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202211161939441.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long LL;const int N &#x3D; 1 &lt;&lt; 24;int n, m, k;int g[50], weights[N];int cnt &#x3D; 0;int ans;void dfs(int u, int s)&#123;    if (u &#x3D;&#x3D; k)    &#123;        weights[cnt ++ ] &#x3D; s;        return;    &#125;    if ((LL)s + g[u] &lt;&#x3D; m) dfs(u + 1, s + g[u]);    dfs(u + 1, s);&#125;void dfs2(int u, int s)&#123;    if (u &#x3D;&#x3D; n)    &#123;        int l &#x3D; 0, r &#x3D; cnt - 1;        while (l &lt; r)        &#123;            int mid &#x3D; l + r + 1 &gt;&gt; 1;            if (weights[mid] + (LL)s &lt;&#x3D; m) l &#x3D; mid;            else r &#x3D; mid - 1;        &#125;        if (weights[l] + (LL)s &lt;&#x3D; m) ans &#x3D; max(ans, weights[l] + s);        return;    &#125;    if ((LL)s + g[u] &lt;&#x3D; m) dfs2(u + 1, s + g[u]);    dfs2(u + 1, s);&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++ ) cin &gt;&gt; g[i];    sort(g, g + n);    reverse(g, g + n);    k &#x3D; n &#x2F; 2;  &#x2F;&#x2F; 防止 n &#x3D; 1时，出现死循环    dfs(0, 0);    sort(weights, weights + cnt);    int t &#x3D; 1;    for (int i &#x3D; 1; i &lt; cnt; i ++ )        if (weights[i] !&#x3D; weights[i - 1])            weights[t ++ ] &#x3D; weights[i];    cnt &#x3D; t;    dfs2(k, 0);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int N &#x3D; 46;int n,m,k;int w[N];int weights[1 &lt;&lt; 25], cnt &#x3D; 1;int ans; &#x2F;&#x2F;全局最小值&#x2F;&#x2F;u是当前枚举到的数,s是当前的和void dfs1(int u,int s)&#123;    if(u &#x3D;&#x3D; k)&#123;        weights[cnt ++ ] &#x3D; s;        return ;    &#125;        dfs1(u + 1, s) ; &#x2F;&#x2F;不选当前的物品    if((LL)s + w[u] &lt;&#x3D; m) dfs1(u + 1, s + w[u]); &#x2F;&#x2F;选当前物品&#125;void dfs2(int u,int s)&#123;    if(u &gt;&#x3D; n)&#123; &#x2F;&#x2F;二分求出w - s的最大值        int l &#x3D; 0 , r &#x3D; cnt - 1;        while(l &lt; r)&#123;            int mid &#x3D; l + r + 1 &gt;&gt; 1;            if(weights[mid] &lt;&#x3D; m - s) l &#x3D; mid;            else r &#x3D; mid - 1;        &#125;                ans &#x3D; max(ans, weights[l] + s);        return ;    &#125;        dfs2(u + 1, s);    if((LL) s + w[u] &lt;&#x3D; m) dfs2(u + 1, s + w[u]);&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; w[i];        sort(w, w + n);    reverse(w, w + n);        k &#x3D; n &gt;&gt; 1;    dfs1(0, 0);        sort(weights, weights + cnt);    cnt &#x3D; unique(weights, weights + cnt) - weights; &#x2F;&#x2F;判重        dfs2(k, 0);        cout &lt;&lt; ans &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h2><p><a href="https://www.acwing.com/problem/content/182/">排书</a></p><p>估价函数：total/3上取整（total存的是错误后继的数量，后面一个数比前面一个大1就是一个正确的后继</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 15;int n;int q[N]; &#x2F;&#x2F; 存储该序列int w[5][N]; &#x2F;&#x2F; 存储现场，方便恢复现场int f() &#x2F;&#x2F; 估价函数&#123;    int cnt &#x3D; 0;    for(int i &#x3D; 0 ; i + 1 &lt; n ; i ++ )        if(q[i + 1] !&#x3D; q[i] + 1)            cnt ++ ;    return (cnt + 2) &#x2F; 3;&#125;bool check() &#x2F;&#x2F;检查是否有错误后继&#123;    for(int i &#x3D; 0; i + 1 &lt; n ; i ++ )        if(q[i + 1] !&#x3D; q[i] + 1)            return false;    return true;&#125;bool dfs(int depth, int max_depth)&#x2F;&#x2F;当前迭代深度，最大迭代深度&#123;    if (depth + f() &gt; max_depth) return false;    if (check()) return true;    for (int len &#x3D; 1; len &lt;&#x3D; n; len ++ )        for (int l &#x3D; 0; l + len - 1 &lt; n; l ++ )        &#123;            int r &#x3D; l + len - 1;            for (int k &#x3D; r + 1; k &lt; n; k ++ )            &#123;                memcpy(w[depth], q, sizeof q);                int x, y;                for (x &#x3D; r + 1, y &#x3D; l; x &lt;&#x3D; k; x ++, y ++ ) q[y] &#x3D; w[depth][x];                for (x &#x3D; l; x &lt;&#x3D; r; x ++, y ++ ) q[y] &#x3D; w[depth][x];                if (dfs(depth + 1, max_depth)) return true;                memcpy(q, w[depth], sizeof q);            &#125;        &#125;    return false;&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T --)    &#123;        cin &gt;&gt; n;        for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; q[i];        int depth &#x3D; 0;        while(depth &lt; 5 &amp;&amp; !dfs(0,depth)) depth ++ ;        if(depth &gt;&#x3D; 5) puts(&quot;5 or more&quot;);        else cout &lt;&lt; depth &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="">回转游戏</a></p><p>估价函数：设中间八个数重复次数最多的数是s次，则其估价函数为8-s</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*      0     1      2     34  5  6  7  8  9  10      11    1213 14 15 16 17 18 19      20    21      22    23*&#x2F;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 24;int op[8][7] &#x3D; &#123;    &#123;0, 2, 6, 11, 15, 20, 22&#125;,    &#123;1, 3, 8, 12, 17, 21, 23&#125;,    &#123;10, 9, 8, 7, 6, 5, 4&#125;,    &#123;19, 18, 17, 16, 15, 14, 13&#125;,    &#123;23, 21, 17, 12, 8, 3, 1&#125;,    &#123;22, 20, 15, 11, 6, 2, 0&#125;,    &#123;13, 14, 15, 16, 17, 18, 19&#125;,    &#123;4, 5, 6, 7, 8, 9, 10&#125;&#125;;int oppsite[8] &#x3D; &#123;5, 4, 7, 6, 1, 0, 3, 2&#125;;int center[8] &#x3D; &#123;6, 7, 8, 11, 12, 15, 16, 17&#125;;int q[N];int path[100];int f() &#x2F;&#x2F;估价函数&#123;    static int sum[4];    memset(sum, 0, sizeof sum);    for (int i &#x3D; 0; i &lt; 8; i ++ ) sum[q[center[i]]] ++ ;    int maxv &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; 3; i ++ ) maxv &#x3D; max(maxv, sum[i]);    return 8 - maxv;&#125;void operate(int x) &#x2F;&#x2F;模拟八个操作&#123;    int t &#x3D; q[op[x][0]];    for (int i &#x3D; 0; i &lt; 6; i ++ ) q[op[x][i]] &#x3D; q[op[x][i + 1]];    q[op[x][6]] &#x3D; t;&#125;bool dfs(int depth, int max_depth, int last) &#x2F;&#x2F;当前深度，最大深度，上个操作&#123;    if (depth + f() &gt; max_depth) return false;    if (f() &#x3D;&#x3D; 0) return true;    for (int i &#x3D; 0; i &lt; 8; i ++ )        if (last !&#x3D; oppsite[i])        &#123;            operate(i);            path[depth] &#x3D; i;            if (dfs(depth + 1, max_depth, i)) return true;            operate(oppsite[i]);        &#125;    return false;&#125;int main()&#123;    while (cin &gt;&gt; q[0], q[0])    &#123;        for (int i &#x3D; 1; i &lt; 24; i ++ ) cin &gt;&gt; q[i];        int depth &#x3D; 0;        while (!dfs(0, depth, -1)) depth ++ ;        if (!depth) printf(&quot;No moves needed&quot;);        else        &#123;            for (int i &#x3D; 0; i &lt; depth; i ++ ) printf(&quot;%c&quot;, &#39;A&#39; + path[i]);        &#125;        printf(&quot;\n%d\n&quot;, q[6]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="提高课（图论）"><a href="#提高课（图论）" class="headerlink" title="提高课（图论）"></a>提高课（图论）</h1><h2 id="单源最短路的建图方式"><a href="#单源最短路的建图方式" class="headerlink" title="单源最短路的建图方式"></a>单源最短路的建图方式</h2><p><a href="https://www.acwing.com/problem/content/1131/">热浪</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 2510, M &#x3D; 2*6210;int n,m,ts,te;int idx,e[M],ne[M],w[M],h[N];int d[N];bool st[N];void add(int a,int b,int c)&#123;    e[idx] &#x3D; b,w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;int dijkstra()&#123;    memset(d, 0x3f, sizeof d);    d[ts] &#x3D; 0;    priority_queue&lt;PII, vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0,ts&#125;);        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis + w[i])&#123;                d[j] &#x3D; dis + w[i];                heap.push(&#123;d[j], j&#125;);            &#125;        &#125;    &#125;        return d[te];&#125;int main()&#123;    memset(h, -1,sizeof h);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; ts &gt;&gt; te;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a,b,c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a,b,c);        add(b,a,c);    &#125;        int t &#x3D; dijkstra();    cout &lt;&lt; t &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1130/">信使</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 110, M &#x3D; 210 * 2;int idx,e[M],ne[M],w[M],h[N];int n,m;bool st[N];int d[N];void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c,ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;&#125;int dijkstra()&#123;    memset(d, 0x3f, sizeof d);    d[1] &#x3D; 0;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0, 1&#125;);        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1 ; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis + w[i])&#123;                d[j] &#x3D; dis + w[i];                heap.push(&#123;d[j], j&#125;);            &#125;        &#125;    &#125;    int res;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        if(d[i] &gt; 0x3f3f3f3f &#x2F;2 ) return -1;        res &#x3D; max(res, d[i]);    &#125;    return res;&#125;int main()&#123;    memset(h, -1,sizeof h);    cin &gt;&gt; n &gt;&gt; m ;    for(int i &#x3D; 0 ; i &lt;m ; i ++ )&#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);        add(b, a, c);    &#125;        int t &#x3D; dijkstra();    cout &lt;&lt; t &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1129/">香甜的黄油</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 810, M &#x3D; 1460 * 2;int n,p,c;int idx,e[M],ne[M],w[M],h[N];bool st[N];int d[N];int num[N];void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++;&#125;int dijkstra(int s)&#123;        memset(st, false, sizeof st);    memset(d, 0x3f, sizeof d);    d[s] &#x3D; 0;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0,s&#125;);        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis + w[i]) &#123;                d[j] &#x3D; dis + w[i];                heap.push(&#123;d[j], j&#125;);            &#125;        &#125;    &#125;    int ans &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++  )&#123;        if(d[num[i]] &gt; 0x3f3f3f3f &#x2F;2 ) return 0x3f3f3f3f;        ans +&#x3D; d[num[i]];    &#125;    return ans;&#125;int main()&#123;    memset(h, -1,sizeof h);    cin &gt;&gt; n &gt;&gt; p &gt;&gt; c;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; num[i];    for(int i &#x3D; 0 ; i &lt; c ; i ++ )&#123;        int x,y,z;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;        add(x,y,z);        add(y,x,z);    &#125;    int res &#x3D; 0x3f3f3f3f;    for(int i &#x3D; 1;  i &lt;&#x3D; p ; i ++ )  res &#x3D; min(res,dijkstra(i));    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1128/">最小花费</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;double,int&gt; PII;const int N  &#x3D; 2010, M &#x3D; 1e5 * 2 + 10;int idx,e[M], ne[M], w[M], h[N];int n, m, A, B;bool st[N];double d[N];void add(int a,int b,int c)&#123;    e[idx] &#x3D; b ,w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx++ ;&#125; double dijkstra()&#123;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ;  i++ ) d[i] &#x3D; 0x3f3f3f3f;    d[B] &#x3D; 100;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    heap.push(&#123;100,B&#125;);        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second;        double dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;        for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis  * 100 &#x2F;(100 - w[i]))&#123;                d[j] &#x3D; dis * 100 &#x2F;(100 - w[i]);                heap.push(&#123;d[j], j&#125;);            &#125;        &#125;    &#125;        return d[A];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h ,-1, sizeof h);    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        int a,b,c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(b, a, c);        add(a, b, c);    &#125;    cin &gt;&gt; A &gt;&gt; B;    double t &#x3D; dijkstra();    printf(&quot;%.8lf\n&quot;, t);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/922/">最优方案</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;sstream&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 510, M &#x3D; 110;int n,m;bool g[N][N];int d[N];bool st[N];int stop[N];void bfs()&#123;    memset(d, 0x3f, sizeof d);    queue&lt;int&gt; q;    q.push(1);    d[1] &#x3D; 0 ;    while(!q.empty())&#123;        auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++)&#123;            if(g[t][i] &amp;&amp; d[i] &gt; d[t] + 1)&#123;                d[i] &#x3D; d[t] + 1;                q.push(i);            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n ;    string line;    getline(cin,line); &#x2F;&#x2F;读入换行符    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        getline(cin ,line);        stringstream ssin(line);        int cnt &#x3D; 0, p ;        while(ssin &gt;&gt; p ) stop[cnt ++ ] &#x3D; p;        for(int j &#x3D; 0 ; j &lt; cnt ; j ++ )&#123;            for(int k &#x3D; j + 1 ; k &lt; cnt ; k ++ )&#123;                g[stop[j]][stop[k]] &#x3D; true;            &#125;        &#125;    &#125;        bfs();        if (d[n] &#x3D;&#x3D; 0x3f3f3f3f) puts(&quot;NO&quot;);    else cout &lt;&lt; max(d[n] - 1,0) &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/905/">昂贵的聘礼</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305022108097.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110, INF &#x3D; 0x3f3f3f3f;int m,n;int g[N][N];int d[N];int level[N];bool st[N];int dijkstra(int lmin, int lmax)&#123;    memset(d, 0x3f, sizeof d);    memset(st, false,sizeof st);    d[0] &#x3D; 0;    for(int i &#x3D; 0; i &lt; n ; i ++ )&#123;        int t &#x3D; -1;        for(int j &#x3D; 0 ; j &lt;&#x3D; n ; j ++ )&#123;            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || d[t] &gt; d[j]))                t &#x3D; j;        &#125;                for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )&#123;            if(level[j] &gt;&#x3D; lmin &amp;&amp; level[j] &lt;&#x3D; lmax)&#123;                d[j] &#x3D; min(d[j], d[t] + g[t][j]);            &#125;        &#125;        st[t] &#x3D; true;    &#125;        return d[1];&#125;int main()&#123;    memset(g, 0x3f, sizeof g);    for(int i &#x3D; 1 ; i &lt;&#x3D; n ;i ++ )&#123;        g[i][i] &#x3D; 0;    &#125;    cin &gt;&gt; m &gt;&gt; n;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        int p, l, x ;        cin &gt;&gt; p &gt;&gt; l &gt;&gt; x;        g[0][i] &#x3D; p;        level[i] &#x3D; l;        while(x -- )&#123;            int t, v;            cin &gt;&gt; t &gt;&gt; v;            g[t][i] &#x3D; v;        &#125;    &#125;    int res &#x3D; INF;    for(int i &#x3D; level[1] - m ; i &lt;&#x3D; level[1] ; i ++ ) res &#x3D; min(res, dijkstra(i, i + m));        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单源最短路的综合应用"><a href="#单源最短路的综合应用" class="headerlink" title="单源最短路的综合应用"></a>单源最短路的综合应用</h2><p><a href="https://www.acwing.com/problem/content/1137/">新年好</a></p><p>单源最短路+dfs暴搜</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 50010, M &#x3D; 1e5 * 2 + 10, INF &#x3D; 0x3f3f3f3f;int idx, e[M], ne[M], w[M], h[N];int n,m;bool st[N];int d[6][N];int source[6];void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dijkstra(int start, int dist[])&#123;    memset(st, false, sizeof st);    memset(dist, 0x3f, N * 4);    priority_queue&lt;PII,vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;    heap.push(&#123;0,start&#125;);    dist[start] &#x3D; 0;        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver] ; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(dist[j] &gt; dis + w[i])&#123;                dist[j] &#x3D; dis + w[i];                heap.push(&#123;dist[j], j&#125;);            &#125;        &#125;    &#125;&#125;&#x2F;&#x2F;u:枚举到第几个亲戚,start:从哪个亲戚出发,dis:当前的距离int dfs(int u,int start,int dis)&#123;    if(u &#x3D;&#x3D; 6) return dis;        int res &#x3D; INF;    for(int i &#x3D; 1; i &lt;&#x3D; 5 ; i++)&#123;        if(!st[i])&#123;            int next &#x3D; source[i];            st[i] &#x3D; true;            res &#x3D; min(res,  dfs(u + 1, i, dis + d[start][next]));            st[i] &#x3D; false;        &#125;    &#125;        return res;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    memset(h ,-1,sizeof h);    source[0] &#x3D; 1;    for(int i &#x3D; 1 ; i &lt;&#x3D; 5 ;  i++ ) cin &gt;&gt; source[i];    for(int i &#x3D; 0 ; i &lt; m ; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);        add(b, a, c);    &#125;        for(int i &#x3D; 0 ; i &lt; 6 ; i ++) dijkstra(source[i], d[i]);        memset(st, false ,sizeof st);    int res &#x3D; dfs(1, 0, 0);    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/342/">通信线路</a><br>双端队列广搜+二分</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305022154140.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305022155649.png" alt="image-20230502215526896"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;deque&gt;using namespace std;const int N &#x3D; 1010, M &#x3D; 20010;int n,m,k;int idx, e[M], ne[M], w[M], h[N];int d[N];bool st[N];deque&lt;int&gt; q;void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx]&#x3D; c, ne[idx]&#x3D; h[a], h[a] &#x3D; idx ++;&#125;bool check(int bound)&#123;    &#x2F;&#x2F;求最小的这样一个x，使得大于等于x的边的数量&lt;&#x3D;k    &#x2F;&#x2F;双端队列广搜求大于等于x的边的数量    memset(st, 0, sizeof st);    memset(d, 0x3f, sizeof d);    d[1] &#x3D; 0;    q.push_back(1);        while(q.size())&#123;        auto t &#x3D; q.front();        q.pop_front();                if(st[t]) continue;        st[t] &#x3D; true;                for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i]) &#123;            int j &#x3D; e[i], x &#x3D; w[i] &gt; bound;            if(d[j] &gt; d[t] + x)&#123;                d[j] &#x3D; d[t] + x;                if(x) q.push_back(j);                else q.push_front(j);            &#125;        &#125;    &#125;        return d[n] &lt;&#x3D; k;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    memset(h, -1, sizeof h);    for(int i &#x3D; 0 ;i &lt; m ;i ++ )&#123;        int a,b,c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);        add(b, a, c);    &#125;        int l &#x3D; 0, r &#x3D; 1e6 +1  ;    while(l &lt; r)&#123;        int mid &#x3D; l + r &gt;&gt; 1;        if(check(mid)) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;        if (r &#x3D;&#x3D; 1e6 + 1) cout &lt;&lt; -1 &lt;&lt; endl;    else cout &lt;&lt; r &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/344/">道路与航线</a></p><p>dfs + 拓扑 + 最短路</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305042104519.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305042055061.png" alt="image-20230504205514350"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305042107887.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 25010, M &#x3D; 150010, INF &#x3D; 0x3f3f3f3f;int n, mr, mp, S, bnt;int idx, e[M], ne[M], w[M], h[N];bool st[N];int d[N];int id[N];int din[N];vector&lt;int&gt; block[N];queue&lt;int&gt; q;void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dfs(int u,int bid)&#123;    block[bid].push_back(u);    id[u] &#x3D; bid;        for(int i &#x3D; h[u]; i !&#x3D; -1; i &#x3D; ne[i])&#123;        int j &#x3D; e[i];        if(!id[j])&#123;            dfs(j, bid);        &#125;    &#125;&#125;void dijkstra(int bid)&#123;    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    for(auto it : block[bid])&#123;        heap.push(&#123;d[it], it&#125;);    &#125;        while(heap.size())&#123;        auto t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i!&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis + w[i])&#123;                d[j] &#x3D; dis + w[i];                if(id[j] &#x3D;&#x3D; id[ver]) heap.push(&#123;d[j], j&#125;);            &#125;                        if(id[ver] !&#x3D; id[j] &amp;&amp; --din[id[j]] &#x3D;&#x3D; 0) q.push(id[j]);        &#125;    &#125;&#125;void topsort()&#123;    memset(d, 0x3f, sizeof d);    d[S] &#x3D; 0 ;        for(int i &#x3D; 1 ; i &lt;&#x3D; bnt ; i ++)&#123;        if(!din[i])&#123;            q.push(i);        &#125;    &#125;        while(q.size())&#123;        auto t &#x3D; q.front();        q.pop();                dijkstra(t);    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; S;    memset(h, -1, sizeof h);    for(int i &#x3D; 0 ; i &lt; mr ; i ++ ) &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c), add(b, a, c);    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++) &#123;        if(!id[i])&#123;            dfs(i, ++ bnt);        &#125;    &#125;        for(int i &#x3D; 0 ; i &lt; mp ; i ++) &#123;        int a,b,c;        cin &gt;&gt; a&gt;&gt; b &gt;&gt; c;        add(a, b, c);        din[id[b]] ++ ;    &#125;        topsort();        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        if(d[i] &gt; INF &#x2F; 2) cout &lt;&lt; &quot;NO PATH&quot; &lt;&lt; endl;        else cout &lt;&lt; d[i] &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/343/">最优贸易</a>（未做）</p><p>dp + 最短路</p><p>先求出：</p><ul><li>从 1走到 i 的过程中，买入水晶球的最低价格 dmin[i]；</li><li>从 i 走到 n 的过程中，卖出水晶球的最高价格 dmax[i]；</li></ul><p>然后枚举每个城市作为买卖的中间城市，求出 dmax[i] - dmin[i] 的最大值即可。</p><p>求 dmin[i] 和 dmax[i] 时，由于不是拓扑图，状态的更新可能存在环，因此不能使用动态规划，只能使用求最短路的方式。</p><blockquote><p>不能用dijsktra算法的原因：</p><p>最一般的最短路维护的是路径上的sum性质，本题维护的是max和min性质，sum性质具有累加性（就是要从前面的值基础上累加，后续出现只会越来越大，所以第一次出现的就是最短），而max 和min对于新出现的数，单独比较即可，所以不能用dijkstra（dijkstra就是利用的sum的累加性）</p><p>总的来说就是max和min，后面出现的数不一定比前面的数都差（而dijkstra的sum性质能保证后面出现的数都比前面的数都差）</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 100010, M &#x3D; 2000010;int n, m;int price[N];int h[N], rh[N], e[M], ne[M], idx;int dmin[N], dmax[N];bool st[N];void add(int *h, int a, int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void spfa(int *d, int start, int *h, bool flag)&#123;    queue&lt;int&gt; q;    memset(st, 0, sizeof st);    if (flag) memset(d, 0x3f, sizeof dmin);    q.push(start);    st[start] &#x3D; true;    d[start] &#x3D; price[start];    while (q.size())    &#123;        int t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for (int i &#x3D; h[t]; ~i; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (flag &amp;&amp; d[j] &gt; min(d[t], price[j]) || !flag &amp;&amp; d[j] &lt; max(d[t], price[j]))            &#123;                if (flag) d[j] &#x3D; min(d[t], price[j]);                else d[j] &#x3D; max(d[t], price[j]);                if (!st[j])                &#123;                    st[j] &#x3D; true;                    q.push(j);                &#125;            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    memset(h, -1, sizeof h);    memset(rh, -1, sizeof rh);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) scanf(&quot;%d&quot;, &amp;price[i]);    while (m -- )    &#123;        int a, b, c;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);        add(h, a, b), add(rh, b, a);        if (c &#x3D;&#x3D; 2) add(h, b, a), add(rh, a, b);    &#125;    spfa(dmin, 1, h, true);    spfa(dmax, n, rh, false);    int res &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res &#x3D; max(res, dmax[i] - dmin[i]);    printf(&quot;%d\n&quot;, res);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="单源最短路的扩展方式"><a href="#单源最短路的扩展方式" class="headerlink" title="单源最短路的扩展方式"></a>单源最短路的扩展方式</h2><p><a href="https://www.acwing.com/problem/content/1139/">选择最佳线路</a></p><p>虚拟源点</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305052121234.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 1010, M &#x3D; 30010, INF &#x3D; 0x3f3f3f3f;int n,m,s;int idx, e[M], ne[M], w[M], h[N];bool st[N];int d[N];int cnt;void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;int dijkstra()&#123;    memset(d, 0x3f, sizeof d);    memset(st, false, sizeof st);    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;    d[0] &#x3D; 0;    heap.push(&#123;0, 0&#125;);        while(heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();        int ver &#x3D; t.second, dis &#x3D; t.first;        if(st[ver]) continue;        st[ver] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; dis + w[i])&#123;                d[j] &#x3D; dis + w[i];                heap.push(&#123;d[j], j&#125;);            &#125;        &#125;    &#125;        if(d[s] &gt; INF &#x2F; 2) return -1;        return d[s];&#125;int main()&#123;    while(cin &gt;&gt; n &gt;&gt; m &gt;&gt; s)&#123;        memset(h, -1, sizeof h);        idx &#x3D; 0;        for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;            int a,b,c;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;            add(a, b, c);        &#125;        cin &gt;&gt; cnt ;        for(int i &#x3D; 0; i &lt; cnt ; i ++ )&#123;            int p;            cin &gt;&gt; p;            add(0, p, 0);        &#125;        int t &#x3D; dijkstra();        cout &lt;&lt; t &lt;&lt; endl;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1133/">拯救大兵瑞恩</a>（未做）</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305052158853.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;deque&gt;#include &lt;set&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 11, M &#x3D; 360, P &#x3D; 1 &lt;&lt; 10;int n, m, k, p;int h[N * N], e[M], w[M], ne[M], idx;int g[N][N], key[N * N];int dist[N * N][P];bool st[N * N][P];set&lt;PII&gt; edges;void add(int a, int b, int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void build()&#123;    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )            for (int u &#x3D; 0; u &lt; 4; u ++ )            &#123;                int x &#x3D; i + dx[u], y &#x3D; j + dy[u];                if (!x || x &gt; n || !y || y &gt; m) continue;                int a &#x3D; g[i][j], b &#x3D; g[x][y];                if (!edges.count(&#123;a, b&#125;)) add(a, b, 0);            &#125;&#125;int bfs()&#123;    memset(dist, 0x3f, sizeof dist);    dist[1][0] &#x3D; 0;    deque&lt;PII&gt; q;    q.push_back(&#123;1, 0&#125;);    while (q.size())    &#123;        PII t &#x3D; q.front();        q.pop_front();        if (st[t.x][t.y]) continue;        st[t.x][t.y] &#x3D; true;        if (t.x &#x3D;&#x3D; n * m) return dist[t.x][t.y];        if (key[t.x])        &#123;            int state &#x3D; t.y | key[t.x];            if (dist[t.x][state] &gt; dist[t.x][t.y])            &#123;                dist[t.x][state] &#x3D; dist[t.x][t.y];                q.push_front(&#123;t.x, state&#125;);            &#125;        &#125;        for (int i &#x3D; h[t.x]; ~i; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if (w[i] &amp;&amp; !(t.y &gt;&gt; w[i] - 1 &amp; 1)) continue;   &#x2F;&#x2F; 有门并且没有钥匙            if (dist[j][t.y] &gt; dist[t.x][t.y] + 1)            &#123;                dist[j][t.y] &#x3D; dist[t.x][t.y] + 1;                q.push_back(&#123;j, t.y&#125;);            &#125;        &#125;    &#125;    return -1;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p &gt;&gt; k;    for (int i &#x3D; 1, t &#x3D; 1; i &lt;&#x3D; n; i ++ )        for (int j &#x3D; 1; j &lt;&#x3D; m; j ++ )            g[i][j] &#x3D; t ++ ;    memset(h, -1, sizeof h);    while (k -- )    &#123;        int x1, y1, x2, y2, c;        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;        int a &#x3D; g[x1][y1], b &#x3D; g[x2][y2];        edges.insert(&#123;a, b&#125;), edges.insert(&#123;b, a&#125;);        if (c) add(a, b, c), add(b, a, c);    &#125;    build();    int s;    cin &gt;&gt; s;    while (s -- )    &#123;        int x, y, c;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; c;        key[g[x][y]] |&#x3D; 1 &lt;&lt; c - 1;    &#125;    cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1136/">最短路计数</a></p><p>最短路的条数</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305062238582.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1e5 + 10, M &#x3D; 4e5 + 10, MOD &#x3D; 100003;int n,m;int idx, e[M], ne[M], h[N];int d[N];int cnt[N];void add(int a,int b)&#123;    e[idx] &#x3D; b, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void bfs()&#123;    memset(d, 0x3f, sizeof d);    queue&lt;int&gt; q;    q.push(1);    d[1] &#x3D; 0;    cnt[1] &#x3D; 1;        while(q.size())&#123;        auto t &#x3D; q.front();        q.pop();                for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j] &gt; d[t] + 1)&#123;                d[j] &#x3D; d[t] + 1;                cnt[j] &#x3D; cnt[t];                q.push(j);            &#125;            else if(d[j] &#x3D;&#x3D; d[t] + 1)&#123;                cnt[j] &#x3D; (cnt[t] + cnt[j]) % MOD;            &#125;        &#125;    &#125;&#125;int main()&#123;    memset(h , -1, sizeof h);    cin &gt;&gt; n &gt;&gt; m ;    for(int i &#x3D; 0; i &lt; m ; i ++ )&#123;        int a,b;        cin &gt;&gt; a &gt;&gt; b;        add(a, b), add(b, a);    &#125;        bfs();        for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ ) cout &lt;&lt; cnt[i] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/385/">观光</a></p><p>最短路径的条数</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;const int N &#x3D; 1010, M &#x3D; 10010;int n,m,S,F;int idx, e[M], ne[M], h[N], w[M];int d[N][2];bool st[N][2];int cnt[N][2];struct Ver &#123;    int ver, type, dist; &#x2F;&#x2F;0:最短路，1:次短路    &#x2F;&#x2F;小根堆重载大于号    bool operator&gt; (const Ver &amp;W) const&#123;        return dist &gt; W.dist;    &#125;&#125;;void add(int a,int b,int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;int dijkstra()&#123;    memset(st, 0, sizeof st);    memset(d, 0x3f, sizeof d);    memset(cnt, 0, sizeof cnt);        d[S][0] &#x3D; 0, cnt[S][0] &#x3D; 1;    priority_queue&lt;Ver, vector&lt;Ver&gt;, greater&lt;Ver&gt;&gt; heap;    heap.push(&#123;S, 0, 0&#125;);        while(heap.size())&#123;        Ver t &#x3D; heap.top();        heap.pop();                int ver &#x3D; t.ver, type &#x3D; t.type, dis &#x3D; t.dist, count &#x3D; cnt[ver][type];        if(st[ver][type]) continue;        st[ver][type] &#x3D; true;                for(int i &#x3D; h[ver]; i !&#x3D; -1 ;i &#x3D; ne[i])&#123;            int j &#x3D; e[i];            if(d[j][0] &gt; dis + w[i])&#123;                &#x2F;&#x2F;最短路变为次短路                d[j][1] &#x3D; d[j][0];                cnt[j][1] &#x3D; cnt[j][0];                heap.push(&#123;j, 1, d[j][1]&#125;);                &#x2F;&#x2F;更新最短路                d[j][0] &#x3D; dis + w[i];                cnt[j][0] &#x3D; count;                heap.push(&#123;j, 0, d[j][0]&#125;);            &#125;            else if(d[j][0] &#x3D;&#x3D; dis + w[i])&#123;                cnt[j][0] +&#x3D; count;            &#125;else if(d[j][1] &gt; dis + w[i])&#123;                &#x2F;&#x2F;更新次短路                d[j][1] &#x3D; dis + w[i];                cnt[j][1] &#x3D; count;                heap.push(&#123;j, 1, d[j][1]&#125;);            &#125;else if(d[j][1] &#x3D;&#x3D; dis + w[i])&#123;                cnt[j][1] +&#x3D; count;            &#125;        &#125;    &#125;        int res &#x3D; cnt[F][0];    if(d[F][0] + 1 &#x3D;&#x3D; d[F][1]) res +&#x3D; cnt[F][1];        return res;&#125;int main()&#123;    int cases;    cin &gt;&gt; cases;    while(cases--)&#123;        memset(h , -1, sizeof h);        idx &#x3D; 0;        cin &gt;&gt; n &gt;&gt; m ;        for(int i &#x3D; 0; i &lt; m ; i++ )&#123;            int a,b,c;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;            add(a, b, c);        &#125;                cin &gt;&gt; S &gt;&gt; F;        cout &lt;&lt; dijkstra() &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h2><p><a href="https://www.acwing.com/problem/content/1127/">牛的旅行</a></p><p>最短路</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305082110528.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305082110502.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#define  x first#define  y secondusing namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 160;const double INF &#x3D; 1e20;int n;double d[N][N];PII q[N];char g[N][N];double maxd[N];double get_dist(PII p1, PII p2)&#123;    int dx &#x3D; p1.x - p2.x, dy &#x3D; p1.y - p2.y;    return sqrt(dx * dx + dy * dy);&#125;void floyd()&#123;    for(int k &#x3D; 0; k &lt; n ; k ++ )&#123;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;            for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;                d[i][j] &#x3D; min(d[i][j], d[i][k] + d[k][j]);            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; g[i];    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++)&#123;            if(i !&#x3D; j)&#123;                if(g[i][j] &#x3D;&#x3D; &#39;1&#39;) d[i][j] &#x3D; get_dist(q[i], q[j]);                else d[i][j] &#x3D; INF;            &#125;        &#125;    &#125;        floyd();        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;            if(d[i][j] &lt; INF&#x2F; 2)&#123;              maxd[i] &#x3D; max(maxd[i], d[i][j]) ;              &#125;        &#125;    &#125;        double res1 &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) res1 &#x3D; max(res1, maxd[i]);    double res2 &#x3D; INF;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;            if(d[i][j] &gt;&#x3D; INF)&#123;                res2 &#x3D; min(res2, maxd[i] + get_dist(q[i], q[j]) + maxd[j]);            &#125;        &#125;    &#125;    printf(&quot;%.6lf\n&quot;, max(res1, res2));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/345/">排序</a></p><p>传递闭包</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305082223854.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305082224447.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 26;int n,m;bool g[N][N], d[N][N];bool st[N]; &#x2F;&#x2F;存储当前变量有没有被输出void floyd()&#123;    memcpy(d, g,sizeof d);    for(int k &#x3D; 0 ; k &lt; n ; k ++ )&#123;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;            for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;                &#x2F;&#x2F;若i&lt;k,且k&lt;j，则存在i&lt;j                d[i][j] |&#x3D; d[i][k] &amp;&amp; d[k][j];            &#125;        &#125;    &#125;&#125;int check()&#123;    for(int i &#x3D; 0; i &lt; n ; i ++ )&#123;        if(d[i][i])        &#x2F;&#x2F;i &lt; i矛盾            return 2;    &#125;        for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        for(int j &#x3D; 0 ; j &lt; i ; j ++ )&#123;            &#x2F;&#x2F; i与j之间没有关系            if(!d[i][j] &amp;&amp; !d[j][i]) &#123;                return 0;            &#125;        &#125;    &#125;        return 1;&#125;char get_min()&#123;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        if(!st[i])        &#123;            bool flag &#x3D; true;            &#x2F;&#x2F;找到是否比i小的点            for(int j &#x3D; 0 ; j &lt; n ; j ++ )&#123;                if(!st[j] &amp;&amp; d[j][i])&#123;                    flag &#x3D; false;                    break;                &#125;            &#125;            &#x2F;&#x2F;没有比i小的            if(flag)            &#123;                st[i] &#x3D; true;                return  &#39;A&#39; + i;            &#125;        &#125;    &#125;&#125;int main()&#123;    while(cin &gt;&gt; n &gt;&gt; m , n || m)&#123;        memset(g, 0, sizeof g);        int type &#x3D; 0; &#x2F;&#x2F; 0:不确定 1:唯一确定 2:矛盾        int t; &#x2F;&#x2F;每个结果对应的轮数        for(int i &#x3D; 1; i &lt;&#x3D; m ; i ++ )&#123;            char str[5];            cin &gt;&gt; str;            int a &#x3D; str[0] - &#39;A&#39;, b &#x3D; str[2] - &#39;A&#39;;            if(!type)&#123;                g[a][b] &#x3D; 1;                floyd();                type &#x3D; check();                if(type) t &#x3D; i;            &#125;        &#125;                if(!type) puts(&quot;Sorted sequence cannot be determined.&quot;);        else if(type &#x3D;&#x3D; 2) printf(&quot;Inconsistency found after %d relations.\n&quot;, t);        else&#123;            memset(st, 0, sizeof st);            printf(&quot;Sorted sequence determined after %d relations: &quot;, t);            for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cout &lt;&lt; get_min();  &#x2F;&#x2F;每次输出最小值            printf(&quot;.\n&quot;);        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/346/">观光之旅</a></p><p>求最小环</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305092127613.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110, INF &#x3D; 0x3f3f3f3f;int n, m;int d[N][N], g[N][N]; int pos[N][N]; &#x2F;&#x2F;i到j是由哪个点转移的int path[N]; &#x2F;&#x2F;存储路径int cnt;&#x2F;&#x2F;路径长度void get_path(int i,int j)&#123;    if(pos[i][j] &#x3D;&#x3D; 0) return ;        int k &#x3D; pos[i][j];    get_path(i, k);    path[cnt++] &#x3D; k;    get_path(k, j);&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    memset(g, 0x3f, sizeof g);    for(int i &#x3D; 0 ; i &lt;&#x3D; n ; i ++ ) g[i][i] &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i++ )&#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);    &#125;        int res &#x3D; INF;    memcpy(d, g, sizeof d);    for(int k &#x3D; 1; k &lt;&#x3D; n ; k ++ )&#123;        for(int i &#x3D; 1; i &lt;&#x3D; k ; i ++ )&#123;            for(int j &#x3D; i + 1 ; j &lt; k ; j ++ )&#123;                if((long long)d[i][j] + g[i][k] + g[k][j] &lt; res) &#123;                    res &#x3D; d[i][j] + g[i][k] + g[k][j];                    cnt &#x3D; 0;                    path[cnt++] &#x3D; k;                    path[cnt++] &#x3D; i;                    get_path(i, j);                    path[cnt++] &#x3D; j;                &#125;            &#125;        &#125;                for(int i &#x3D; 1 ; i &lt;&#x3D; n  ; i ++ )&#123;            for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )&#123;                if(d[i][j] &gt; d[i][k] + d[k][j])&#123;                    d[i][j] &#x3D; d[i][k] + d[k][j];                    pos[i][j] &#x3D; k;                &#125;            &#125;        &#125;    &#125;        if(res &gt; INF &#x2F; 2) cout &lt;&lt; &quot;No solution.&quot; &lt;&lt; endl;    else &#123;        for(int i &#x3D; 0 ;i &lt; cnt; i ++ ) cout &lt;&lt; path[i] &lt;&lt; &#39; &#39;;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/347/">牛站</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305092203879.png"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305092203898.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int N &#x3D; 210;int k, n, m, S, E;int g[N][N];int res[N][N];void mul(int c[][N], int a[][N], int b[][N])&#123;    static int temp[N][N];    memset(temp, 0x3f, sizeof temp);    for (int k &#x3D; 1; k &lt;&#x3D; n; k ++ )        for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for (int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                temp[i][j] &#x3D; min(temp[i][j], a[i][k] + b[k][j]);    memcpy(c, temp, sizeof temp);&#125;void qmi()&#123;    memset(res, 0x3f, sizeof res);    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) res[i][i] &#x3D; 0;    while (k)    &#123;        if (k &amp; 1) mul(res, res, g);    &#x2F;&#x2F; res &#x3D; res * g        mul(g, g, g);   &#x2F;&#x2F; g &#x3D; g * g        k &gt;&gt;&#x3D; 1;    &#125;&#125;int main()&#123;    cin &gt;&gt; k &gt;&gt; m &gt;&gt; S &gt;&gt; E;    memset(g, 0x3f, sizeof g);    map&lt;int, int&gt; ids;    if (!ids.count(S)) ids[S] &#x3D; ++ n;    if (!ids.count(E)) ids[E] &#x3D; ++ n;    S &#x3D; ids[S], E &#x3D; ids[E];    while (m -- )    &#123;        int a, b, c;        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;        if (!ids.count(a)) ids[a] &#x3D; ++ n;        if (!ids.count(b)) ids[b] &#x3D; ++ n;        a &#x3D; ids[a], b &#x3D; ids[b];        g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);    &#125;    qmi();    cout &lt;&lt; res[S][E] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><a href="https://www.acwing.com/problem/content/1142/">最短网络</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 110,INF &#x3D; 0x3f3f3f3f;int n;int g[N][N];int d[N];bool st[N];int prim()&#123;    memset(d, 0x3f, sizeof d);    int res &#x3D; 0;    d[1] &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int t &#x3D; -1;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            if(!st[j] &amp;&amp;(t &#x3D;&#x3D; -1 || d[t] &gt; d[j]))            &#123;                t &#x3D; j;            &#125;        &#125;                if(i &amp;&amp; d[t] &#x3D;&#x3D; INF) return INF;        if(i) res +&#x3D; d[t];                for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ ) d[j] &#x3D; min(d[j], g[t][j]);        st[t] &#x3D; true;    &#125;        return res;&#125;int main()&#123;    cin &gt;&gt; n ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; n ; j ++ )        &#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;        int t &#x3D; prim();    cout &lt;&lt; t &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1143/">局域网</a></p><p>最小生成森林：只能用kruscal</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 110,M &#x3D; 210, INF &#x3D; 0x3f3f3f3f;int n, m;int p[N];struct Edge&#123;    int a, b, w;        bool operator &lt;(const Edge &amp;W)const &#123;        return w &lt; W.w;    &#125;&#125;edges[M];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    int sum &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        edges[i].a &#x3D; a, edges[i].b &#x3D; b, edges[i].w &#x3D; w;        sum +&#x3D; w;    &#125;        int res &#x3D; 0, cnt &#x3D; 0;        sort(edges, edges + m);    for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i]. w;        a &#x3D; find(a), b &#x3D; find(b);        if(a !&#x3D; b)        &#123;            p[a] &#x3D; b;            res +&#x3D; w;            cnt ++ ;        &#125;    &#125;        cout &lt;&lt; sum - res &lt;&lt; endl;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1144/">繁忙的都市</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 310, M &#x3D; 8010, INF &#x3D; 0x3f3f3f3f;int n, m;int p[N];struct Edge&#123;    int a, b, w;    bool operator&lt;(const Edge &amp;W) const &#123;        return w &lt; W.w;    &#125;&#125;edges[M];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a, b, w;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;        edges[i].a &#x3D; a, edges[i].b &#x3D; b, edges[i].w &#x3D; w;    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i;    sort(edges, edges + m);    int res &#x3D; 0, cnt &#x3D; 0, medge &#x3D; 0 ;        for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int a &#x3D; edges[i].a ,b &#x3D; edges[i].b, w &#x3D; edges[i].w;        a &#x3D; find(a), b &#x3D; find(b);        if(a !&#x3D; b)&#123;            p[a] &#x3D; b;            res +&#x3D; w;            medge &#x3D; max(medge, w);            cnt ++;        &#125;    &#125;        cout &lt;&lt; cnt &lt;&lt; &#39; &#39; &lt;&lt; medge &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/description/1145/">联络员</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 2010, M &#x3D; 10010, INF &#x3D; 0x3f3f3f3f;struct Edge&#123;    int a, b, w;    bool operator&lt;(const Edge&amp;W) const &#123;         return w &lt; W.w;    &#125;&#125;edges[M];int n, m;int p[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++ ) p[i] &#x3D; i;    int res &#x3D; 0, cnt &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int t, a, b, w;        cin &gt;&gt; t &gt;&gt; a &gt;&gt; b &gt;&gt; w;        if(t &#x3D;&#x3D; 1)        &#123;            p[find(a)] &#x3D; find(b);            cnt ++ ;            res +&#x3D; w;        &#125;        edges[i].a &#x3D; a;        edges[i].b &#x3D; b;        edges[i].w &#x3D; w;     &#125;            sort(edges , edges + m);        for(int i &#x3D; 0 ; i &lt; m ; i++ )    &#123;        int a &#x3D; edges[i].a, b &#x3D; edges[i].b, w &#x3D; edges[i].w;        a &#x3D; find(a), b &#x3D; find(b);        if(a !&#x3D; b)&#123;            p[a] &#x3D; b;            res +&#x3D; w;            cnt ++ ;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1146/">连接格点</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 1010, M &#x3D; 10010, K &#x3D; N * N * 2, INF &#x3D; 0x3f3f3f3f ;struct Edge&#123;    int a, b, w;&#125;edges[K];int n, m, k;int ids[N][N];int p[K];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;void get_edges()&#123;    int dx[4] &#x3D; &#123;-1, 0, 1, 0&#125;, dy[4] &#x3D; &#123;0, 1, 0, -1&#125;, dw[4] &#x3D; &#123;1, 2, 1, 2&#125;; &#x2F;&#x2F;上、右，下，左    for(int z &#x3D; 0 ; z &lt; 2 ; z ++ )        for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ )            for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )                for(int u &#x3D; 0 ; u &lt; 4 ; u ++ )                    if(u % 2 &#x3D;&#x3D; z)                    &#123;                        int x &#x3D; i + dx[u], y &#x3D; j + dy[u], w &#x3D; dw[u];                        if(x &amp;&amp; x &lt;&#x3D; n &amp;&amp; y &amp;&amp; y &lt;&#x3D; m)                        &#123;                            int a &#x3D; ids[i][j], b &#x3D; ids[x][y];                            if(a &lt; b) edges[k ++] &#x3D; &#123;a, b, w&#125;;                        &#125;                    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    int t &#x3D; 1;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )        &#123;            ids[i][j] &#x3D; t++;        &#125;    &#125;        for(int i &#x3D; 1; i &lt;&#x3D; t ; i ++ ) p[i] &#x3D; i;    int x1, y1, x2, y2;    while(cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2)    &#123;        int a &#x3D; ids[x1][y1], b &#x3D; ids[x2][y2];        p[find(a)] &#x3D; find(b);    &#125;        get_edges();        int res &#x3D; 0 ;    for(int i &#x3D; 0 ; i &lt; k ;i ++ )    &#123;        int a &#x3D; find(edges[i].a), b &#x3D; find(edges[i].b), w &#x3D; edges[i].w;        if(a !&#x3D; b)        &#123;            p[a] &#x3D; b;            res +&#x3D; w;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小生成树的扩展应用"><a href="#最小生成树的扩展应用" class="headerlink" title="最小生成树的扩展应用"></a>最小生成树的扩展应用</h2><p><a href="https://www.acwing.com/problem/content/description/1148/">新的开始</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 310, INF &#x3D; 0x3f3f3f3f;int n;int d[N];int g[N][N];bool st[N];int prim()&#123;    memset(d, 0x3f, sizeof d);    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; n + 1 ; i ++ )    &#123;        int t &#x3D; -1;        for(int j &#x3D; 0; j &lt; n + 1 ; j ++ )            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || d[j] &lt; d[t]))                t &#x3D; j;                        if(i &amp;&amp; d[t] &#x3D;&#x3D; INF) return INF;        if(i) res +&#x3D; d[t];        for(int j &#x3D; 0 ; j &lt; n + 1; j ++ ) d[j] &#x3D; min(d[j], g[t][j]);        st[t] &#x3D; true;    &#125;        return res;&#125;int main()&#123;    cin &gt;&gt; n ;    memset(g, 0x3f, sizeof g);    for(int i &#x3D; 1; i &lt;&#x3D; n ; i++ )    &#123;        int a;        cin &gt;&gt; a;        g[0][i] &#x3D; g[i][0] &#x3D; a;    &#125;        for(int i &#x3D; 1; i &lt;&#x3D; n ; i++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; n; j++ )            cin &gt;&gt; g[i][j];                int t &#x3D; prim();    cout &lt;&lt; t &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1147/">北极通讯网络</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 510 , M &#x3D; N * N &#x2F; 2;int n,m,k;PII q[N];int p[N];struct Edge&#123;    int a, b;    double w;    bool operator &lt;(const Edge&amp; W) const &#123;        return w &lt; W.w;    &#125;&#125;e[M];double get_dist(PII a, PII b)&#123;    int dx &#x3D; a.x - b.x;    int dy &#x3D; a.y - b.y;    return sqrt(dx * dx + dy * dy);&#125;int find(int x)&#123;    if(p[x] !&#x3D; x) return p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for(int i &#x3D; 0 ; i &lt; n ; i++) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )        for(int j &#x3D; 0 ; j &lt; i ; j ++)             e[m ++ ] &#x3D; &#123;i , j , get_dist(q[i], q[j])&#125;;                sort(e, e + m);    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) p[i] &#x3D; i;    int cnt &#x3D; n;    double res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        if(cnt &lt;&#x3D; k ) break;        int a &#x3D; find(e[i].a) , b &#x3D; find(e[i].b);        double w &#x3D; e[i].w;                if(a !&#x3D; b)        &#123;            p[a] &#x3D; b;            cnt -- ;            res &#x3D; w;        &#125;    &#125;        printf(&quot;%.2lf\n&quot;, res);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/348/">走廊泼水节</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305262311755.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 6010;struct Edge&#123;    int a, b, w;    bool operator &lt;(const Edge &amp;W) const &#123;        return w &lt; W.w;    &#125;&#125;e[N];int n;int p[N];int sz[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T -- )    &#123;        cin &gt;&gt; n;        for(int i &#x3D; 0 ; i &lt; n - 1 ; i ++ )        &#123;            int a, b, w;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;            e[i] &#x3D; &#123;a, b, w&#125;;        &#125;                sort(e, e + n - 1);        for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i, sz[i] &#x3D; 1;                int res &#x3D; 0;        for(int i &#x3D; 0 ; i &lt; n - 1 ; i ++ )        &#123;            int a &#x3D; find(e[i].a), b &#x3D; find(e[i].b);            int w &#x3D; e[i].w;            if(a !&#x3D; b)            &#123;                res +&#x3D; (sz[a] * sz[b] - 1) * (w + 1);                sz[b] +&#x3D; sz[a];                p[a] &#x3D; b;                            &#125;        &#125;                cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1150/">秘密的牛奶运输</a>（未做）</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int N &#x3D; 505, M &#x3D; 10005, L &#x3D; 10, INF &#x3D; 2e9;int n, m, fa[N][L], fMax[N][L][2], f[N];int dep[N];LL res &#x3D; 0, ans &#x3D; 9e18;bool st[M];&#x2F;*fMax[i][j][0 &#x2F; 1] 表示 i 这个点往上跳 2 ^ j 个点，这个范围内的 最大值 &#x2F; 最小值。*&#x2F;int head[N], numE &#x3D; 0;struct Edge&#123;    int next, from, to, dis;&#125;e[M &lt;&lt; 1];struct E&#123;    int u, v, w;    bool operator &lt; (const E &amp;x) const&#123;        return w &lt; x.w;    &#125;&#125;g[M];void inline addEdge(int from, int to, int dis)&#123;    e[++numE].next &#x3D; head[from];    e[numE].to &#x3D; to;    e[numE].from &#x3D; from;    e[numE].dis &#x3D; dis;    head[from] &#x3D; numE;&#125;void dfs(int u, int last)&#123;    for(int i &#x3D; 1; fa[fa[u][i - 1]][i - 1]; i++)&#123;        fa[u][i] &#x3D; fa[fa[u][i - 1]][i - 1];        if(fMax[u][i - 1][0] &#x3D;&#x3D; fMax[fa[u][i - 1]][i - 1][0])&#123;            fMax[u][i][0] &#x3D; fMax[u][i - 1][0];            fMax[u][i][1] &#x3D; max(fMax[u][i - 1][1], fMax[fa[u][i - 1]][i - 1][1]);        &#125;else&#123;            fMax[u][i][0] &#x3D; max(fMax[u][i - 1][0], fMax[fa[u][i - 1]][i - 1][0]);            fMax[u][i][1] &#x3D; min(fMax[u][i - 1][0], fMax[fa[u][i - 1]][i - 1][0]);        &#125;    &#125;    for(int i &#x3D; head[u]; i; i &#x3D; e[i].next)&#123;        int v &#x3D; e[i].to;        if(v &#x3D;&#x3D; last) continue;        fa[v][0] &#x3D; u, fMax[v][0][0] &#x3D; e[i].dis;        dep[v] &#x3D; dep[u] + 1, fMax[v][0][1] &#x3D; -INF;        dfs(v, u);    &#125;&#125;int find(int x)&#123;    return x &#x3D;&#x3D; f[x] ? x : f[x] &#x3D; find(f[x]);&#125;void inline update(int v, int &amp;val1, int &amp;val2)&#123;    if(v &gt; val1) val2 &#x3D; val1, val1 &#x3D; v;    else if(v &gt; val2 &amp;&amp; v !&#x3D; val1) val2 &#x3D; v;&#125;void inline lca(int x, int y, int &amp;val1, int &amp;val2)&#123;    if(dep[x] &lt; dep[y]) swap(x, y);    for(int i &#x3D; L - 1; ~i; i--)        if(dep[x] - (1 &lt;&lt; i) &gt;&#x3D; dep[y]) &#123;            update(fMax[x][i][0], val1, val2);            update(fMax[x][i][1], val1, val2);            x &#x3D; fa[x][i];        &#125;    if(x &#x3D;&#x3D; y) return;    for(int i &#x3D; L - 1; ~i; i--)&#123;        if(fa[x][i] !&#x3D; fa[y][i])&#123;            update(fMax[x][i][0], val1, val2);            update(fMax[x][i][1], val1, val2);            update(fMax[y][i][0], val1, val2);            update(fMax[y][i][1], val1, val2);            x &#x3D; fa[x][i], y &#x3D; fa[y][i];        &#125;    &#125;    update(fMax[x][0][0], val1, val2);    update(fMax[x][0][1], val1, val2);    update(fMax[y][0][0], val1, val2);    update(fMax[y][0][1], val1, val2);&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)        f[i] &#x3D; i;    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;        int u, v, w; scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);        g[i] &#x3D; (E)&#123; u, v, w &#125;;    &#125;    sort(g + 1, g + 1 + m);    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;        int u &#x3D; find(g[i].u), v &#x3D; find(g[i].v), w &#x3D; g[i].w;        if(u !&#x3D; v)&#123;            f[u] &#x3D; v, res +&#x3D; w, st[i] &#x3D; true;            addEdge(g[i].u, g[i].v, w); addEdge(g[i].v, g[i].u, w);        &#125;    &#125;    dfs(1, 0);    for(int i &#x3D; 1; i &lt;&#x3D; m; i++)&#123;        if(!st[i])&#123;            int val1 &#x3D; -INF, val2 &#x3D; -INF;            lca(g[i].u, g[i].v, val1, val2);            if(val1 &#x3D;&#x3D; g[i].w)                ans &#x3D; min(ans, res - val2 + g[i].w);            else ans &#x3D; min(ans, res - val1 + g[i].w);        &#125;    &#125;    printf(&quot;%lld\n&quot;, ans);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（二）数据结构</title>
      <link href="/2023/041152485.html"/>
      <url>/2023/041152485.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法基础课"><a href="#算法基础课" class="headerlink" title="算法基础课"></a>算法基础课</h1><h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点int head, e[N], ne[N], idx;&#x2F;&#x2F; 初始化void init()&#123;    head &#x3D; -1;    idx &#x3D; 0;&#125;&#x2F;&#x2F; 在链表头插入一个数avoid insert(int a)&#123;    e[idx] &#x3D; a, ne[idx] &#x3D; head, head &#x3D; idx ++ ;&#125;&#x2F;&#x2F; 将头结点删除，需要保证头结点存在void remove()&#123;    head &#x3D; ne[head];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> head<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 初始化数据</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    head <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将val插入到头结点</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>    head <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将下标是k的点后面的点删掉</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>    ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/828/">单链表</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 100010;&#x2F;&#x2F;head 表示头结点的下标&#x2F;&#x2F;e[i] 表示节点i的值&#x2F;&#x2F;ne[i] 表示节点i的next指针是多少&#x2F;&#x2F;idx 存储当前已经用到了哪些点int head,e[N],ne[N],idx;&#x2F;&#x2F;初始化void init()&#123;    head &#x3D; -1;    idx &#x3D; 0;&#125;&#x2F;&#x2F;将x插到头结点void add_to_head(int x)&#123;    e[idx] &#x3D; x; &#x2F;&#x2F;存储新的节点值    ne[idx] &#x3D; head; &#x2F;&#x2F;将新的节点插入到首节点前面    head &#x3D; idx++; &#x2F;&#x2F;将head指向新节点&#125;&#x2F;&#x2F;将x插入到下标是k的节点的后面void add(int k,int x)&#123;e[idx] &#x3D; x;    ne[idx] &#x3D; ne[k];    ne[k] &#x3D; idx++;&#125;&#x2F;&#x2F;将下标是k的点的后面的点删除掉void remove(int k)&#123;    ne[k] &#x3D; ne[ne[k]];&#125;    int main()&#123;    init();    int m ;    cin &gt;&gt; m;    while(m--)    &#123;        int k , x ;         char op;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &#39;H&#39;)        &#123;            cin &gt;&gt; x;            add_to_head(x);        &#125;        else if(op &#x3D;&#x3D; &#39;D&#39;)        &#123;            cin &gt;&gt; k;            if(!k) head &#x3D; ne[head];            remove(k-1);        &#125;        else        &#123;            cin &gt;&gt; k &gt;&gt; x ;            add(k-1,x);        &#125;    &#125;        for(int i &#x3D; head ; i !&#x3D; -1 ; i &#x3D; ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#39; &#39; ;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">,</span> <span class="token class-name">M</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> head<span class="token punctuation">,</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 初始化数据</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>head <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将val插入到头结点</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> head<span class="token punctuation">;</span>head <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 将下标是k的点后面的点删掉</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>ne<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>ne<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> agrs<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">M</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token class-name">M</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"H"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">addToHead</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">add</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 第 k个结点的下标为 k-1, 所以插入到下标为 k-1结点的后面</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>head <span class="token operator">=</span> ne<span class="token punctuation">[</span>head<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span><span class="token function">remove</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> head<span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点int e[N], l[N], r[N], idx;&#x2F;&#x2F; 初始化void init()&#123;    &#x2F;&#x2F;0是左端点，1是右端点    r[0] &#x3D; 1, l[1] &#x3D; 0;    idx &#x3D; 2;&#125;&#x2F;&#x2F; 在节点a的右边插入一个数xvoid insert(int a, int x)&#123;    e[idx] &#x3D; x;    l[idx] &#x3D; a, r[idx] &#x3D; r[a];    l[r[a]] &#x3D; idx, r[a] &#x3D; idx ++ ;&#125;&#x2F;&#x2F; 删除节点avoid remove(int a)&#123;    l[r[a]] &#x3D; l[a];    r[l[a]] &#x3D; r[a];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> l<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">//0是左端点，1是右端点</span>    r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    idx <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>    l<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>    r<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>    r<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>    idx <span class="token operator">++</span> <span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    r<span class="token punctuation">[</span>l<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/829/">双链表</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int r[N], l[N], idx , e[N];void init()&#123;    &#x2F;&#x2F;0是左端点，1是右端点    r[0] &#x3D; 1, l[1] &#x3D; 0;    idx &#x3D; 2;&#125;&#x2F;&#x2F;在下标是k的右边插入一个数void add(int a,int x)&#123;    e[idx] &#x3D; x;    l[idx] &#x3D; a, r[idx] &#x3D; r[a];    l[r[a]] &#x3D; idx , r[a] &#x3D; idx;    idx ++;&#125;void remove(int a)&#123;    l[r[a]] &#x3D; l[a];    r[l[a]] &#x3D; r[a];&#125;int main()&#123;    int m ;    cin &gt;&gt; m;    init();    while(m--)    &#123;        string op ;        int k,x;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &quot;L&quot;)        &#123;            cin &gt;&gt; x;            add(0,x);        &#125;        else if(op &#x3D;&#x3D; &quot;R&quot;)        &#123;            cin &gt;&gt; x;            add(l[1],x);        &#125;        else if(op &#x3D;&#x3D; &quot;D&quot;)        &#123;            cin &gt;&gt; k;            remove(k+1);        &#125;        else if(op &#x3D;&#x3D; &quot;IL&quot;)        &#123;            cin &gt;&gt; k &gt;&gt; x;            add(l[k+1], x);        &#125;        else         &#123;            cin &gt;&gt; k &gt;&gt; x;            add(k+1 , x);        &#125;    &#125;        for(int i &#x3D; r[0]; i !&#x3D; 1 ; i &#x3D; r[i]) cout &lt;&lt; e[i] &lt;&lt; &#39; &#39;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> head<span class="token punctuation">,</span> idx<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> l<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> r<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//0是左端点，1是右端点</span>        r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        idx <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        e<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>        l<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>        r<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>        r<span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">=</span> idx<span class="token punctuation">;</span>        idx <span class="token operator">++</span> <span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        l<span class="token punctuation">[</span>r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> l<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>        r<span class="token punctuation">[</span>l<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> <span class="token class-name">M</span> <span class="token operator">=</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token class-name">M</span> <span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> k<span class="token punctuation">,</span>x<span class="token punctuation">;</span>            <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                x <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"R"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                x <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">remove</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"IL"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">[</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                k <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                x <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">add</span><span class="token punctuation">(</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">=</span> r<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; tt表示栈顶int stk[N], tt &#x3D; 0;&#x2F;&#x2F; 向栈顶插入一个数stk[ ++ tt] &#x3D; x;&#x2F;&#x2F; 从栈顶弹出一个数tt -- ;&#x2F;&#x2F; 栈顶的值stk[tt];&#x2F;&#x2F; 判断栈是否为空if (tt &gt; 0)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/830/">https://www.acwing.com/problem/content/830/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int stk[N],tt ;void push(int x)&#123;    stk[++tt] &#x3D; x;&#125;void pop()&#123;    tt --;&#125;bool isempty()&#123;    return tt &#x3D;&#x3D; 0 ;&#125;int query()&#123;    return stk[tt];&#125;int main()&#123;    int m ;    cin &gt;&gt; m;    while(m--)    &#123;        string op;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &quot;push&quot;)&#123;            int x;            cin &gt;&gt; x;            push(x);        &#125;else if( op &#x3D;&#x3D; &quot;pop&quot; )        &#123;            pop();        &#125;else if( op &#x3D;&#x3D; &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt; endl;        &#125;else if( op &#x3D;&#x3D; &quot;empty&quot;)        &#123;            bool flag &#x3D; isempty();            if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; hh 表示队头，tt表示队尾int q[N], hh &#x3D; 0, tt &#x3D; -1;&#x2F;&#x2F; 向队尾插入一个数q[ ++ tt] &#x3D; x;&#x2F;&#x2F; 从队头弹出一个数hh ++ ;&#x2F;&#x2F; 队头的值q[hh];&#x2F;&#x2F; 判断队列是否为空if (hh &lt;&#x3D; tt)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/831/">https://www.acwing.com/problem/content/831/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int q[N], hh &#x3D; 0 , tt &#x3D; -1 ;&#x2F;&#x2F; hh ... tt void push(int x)&#123;    q[++tt] &#x3D; x;&#125;void pop()&#123;    hh ++ ;&#125;int query()&#123;    return q[hh];&#125;bool isempty()&#123;    return hh &gt; tt ;&#125;int main()&#123;    int m;    cin &gt;&gt; m;    while(m--)    &#123;        string op;        cin &gt;&gt; op;        int x;        if( op &#x3D;&#x3D; &quot;push&quot; ) &#123;            cin &gt;&gt; x;            push(x);        &#125;else if( op &#x3D;&#x3D; &quot;pop&quot;)        &#123;            pop();        &#125;else if( op &#x3D;&#x3D; &quot;query&quot;)        &#123;            cout &lt;&lt; query() &lt;&lt; endl;        &#125;else if( op &#x3D;&#x3D; &quot;empty&quot;)        &#123;            bool flag &#x3D; isempty();            if(flag) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;            else cout &lt;&lt; &quot;NO&quot; &lt;&lt;endl;        &#125;            &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; hh 表示队头，tt表示队尾的后一个位置int q[N], hh &#x3D; 0, tt &#x3D; 0;&#x2F;&#x2F; 向队尾插入一个数q[tt ++ ] &#x3D; x;if (tt &#x3D;&#x3D; N) tt &#x3D; 0;&#x2F;&#x2F; 从队头弹出一个数hh ++ ;if (hh &#x3D;&#x3D; N) hh &#x3D; 0;&#x2F;&#x2F; 队头的值q[hh];&#x2F;&#x2F; 判断队列是否为空if (hh !&#x3D; tt)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 在队尾插入元素，在队头弹出元素int q[N], hh, tt &#x3D; -1;&#x2F;&#x2F; 插入q[++tt] &#x3D; x;&#x2F;&#x2F; 弹出hh++;&#x2F;&#x2F; 判断队列是否为空if(hh &lt;&#x3D; tt) not empty;else empty;&#x2F;&#x2F; 取出队头元素q[hh];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">常见模型：找出每个数左边离它最近的比它大&#x2F;小的数int tt &#x3D; 0;for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;    while (tt &amp;&amp; check(stk[tt], i)) tt -- ;    stk[ ++ tt] &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/832/">单调栈</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int stk[N] , tt;int main()&#123;    int n;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;          int x;        cin &gt;&gt; x;        while(tt &amp;&amp; stk[tt] &gt;&#x3D; x) tt --;        if(tt) cout &lt;&lt; stk[tt] &lt;&lt; &#39; &#39;;        else cout &lt;&lt; -1 &lt;&lt; &#39; &#39;;        stk[++tt] &#x3D; x;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> st <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"-1 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>st<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">常见模型：找出滑动窗口中的最大值&#x2F;最小值int hh &#x3D; 0, tt &#x3D; -1;for (int i &#x3D; 0; i &lt; n; i ++ )&#123;    while (hh &lt;&#x3D; tt &amp;&amp; check_out(q[hh])) hh ++ ;  &#x2F;&#x2F; 判断队头是否滑出窗口    while (hh &lt;&#x3D; tt &amp;&amp; check(q[tt], i)) tt -- ;    q[ ++ tt] &#x3D; i;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/156/">滑动窗口</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int n,k;int a[N],q[N]; &#x2F;&#x2F;q队列存的是下标int main()&#123;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%d&quot;,&amp;k);    for(int i &#x3D; 0 ;i &lt; n; i++) scanf(&quot;%d&quot;,&amp;a[i]);        int hh &#x3D; 0, tt &#x3D; -1;    for ( int i &#x3D; 0; i &lt; n ; i++)    &#123;        if(hh &lt;&#x3D; tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++; &#x2F;&#x2F;判断队头是否已经滑出窗口        while(hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &gt;&#x3D; a[i]) tt--;    &#x2F;&#x2F;如果插入的数比队列中的数小，则将该数插入到队列中，需始终保持队列中的数严格递增，且大于插入数的数可以抛弃，因为不再需要，因此只需移动tt即可        q[ ++ tt] &#x3D; i; &#x2F;&#x2F;插入队列        if(i &gt;&#x3D; k - 1) printf(&quot;%d &quot;, a[q[hh]]);    &#x2F;&#x2F;输入最小的数，即队头的数    &#125;    puts(&quot;&quot;);        hh &#x3D; 0, tt &#x3D; -1;    for ( int i &#x3D; 0; i &lt; n ; i++)    &#123;        &#x2F;&#x2F;判断队头是否已经滑出窗口        if(hh &lt;&#x3D; tt &amp;&amp; i - k + 1 &gt; q[hh]) hh++;        while(hh &lt;&#x3D; tt &amp;&amp; a[q[tt]] &lt;&#x3D; a[i]) tt--;        q[ ++ tt] &#x3D; i;        if(i &gt;&#x3D; k - 1) printf(&quot;%d &quot;, a[q[hh]]);       &#125;    puts(&quot;&quot;);        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Deque</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> q <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 维护一个单调递增的队列，每次弹出队头</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> q<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">>=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">></span> q<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">getLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>q<span class="token punctuation">.</span><span class="token function">removeLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>q<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>q<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; s[]是长文本，p[]是模式串，n是s的长度，m是p的长度求模式串的Next数组：for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; m; i ++ )&#123;    while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];    if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;    ne[i] &#x3D; j;&#125;&#x2F;&#x2F; 匹配for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; n; i ++ )&#123;    while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];    if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;    if (j &#x3D;&#x3D; m)    &#123;        j &#x3D; ne[j];        &#x2F;&#x2F; 匹配成功后的逻辑    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/833/">https://www.acwing.com/problem/content/833/</a></p><p>暴力算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">s[N],p[M];for(int i &#x3D; 1;i &lt;&#x3D; n;i ++)&#123;    bool flag &#x3D; true;    for(int j &#x3D; 1; j&lt;&#x3D; m; j++)        if(s[i+j-1] !&#x3D; p[j])        &#123;            flag &#x3D; false;            break;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>KMP算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e5+10 , M &#x3D; 1e6+10;int n, m;int ne[N];char s[M], p[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;    &#x2F;&#x2F;求next数组    for (int i &#x3D; 2, j &#x3D; 0; i &lt;&#x3D; n; i ++ )    &#123;        while (j &amp;&amp; p[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];        if (p[i] &#x3D;&#x3D; p[j + 1]) j ++ ;        ne[i] &#x3D; j;    &#125;    &#x2F;&#x2F;kmp匹配操作    for (int i &#x3D; 1, j &#x3D; 0; i &lt;&#x3D; m; i ++ )    &#123;        while (j &amp;&amp; s[i] !&#x3D; p[j + 1]) j &#x3D; ne[j];&#x2F;&#x2F;若不能再匹配，则j退一步到与该后缀相同的前缀字符串处（这里的后缀和前缀指的都是匹配字符串）        if (s[i] &#x3D;&#x3D; p[j + 1]) j ++ ;        if (j &#x3D;&#x3D; n)        &#123;            printf(&quot;%d &quot;, i - n);            j &#x3D; ne[j];        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">,</span> <span class="token class-name">M</span> <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token class-name">M</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 模式串</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 总串</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> ne<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> <span class="token class-name">P</span> <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">P</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> <span class="token class-name">S</span> <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token class-name">S</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 构造前缀数组</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>j<span class="token operator">++</span><span class="token punctuation">;</span>ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// kmp匹配操作</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">-</span> n <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Trie树"><a href="#Trie树" class="headerlink" title="Trie树"></a>Trie树</h1><p>快速存储字符串集合的数据结构</p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111629842.png" style="zoom:67%;" /><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int son[N][26], cnt[N], idx;&#x2F;&#x2F; 0号点既是根节点，又是空节点&#x2F;&#x2F; son[][]存储树中每个节点的子节点&#x2F;&#x2F; cnt[]存储以每个节点结尾的单词数量&#x2F;&#x2F; 插入一个字符串void insert(char *str)&#123;    int p &#x3D; 0;    for (int i &#x3D; 0; str[i]; i ++ )    &#123;        int u &#x3D; str[i] - &#39;a&#39;;        if (!son[p][u]) son[p][u] &#x3D; ++ idx;        p &#x3D; son[p][u];    &#125;    cnt[p] ++ ;&#125;&#x2F;&#x2F; 查询字符串出现的次数int query(char *str)&#123;    int p &#x3D; 0;    for (int i &#x3D; 0; str[i]; i ++ )    &#123;        int u &#x3D; str[i] - &#39;a&#39;;        if (!son[p][u]) return 0;        p &#x3D; son[p][u];    &#125;    return cnt[p];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>        p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/837/">Trie字符串统计</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int son[N][26],cnt[N],idx;&#x2F;&#x2F;son[][] &#x3D;&gt; tries树每个点的所有儿子&#x2F;&#x2F;cnt[] &#x3D;&gt; 以当前这个点的结尾的单词有多少个&#x2F;&#x2F;idx &#x3D;&gt; 当前用到了哪个下标 下标为0的点既是根节点，又是空节点char str[N];void insert(char str[]) &#123;    int p &#x3D; 0; &#x2F;&#x2F;根节点开始    for(int i&#x3D;0;str[i];i++)    &#123;        int u &#x3D; str[i] - &#39;a&#39;; &#x2F;&#x2F;取插入字符串的每个字符的编号 a-z &#x3D;&gt; 0-25        if(!son[p][u]) son[p][u] &#x3D; ++idx; &#x2F;&#x2F;创建该节点        p &#x3D; son[p][u]; &#x2F;&#x2F;走原有或刚创建的子节点    &#125;    cnt[p] ++ &#x2F;&#x2F;记录个数加1&#125;int query(char str[])&#123;    int p &#x3D; 0;    for(int i &#x3D; 0;str[i];i++)    &#123;        int u &#x3D; str[i] - &#39;a&#39;;        if(!son[p][u]) return 0;        p &#x3D; son[p][u];    &#125;    return cnt[p];&#125;int main()&#123;    int n;    scanf(&quot;%d&quot; , &amp;n);    while(n--)    &#123;        char op[2];        scanf(&quot;%s%s&quot;,op,str);        if(op[0] &#x3D;&#x3D; &#39;I&#39;) insert(str);        else printf(&quot;%d\n&quot;,query(str));    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> son<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> cnt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> idx<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">++</span>idx<span class="token punctuation">;</span>p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> u <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>p <span class="token operator">=</span> son<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cnt<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> strings <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>strings<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    str <span class="token operator">=</span> strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">insert</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    str <span class="token operator">=</span> strings<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token function">query</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><ol><li>将两个集合合并</li><li>询问两个元素是否在一个集合当中</li></ol><p>基本原理：每个集合用一颗树表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点</p><ul><li>判断树根？if(p[x]=x)</li><li>求x的集合编号？while(p[x]!=x) x=p[x];</li><li>合并两个集合：px是x的集合编号，py是y的集合编号 p[x]=y</li></ul><p>优化：路径压缩 遍历到根节点后，直接将所有的路径上的点与根节点相连</p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(1)朴素并查集：    int p[N]; &#x2F;&#x2F;存储每个点的祖宗节点    &#x2F;&#x2F; 返回x的祖宗节点    int find(int x)    &#123;        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);        return p[x];    &#125;    &#x2F;&#x2F; 初始化，假定节点编号是1~n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ ) p[i] &#x3D; i;    &#x2F;&#x2F; 合并a和b所在的两个集合：    p[find(a)] &#x3D; find(b);(2)维护size的并查集：    int p[N], size[N];    &#x2F;&#x2F;p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量    &#x2F;&#x2F; 返回x的祖宗节点    int find(int x)    &#123;        if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);        return p[x];    &#125;    &#x2F;&#x2F; 初始化，假定节点编号是1~n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        p[i] &#x3D; i;        size[i] &#x3D; 1;    &#125;    &#x2F;&#x2F; 合并a和b所在的两个集合：    size[find(b)] +&#x3D; size[find(a)];    p[find(a)] &#x3D; find(b);(3)维护到祖宗节点距离的并查集：    int p[N], d[N];    &#x2F;&#x2F;p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离    &#x2F;&#x2F; 返回x的祖宗节点    int find(int x)    &#123;        if (p[x] !&#x3D; x)        &#123;            int u &#x3D; find(p[x]);            d[x] +&#x3D; d[p[x]];            p[x] &#x3D; u;        &#125;        return p[x];    &#125;    &#x2F;&#x2F; 初始化，假定节点编号是1~n    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        p[i] &#x3D; i;        d[i] &#x3D; 0;    &#125;    &#x2F;&#x2F; 合并a和b所在的两个集合：    p[find(a)] &#x3D; find(b);    d[find(a)] &#x3D; distance; &#x2F;&#x2F; 根据具体问题，初始化find(a)的偏移量distance<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/838/">合并集合</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int p[N];&#x2F;&#x2F;每个元素的父节点int find(int x)&#x2F;&#x2F;返回祖宗节点+路径压缩&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    int n , m;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i ; &#x2F;&#x2F;初始化，使头结点指向自己    while(m--)    &#123;        char op[2];        int a,b;        scanf(&quot;%s%d%d&quot;,op,&amp;a,&amp;b);        if(op[0] &#x3D;&#x3D; &#39;M&#39;) p[find(a)] &#x3D; find(b);        else &#123;            if(find(a) &#x3D;&#x3D; find(b)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 每个元素的父节点</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> str <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>n <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>m <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>str <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token punctuation">[</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">find</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/839/">连通块中点的数量</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 1e5;int n, m;int p[N];int s[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        p[i] &#x3D; i;        s[i] &#x3D; 1;    &#125;     for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        string op;        int a, b;        cin &gt;&gt; op;        if(op &#x3D;&#x3D; &quot;C&quot;)&#123;            cin &gt;&gt; a &gt;&gt; b;            if(find(a) &#x3D;&#x3D; find(b)) continue;            s[find(b)] +&#x3D; s[find(a)];            p[find(a)] &#x3D; find(b);                    &#125;else if(op &#x3D;&#x3D; &quot;Q1&quot;)&#123;            cin &gt;&gt; a &gt;&gt; b;            if(find(a) &#x3D;&#x3D; find(b)) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;            else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;        &#125;else &#123;            cin &gt;&gt; a;            cout &lt;&lt; s[find(a)] &lt;&lt; endl;        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/242/">食物链</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305102147225.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 50010;int n, m;int d[N];int p[N];int find(int x)&#123;    if(p[x] !&#x3D; x) &#123;        int u &#x3D; find(p[x]);        d[x] +&#x3D; d[p[x]];        p[x] &#x3D; u;    &#125;    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++) p[i] &#x3D; i;    int res &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        int D, x, y;        cin &gt;&gt; D &gt;&gt; x &gt;&gt; y;        if(x &gt; n || y &gt; n) res ++ ;        else &#123;            int px &#x3D; find(x), py &#x3D; find(y);            if(D &#x3D;&#x3D; 1) &#123;                if(px &#x3D;&#x3D; py &amp;&amp; (d[x] - d[y]) % 3) res ++;                else if(px !&#x3D; py)&#123;                    p[px] &#x3D; py;                    d[px] &#x3D; d[y] - d[x]; &#x2F;&#x2F; (d[x] + ? - d[y]) mod 3 &#x3D;&#x3D; 0;                &#125;            &#125;            else &#123;                if(px &#x3D;&#x3D; py &amp;&amp; (d[x] - d[y] - 1) % 3) res ++;                else if(px !&#x3D; py)                &#123;                    p[px] &#x3D; py;                    d[px] &#x3D; d[y] + 1 - d[x]; &#x2F;&#x2F;(d[x] + ? - d[y] - 1) mod 3 &#x3D;&#x3D; 0;                &#125;            &#125;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304021645655.png"></p><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1&#x2F;&#x2F; ph[k]存储第k个插入的点在堆中的位置&#x2F;&#x2F; hp[k]存储堆中下标是k的点是第几个插入的int h[N], ph[N], hp[N], size;&#x2F;&#x2F; 交换两个点，及其映射关系void heap_swap(int a, int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a], hp[b]);    swap(h[a], h[b]);&#125;void down(int u)&#123;    int t &#x3D; u;    if (u * 2 &lt;&#x3D; size &amp;&amp; h[u * 2] &lt; h[t]) t &#x3D; u * 2;    if (u * 2 + 1 &lt;&#x3D; size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t &#x3D; u * 2 + 1;    if (u !&#x3D; t)    &#123;        heap_swap(u, t);        down(t);    &#125;&#125;void up(int u)&#123;    while (u &#x2F; 2 &amp;&amp; h[u] &lt; h[u &#x2F; 2])    &#123;        heap_swap(u, u &#x2F; 2);        u &gt;&gt;&#x3D; 1;    &#125;&#125;&#x2F;&#x2F; O(n)建堆for (int i &#x3D; n &#x2F; 2; i; i -- ) down(i);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/840/">https://www.acwing.com/problem/content/840/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string.h&gt;using namespace std;const int N &#x3D; 100010;int h[N],hp[N],ph[N],mysize;void heap_swap(int a,int b)&#123;    swap(ph[hp[a]],ph[hp[b]]);    swap(hp[a],hp[b]);    swap(h[a],h[b]);&#125;void down(int u)&#123;    int t &#x3D; u;    if(u*2 &lt;&#x3D; mysize &amp;&amp; h[u*2] &lt;&#x3D; h[t]) t &#x3D; u*2;    if(u*2+1 &lt;&#x3D; mysize &amp;&amp; h[u*2+1] &lt;&#x3D; h[t]) t &#x3D; u*2 +1;    if(u!&#x3D;t)    &#123;        heap_swap(u,t);        down(t);    &#125;&#125;void up(int u)&#123;    while(u&#x2F;2 &amp;&amp; h[u&#x2F;2] &gt; h[u])    &#123;        heap_swap(u,u&#x2F;2);        u &#x2F;&#x3D; 2;    &#125;&#125;int main()&#123;    int n,m &#x3D; 0;    scanf(&quot;%d&quot;,&amp;n);    while(n--)    &#123;        char op[10];        scanf(&quot;%s&quot;,op);        int x,k;        if(!strcmp(op,&quot;I&quot;))        &#123;            scanf(&quot;%d&quot;,&amp;x);            mysize ++ ;            m ++ ;            ph[m] &#x3D; mysize , hp[mysize] &#x3D; m;            h[mysize] &#x3D; x;            up(mysize);        &#125;        else if(!strcmp(op,&quot;PM&quot;)) printf(&quot;%d\n&quot;,h[1]);        else if(!strcmp(op,&quot;DM&quot;))        &#123;            heap_swap(1,mysize);            mysize -- ;            down(1);        &#125;        else if(!strcmp(op,&quot;D&quot;))        &#123;            scanf(&quot;%d&quot;,&amp;k);            k &#x3D; ph[k];            heap_swap(k,mysize);            mysize -- ;            down(k), up(k);        &#125;        else         &#123;            scanf(&quot;%d%d&quot;,&amp;k,&amp;x);            k &#x3D; ph[k];            h[k] &#x3D; x;            down(k),up(k);        &#125;            &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304021644791.png"></p><p>取模的数要取质数，且离2的整数次幂最远</p><h2 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h2><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(1) 拉链法    int h[N], e[N], ne[N], idx;    &#x2F;&#x2F; 向哈希表中插入一个数    void insert(int x)    &#123;        int k &#x3D; (x % N + N) % N;        e[idx] &#x3D; x;        ne[idx] &#x3D; h[k];        h[k] &#x3D; idx ++ ;    &#125;    &#x2F;&#x2F; 在哈希表中查询某个数是否存在    bool find(int x)    &#123;        int k &#x3D; (x % N + N) % N;        for (int i &#x3D; h[k]; i !&#x3D; -1; i &#x3D; ne[i])            if (e[i] &#x3D;&#x3D; x)                return true;        return false;    &#125;(2) 开放寻址法    int h[N];    &#x2F;&#x2F; 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置    int find(int x)    &#123;        int t &#x3D; (x % N + N) % N;        while (h[t] !&#x3D; null &amp;&amp; h[t] !&#x3D; x)        &#123;            t ++ ;            if (t &#x3D;&#x3D; N) t &#x3D; 0;        &#125;        return t;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/842/">https://www.acwing.com/problem/content/842/</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 100003;&#x2F;&#x2F;大于十万的第一个质数int h[N];&#x2F;&#x2F;哈希表的槽int e[N],ne[N],idx;&#x2F;&#x2F;每个槽的链表void insert(int x)&#123;    int k &#x3D; (x % N + N) % N ;&#x2F;&#x2F;让余数变成正数        e[idx] &#x3D; x;    ne[idx] &#x3D; h[k];    h[k] &#x3D; idx ++ ;&#125;bool find(int x)&#123;    int k &#x3D; (x % N + N) % N;    for(int i &#x3D; h[k] ; i !&#x3D; -1 ; i &#x3D; ne[i])    &#123;        if(e[i] &#x3D;&#x3D; x) return true;    &#125;    return false;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);        memset(h,-1,sizeof h);    while(n--)    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;,op,&amp;x);        if(*op &#x3D;&#x3D; &#39;I&#39;) insert(x);        else         &#123;            if(find(x)) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 200003, null &#x3D; 0x3f3f3f3f;&#x2F;&#x2F;大于二十万的第一个质数int h[N];&#x2F;&#x2F;哈希表的槽&#x2F;&#x2F;若存在元素,find函数返回位置，若不存在，则返回应该存储的位置int find(int x)&#123;    int k &#x3D; (x % N + N)%N;    while(h[k] !&#x3D; null &amp;&amp; h[k] !&#x3D; x)&#x2F;&#x2F;当前位置不为空，且元素不是他自己    &#123;        k ++ ;        if(k &#x3D;&#x3D; N) k &#x3D; 0;&#x2F;&#x2F;若k走到最后的一个位置，则从头开始找    &#125;    return k;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);        memset(h,0x3f,sizeof h);&#x2F;&#x2F;memset是按字节进行    while(n--)    &#123;        char op[2];        int x;        scanf(&quot;%s%d&quot;,op,&amp;x);        int k &#x3D; find(x);        if(*op &#x3D;&#x3D; &#39;I&#39;) h[k] &#x3D; x;        else         &#123;            if(h[k] !&#x3D; null) puts(&quot;Yes&quot;);            else puts(&quot;No&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="字符串前缀哈希法"><a href="#字符串前缀哈希法" class="headerlink" title="字符串前缀哈希法"></a>字符串前缀哈希法</h2><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果typedef unsigned long long ULL;ULL h[N], p[N]; &#x2F;&#x2F; h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64&#x2F;&#x2F; 初始化p[0] &#x3D; 1;for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )&#123;    h[i] &#x3D; h[i - 1] * P + str[i];    p[i] &#x3D; p[i - 1] * P;&#125;&#x2F;&#x2F; 计算子串 str[l ~ r] 的哈希值ULL get(int l, int r)&#123;    return h[r] - h[l - 1] * p[r - l + 1];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/843/">https://www.acwing.com/problem/content/843/</a></p><p>预处理字符串前缀的哈希</p><p>Q：如何定义某一个前缀的哈希值</p><p>A：把字符串看成一个P进制的数                                                                     </p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304021644086.png"></p><p>如果实现取字符串的两个子串匹配，每取一次就计算一次哈希值的时间复杂度也会到O(n)。最好的方法就是预处理求前缀和，把时间复杂度降低为O(1)。<br>当得到前缀和数组后，每次对[l, r]区间字符串的访问就可以直接得到其哈希值了。<br>对应的两个公式分别是：</p><p>预处理：h[i] = h[i - 1] * P + str[i]<br>每次查询[l, r]：h[r] - h[l - 1] * Pr-l+1<br>注：为什么不是 h[r] - h[l-1] 而是 h[r] - h[l - 1] * pr-l+1？理由如下：<br>给定字符串ABCDE，想知道ABC和DE，那么看成P进制的数之后，DE = ABCDE - ABC00（其中：ABC00 = ABC * p2），而不是ABCDE - ABC。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;typedef unsigned long long ULL;const int N &#x3D; 100010, P &#x3D; 131;int n,m;char str[N];ULL h[N],p[N];ULL get(int l,int r)&#123;    return h[r] - h[l-1] * p[r-l+1];&#125;int main()&#123;    scanf(&quot;%d%d%s&quot;,&amp;n,&amp;m,str+1);    p[0] &#x3D; 1;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        p[i] &#x3D; p[i-1] * P;        h[i] &#x3D; h[i-1] * P + str[i];    &#125;        while(m--)    &#123;        int l1,r1,l2,r2;        scanf(&quot;%d%d%d%d&quot;,&amp;l1,&amp;r1,&amp;l2,&amp;r2);        if(get(l1,r1) &#x3D;&#x3D; get(l2,r2)) puts(&quot;Yes&quot;);        else puts(&quot;No&quot;);    &#125;        return 0;&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="stl"><a href="#stl" class="headerlink" title="stl"></a>stl</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector, 变长数组，倍增的思想    size()  返回元素个数    empty()  返回是否为空    clear()  清空    front()&#x2F;back() 第一个数&#x2F;最后一个数    push_back()&#x2F;pop_back() 向最后插入一个数&#x2F;删掉最后一个数    begin()&#x2F;end() 第0个数&#x2F;最后一个数的后面一个数 即a[0]&#x2F;a[a.size()]    [] 支持随机寻址    支持比较运算，按字典序pair&lt;int, int&gt;    first, 第一个元素    second, 第二个元素    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）string，字符串    size()&#x2F;length()  返回字符串长度    empty()    clear()    substr(起始下标，(子串长度))  返回子串    c_str()  返回字符串所在字符数组的起始地址queue, 队列    size()    empty()    push()  向队尾插入一个元素    front()  返回队头元素    back()  返回队尾元素    pop()  弹出队头元素priority_queue, 优先队列，默认是大根堆    size()    empty()    push()  插入一个元素    top()  返回堆顶元素    pop()  弹出堆顶元素    定义成小根堆的方式：priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;stack, 栈    size()    empty()    push()  向栈顶插入一个元素    top()  返回栈顶元素    pop()  弹出栈顶元素deque, 双端队列    size()    empty()    clear()    front()&#x2F;back()    push_back()&#x2F;pop_back()    push_front()&#x2F;pop_front()    begin()&#x2F;end()    []set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列    size()    empty()    clear()    begin()&#x2F;end()    ++, -- 返回前驱和后继，时间复杂度 O(logn)    set&#x2F;multiset        insert()  插入一个数        find()  查找一个数        count()  返回某一个数的个数        erase()            (1) 输入是一个数x，删除所有x   O(k + logn)            (2) 输入一个迭代器，删除这个迭代器        lower_bound()&#x2F;upper_bound()            lower_bound(x)  返回大于等于x的最小的数的迭代器            upper_bound(x)  返回大于x的最小的数的迭代器    map&#x2F;multimap        insert()  插入的数是一个pair        erase()  输入的参数是pair或者迭代器        find()        []  注意multimap不支持此操作。 时间复杂度是 O(logn)        lower_bound()&#x2F;upper_bound()unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表    和上面类似，增删改查的时间复杂度是 O(1)    不支持 lower_bound()&#x2F;upper_bound()， 迭代器的++，--bitset, 圧位    最主要特点是可以省空间    bitset&lt;10000&gt; s; bit&lt;个数&gt;    ~, &amp;, |, ^    &gt;&gt;, &lt;&lt; 移位操作    &#x3D;&#x3D;, !&#x3D;    []    count()  返回有多少个1    any()  判断是否至少有一个1    none()  判断是否全为0    set()  把所有位置成1    set(k, v)  将第k位变成v    reset()  把所有位变成0    flip()  等价于~    flip(k) 把第k位取反<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; a(10,3); &#x2F;&#x2F;定义长度为10的数组并初始化为3    vector&lt;int&gt; a;        for(int i &#x3D; 0; i&lt; 10;i++) a.push_back(i);    for(int i &#x3D; 0; i &lt; a.size();i++) cour &lt;&lt; a[i] &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;        for(vector&lt;int&gt;::iterator i &#x3D; a.begin(); i ++ ) cout &lt;&lt; *i &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl;        for(auto x : a) cout &lt;&lt; x &lt;&lt; &#39; &#39;;    cout &lt;&lt; endl; &#x2F;&#x2F;auto自动推断变量类型        &#x2F;&#x2F;支持比较    &#x2F;*    如果两个vector对象的容量不同，但是相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象。若元素的值有区别，则vector对象的大小关系由第一对相异的元素值的大小关系决定。*&#x2F;    vector&lt;int&gt; a(4,3) , b(3,4);    if(a&lt;b) puts(&quot;a&lt;b&quot;);    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>系统为某个程序分配空间时，所需时间与空间大小无关，与申请次数有关</p></blockquote><p>vector优化：数组需要变长时，就把数组元素×2——倍增的思想</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">pair&lt;int,string&gt;p;p.first;p.second;p &#x3D; make_pair(10,&quot;yxc&quot;);p &#x3D; &#123;20, &quot;abc&quot;&#125;;pair&lt;int,pair&lt;int,int&gt;&gt;p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string a &#x3D; &quot;yxc&quot;;a +&#x3D; &quot;def&quot;;a +&#x3D; &#39;c&#39;;cout &lt;&lt; a.substr(1,2) &lt;&lt; endl &#x2F;&#x2F;xc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">queue&lt;int&gt; q;q &#x3D; queue&lt;int&gt;();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h2><p>优先队列，默认是大根堆</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">priority_queue&lt;int&gt; heap;&#x2F;&#x2F;插入时按负数插入，可实现小根堆heap.push(-x);&#x2F;&#x2F;直接定义小根堆priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; heap;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="算法提高课"><a href="#算法提高课" class="headerlink" title="算法提高课"></a>算法提高课</h1><h1 id="并查集-1"><a href="#并查集-1" class="headerlink" title="并查集"></a>并查集</h1><p><a href="https://www.acwing.com/problem/content/1252/">格子游戏</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 40010;int n, m;int p[N];int get(int a,int b)&#123;    return a * n + b;&#125;int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m ;    for(int i &#x3D; 0 ; i &lt; n * n ; i ++ ) p[i] &#x3D; i;        int res &#x3D; 0;    for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++ )&#123;        int x, y;        char d;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;        x-- , y--;        int a &#x3D; get(x, y);        int b;        if(d &#x3D;&#x3D; &#39;D&#39;) b &#x3D; get(x + 1, y);        else b &#x3D; get(x, y + 1);                int pa &#x3D; find(a), pb &#x3D; find(b);        if(pa &#x3D;&#x3D; pb)&#123;          res &#x3D; i;          break;        &#125;         p[pa] &#x3D; pb;    &#125;    if(!res) cout &lt;&lt; &quot;draw&quot; &lt;&lt; endl;    else cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/1254/">搭配购买</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 10010;int n, m, vol;int v[N], w[N];int p[N];int f[N];int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; vol;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )&#123;        cin &gt;&gt; v[i] &gt;&gt; w[i];    &#125;        for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        int pa &#x3D; find(a);        int pb &#x3D; find(b);        if(pa !&#x3D; pb)&#123;            v[pb] +&#x3D; v[pa];            w[pb] +&#x3D; w[pa];            p[pa] &#x3D; pb;        &#125;    &#125;        &#x2F;&#x2F;01背包    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++ )        if(p[i] &#x3D;&#x3D; i)        &#123;            for(int j &#x3D; vol; j &gt;&#x3D; v[i]; j -- )&#123;                f[j] &#x3D; max(f[j], f[j - v[i]] + w[i]);            &#125;        &#125;            cout &lt;&lt; f[vol] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/239/">程序自动分析</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;unordered_map&gt;using namespace std;const int N &#x3D; 200010;int n,m ;int p[N];unordered_map&lt;int,int&gt; S;struct Query&#123;    int x, y, e;&#125;query[N];int get(int x)&#123;    if(S.count(x) &#x3D;&#x3D; 0) S[x] &#x3D; ++n ;    return S[x];&#125;int find(int x)&#123;    if(p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    int T;    cin &gt;&gt; T;    while(T --)&#123;        n &#x3D; 0;        cin &gt;&gt; m ;        S.clear();        for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;            int x, y, e;            cin &gt;&gt; x &gt;&gt; y &gt;&gt; e;            query[i] &#x3D; &#123;get(x), get(y), e&#125;;        &#125;                for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ ) p[i] &#x3D; i;                for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;            if(query[i].e &#x3D;&#x3D; 1)&#123;                int pa &#x3D; find(query[i].x);                int pb &#x3D; find(query[i].y);                p[pa] &#x3D; pb;            &#125;        &#125;                bool flag &#x3D; false;        for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;            if(query[i].e &#x3D;&#x3D; 0)&#123;                int pa &#x3D; find(query[i].x);                int pb &#x3D; find(query[i].y);                if(pa &#x3D;&#x3D; pb)&#123;                    flag &#x3D; true;                    break;                &#125;            &#125;        &#125;                if(flag) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl;        else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl;    &#125;         return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/240/">银河英雄传说</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 30010;int m;int p[N], sz[N], d[N];int find(int x)&#123;    if(p[x] !&#x3D; x)&#123;        int u &#x3D; find(p[x]);        d[x] +&#x3D; d[p[x]];        p[x] &#x3D; u;    &#125;    return p[x];&#125;int main()&#123;    cin &gt;&gt; m ;        for(int i &#x3D; 1 ; i &lt; N ; i ++ )&#123;        p[i] &#x3D; i;        sz[i] &#x3D; 1;    &#125;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )&#123;        char op[2];        int a, b;        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;        if(op[0] &#x3D;&#x3D; &#39;M&#39;)&#123;            int pa &#x3D; find(a), pb &#x3D; find(b);            if(pa !&#x3D; pb)&#123;                d[pa] &#x3D; sz[pb];                sz[pb] +&#x3D; sz[pa];                p[pa] &#x3D; pb;                            &#125;        &#125;else &#123;            int pa &#x3D; find(a), pb &#x3D; find(b);            if(pa !&#x3D; pb) cout &lt;&lt; &quot;-1&quot; &lt;&lt; endl;            else cout &lt;&lt; max(abs(d[a] - d[b]) - 1 , 0) &lt;&lt; endl;        &#125;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/241/">奇偶游戏</a></p><p>带边权写法</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305222204679.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 20010;int n, m;int p[N], d[N];unordered_map&lt;int,int&gt; S;int get(int x)&#123;    if(S.count(x) &#x3D;&#x3D; 0) S[x] &#x3D; ++ n;    return S[x];&#125;int find(int x)&#123;    if(p[x] !&#x3D; x)&#123;        int u &#x3D; find(p[x]);        d[x] +&#x3D; d[p[x]];        p[x] &#x3D; u;    &#125;        return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    n &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; N ; i++ ) p[i] &#x3D; i;    int res &#x3D; m;    for(int i &#x3D; 1 ; i &lt;&#x3D; m ; i ++ )&#123;        int a, b;        string type;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;        a &#x3D; get(a - 1), b &#x3D; get(b);                int t &#x3D; 0;        if(type &#x3D;&#x3D; &quot;odd&quot;) t &#x3D; 1;        int pa &#x3D; find(a), pb &#x3D; find(b);        if(pa &#x3D;&#x3D; pb)&#123;            if(((d[a] + d[b]) % 2 + 2) % 2 !&#x3D; t)            &#123;                res &#x3D; i - 1 ;                break;            &#125;        &#125;        else &#123;            p[pa] &#x3D; pb;            d[pa] &#x3D; d[a] ^ d[b] ^ t;        &#125;    &#125;        cout &lt;&lt; res &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>扩展域写法</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305222212339.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int N &#x3D; 40010, Base &#x3D; N &#x2F; 2;int n, m;int p[N];unordered_map&lt;int, int&gt; S;int get(int x)&#123;    if (S.count(x) &#x3D;&#x3D; 0) S[x] &#x3D; ++ n;    return S[x];&#125;int find(int x)&#123;    if (p[x] !&#x3D; x) p[x] &#x3D; find(p[x]);    return p[x];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    n &#x3D; 0;    for (int i &#x3D; 0; i &lt; N; i ++ ) p[i] &#x3D; i;    int res &#x3D; m;    for (int i &#x3D; 1; i &lt;&#x3D; m; i ++ )    &#123;        int a, b;        string type;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; type;        a &#x3D; get(a - 1), b &#x3D; get(b);        if (type &#x3D;&#x3D; &quot;even&quot;)        &#123;            if (find(a + Base) &#x3D;&#x3D; find(b))            &#123;                res &#x3D; i - 1;                break;            &#125;            p[find(a)] &#x3D; find(b);            p[find(a + Base)] &#x3D; find(b + Base);        &#125;        else        &#123;            if (find(a) &#x3D;&#x3D; find(b))            &#123;                res &#x3D; i - 1;                break;            &#125;            p[find(a + Base)] &#x3D; find(b);            p[find(a)] &#x3D; find(b + Base);        &#125;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><p><a href="https://www.acwing.com/problem/content/243/">楼兰图腾</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 2000010;typedef long long LL;int n;&#x2F;&#x2F;t[i]表示树状数组i结点覆盖的范围和int a[N], t[N];&#x2F;&#x2F;Lower[i]表示左边比第i个位置小的数的个数&#x2F;&#x2F;Greater[i]表示左边比第i个位置大的数的个数int Lower[N], Greater[N];&#x2F;&#x2F;返回非负整数x在二进制表示下最低位1及其后面的0构成的数值int lowbit(int x)&#123;    return x &amp; -x;&#125;&#x2F;&#x2F;将序列中第x个数加上k。void add(int x, int k)&#123;    for(int i &#x3D; x; i &lt;&#x3D; n; i +&#x3D; lowbit(i)) t[i] +&#x3D; k;&#125;&#x2F;&#x2F;查询序列前x个数的和int ask(int x)&#123;    int sum &#x3D; 0;    for(int i &#x3D; x; i; i -&#x3D; lowbit(i)) sum +&#x3D; t[i];    return sum;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for(int i &#x3D; 1; i &lt;&#x3D; n; i++) scanf(&quot;%d&quot;, &amp;a[i]);    &#x2F;&#x2F;从左向右，依次统计每个位置左边比第i个数y小的数的个数、以及大的数的个数    for(int i &#x3D; 1; i &lt;&#x3D; n; i++)    &#123;        int y &#x3D; a[i]; &#x2F;&#x2F;第i个数        &#x2F;&#x2F;在前面已加入树状数组的所有数中统计在区间[1, y - 1]的数字的出现次数        Lower[i] &#x3D; ask(y - 1);         &#x2F;&#x2F;在前面已加入树状数组的所有数中统计在区间[y + 1, n]的数字的出现次数        Greater[i] &#x3D; ask(n) - ask(y);        &#x2F;&#x2F;将y加入树状数组，即数字y出现1次        add(y, 1);    &#125;    &#x2F;&#x2F;清空树状数组，从右往左统计每个位置右边比第i个数y小的数的个数、以及大的数的个数    memset(t, 0, sizeof t);    LL resA &#x3D; 0, resV &#x3D; 0;    &#x2F;&#x2F;从右往左统计    for(int i &#x3D; n; i &gt;&#x3D; 1; i--)    &#123;        int y &#x3D; a[i];        resA +&#x3D; (LL)Lower[i] * ask(y - 1);        resV +&#x3D; (LL)Greater[i] * (ask(n) - ask(y));        &#x2F;&#x2F;将y加入树状数组，即数字y出现1次        add(y, 1);    &#125;    printf(&quot;%lld %lld\n&quot;, resV, resA);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法（一）基础算法</title>
      <link href="/2023/03289396.html"/>
      <url>/2023/03289396.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法（一）基础算法"><a href="#算法（一）基础算法" class="headerlink" title="算法（一）基础算法"></a>算法（一）基础算法</h1><h1 id="基础课"><a href="#基础课" class="headerlink" title="基础课"></a>基础课</h1><h2 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h2><p><strong>分治</strong></p><ol><li>确定分界点</li><li>调整范围（重点）</li><li>递归处理左右两段</li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void quick_sort(int q[],int l,int r)&#123;if(l &gt;&#x3D; r) return;int x &#x3D; q[l+r&gt;&gt;1] , i &#x3D; l-1, j &#x3D; r+1;while(i&lt;j)&#123;do i++ ; while(q[i]&lt;x);do j-- ; while(q[j]&gt;x);if(i&lt;j) swap(q[i],q[j]);&#125;quick_sort(q,l,j);quick_sort(q,j+1,r);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>l<span class="token operator">+</span>r<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">do</span> i<span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> j<span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>     <span class="token punctuation">&#125;</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>l<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/787/">快速排序</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1e6+10;int n;int q[N];void quick_sort(int q[],int l,int r)&#123;if(l &gt;&#x3D; r) return;int x &#x3D; q[l] , i &#x3D; l-1, j &#x3D; r+1;while(i&lt;j)&#123;do i++ ; while(q[i]&lt;x);do j-- ; while(q[j]&gt;x);if(i&lt;j) swap(q[i],q[j]);&#125;quick_sort(q,l,j);quick_sort(q,j+1,r);&#125;int main()&#123;scanf(&quot;%d&quot;,&amp;n);for(int i&#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]);quick_sort(q,0,n-1);for(int i&#x3D;0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quick_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span>     <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">int</span> x <span class="token operator">=</span> q<span class="token punctuation">[</span>l<span class="token operator">+</span>r<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">do</span> i<span class="token operator">++</span> <span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">do</span> j<span class="token operator">--</span> <span class="token punctuation">;</span> <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                q<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>         <span class="token punctuation">&#125;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>l<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">quick_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h2><p><strong>分治</strong></p><ol><li>确定分界点mid=(1+r)/2</li><li>递归排序左边和右边</li><li>归并-合二为一（重点）</li></ol><blockquote><p>算法的稳定性：若原序列中相同数值的数排序后前后位置不发生变化，则称算法是稳定的，反之则是不稳定的</p><p>快排不稳定，归排稳定</p></blockquote><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort(int q[n],int l,int r)&#123;if (l&gt;&#x3D;r )return;int mid&#x3D; l+r &gt;&gt; 1; &#x2F;&#x2F;(l+r)&#x2F;2merge_sort(q,l,mid);merge_sort(q,mid+1,r);int k &#x3D;0 ,i &#x3D; l,j &#x3D; mid +1;while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;r)if(q[i] &lt;&#x3D; q[j]) tmp[k++] &#x3D; q[i++];else tmp[k++] &#x3D; q[j++];while(i&lt;&#x3D;mid) tmp[k++] &#x3D; q[i++];while(j&lt;&#x3D;r) tmp[k++] &#x3D; q[j++];for(i &#x3D; 1,j&#x3D;0;i&lt;&#x3D;r;i++,j++) q[i] &#x3D; tmp[j]; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> l<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span>i <span class="token operator">++</span> <span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/789/">归并排序</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1000010;int n;int q[N],tmp[N];void merge_sort(int q[n],int l,int r)&#123;if (l&gt;&#x3D;r )return;int mid&#x3D; l+r &gt;&gt; 1; &#x2F;&#x2F;(l+r)&#x2F;2merge_sort(q,l,mid);merge_sort(q,mid+1,r);int k &#x3D;0 ,i &#x3D; l,j &#x3D; mid +1;while(i&lt;&#x3D;mid &amp;&amp; j&lt;&#x3D;r)if(q[i] &lt;&#x3D; q[j]) tmp[k++] &#x3D; q[i++];else tmp[k++] &#x3D; q[j++];while(i&lt;&#x3D;mid) tmp[k++] &#x3D; q[i++];while(j&lt;&#x3D;r) tmp[k++] &#x3D; q[j++];for(i &#x3D; l,j&#x3D;0;i&lt;&#x3D;r;i++,j++) q[i] &#x3D; tmp[j]; &#125;int main()&#123;scanf(&quot;%d&quot;,&amp;n);for (int i &#x3D; 0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]);merge_sort(q,0,n-1);for (int i &#x3D; 0;i&lt;n;i++) printf(&quot;%d &quot;,q[i]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> q<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> temp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> q<span class="token punctuation">,</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">>=</span> r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>l<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">=</span> l<span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> q<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> l<span class="token punctuation">,</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> r<span class="token punctuation">;</span>i <span class="token operator">++</span> <span class="token punctuation">,</span> j <span class="token operator">++</span> <span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge_sort</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、二分"><a href="#3、二分" class="headerlink" title="3、二分"></a>3、二分</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ol><li>mid=(l+r+1)/2</li><li>check(mid):true-&gt;[mid,r],l=mid;false-&gt;[l,mid-1],r=mid-1</li><li>mid=(l+r)/2</li><li>check(mid):true-&gt;[l,mid];false-&gt;[mid+1,r]</li></ol><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(int x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质&#x2F;&#x2F; 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：int bsearch_1(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (check(mid)) r &#x3D; mid;    &#x2F;&#x2F; check()判断mid是否满足性质        else l &#x3D; mid + 1;    &#125;    return l;&#125;&#x2F;&#x2F; 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：int bsearch_2(int l, int r)&#123;    while (l &lt; r)    &#123;        int mid &#x3D; l + r + 1 &gt;&gt; 1;        if (check(mid)) l &#x3D; mid;        else r &#x3D; mid - 1;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/791/">数的范围</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n,m;int q[N];int mian()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i &#x3D;0;i&lt;n;i++) scanf(&quot;%d&quot;,&amp;q[i]);    while(m--)    &#123;        int x;        scanf(&quot;%d&quot;,&amp;x);                int l &#x3D;0,r&#x3D;n-1;        while(l&lt;r)        &#123;            int mid &#x3D; l+r&gt;&gt;1;            if(q[mid]&gt;&#x3D;x) r&#x3D;mid;            else l &#x3D;mid+1;        &#125;        if(q[l] !&#x3D; x) cout&lt;&lt;&quot;-1 -1&quot;&lt;&lt;endl;        else&#123;            cout &lt;&lt;l&lt;&lt;&#39; &#39;;            int l &#x3D;0,r&#x3D;n-1;        while(l&lt;r)        &#123;            int mid &#x3D; l+r+1&gt;&gt;1;            if(q[mid]&lt;&#x3D;x) l&#x3D;mid;            else r &#x3D;mid-1;        &#125;            cout&lt;&lt;l&lt;&lt;endl        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">import java.io.*;import java.util.*;public class Main&#123;    public static BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(System.in));    public static StreamTokenizer in &#x3D; new StreamTokenizer(new InputStreamReader(System.in));    public static PrintWriter out &#x3D; new PrintWriter(new OutputStreamWriter(System.out));        public static int nextInt() throws Exception&#123;        in.nextToken();        return (int)in.nval;    &#125;        public static int N &#x3D; 100010;    public static int n,m;    public static int q[] &#x3D; new int[N];    public static void main(String[] args)throws Exception&#123;        n &#x3D; nextInt();        m &#x3D; nextInt();        for(int i &#x3D; 0; i &lt; n ; i ++ ) q[i] &#x3D; nextInt();        while(m&gt;0)        &#123;            int x;            x &#x3D; nextInt();            int l &#x3D; 0, r &#x3D; n - 1;            while(l &lt; r)            &#123;                int mid &#x3D; l + r &gt;&gt; 1;                if(q[mid] &gt;&#x3D; x) r &#x3D; mid;                else l &#x3D; mid + 1;            &#125;            if(q[l] !&#x3D; x) out.println(&quot;-1 -1&quot;);            else &#123;                out.print(l + &quot; &quot;);                l &#x3D; 0;                r &#x3D; n - 1;                while(l &lt; r)                &#123;                    int mid &#x3D; l + r + 1 &gt;&gt; 1;                    if(q[mid] &lt;&#x3D; x) l &#x3D; mid;                    else r &#x3D; mid - 1;                &#125;                out.println(l);            &#125;            m--;        &#125;        out.flush();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="浮点数二分算法"><a href="#浮点数二分算法" class="headerlink" title="浮点数二分算法"></a>浮点数二分算法</h3><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool check(double x) &#123;&#x2F;* ... *&#x2F;&#125; &#x2F;&#x2F; 检查x是否满足某种性质double bsearch_3(double l, double r)&#123;    const double eps &#x3D; 1e-6;   &#x2F;&#x2F; eps 表示精度，取决于题目对精度的要求    while (r - l &gt; eps)    &#123;        double mid &#x3D; (l + r) &#x2F; 2;        if (check(mid)) r &#x3D; mid;        else l &#x3D; mid;    &#125;    return l;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4、高精度运算"><a href="#4、高精度运算" class="headerlink" title="4、高精度运算"></a>4、高精度运算</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p><strong>Java中有两个类可以来处理高精度的计算</strong>，分别是处理整数的<strong>BigInteger</strong>和处理小数的<strong>BigDecimal</strong></p><p><strong>BigInteger</strong></p><p><strong>构造方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> val<span class="token punctuation">)</span> 将包含<span class="token class-name">BigInteger</span>的二进制补码二进制表达式的字节数组转换为<span class="token class-name">BigInteger</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> numBits<span class="token punctuation">,</span> <span class="token class-name">Random</span> rnd<span class="token punctuation">)</span> 构造一个随机生成的<span class="token class-name">BigInteger</span>，均匀分布在<span class="token number">0</span>到（<span class="token number">2</span> numBits <span class="token operator">-</span> <span class="token number">1</span>）的范围内。  <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token class-name">String</span> val<span class="token punctuation">)</span> 将<span class="token class-name">BigInteger</span>的十进制字符串表示形式转换为<span class="token class-name">BigInteger</span>。  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加法add()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>减法substract()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">subtract</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>乘法multiply()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">multiply</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>除法divideAndRemainder()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//divide 返回值为 a/b</span>        <span class="token class-name">BigInteger</span><span class="token punctuation">[</span><span class="token punctuation">]</span> c <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">divideAndRemainder</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//返回值为数组，分别为a/b和a%b</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>取余mod()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigInteger</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigInteger</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">mod</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>BigDecimal处理浮点数运算</strong><br><strong>构造方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">)</span> 一个转换的字符数组表示 <span class="token class-name">BigDecimal</span>成 <span class="token class-name">BigDecimal</span> ，接受字符作为的相同序列 <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>构造。  <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> in<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> 一个转换的字符数组表示 <span class="token class-name">BigDecimal</span>成 <span class="token class-name">BigDecimal</span> ，接受字符作为的相同序列 <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span>构造，同时允许一个子阵列被指定。    <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">double</span> val<span class="token punctuation">)</span> 将 <span class="token keyword">double</span>转换为 <span class="token class-name">BigDecimal</span> ，这是 <span class="token keyword">double</span>的二进制浮点值的精确十进制表示 <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span>将 <span class="token keyword">int</span>成 <span class="token class-name">BigDecimal</span><span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token keyword">long</span> val<span class="token punctuation">)</span> 将 <span class="token keyword">long</span>成 <span class="token class-name">BigDecimal</span><span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token class-name">String</span> val<span class="token punctuation">)</span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>加法add()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>取余remainder()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">remainder</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>除法divide()</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>math<span class="token punctuation">.</span></span><span class="token class-name">BigDecimal</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">BufferedReader</span> reader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">BigDecimal</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span>reader<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">divide</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        reader<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h3><ol><li>大整数存储（数组0位存个位，依此类推）</li><li>代码模拟加法的过程</li></ol><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; C &#x3D; A + B, A &gt;&#x3D; 0, B &gt;&#x3D; 0vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123;    if (A.size() &lt; B.size()) return add(B, A);    vector&lt;int&gt; C;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; A.size(); i ++ )    &#123;        t +&#x3D; A[i];        if (i &lt; B.size()) t +&#x3D; B[i];        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    if (t) C.push_back(t);    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/793/">高精度加法</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace stdconst int N&#x3D;1e6+10;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i&#x3D;0;i&lt;A.size()||i&lt;B.size();i++)    &#123;        if(i&lt;A.size()) t+&#x3D;A[i];        if(i&lt;B.size()) t+&#x3D;B[i];        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;        if(t) C.push_back(t);    return C;&#125;int main()&#123;string a,b;vector&lt;int&gt; A,B;cin&gt;&gt;a&gt;&gt;b;for(int i &#x3D;a.size()-1;i&gt;&#x3D;0;i--) A.push_back(a[i]-&#39;0&#39;);for(int i &#x3D;b.size()-1;i&gt;&#x3D;0;i--) B.push_back(b[i]- &#39;0&#39;);auto C&#x3D;add(A,b); &#x2F;&#x2F;auto意思是编译器自动推断返回值是什么类型for(int i&#x3D;C.size()-1;i&gt;&#x3D;0;i--) printf(&quot;%d&quot;,C[i]);return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h3><p>模板：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;    if(A.size() !&#x3D; B.size()) return A.size() &gt; B.size();    for(int i &#x3D; A.size() - 1; i &gt;&#x3D; 0 ; i -- )&#123;        if(A[i] !&#x3D; B[i])&#123;            return A[i] &gt; B[i];        &#125;    &#125;    return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; A.size() ; i ++ )    &#123;        t &#x3D; A[i] - t;        if(i&lt;B.size()) t-&#x3D; B[i];        C.push_back((t+10)%10);        if(t&lt;0) t &#x3D; 1;        else t &#x3D; 0;    &#125;        while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/794/">高精度减法</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;    if(A.size()!&#x3D;B.size()) return A.size() &gt; B.size();    for(int i &#x3D; A.size() - 1 ; i &gt;&#x3D; 0  ; i -- ) &#123;        if(A[i]!&#x3D;B[i]) return A[i] &gt; B[i];    &#125;    return true;&#125;vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; A.size() ; i ++ )&#123;        t &#x3D; A[i] - t;        if(i&lt;B.size()) t -&#x3D; B[i];        C.push_back((t+10)%10);        if(t&lt;0) t &#x3D; 1;        else t &#x3D; 0;    &#125;        while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    string a,b;    cin &gt;&gt; a &gt;&gt; b;    vector&lt;int&gt; A,B;    for(int i &#x3D; a.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) A.push_back(a[i]-&#39;0&#39;);    for(int i &#x3D; b.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) B.push_back(b[i]-&#39;0&#39;);    vector&lt;int&gt; C;    if(cmp(A,B)) &#123;        C &#x3D; sub(A,B);        for(int i &#x3D; C.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) printf(&quot;%d&quot;,C[i]);    &#125;else &#123;        C &#x3D; sub(B,A);        printf(&quot;-&quot;);        for(int i &#x3D; C.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) printf(&quot;%d&quot;,C[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; C &#x3D; A * b, A &gt;&#x3D; 0, b &gt;&#x3D; 0vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; A.size() || t; i ++ )    &#123;        if (i &lt; A.size()) t +&#x3D; A[i] * b;        C.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/795/">高精度乘法</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt;&amp;A,int b)&#123;    vector&lt;int&gt; C;    int t &#x3D; 0;    for(int i &#x3D; 0 ; i &lt; A.size() || t ; i ++ )    &#123;        if(i &lt; A.size()) t +&#x3D; A[i] * b;        C.push_back(t%10);        t&#x2F;&#x3D;10;    &#125;    while(C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    string a;    int b;    cin &gt;&gt; a ;    cin &gt;&gt; b ;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) A.push_back(a[i]-&#39;0&#39;);    vector&lt;int&gt; C;    C &#x3D; mul(A,b);    for(int i &#x3D; C.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) printf(&quot;%d&quot;,C[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="高精度除以低精度"><a href="#高精度除以低精度" class="headerlink" title="高精度除以低精度"></a>高精度除以低精度</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; A &#x2F; b &#x3D; C ... r, A &gt;&#x3D; 0, b &gt; 0vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)&#123;    vector&lt;int&gt; C;    r &#x3D; 0;    for (int i &#x3D; A.size() - 1; i &gt;&#x3D; 0; i -- )    &#123;        r &#x3D; r * 10 + A[i];        C.push_back(r &#x2F; b);&#x2F;&#x2F;push_back即在数组后添加某数        r %&#x3D; b;    &#125;    reverse(C.begin(), C.end());    while (C.size() &gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/796/">高精度除法</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt;&amp; A,int b ,int&amp; r)&#123;    vector&lt;int&gt; C;    r &#x3D; 0;    for(int i &#x3D; A.size()- 1 ; i &gt;&#x3D; 0 ; i -- )    &#123;        r &#x3D; r * 10 + A[i];        C.push_back(r&#x2F;b);        r %&#x3D; b;    &#125;    reverse(C.begin(),C.end());    while(C.size()&gt; 1 &amp;&amp; C.back() &#x3D;&#x3D; 0) C.pop_back();    return C;&#125;int main()&#123;    string a;    int b;    cin &gt;&gt; a ;    cin &gt;&gt; b ;    vector&lt;int&gt; A;    for(int i &#x3D; a.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) A.push_back(a[i]-&#39;0&#39;);    vector&lt;int&gt; C;    int r;    C &#x3D; div(A,b,r);    for(int i &#x3D; C.size() - 1 ; i &gt;&#x3D; 0 ; i -- ) printf(&quot;%d&quot;,C[i]);    printf(&quot;\n%d&quot;,r);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5、前缀和与差分"><a href="#5、前缀和与差分" class="headerlink" title="5、前缀和与差分"></a>5、前缀和与差分</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>原数组：a1,a2,a3,a4….an</p><p>前缀和：Si=a1+a2+…ai</p><ol><li>如何求Si：S[i]=S[i-1]+a[i]</li><li>作用：快速求出原数组中的一段数的和 al+…+ar=S[r]-S[l-1]</li></ol><p>模板：</p><pre class="line-numbers language-none"><code class="language-none">S[i] &#x3D; a[1] + a[2] + ... a[i]a[l] + ... + a[r] &#x3D; S[r] - S[l - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/797/">前缀和</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n,m;int a[N],s[N];int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)scanf(&quot;%d&quot;,&amp;a[i]);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)s[i]&#x3D;s[i-1]+a[i];    while(m--)    &#123;        int l,r;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        printf(&quot;%d\n&quot;,s[r]-s[l - 1]);    &#125;      return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n<span class="token operator">=</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m<span class="token operator">=</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l<span class="token punctuation">,</span>r<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>l<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>模板</p><pre class="line-numbers language-none"><code class="language-none">S[i, j] &#x3D; 第i行j列格子左上部分所有元素的和以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]初始化：s[i][j] &#x3D; s[i][j-1] + s[i-1][j] - s[i-1][j-1] + q[i][j];前缀和：s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1 - 1][y1 - 1]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/798/">子矩阵的和</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n,m,k,q[N][N],s[N][N];int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            scanf(&quot;%d&quot;,&amp;q[i][j]);                for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            s[i][j] &#x3D; s[i-1][j] + s[i][j-1] - s[i-1][j-1] + q[i][j];    while(k--)    &#123;        int x1,y1,x2,y2;        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        printf(&quot;%d\n&quot;,s[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">;</span>            x1 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            y1 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            x2 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            y2 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>x1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>x2<span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> s<span class="token punctuation">[</span>x1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>原数组：a1,a2,a3,a4….an</p><p>构造b1,b2…bn</p><p>使得ai=b1+b2+…bi</p><p>即b1=a1;b2=a2-a1;b3=a3-a2</p><p>模板</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">给区间<span class="token punctuation">[</span>l<span class="token punctuation">,</span> r<span class="token punctuation">]</span>中的每个数加上c：B<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">,</span> B<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/799/">差分</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n,m;int a[N],b[N];void insert(int l,int r,int c)&#123;    b[l]+&#x3D;c;    b[r+1]-&#x3D;c;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) scanf(&quot;%d&quot;,&amp;a[i]);    for(int i &#x3D; 1;i &lt;&#x3D; n;i++) insert(i, i, a[i]);    while(m--)    &#123;        int l,r,c;        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;c);        insert(l,r,c);    &#125;    for(int i &#x3D;1;i&lt;&#x3D;n;i++) b[i] +&#x3D; b[i-1];    for(int i &#x3D;1;i&lt;&#x3D;n;i++) printf(&quot;%d &quot;,b[i]);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span><span class="token keyword">int</span> r<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        b<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">;</span>        b<span class="token punctuation">[</span>r<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i<span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>m<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> l<span class="token punctuation">,</span> r <span class="token punctuation">,</span> c<span class="token punctuation">;</span>            l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">insert</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> b<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>模板：</p><pre class="line-numbers language-none"><code class="language-none">给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：S[x1, y1] +&#x3D; c, S[x2 + 1, y1] -&#x3D; c, S[x1, y2 + 1] -&#x3D; c, S[x2 + 1, y2 + 1] +&#x3D; c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/800/">差分矩阵</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 1010;int n,m,k,q[N][N],b[N][N];void insert(int x1,int y1,int x2,int y2,int c)&#123;    b[x1][y1] +&#x3D; c;    b[x1][y2+1] -&#x3D;c;    b[x2+1][y1] -&#x3D;c;    b[x2+1][y2+1] +&#x3D; c;    &#125;int main()&#123;    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i++ )         for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )             scanf(&quot;%d&quot;,&amp;q[i][j]);                for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            insert(i,j,i,j,q[i][j]);    while(k--)    &#123;        int x1,y1,x2,y2,c;        scanf(&quot;%d%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;c);        insert(x1,y1,x2,y2,c);    &#125;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++)            q[i][j] &#x3D; q[i-1][j] + q[i][j-1] - q[i-1][j-1] + b[i][j] ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ )    &#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; m ; j ++ )            printf(&quot;%d &quot;,q[i][j]);        puts(&quot;&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>q<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x1<span class="token punctuation">,</span><span class="token keyword">int</span> y1<span class="token punctuation">,</span><span class="token keyword">int</span> x2<span class="token punctuation">,</span><span class="token keyword">int</span> y2<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        b<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">;</span>        b<span class="token punctuation">[</span>x1<span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-=</span> c<span class="token punctuation">;</span>        b<span class="token punctuation">[</span>x2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y1<span class="token punctuation">]</span> <span class="token operator">-=</span> c<span class="token punctuation">;</span>        b<span class="token punctuation">[</span>x2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>y2<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> c<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        q <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                <span class="token function">insert</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>q<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x1<span class="token punctuation">,</span>y1<span class="token punctuation">,</span>x2<span class="token punctuation">,</span>y2<span class="token punctuation">,</span>c<span class="token punctuation">;</span>            x1 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            y1 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            x2 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            y2 <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">insert</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> a<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、位运算"><a href="#6、位运算" class="headerlink" title="6、位运算"></a>6、位运算</h2><p>n的二进制表示中第k位是几</p><ol><li>先把第k位移到最后一位 n&gt;&gt;k</li><li>看个位是几</li></ol><p>模板：</p><pre class="line-numbers language-none"><code class="language-none">求n的第k位数字: n &gt;&gt; k &amp; 1 &#x2F;&#x2F;&amp;1的意思是&amp;000...01返回n的最后一位1：lowbit(n) &#x3D; n &amp; -n&#x2F;&#x2F;即若n&#x3D;1010则lowbit(n)&#x3D;10&#x2F;&#x2F;在c++里，-n为n的补码操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/803/">二进制中1的个数</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;int lowbit(int x)&#123;    return x &amp; -x;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while(n -- )&#123;        int x;        cin &gt;&gt; x;        int res &#x3D; 0;        while(x) x-&#x3D;lowbit(x),res++; &#x2F;&#x2F;每次减去x的最后一位1        cout&lt;&lt;res&lt;&lt;&#39; &#39;;            &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">lowbit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> x<span class="token punctuation">;</span>            x <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>x <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                x <span class="token operator">-=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">++</span> <span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>             out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7、双指针算法"><a href="#7、双指针算法" class="headerlink" title="7、双指针算法"></a>7、双指针算法</h2><p>模板</p><pre class="line-numbers language-none"><code class="language-none">for (int i &#x3D; 0, j &#x3D; 0; i &lt; n; i ++ )&#123;    while (j &lt; i &amp;&amp; check(i, j)) j ++ ;    &#x2F;&#x2F; 具体问题的逻辑&#125;常见问题分类：    (1) 对于一个序列，用两个指针维护一段区间    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/801/">最长连续不重复子序列</a></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int a[N] , s[N] , n;int main()&#123;    cin &gt;&gt; n;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];    int res &#x3D; 0;    for(int i &#x3D; 0 , j &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        s[a[i]] ++ ;        while(s[a[i]] &gt; 1)        &#123;            s[a[j]] -- ;            j ++;        &#125;        res &#x3D; max(res, i - j + 1);    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> r <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> r <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            s<span class="token punctuation">[</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>a<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token punctuation">&#123;</span>                s<span class="token punctuation">[</span>a<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">--</span> <span class="token punctuation">;</span>                l <span class="token operator">++</span> <span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            res <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> r <span class="token operator">-</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/802/">数组元素的目标和</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n,m,x;int a[N],b[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;    for(int i &#x3D; 0 ;i &lt; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 0 ;i &lt; m ; i ++ ) cin &gt;&gt; b[i];        for(int i &#x3D; 0 , j &#x3D; m - 1 ; i &lt; n ; i ++ )&#123;        while(j &gt;&#x3D; 0 &amp;&amp; a[i] + b[j] &gt; x) j -- ;        if(j &gt;&#x3D; 0 &amp;&amp; a[i] + b[j] &#x3D;&#x3D; x) cout &lt;&lt; i &lt;&lt; &#39; &#39; &lt;&lt; j &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>x<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        x <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//和暴力算法的区别在于：j不会回退</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> x<span class="token punctuation">)</span> j <span class="token operator">--</span> <span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/2818/">判断子序列</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;using namespace std;const int N &#x3D; 100010;int n,m;int a[N],b[N];int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 0 ; i &lt; m ; i ++ ) cin &gt;&gt; b[i];        int i &#x3D; 0;    for(int j &#x3D; 0 ; j &lt; m ; j ++ )    &#123;        if(i &lt; n &amp;&amp; a[i] &#x3D;&#x3D; b[j]) i ++ ;    &#125;        if(i &#x3D;&#x3D; n) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;    else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>x<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">&#123;</span>        n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m <span class="token punctuation">;</span> j <span class="token operator">++</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> b<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> i <span class="token operator">++</span> <span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> n<span class="token punctuation">)</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Yes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8、离散化"><a href="#8、离散化" class="headerlink" title="8、离散化"></a>8、离散化</h2><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;将一个值域特别大的数组有序的映射到一个值域较小的数组vector&lt;int&gt; alls; &#x2F;&#x2F; 存储所有待离散化的值sort(alls.begin(), alls.end()); &#x2F;&#x2F; 将所有值排序alls.erase(unique(alls.begin(), alls.end()), alls.end());   &#x2F;&#x2F; 去掉重复元素&#x2F;&#x2F; 二分求出x对应的离散化的值int find(int x) &#x2F;&#x2F; 找到第一个大于等于x的位置&#123;    int l &#x3D; 0, r &#x3D; alls.size() - 1;    while (l &lt; r)    &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if (alls[mid] &gt;&#x3D; x) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r + 1; &#x2F;&#x2F; 映射到1, 2, ...n&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> add <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//n次操作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> query <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m次询问</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> alls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存储待离散化的值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            j<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>      <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 二分求出x对应的离散化的值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 找到第一个大于等于x的位置</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> r <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//因为要考虑到前缀和，映射到1, 2, ...n</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">int</span> second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/804/">区间和</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 300010 ;int n, m;vector&lt;PII&gt; add, query;vector&lt;int&gt; alls; &#x2F;&#x2F;存储所有待离散化的值int a[N], s[N];&#x2F;&#x2F;二分查找,目的就是取出x的坐标int find(int x)&#123;    int l &#x3D; 0 , r &#x3D; alls.size() - 1;    while(l&lt;r)    &#123;        int mid &#x3D; l + r &gt;&gt; 1;        if(alls[mid] &gt;&#x3D; x) r &#x3D; mid;        else l &#x3D; mid + 1;    &#125;    return r + 1; &#x2F;&#x2F;+1是因为前缀和是从1开始求的&#125;int main()&#123;    cin &gt;&gt; n  &gt;&gt; m;    for(int i &#x3D; 0 ; i &lt; n ; i ++ )    &#123;        int x , c;        cin &gt;&gt; x &gt;&gt; c;        add.push_back(&#123;x,c&#125;);        alls.push_back(x);    &#125;    for(int i &#x3D; 0 ; i &lt; m ; i ++ )    &#123;        int l , r ;        cin &gt;&gt; l &gt;&gt; r;        query.push_back(&#123;l,r&#125;);        alls.push_back(l);        alls.push_back(r);    &#125;    sort(alls.begin(),alls.end());    alls.erase(unique(alls.begin(),alls.end()),alls.end()); &#x2F;&#x2F;去掉重复元素        for(auto it : add)    &#123;        int x &#x3D; find(it.first);        a[x] +&#x3D; it.second;    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; alls.size() ; i ++ ) s[i] &#x3D; s[i-1] + a[i];    for(auto it : query)    &#123;        int l &#x3D; find(it.first) , r &#x3D; find(it.second);        cout &lt;&lt; s[r] - s[l-1] &lt;&lt; endl;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">300010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m <span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> add <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//n次操作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> query <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//m次询问</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> alls <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//存储待离散化的值</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> s<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">N</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">unique</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>                list<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>j<span class="token punctuation">,</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>          <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> j<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> r <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> r <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span> <span class="token operator">>=</span> x<span class="token punctuation">)</span> r <span class="token operator">=</span> mid<span class="token punctuation">;</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> l <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//因为要考虑到前缀和</span>    <span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> m <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>add<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>query<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>alls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>alls<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>alls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> unique <span class="token operator">=</span> <span class="token function">unique</span><span class="token punctuation">(</span>alls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> subList <span class="token operator">=</span> alls<span class="token punctuation">.</span><span class="token function">subList</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> unique<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将去重后的List保存下来</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Pairs</span> item<span class="token operator">:</span>add<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>first<span class="token punctuation">,</span> subList<span class="token punctuation">)</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+=</span> item<span class="token punctuation">.</span>second<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//求前缀和</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> subList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Pairs</span> item<span class="token operator">:</span>query<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>first<span class="token punctuation">,</span> subList<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>second<span class="token punctuation">,</span> subList<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">-</span> s<span class="token punctuation">[</span>l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">int</span> second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9、区间合并"><a href="#9、区间合并" class="headerlink" title="9、区间合并"></a>9、区间合并</h2><ol><li>按区间左端点排序</li><li>扫描整个区间，过程中将所可能合并的区间合并</li></ol><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202304111625684.png"></p><p>模板</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 将所有存在交集的区间合并void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;    sort(segs.begin(), segs.end());    int st &#x3D; -2e9, ed &#x3D; -2e9;    for (auto seg : segs)        if (ed &lt; seg.first)        &#123;            if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);            st &#x3D; seg.first, ed &#x3D; seg.second;        &#125;        else ed &#x3D; max(ed, seg.second);    if (st !&#x3D; -2e9) res.push_back(&#123;st, ed&#125;);    segs &#x3D; res;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> segs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> segs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>segs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> st <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> ed <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Pairs</span> seg<span class="token operator">:</span> segs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ed <span class="token operator">&lt;</span> seg<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>st <span class="token operator">!=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> ed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            st <span class="token operator">=</span> seg<span class="token punctuation">.</span>first<span class="token punctuation">;</span>            ed <span class="token operator">=</span> seg<span class="token punctuation">.</span>second<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> ed <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>st <span class="token operator">!=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> ed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">int</span> second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Pairs</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">!=</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">-</span> p<span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">-</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>原题链接：<a href="https://www.acwing.com/problem/content/805/">区间合并</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespce std;typedef pair&lt;int,int&gt; PII;const int N&#x3D;100010;int n;vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt; &amp;segs)&#123;    vector&lt;PII&gt; res;        sort(segs.begin(),segs.end()); &#x2F;&#x2F;按左端点排序        int st &#x3D; -2e9,ed&#x3D; -2e9; &#x2F;&#x2F;预先设定边界值，即负无穷    for(auto seg :segs)        if(ed &lt; seg.first) &#x2F;&#x2F;若区间没有交叉，则跳转到下一个区间        &#123;            if (st !&#x3D; -2e9) res.push_back(&#123;st,ed&#125;);            st &#x3D; seg.first,ed &#x3D; seg.second;        &#125;    else ed &#x3D; max(ed, seg.second); &#x2F;&#x2F;若有交叉则更新右边界    if(st!&#x3D; -2e9) res.push_back(&#123;st,ed&#125;); &#x2F;&#x2F;将最后一个区间添加到结果中，判断条件是防止输入区为空    segs &#x3D; res;&#125;int main()&#123;    cin &gt;&gt; n;    for(int i&#x3D;0;i&lt;n;i++)    &#123;        int l,r;        cin &gt;&gt; l &gt;&gt; r;        segs.push_back(&#123;l,r&#125;);    &#125;    merge(segs);    cout &lt;&lt; segs.size() &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token operator">*</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">BufferedReader</span> br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">StreamTokenizer</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StreamTokenizer</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OutputStreamWriter</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span>in<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> in<span class="token punctuation">.</span>nval<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> segs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//n次操作</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> segs<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>segs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> st <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">,</span> ed <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">Pairs</span> seg<span class="token operator">:</span> segs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ed <span class="token operator">&lt;</span> seg<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st <span class="token operator">!=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> ed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        st <span class="token operator">=</span> seg<span class="token punctuation">.</span>first<span class="token punctuation">;</span>        ed <span class="token operator">=</span> seg<span class="token punctuation">.</span>second<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span> ed <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ed<span class="token punctuation">,</span> seg<span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>st <span class="token operator">!=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> ed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>segs<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span> res <span class="token operator">=</span> <span class="token function">merge</span><span class="token punctuation">(</span>segs<span class="token punctuation">)</span><span class="token punctuation">;</span>        out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>out<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name">Pairs</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Pairs</span><span class="token punctuation">></span></span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> first<span class="token punctuation">;</span>    <span class="token keyword">int</span> second<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">Pairs</span><span class="token punctuation">(</span><span class="token keyword">int</span> first<span class="token punctuation">,</span> <span class="token keyword">int</span> second<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">=</span> first<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">=</span> second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Pairs</span> p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">!=</span> p<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>first <span class="token operator">-</span> p<span class="token punctuation">.</span>first<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>second <span class="token operator">-</span> p<span class="token punctuation">.</span>second<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="提高课"><a href="#提高课" class="headerlink" title="提高课"></a>提高课</h1><h1 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h1><p><a href="https://www.acwing.com/problem/content/description/101/">激光炸弹</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N &#x3D; 5010;int s[N][N];int main()&#123;    int n, R;    cin &gt;&gt; n &gt;&gt; R;    R &#x3D; min(R, 5001);    for(int i &#x3D; 0 ; i &lt; n ; i ++ )&#123;        int x, y, w;        cin &gt;&gt; x &gt;&gt; y &gt;&gt; w;        x ++, y ++ ;        s[x][y] +&#x3D; w;    &#125;        for(int i &#x3D; 1 ; i &lt;&#x3D; 5001 ; i ++ )&#123;        for(int j &#x3D; 1 ; j &lt;&#x3D; 5001 ; j ++ )&#123;            s[i][j] +&#x3D; s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];        &#125;    &#125;    int res &#x3D; 0;    for(int i &#x3D; R ; i &lt;&#x3D; 5001 ; i ++ )&#123;        for(int j &#x3D; R ; j &lt;&#x3D; 5001 ; j ++ )&#123;            res &#x3D; max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]);        &#125;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/102/">增减序列</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305232233116.png"> </p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N &#x3D; 100010;int n;ll a[N], b[N];int main()&#123;    cin &gt;&gt; n ;    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) cin &gt;&gt; a[i];    for(int i &#x3D; 1 ; i &lt;&#x3D; n ; i ++ ) b[i] &#x3D; a[i] - a[i - 1];        ll p &#x3D; 0 , q &#x3D; 0;    for(int i &#x3D; 2 ; i &lt;&#x3D; n ; i ++ )     &#123;        if(b[i] &gt; 0 ) p +&#x3D; b[i];        else q -&#x3D; b[i];    &#125;        cout &lt;&lt; max(p, q) &lt;&lt; endl;    cout &lt;&lt; abs(p - q) + 1 &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/104/">最佳牛围栏</a></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202305232317065.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N &#x3D; 100010;int n, F;double a[N], s[N];bool check(double avg)&#123;    for(int i &#x3D; 1; i &lt;&#x3D; n ; i ++ ) s[i] &#x3D; s[i - 1] + a[i] - avg;        double mins &#x3D; 0 ;    for(int k &#x3D; F ; k &lt;&#x3D; n ; k ++ )&#123;        mins &#x3D; min(mins, s[k - F]);        if(s[k] &gt;&#x3D; mins) return true;    &#125;        return false;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; F;    double l &#x3D; 0 , r &#x3D; 0 ;    for(int i &#x3D; 1 ; i &lt; n ; i ++ )&#123;        cin &gt;&gt; a[i];        r &#x3D; max(r, a[i]);    &#125;         while(r - l &gt; 1e-5)&#123;        double mid &#x3D; (l + r) &#x2F; 2;        if(check(mid)) l &#x3D; mid;        else r &#x3D; mid;    &#125;        cout &lt;&lt; (int)(r * 1000) &lt;&lt; endl;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.acwing.com/problem/content/115/">特殊排序</a></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Forward declaration of compare API.&#x2F;&#x2F; bool compare(int a, int b);&#x2F;&#x2F; return bool means whether a is less than b.class Solution &#123;public:    vector&lt;int&gt; specialSort(int N) &#123;        vector&lt;int&gt; res ;        res.push_back(1);        for(int i &#x3D; 2; i &lt;&#x3D; N ; i ++)        &#123;            int l &#x3D; 0, r &#x3D; res.size() - 1;            while(l &lt; r)            &#123;                int mid &#x3D; l + r + 1&gt;&gt; 1;                if(compare(res[mid], i)) l &#x3D; mid;                else r &#x3D; mid - 1;            &#125;                        res.push_back(i);            for(int j &#x3D; res.size() - 2; j &gt; r ; j -- ) swap(res[j], res[j + 1]);            if(compare(i, res[r])) swap(res[r], res[r + 1]);        &#125;                return res;    &#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法基础课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GFS</title>
      <link href="/2023/032518626.html"/>
      <url>/2023/032518626.html</url>
      
        <content type="html"><![CDATA[<h1 id="1、GFS简介"><a href="#1、GFS简介" class="headerlink" title="1、GFS简介"></a>1、GFS简介</h1><p>Google文件系统(Google FIle Sysem)</p><p><strong>设计思路</strong></p><ol><li>组件失效被认为是常态事件，而不是意外事件。</li><li>以通常的标准衡量，我们的文件非常巨大。</li><li>绝大部分文件的修改是采用在文件尾部追加数据，而不是覆盖原有数据的方式。</li><li>应用程序和文件系统API的协同设计提高了整个系统的灵活性。</li></ol><h1 id="2、设计概览"><a href="#2、设计概览" class="headerlink" title="2、设计概览"></a>2、设计概览</h1><h2 id="2-1、设计预期"><a href="#2-1、设计预期" class="headerlink" title="2.1、设计预期"></a>2.1、设计预期</h2><ol><li>系统由许多廉价的普通组件组成，组件失效是一种常态。</li><li>系统存储一定数量的大文件。</li><li>系统的工作负载主要由两种读操作组成：大规模的流式读取和小规模的随机读取。</li><li>系统的工作负载还包括许多大规模的、顺序的、数据追加方式的写操作。</li><li>系统必须高效的、行为定义明确的，实现多客户端并行追加数据到同一个文件里的语意。</li><li>高性能的稳定网络带宽远比低延迟重要。</li></ol><h2 id="2-2、接口"><a href="#2-2、接口" class="headerlink" title="2.2、接口"></a>2.2、接口</h2><p>GFS提供了一套类似传统文件系统的API接口函数，虽然并不是严格按照POSIX等标准API的形式实现的。</p><p>文件以分层目录的形式组织，用路径名来标识。我们支持常用的操作，如创建新文件、删除文件、打开文件、关闭文件、读和写文件。</p><blockquote><p>POSIX：<em>可移植操作系统接口(Portable Operating System Interface)</em> 它是一个 IEEE 1003.1 标准，其定义了应用程序（以及命令行 Shell 和实用程序接口）和 UNIX 操作系统之间的语言接口。</p></blockquote><h2 id="2-3、架构"><a href="#2-3、架构" class="headerlink" title="2.3、架构"></a>2.3、架构</h2><p>​    一个GFS集群包含一个单独的<strong>Master节点</strong>（这里的一个单独的Master节点的含义是GFS系统中只存在一个逻辑上的<em>Master</em>组件。后面我们还会提到Master节点复制，因此，为了理解方便，我们把Master节点视为一个逻辑上的概念，一个逻辑的Master节点包括两台物理主机，即两台Master服务器）、多台<strong>Chunk服务器</strong>，并且同时被多个客户端访问。</p><p>​        GFS存储的文件都被分割成固定大小的<strong>Chunk</strong>。在Chunk创建的时候，Master服务器会给每个Chunk分配一个不变的、全球唯一的<strong>64位的Chunk标识</strong>。Chunk服务器把Chunk以linux文件的形式保存在本地硬盘上，并且根据<strong>指定的Chunk标识和字节范围</strong>来读写块数据。出于可靠性的考虑，每个块都会复制到多个块服务器上。缺省情况下，我们使用<strong>3</strong>个存储复制节点，不过用户可以为不同的文件命名空间设定不同的复制级别。</p><p>​        Master节点管理所有的文件系统<strong>元数据</strong>。这些元数据包括名字<strong>空间、访问控制信息、文件和Chunk的映射信息、以及当前Chunk的位置信息</strong>。Master节点还管理着<strong>系统范围内的活动</strong>，比如，Chunk租用管理、孤儿Chunk的回收、以及Chunk在Chunk服务器之间的迁移。Master节点使用<strong>心跳信息</strong>周期地和每个Chunk服务器通讯，发送指令到各个Chunk服务器并接收Chunk服务器的状态信息。</p><p>​    GFS客户端代码以<strong>库</strong>的形式被链接到客户程序里。客户端代码实现了GFS文件系统的API接口函数、应用程序与Master节点和Chunk服务器通讯、以及对数据进行读写操作。客户端和Master节点的通信只获取<strong>元数据</strong>，所有的数据操作都是由客户端直接和Chunk服务器进行交互的。我们不提供POSIX标准的API的功能，因此，GFS API调用不需要深入到Linux vnode级别。</p><p>客户端和Chunk服务器都不需要缓存文件数据。</p><h2 id="2-4、单一Master节点"><a href="#2-4、单一Master节点" class="headerlink" title="2.4、单一Master节点"></a>2.4、单一Master节点</h2><p>单一的Master节点可以通过全局的信息精确定位Chunk的位置以及进行复制决策。另外，我们必须减少对Master节点的读写，避免Master节点成为系统的瓶颈。客户端并不通过Master节点读写文件数据。反之，客户端向Master节点询问它应该联系的Chunk服务器。客户端将这些元数据信息缓存一段时间，后续的操作将直接和Chunk服务器进行数据读写操作。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241555591.png" alt="image-20230324155518538"></p><p>图1是简单读取的流程</p><ol><li>客户端把文件名和程序指定的字节偏移，根据固定的Chunk大小，转换成文件的Chunk索引</li><li>它把文件名和Chunk索引发送给Master节点。Master节点将相应的Chunk标识和副本的位置信息发还给客户端。客户端用文件名和Chunk索引作为key缓存这些信息。</li><li>后客户端发送请求到其中的一个副本处，一般会选择最近的。请求信息包含了Chunk的标识和字节范围。</li></ol><blockquote><p>在对这个Chunk的后续读取操作中，客户端不必再和Master节点通讯了，除非缓存的元数据信息过期或者文件被重新打开。</p></blockquote><h2 id="2-5、Chunk大小"><a href="#2-5、Chunk大小" class="headerlink" title="2.5、Chunk大小"></a>2.5、Chunk大小</h2><p>我们选择了64MB，这个尺寸远远大于一般文件系统的Blocksize。每个Chunk的副本都以普通Linux文件的形式保存在Chunk服务器上，只有在需要的时候才扩大。</p><p><strong>优点</strong></p><ol><li>它减少了客户端和Master节点通讯的需求，因为只需要一次和Mater节点的通信就可以获取Chunk的位置信息，之后就可以对同一个Chunk进行多次的读写操作</li><li>采用较大的Chunk尺寸，客户端能够对一个块进行多次操作，这样就可以通过与Chunk服务器保持较长时间的TCP连接来减少网络负载。</li><li>选用较大的Chunk尺寸减少了Master节点需要保存的元数据的数量。这就允许我们把元数据全部放在内存中</li></ol><p><strong>缺点</strong></p><ol><li>小文件包含较少的Chunk，甚至只有一个Chunk。当有许多的客户端对同一个小文件进行多次的访问时，存储这些Chunk的Chunk服务器就会变成热点。</li></ol><h2 id="2-6、元数据"><a href="#2-6、元数据" class="headerlink" title="2.6、元数据"></a>2.6、元数据</h2><p>Master服务器存储3种主要类型的元数据，包括：<strong>文件和Chunk的命名空间、文件和Chunk的对应关系、每个Chunk副本的存放地点</strong>。</p><p>所有的元数据都保存在Master服务器的内存中。前两种类型的元数据（命名空间、文件和Chunk的对应关系）同时也会以<strong>记录变更日志</strong>的方式记录在操作系统的系统日志文件中，日志文件存储在本地磁盘上，同时日志会被<strong>复制</strong>到其它的远程Master服务器上。采用保存变更日志的方式，我们能够简单可靠的更新Master服务器的状态，并且不用担心Master服务器崩溃导致数据不一致的风险。Master服务器不会持久保存Chunk位置信息。Master服务器在启动时，或者有新的Chunk服务器加入时，向各个Chunk服务器<strong>轮询</strong>它们所存储的Chunk的信息。</p><h3 id="2-6-1、内存中的数据结构"><a href="#2-6-1、内存中的数据结构" class="headerlink" title="2.6.1、内存中的数据结构"></a>2.6.1、内存中的数据结构</h3><p>将元数据全部保存在内存中的方法有潜在问题：Chunk的数量以及整个系统的承载能力都受限于Master服务器所拥有的内存大小。</p><p>但是在实际应用中，这并不是一个严重的问题。</p><ul><li>Master服务器只需要不到64个字节的元数据就能够管理一个64MB的Chunk。由于大多数文件都包含多个Chunk，因此绝大多数Chunk都是满的，除了文件的最后一个Chunk是部分填充的。</li><li>同样的，每个文件的在命名空间中的数据大小通常在64字节以下，因为保存的文件名是用前缀压缩算法压缩过的。</li></ul><h3 id="2-6-2、Chunk位置信息"><a href="#2-6-2、Chunk位置信息" class="headerlink" title="2.6.2、Chunk位置信息"></a>2.6.2、Chunk位置信息</h3><p>Master服务器并不保存持久化保存哪个Chunk服务器存有指定Chunk的副本的信息。Master服务器只是在启动的时候轮询Chunk服务器以获取这些信息。</p><p>这种设计简化了在有Chunk服务器加入集群、离开集群、更名、失效、以及重启的时候，Master服务器和Chunk服务器数据同步的问题。</p><h3 id="2-6-3、操作日志"><a href="#2-6-3、操作日志" class="headerlink" title="2.6.3、操作日志"></a>2.6.3、操作日志</h3><p>操作日志包含了<strong>关键的元数据变更历史记录</strong>。</p><p>操作日志是元数据唯一的持久化存储记录，它也作为判断同步操作顺序的逻辑时间基线（通过逻辑日志的序号作为操作发生的逻辑时间）</p><p>我们会把日志复制到多台远程机器，并且只有把相应的日志记录写入到本地以及远程机器的硬盘后，才会响应客户端的操作请求。Master服务器会收集多个日志记录后批量处理，以减少写入磁盘和复制对系统整体性能的影响。</p><p>​    Master服务器在灾难恢复时，通过重演操作日志把文件系统恢复到最近的状态。为了缩短Master启动的时间，我们必须使日志足够小（即重演系统操作的日志量尽量的少）。Master服务器在日志增长到一定量时对系统状态做一次<strong>Checkpoint</strong>(Checkpoint是一种行为，一种对数据库状态作一次快照的行为)，将所有的状态数据写入一个Checkpoint文件（并删除之前的日志文件）。在灾难恢复的时候，Master服务器就通过<strong>从磁盘上读取这个Checkpoint文件，以及重演Checkpoint之后的有限个日志文件</strong>就能够恢复系统。Checkpoint文件以压缩B-树形势的数据结构存储，可以直接映射到内存，在用于命名空间查询时无需额外的解析。这大大提高了恢复速度，增强了可用性。</p><p>Master服务器使用独立的线程切换到新的日志文件和创建新的Checkpoint文件。</p><p>Master服务器恢复只需要最新的Checkpoint文件和后续的日志文件。旧的Checkpoint文件和日志文件可以被删除，但是为了应对灾难性的故障（<em>catastrophes</em>，数据备份相关文档中经常会遇到这个词，表示一种超出预期范围的灾难性事件），我们通常会多保存一些历史文件。</p><h2 id="2-7、一致性模型"><a href="#2-7、一致性模型" class="headerlink" title="2.7、一致性模型"></a>2.7、一致性模型</h2><p>宽松的一致性模型</p><h3 id="2-7-1、GFS一致性保障机制"><a href="#2-7-1、GFS一致性保障机制" class="headerlink" title="2.7.1、GFS一致性保障机制"></a>2.7.1、GFS一致性保障机制</h3><p>文件命名空间的修改（例如，文件创建）是原子性的。它们仅由Master节点的控制：命名空间锁提供了原子性和正确性（4.1章）的保障；Master节点的操作日志定义了这些操作在全局的顺序（2.6.3章）。</p><p>数据修改后文件region（<em>region</em>这个词用中文非常难以表达，我认为应该是修改操作所涉及的文件中的某个范围）的状态取决于操作的类型、成功与否、以及是否同步修改。表1总结了各种操作的结果。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241630130.png" alt="image-20230324163023055"></p><ul><li>如果所有客户端，无论从哪个副本读取，读到的数据都一样，那么我们认为文件region是“<strong>一致的</strong>”</li><li>如果对文件的数据修改之后，region是一致的，并且客户端能够看到写入操作全部的内容，那么这个region是“<strong>已定义的</strong>”。</li></ul><p>当一个数据修改操作成功执行，并且没有受到同时执行的其它写入操作的干扰，那么影响的region就是<strong>已定义的</strong>（隐含了<strong>一致性</strong>）：所有的客户端都可以看到写入的内容。</p><p>并行修改操作成功完成之后，region处于<strong>一致的、未定义</strong>的状态：所有的客户端看到同样的数据，但是无法读到任何一次写入操作写入的数据。</p><p>通常情况下，文件region内包含了来自多个修改操作的、混杂的数据片段。失败的修改操作导致一个region处于不一致状态（同时也是未定义的）：不同的客户在不同的时间会看到不同的数据。</p><p>数据修改操作分为<strong>写入</strong>或者<strong>记录追加</strong>两种。写入操作把数据写在应用程序指定的文件偏移位置上。即使有多个修改操作并行执行时，记录追加操作至少可以把数据原子性的追加到文件中一次，但是<strong>偏移位置</strong>是由GFS选择的（3.3章）（这句话有点费解，其含义是所有的追加写入都会成功，但是有可能被执行了多次，而且每次追加的文件偏移量由<em>GFS</em>自己计算）。（相比而言，通常说的追加操作写的偏移位置是文件的尾部。）GFS返回给客户端一个偏移量，表示了包含了<strong>写入记录的、已定义的region的起点</strong>。另外，GFS可能会在文件中间插入填充数据或者重复记录。这些数据占据的文件region被认定是不一致的，这些数据通常比用户数据小的多。</p><p>经过了一系列的成功的修改操作之后，GFS确保被修改的文件region是已定义的，并且包含最后一次修改操作写入的数据。GFS通过以下措施确保上述行为：</p><p>（a） 对Chunk的所有副本的修改操作顺序一致（3.1章）</p><p>（b）使用Chunk的版本号来检测副本是否因为它所在的Chunk服务器宕机（4.5章）而错过了修改操作而导致其失效。失效的副本不会再进行任何修改操作，Master服务器也不再返回这个Chunk副本的位置信息给客户端。它们会被垃圾收集系统尽快回收。</p><p>​    即使在修改操作成功执行很长时间之后，组件的失效也可能损坏或者删除数据。GFS通过Master服务器和所有Chunk服务器的定期<strong>“握手”</strong>来找到失效的Chunk服务器，并且使用<strong>Checksum</strong>来校验数据是否损坏（5.2章）。一旦发现问题，数据要尽快利用有效的副本进行恢复（4.3章）。只有当一个Chunk的所有副本在GFS检测到错误并采取应对措施之前全部丢失，这个Chunk才会不可逆转的丢失。在一般情况下GFS的反应时间（指<em>Master</em>节点检测到错误并采取应对措施）是几分钟。即使在这种情况下，Chunk也只是不可用了，而不是损坏了：应用程序会收到明确的错误信息而不是损坏的数据。</p><hr><h4 id="笔记1"><a href="#笔记1" class="headerlink" title="笔记1"></a>笔记1</h4><p><strong>串行Over-Write</strong></p><p>over-write由客户端指定文件更新offset。当客户端是串行更新时，客户端自己知道写入文件范围以及写入数据内容，且本次写入在数据服务器的多副本上均执行成功。因此，本次写结果对于客户端来说就是明确的，且多副本上数据一致，故而结果是defined。如下图：</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241745181.png" alt="image-20230324174551088"></p><p><strong>并行Over-Write</strong></p><p>并行写入时多个客户端由于写入范围可能交叉而形成交织写。这时候，由于单个客户端无法决定写入顺序（只有主副本才能决定谁先写谁后写），因此，即使写入成功，客户端仍无法确定在并发写入时交叉部分最终写入结果，但是因为写入成功，所以多副本数据必然一致。如下图：</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241746340.png" alt="image-20230324174611287"></p><p>图中红色部分代表并发追加的部分，这部分数据由于无法确定谁先谁后执行，因此结果不确定。但由于跟新成功，因此，副本间数据是一致的，这就是consistent but undefined。</p><p>无论是串行还是并行over-write，一旦失败，多个chunk副本上的数据可能都不一致了，其次，客户端从不同的副本上读出的数据也不一样（可能某些副本成功而某些副本失败），因此，必然也是undefined，也是inconsistent。</p><p><strong>append</strong></p><p>客户端append操作无需指定offset，由chunk主副本根据当前文件大小决定写入offset，在写入成功后将该offset返回给客户端。因此，客户端能够根据offset确切知道写入结果，无论是串行写入还是并发写入，其行为是defined。如下：</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241746215.png" alt="image-20230324174645164"></p><p><strong>append失败</strong></p><p>假设上面的append经历了一次重试，那可能实际chunk的布局如下：</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303241747475.png" alt="image-20230324174705417"></p><p>由于第一次写失败（错误可能发生在任意一个副本），导致了多副本之间从50至80的数据可能不一致。但接下来重试成功，从80至110之间的数据一致，因此，其状态是interspersed with inconsistent。</p><h3 id="2-7-2、程序的实现"><a href="#2-7-2、程序的实现" class="headerlink" title="2.7.2、程序的实现"></a>2.7.2、程序的实现</h3><p>​    在实际应用中，我们所有的应用程序对文件的写入操作都是尽量采用数据追加方式，而不是覆盖方式。一种典型的应用，应用程序从头到尾写入数据，生成了一个文件。写入所有数据之后，应用程序自动将文件改名为一个永久保存的文件名，或者周期性的作Checkpoint，记录成功写入了多少数据。Checkpoint文件可以包含程序级别的校验和。Readers（即执行GFS读取的程序）仅校验并处理上个Checkpoint之后产生的文件region，这些文件region的状态一定是已定义的。</p><p>​    我们再来分析另一种典型的应用。许多应用程序并行的追加数据到同一个文件，比如进行结果的合并或者是一个生产者-消费者队列。记录追加方式的“至少一次追加”的特性保证了Writer的输出。Readers使用下面的方法来处理偶然性的填充数据和重复内容。Writers在每条写入的记录中都包含了额外的信息，例如<strong>Checksum</strong>，用来验证它的有效性。Reader可以利用Checksum<strong>识别和抛弃额外的填充数据和记录片段</strong>。如果应用不能容忍偶尔的重复内容(比如，如果这些重复数据触发了非幂等操作)，可以用记录的<strong>唯一标识符</strong>来过滤它们，这些唯一标识符通常用于<strong>命名程序中处理的实体对象</strong>，例如web文档。这些记录I/O功能（These functionalities for record I/O）（除了剔除重复数据）都包含在我们的程序共享的库中，并且适用于Google内部的其它的文件接口实现。所以，相同序列的记录，加上一些偶尔出现的重复数据，都被分发到Reader了。</p><h1 id="3、系统交互"><a href="#3、系统交互" class="headerlink" title="3、系统交互"></a>3、系统交互</h1><p>设计系统原则：<strong>最小化所有操作和Master节点的交互</strong></p><h2 id="3-1、租约及变更顺序"><a href="#3-1、租约及变更顺序" class="headerlink" title="3.1、租约及变更顺序"></a>3.1、租约及变更顺序</h2><p>​    变更是一个会改变Chunk内容或者元数据的操作，比如写入操作或者记录追加操作。变更操作会在Chunk的所有副本上执行。我们使用租约（lease）机制来保持<strong>多个副本间变更顺序的一致性</strong>。Master节点为Chunk的一个副本建立一个租约，我们把这个副本叫做<strong>主Chunk</strong>。主Chunk对Chunk的所有更改操作进行<strong>序列化</strong>。所有的副本都遵从这个序列进行修改操作。因此，修改操作全局的顺序<strong>首先由Master节点选择的租约的顺序决定，然后由租约中主Chunk分配的序列号决定。</strong></p><p>​    设计租约机制的目的是为了<strong>最小化Master节点的管理负担</strong>。租约的初始超时设置为60秒。不过，只要Chunk被修改了，主Chunk就可以申请<strong>更长的租期</strong>，通常会得到Master节点的确认并收到租约延长的时间。这些租约延长请求和批准的信息通常都是附加在Master节点和Chunk服务器之间的心跳消息中来传递。有时Master节点会试图<strong>提前取消租约</strong>（例如，Master节点想取消在一个已经被改名的文件上的修改操作）。即使Master节点和主Chunk失去联系，它仍然可以安全地在旧的租约到期后和另外一个Chunk副本签订新的租约。</p><p>图2：写入操作流程</p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251227081.png" alt="image-20230325122719920" style="zoom:67%;" /><p><strong>step1</strong>：客户机向Master节点询问哪一个Chunk服务器持有当前的<strong>租约</strong>，以及其它副本的位置。如果没有一个Chunk持有租约，Master节点就选择其中一个副本建立一个租约（这个步骤在图上没有显示）。</p><p><strong>step2</strong>：Master节点将<strong>主Chunk的标识符以及其它副本</strong>（又称为secondary副本、二级副本）的位置返回给客户机。客户机缓存这些数据以便后续的操作。只有在主Chunk不可用，或者主Chunk回复信息表明它已不再持有租约的时候，客户机才需要重新跟Master节点联系。</p><p><strong>step3</strong>： 客户机把数据推送到所有的副本上。客户机可以以任意的顺序推送数据。Chunk服务器接收到数据并保存在它的<strong>内部LRU缓存</strong>中，一直到数据被使用或者过期交换出去。由于数据流的网络传输负载非常高，通过分离数据流和控制流，我们可以基于<strong>网络拓扑情况</strong>对数据流进行规划，提高系统性能，而不用去理会哪个Chunk服务器保存了主Chunk。3.2章节会进一步讨论这点。</p><p><strong>step4</strong>: 当所有的副本都确认接收到了数据，客户机发送<strong>写请求</strong>到主Chunk服务器。这个请求标识了早前推送到所有副本的数据。主Chunk为接收到的所有操作分配<strong>连续的序列号</strong>，这些操作可能来自不同的客户机，<strong>序列号保证了操作顺序执行</strong>。它以序列号的顺序把操作应用到它自己的本地状态中（也就是在本地执行这些操作，这句话按字面翻译有点费解，也许应该翻译为<em>“</em>它顺序执行这些操作，并更新自己的状态”）。</p><p><strong>step5</strong>： 主Chunk把<strong>写请求</strong>传递到所有的<strong>二级副本</strong>。每个二级副本依照主Chunk分配的序列号以相同的顺序执行这些操作。</p><p><strong>step6</strong>： 所有的二级副本<strong>回复主Chunk</strong>，它们已经完成了操作。</p><p><strong>step7</strong>：主Chunk服务器（即主Chunk所在的Chunk服务器）<strong>回复</strong>客户机。任何副本产生的任何错误都会返回给客户机。在出现错误的情况下，写入操作可能在主Chunk和一些二级副本执行成功。（如果操作在主Chunk上失败了，操作就不会被分配序列号，也不会被传递。）客户端的请求被确认为失败，被修改的region处于不一致的状态。我们的客户机代码通过重复执行失败的操作来处理这样的错误。在从头开始重复执行之前，客户机会先从步骤（3）到步骤（7）做几次尝试。</p><p>​    如果应用程序一次写入的数据量很大，或者数据跨越了多个Chunk，GFS客户机代码会把它们分成多个写操作。这些操作都遵循前面描述的控制流程，但是可能会被其它客户机上同时进行的操作打断或者覆盖。因此，共享的文件region的尾部可能包含来自不同客户机的数据片段，尽管如此，由于这些分解后的写入操作在所有的副本上都以相同的顺序执行完成，Chunk的所有副本都是一致的。这使文件region处于2.7节描述的一致的、但是未定义的状态。</p><h4 id="笔记2"><a href="#笔记2" class="headerlink" title="笔记2"></a>笔记2</h4><ol><li>客户端向Master查询待写入的chunk的副本信息，</li><li>Master返回副本列表，第一项为主副本，即当前持有租约的副本；</li><li>客户端向多副本推送待写入数据，这里的推送是指将数据发送至chunk多副本，<a href="https://www.zhihu.com/search?q=chunkserver&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2228155582%22%7D">chunkserver</a>会缓存这些数据，此时数据并不落盘；</li><li>客户端向主副本发起Sync请求；</li><li>主副本将数据写入本地的同时通知其他副本将数据写入各自节点，此时数据方才落盘；</li><li>主副本等待所有从副本的sync响应；</li><li>主副本给客户端返回写入成功响应</li></ol><h2 id="3-2、数据流"><a href="#3-2、数据流" class="headerlink" title="3.2、数据流"></a>3.2、数据流</h2><p>​    为了提高网络效率，我们采取了把<strong>数据流和控制流</strong>分开的措施。在控制流从客户机到主Chunk、然后再到所有二级副本的同时，<strong>数据以管道的方式，顺序的沿着一个精心选择的Chunk服务器链推送</strong>。我们的目标是充分利用每台机器的带宽，避免网络瓶颈和高延时的连接，最小化推送所有数据的延时。</p><p>​    为了充分利用每台机器的带宽，数据沿着一个Chunk服务器链顺序的推送，而不是以其它拓扑形式分散推送（例如，树型拓扑结构）。线性推送模式下，<strong>每台机器所有的出口带宽都用于以最快的速度传输数据，而不是在多个接受者之间分配带宽</strong>。</p><p>​    为了尽可能的避免出现网络瓶颈和高延迟的链接（eg，inter-switch最有可能出现类似问题），<strong>每台机器都尽量的在网络拓扑中选择一台还没有接收到数据的、离自己最近的机器作为目标推送数据</strong>。假设客户机把数据从Chunk服务器S1推送到S4。它把数据推送到最近的Chunk服务器S1。S1把数据推送到S2，因为S2和S4中最接近的机器是S2。同样的，S2把数据传递给S3和S4之间更近的机器，依次类推推送下去。我们的网络拓扑非常简单，通过IP地址就可以计算出节点的“距离”。</p><p>​    最后，我们利用<strong>基于TCP连接的、管道式数据推送方式</strong>来最小化延迟。Chunk服务器接收到数据后，马上开始向前推送。管道方式的数据推送对我们帮助很大，因为我们采用<strong>全双工</strong>的交换网络。接收到数据后立刻向前推送不会降低接收的速度。在没有网络拥塞的情况下，传送B字节的数据到R个副本的理想时间是<strong>B/T+RL</strong> ，T是网络的吞吐量，L是在两台机器数据传输的延迟。通常情况下，我们的网络连接速度是100Mbps（T），L将远小于1ms。因此，1MB的数据在理想情况下80ms左右就能分发出去。</p><h2 id="3-3、原子的记录追加"><a href="#3-3、原子的记录追加" class="headerlink" title="3.3、原子的记录追加"></a>3.3、原子的记录追加</h2><p>​    GFS提供了一种原子的数据追加操作–记录追加。传统方式的写入操作，客户程序会指定数据写入的偏移量。对同一个region的并行写入操作不是串行的：region尾部可能会包含多个不同客户机写入的数据片段。使用记录追加，客户机只需要指定要写入的数据。<strong>GFS 会原子性至少一次在 GFS 选择的偏移量将数据写到文件中（比如，作为一个连续的字节序列）并将偏移位置返回给客户端</strong>。这类似于在Unix操作系统编程环境中，对以O_APPEND模式打开的文件，多个并发写操作在没有竞态条件时的行为。（<em>Unix文件系统中以O_APPEND模式调用write函数时，不会发生并发问题，文件指针在每一次调用时都会指向文件尾。在此处paper并未说明GFS具体是如何实现原子追加操作的。</em>）</p><p>​    记录追加在我们的分布应用中非常频繁的使用，在这些分布式应用中，通常有很多的客户机并行地对同一个文件追加写入数据。如果我们采用传统方式的文件写入操作，客户机需要额外的<strong>复杂、昂贵的同步机制</strong>，例如使用一个分布式的锁管理器。在我们的工作中，这样的文件通常用于多个生产者/单一消费者的队列系统，或者是合并了来自多个客户机的数据的结果文件。</p><p>​    记录追加是一种修改操作，它也遵循3.1节描述的控制流程，除了在主Chunk有些额外的控制逻辑。客户机把数据推送给文件最后一个Chunk的所有副本，之后发送请求给主Chunk。主Chunk会检查这次记录追加操作是否会使Chunk超过最大尺寸（64MB）。如果超过了最大尺寸，主Chunk首先将当前Chunk填充到最大尺寸，之后通知所有二级副本做同样的操作，然后回复客户机要求其对下一个Chunk重新进行记录追加操作。（记录追加的数据大小严格控制在Chunk最大尺寸的1/4，这样即使在最坏情况下，数据碎片的数量仍然在可控的范围。）<strong>通常情况下追加的记录不超过Chunk的最大尺寸</strong>，主Chunk把数据追加到自己的副本内，然后通知二级副本把数据写在跟主Chunk一样的位置上，最后回复客户机操作成功。</p><p>​    如果记录追加操作在任何一个副本上失败了，客户端就需要重新进行操作。重新进行记录追加的结果是，同一个Chunk的不同副本可能包含不同的数据–重复包含一个记录全部或者部分的数据。GFS并不保证Chunk的所有副本在字节级别是完全一致的。它只保证数据作为一个整体原子的被至少写入一次。这个特性可以通过简单观察推导出来：如果操作成功执行，数据一定已经写入到Chunk的所有副本的相同偏移位置上。这之后，所有的副本至少都到了记录尾部的长度，任何后续的记录都会追加到更大的偏移地址，或者是不同的Chunk上，即使其它的Chunk副本被Master节点选为了主Chunk。就我们的一致性保障模型而言，记录追加操作成功写入数据的region是已定义的（因此也是一致的），反之则是不一致的（因此也就是未定义的）。正如我们在2.7.2节讨论的，我们的程序可以处理不一致的区域。</p><h2 id="3-4、快照"><a href="#3-4、快照" class="headerlink" title="3.4、快照"></a>3.4、快照</h2><p>​    快照操作几乎可以瞬间完成对一个文件或者目录树（“源”）做一个拷贝，并且几乎不会对正在进行的其它操作造成任何干扰。我们的用户可以使用快照迅速的<strong>创建一个巨大的数据集的分支拷贝</strong>（而且经常是递归的拷贝），或者是在做实验性的数据操作之前，使用快照操作备份当前状态，这样之后就可以轻松的提交或者回滚到备份时的状态。</p><p>​    就像AFS（<em>alex</em>注：<em>AFS</em>，即<em>Andrew File System</em>，一种分布式文件系统），我们用标准的<strong>copy-on-write技术</strong>实现快照。当Master节点收到一个快照请求，它首先取消作快照的文件的所有Chunk的租约。这个措施保证了后续对这些Chunk的写操作都必须与Master交互交互以找到租约持有者。这就给Master节点一个率先创建Chunk的新拷贝的机会。</p><p>​    租约取消或者过期之后，Master节点把这个操作以<strong>日志</strong>的方式记录到硬盘上。然后，Master节点通过复制源文件或者目录的元数据的方式，把这条日志记录的变化反映到保存在内存的状态中。新创建的快照文件和源文件指向完全相同的Chunk地址。</p><p>​    在快照操作之后，当客户机第一次想写入数据到Chunk C，它首先会发送一个请求到Master节点查询当前的租约持有者。Master节点注意到Chunke C的引用计数超过了1。Master节点不会马上回复客户机的请求，而是<strong>创建一个新名为C~的Chunk</strong>。之后，Master节点要求每个拥有Chunk C当前副本的Chunk服务器创建一个叫做C<del>的新Chunk。通过在源Chunk所在Chunk服务器上创建新的Chunk，我们确保<strong>数据在本地而不是通过网络复制</strong>（我们的硬盘比我们的100Mb以太网大约快3倍）。从这点来讲，请求的处理方式和任何其它Chunk没什么不同：Master节点确保新Chunk C</del>的一个副本拥有租约，之后回复客户机，客户机得到回复后就可以正常的写这个Chunk，而不必理会它是从一个已存在的Chunk克隆出来的。</p><h4 id="笔记3"><a href="#笔记3" class="headerlink" title="笔记3"></a>笔记3</h4><p>COW原理是如果被Snapshot的文件有更新操作时，就将文件的要被更新的chunk复制一份，然后对复制的chunk进行更新，而原来的chunk作为快照数据被保留，以后要恢复到该快照时，直接将该chunk读出即可。</p><p>当GFS的Master节点收到Snapshot请求时：</p><ol><li>回收Snapshot请求覆盖的文件chunks上的租约，这样，接下来客户端要对文件修改时，就必须向Master申请，而此时master就可以对chunk进行复制；</li><li>Master在日志中记录本次Snapshot操作，然后在内存中执行Snapshot动作，具体是将被Snapshot的文件或目录的元数据复制一份，被复制出的文件与原始文件指向相同的chunk；</li><li>假如客户端申请更新被Snapshot的文件内容，那么找到需要更新的Chunk，向其多个副本发送拷贝命令，在其本地创建出Chunk的副本Chunk’，之所以本地创建是因为可以避免跨节点之间的数据拷贝，节省网络带宽；</li><li>客户端收到Master的响应后，表示该Chunk已经COW结束，接下来客户端的更新流程与正常的没有区别。</li></ol><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251720872.png" alt="image-20230325164122077"></p><h1 id="4、Matser节点的操作"><a href="#4、Matser节点的操作" class="headerlink" title="4、Matser节点的操作"></a>4、Matser节点的操作</h1><p>​    Master节点执行所有的名称空间操作。此外，它还管理着整个系统里所有Chunk的副本：它决定<strong>Chunk的存储位置</strong>，<strong>创建新Chunk</strong>和<strong>它的副本</strong>，协调各种各样的<strong>系统活动</strong>以保证Chunk被完全复制，在所有的Chunk服务器之间的进行负载均衡，回收不再使用的存储空间。本节我们讨论上述的主题。</p><h2 id="4-1、名称空间和锁"><a href="#4-1、名称空间和锁" class="headerlink" title="4.1、名称空间和锁"></a>4.1、名称空间和锁</h2><p>​    Master节点的很多操作会花费很长的时间：比如，快照操作必须取消Chunk服务器上快照所涉及的所有的Chunk的租约。我们不希望在这些操作的运行时，延缓了其它的Master节点的操作。因此，我们允许多个操作同时进行，使用名称空间的region上的锁来保证执行的正确顺序。</p><p>​    不同于许多传统文件系统，<strong>GFS没有针对每个目录实现能够列出目录下所有文件的数据结构</strong>。GFS也<strong>不支持文件或者目录的链接</strong>（Unix术语中的硬链接或者符号链接）。在逻辑上，GFS的名称空间就是一个<strong>全路径和元数据映射关系的查找表</strong>。利用前缀压缩，这个表可以高效的存储在内存中。在存储名称空间的树型结构上，每个节点（绝对路径的文件名或绝对路径的目录名）都有一个关联的<strong>读写锁</strong>。</p><p>​    每个Master节点的操作在开始之前都要获得一系列的锁。通常情况下，如果一个操作涉及/d1/d2/…/dn/leaf，那么操作首先要获得目录/d1，/d1/d2，…，/d1/d2/…/dn的读锁，以及/d1/d2/…/dn/leaf的读写锁。注意，根据操作的不同，leaf可以是一个文件，也可以是一个目录。</p><p>​    现在，我们演示一下在/home/user被快照到/save/user的时候，锁机制如何防止创建文件/home/user/foo。<strong>快照操作</strong>获取/home和/save的读取锁，以及/home/user和/save/user的写入锁。<strong>文件创建操作</strong>获得/home和/home/user的读取锁，以及/home/user/foo的写入锁。这两个操作要顺序执行，因为它们试图获取的/home/user的锁是相互冲突。文件创建操作不需要获取父目录的写入锁，因为这里没有”目录”，或者类似inode等用来禁止修改的数据结构。文件名的读取锁足以防止父目录被删除。</p><p>​    采用这种锁方案的优点是<strong>支持对同一目录的并行操作。</strong>比如，可以再同一个目录下同时创建多个文件：每一个操作都获取一个目录名的上的读取锁和文件名上的写入锁。目录名的读取锁足以的防止目录被删除、改名以及被快照。文件名的写入锁序列化文件创建操作，确保不会多次创建同名的文件。</p><p>​    因为名称空间可能有很多节点，读写锁采用惰性分配策略，在不再使用的时候立刻被删除。同样，锁的获取也要依据一个全局一致的顺序来避免死锁：首先按名称空间的层次排序，在同一个层次内按字典顺序排序。</p><h2 id="4-2、副本的位置"><a href="#4-2、副本的位置" class="headerlink" title="4.2、副本的位置"></a>4.2、副本的位置</h2><p>​    GFS集群是<strong>高度分布的多层布局结构</strong>，而不是平面结构。典型的拓扑结构是<strong>有数百个Chunk服务器安装在许多机架上</strong>。<strong>Chunk服务器被来自同一或者不同机架上的数百个客户机轮流访问</strong>。不同机架上的两台机器间的通讯可能跨越一个或多个网络交换机。另外，机架的出入带宽可能比机架内所有机器加和在一起的带宽要小。多层分布架构对数据的灵活性、可靠性以及可用性方面提出特有的挑战。</p><p>​    Chunk副本位置选择的策略服务两大目标：<strong>最大化数据可靠性和可用性，最大化网络带宽利用率</strong>。为了实现这两个目的，仅仅是在多台机器上分别存储这些副本是不够的，这只能预防硬盘损坏或者机器失效带来的影响，以及最大化每台机器的网络带宽利用率。我们必须在<strong>多个机架间分布储存Chunk的副本</strong>。这保证Chunk的一些副本在整个机架被破坏或掉线（比如，共享资源，如电源或者网络交换机造成的问题）的情况下依然存在且保持可用状态。这还意味着在网络流量方面，尤其是针对Chunk的读操作，能够有效利用多个机架的整合带宽。另一方面，<strong>写操作必须和多个机架上的设备进行网络通信</strong>，但是这个代价是我们愿意付出的。</p><h2 id="4-3、创建、重新复制、重新负载均衡"><a href="#4-3、创建、重新复制、重新负载均衡" class="headerlink" title="4.3、创建、重新复制、重新负载均衡"></a>4.3、创建、重新复制、重新负载均衡</h2><p>Chunk的副本有三个用途：<strong>Chunk创建，重新复制和重新负载均衡</strong>。</p><p>​    当Master节点创建一个Chunk时，它会选择在哪里放置初始的空的副本。Master节点会考虑几个因素。（1）<strong>我们希望在低于平均硬盘使用率的Chunk服务器上存储新的副本。</strong>这样的做法最终能够平衡Chunk服务器之间的硬盘使用率。（2）<strong>我们希望限制在每个Chunk服务器上”最近”的Chunk创建操作的次数。</strong>虽然创建操作本身是廉价的，但是创建操作也意味着随之会有大量的写入数据的操作，因为Chunk在Writer真正写入数据的时候才被创建，而在我们的”追加一次，读取多次”的工作模式下，Chunk一旦写入成功之后就会变为只读的了。（3）如上所述，<strong>我们希望把Chunk的副本分布在多个机架之间。</strong></p><p>​    当Chunk的有效副本数量少于用户指定的复制因数的时候，Master节点会重新复制它。这可能是由几个原因引起的：<strong>一个Chunk服务器不可用了</strong>，Chunk服务器报告它所存储的一个副本损坏了，Chunk服务器的一个磁盘因为错误不可用了，或者Chunk副本的复制因数提高了。每个需要被重新复制的Chunk都会根据<strong>几个因素进行排序</strong>。一个因素是<strong>Chunk现有副本数量和复制因数相差多少</strong>。例如，丢失两个副本的Chunk比丢失一个副本的Chunk有更高的优先级。另外，我们<strong>优先重新复制活跃（live）文件的Chunk</strong>而不是最近刚被删除的文件的Chunk（查看4.4节）。最后，为了最小化失效的Chunk对正在运行的应用程序的影响，我们提高会阻塞客户机程序处理流程的Chunk的优先级。</p><p>​    Master节点选择<strong>优先级最高的Chunk</strong>，然后命令某个Chunk服务器直接从可用的副本”克隆”一个副本出来。选择新副本的位置的策略和创建时类似：<strong>平衡硬盘使用率、限制同一台Chunk服务器上的正在进行的克隆操作的数量、在机架间分布副本</strong>。为了防止克隆产生的网络流量大大超过客户机的流量，Master节点对整个集群和每个Chunk服务器上的同时进行的克隆操作的数量都进行了限制。另外，Chunk服务器通过调节它对源Chunk服务器读请求的频率来限制它用于克隆操作的带宽。</p><p>​    最后，Master服务器周期性地对副本进行重新负载均衡：<strong>它检查当前的副本分布情况，然后移动副本以便更好的利用硬盘空间、更有效的进行负载均衡。</strong>而且在这个过程中，Master服务器逐渐的填满一个新的Chunk服务器，而不是在短时间内用新的Chunk填满它，以至于过载。新副本的存储位置选择策略和上面讨论的相同。另外，Master节点必须选择哪个副本要被移走。通常情况，Master节点移走那些剩余空间低于平均值的Chunk服务器上的副本，从而平衡系统整体的硬盘使用率。</p><h4 id="笔记4"><a href="#笔记4" class="headerlink" title="笔记4"></a>笔记4</h4><p>创建chunk时副本位置的选择算法：</p><ol><li>选择存储空间利用率最低的节点和磁盘；</li><li>选择最近一段时间内新建chunk数量较少的节点和磁盘；</li><li>将多个副本分散在不同的rack上。</li></ol><h2 id="4-4、垃圾回收"><a href="#4-4、垃圾回收" class="headerlink" title="4.4、垃圾回收"></a>4.4、垃圾回收</h2><p>GFS在文件删除后不会立刻回收可用的物理空间。GFS空间回收采用惰性的策略，只在文件和Chunk级的常规垃圾收集时进行。我们发现这个方法使系统更简单、更可靠。</p><h3 id="4-4-1、机制"><a href="#4-4-1、机制" class="headerlink" title="4.4.1、机制"></a>4.4.1、机制</h3><p>​    当一个文件被应用程序删除时，Master节点像对待其它修改操作一样，立刻把删除操作以日志的方式记录下来。但是，Master节点并不马上回收资源，而是把文件名改为一<strong>个包含删除时间戳的、隐藏的名字</strong>。当Master节点对文件系统命名空间做常规扫描的时候，它会<strong>删除所有三天前的隐藏文件</strong>（这个时间间隔是可以设置的）。直到文件被真正删除，它们仍旧可以用新的特殊的名字读取，也可以通过把隐藏文件改名为正常显示的文件名的方式“反删除”。<strong>当隐藏文件被从名称空间中删除，Master服务器内存中保存的这个文件的相关元数据才会被删除</strong>。这也有效的切断了文件和它包含的所有Chunk的连接。</p><p>​    在对Chunk名字空间做类似的常规扫描时，Master节点找到<strong>孤儿Chunk（不被任何文件包含的Chunk）并删除它们的元数据</strong>。Chunk服务器在和Master节点交互的心跳信息中，报告它拥有的Chunk子集的信息，Master节点回复Chunk服务器哪些Chunk在Master节点保存的元数据中已经不存在了。Chunk服务器可以任意删除这些Chunk的副本。</p><h3 id="4-4-2、讨论"><a href="#4-4-2、讨论" class="headerlink" title="4.4.2、讨论"></a>4.4.2、讨论</h3><p>​    虽然分布式垃圾回收在编程语言领域是一个需要复杂的方案才能解决的难题，但是在GFS系统中是非常简单的。<strong>我们可以轻易的得到Chunk的所有引用：它们都只存储在Master服务器上的文件到块的映射表中。我们也可以很轻易的得到所有Chunk的副本：它们都以Linux文件的形式存储在Chunk服务器的指定目录下</strong>。所有Master节点不能识别的副本都是”垃圾”。</p><p>​    垃圾回收在空间回收方面相比直接删除有几个优势。<strong>首先，对于组件失效是常态的大规模分布式系统，垃圾回收方式简单可靠。</strong>Chunk可能在某些Chunk服务器创建成功，某些Chunk服务器上创建失败，失败的副本处于无法被Master节点识别的状态。副本删除消息可能丢失，Master节点必须重新发送失败的删除消息，包括自身的和Chunk服务器的（自身的指删除<em>metadata</em>的消息）。垃圾回收提供了一致的、可靠的清除无用副本的方法。<strong>第二，垃圾回收把存储空间的回收操作合并到Master节点规律性的后台活动中</strong>，比如，例行扫描和与Chunk服务器握手等。因此，操作被批量的执行，开销会被分散。<strong>另外，垃圾回收在Master节点相对空闲的时候完成。</strong>这样Master节点就可以给那些需要快速反应的客户机请求提供更快捷的响应。<strong>第三，延缓存储空间回收为意外的、不可逆转的删除操作提供了安全保障。</strong></p><p>​    根据我们的使用经验，延迟回收空间的主要问题是，延迟回收会阻碍用户调优存储空间的使用，特别是当存储空间比较紧缺的时候。当应用程序重复创建和删除临时文件时，释放的存储空间不能马上重用。我们通过显式的再次删除一个已经被删除的文件的方式加速空间回收的速度。我们允许用户为命名空间的不同部分设定不同的复制和回收策略。例如，用户可以指定某些目录树下面的文件不做复制，删除的文件被即时的、不可恢复的从文件系统移除。</p><h2 id="4-5、过期失效的副本检测"><a href="#4-5、过期失效的副本检测" class="headerlink" title="4.5、过期失效的副本检测"></a>4.5、过期失效的副本检测</h2><p>​    当Chunk服务器失效时，Chunk的副本有可能因错失了一些修改操作而过期失效。Master节点保存了<strong>每个Chunk的版本号</strong>，用来区分当前的副本和过期副本。</p><p>​    无论何时，只要Master节点和Chunk签订一个新的租约，它就增加Chunk的版本号，然后通知最新的副本。Master节点和这些副本都把新的版本号记录在它们<strong>持久化存储的状态信息</strong>中。这个动作发生在任何客户机得到通知以前，因此也是对这个Chunk开始写之前。如果某个副本所在的Chunk服务器正好处于失效状态，那么副本的版本号就不会被增加。<strong>Master节点在这个Chunk服务器重新启动，并且向Master节点报告它拥有的Chunk的集合以及相应的版本号的时候，就会检测出它包含过期的Chunk</strong>。如果Master节点看到一个比它记录的版本号更高的版本号，Master节点会认为它和Chunk服务器签订租约的操作失败了，因此会选择<strong>更高的版本号作为当前的版本号。</strong></p><p>​    Master节点在例行的垃圾回收过程中<strong>移除所有的过期失效副本</strong>。在此之前，Master节点在回复客户机的Chunk信息请求的时候，简单的认为那些过期的块根本就不存在。另外一重保障措施是，Master节点在通知客户机哪个Chunk服务器持有租约、或者指示Chunk服务器从哪个Chunk服务器进行克隆时，消息中都附带了Chunk的版本号。客户机或者Chunk服务器在执行操作时都会验证版本号以确保总是访问当前版本的数据。</p><h1 id="5、容错和诊断"><a href="#5、容错和诊断" class="headerlink" title="5、容错和诊断"></a>5、容错和诊断</h1><p>​    我们在设计GFS时遇到的最大挑战之一是<strong>如何处理频繁发生的组件失效</strong>。组件的数量和质量让这些问题出现的频率远远超过一般系统意外发生的频率：我们不能完全依赖机器的稳定性，也不能完全相信硬盘的可靠性。组件的失效可能造成系统不可用，更糟糕的是，还可能产生不完整的数据。我们讨论我们如何面对这些挑战，以及当组件失效不可避免的发生时，用GFS自带工具诊断系统故障。</p><h2 id="5-1、高可用性"><a href="#5-1、高可用性" class="headerlink" title="5.1、高可用性"></a>5.1、高可用性</h2><p>在GFS集群的数百个服务器之中，在任何给定的时间必定会有些服务器是不可用的。我们使用两条简单但是有效的策略保证整个系统的高可用性：<strong>快速恢复和复制。</strong></p><h3 id="5-1-1、快速复制"><a href="#5-1-1、快速复制" class="headerlink" title="5.1.1、快速复制"></a>5.1.1、快速复制</h3><p>​    ‘不管Master服务器和Chunk服务器是如何关闭的，它们都被设计为<strong>可以在数秒钟内恢复它们的状态并重新启动</strong>。事实上，我们并<strong>不区分正常关闭和异常关闭</strong>；通常，我们通过直接kill掉进程来关闭服务器。客户机和其它的服务器会感觉到系统有点颠簸*(*a minor hiccup)，正在发出的请求会超时，需要重新连接到重启后的服务器，然后重试这个请求。6.6.2章节记录了实测的启动时间。</p><h3 id="5-1-2、Chunk复制"><a href="#5-1-2、Chunk复制" class="headerlink" title="5.1.2、Chunk复制"></a>5.1.2、Chunk复制</h3><p>​    正如之前讨论的，每个Chunk都被复制到不同机架上的不同的Chunk服务器上。用户可以为文件命名空间的不同部分设定不同的复制级别。缺省是3。当有Chunk服务器离线了，或者通过Checksum校验（参考5.2节）发现了已经损坏的数据，<strong>Master节点通过克隆已有的副本保证每个Chunk都被完整复制</strong>（即每个<em>Chunk</em>都有复制因子制定的个数个副本，缺省是<em>3</em>）。虽然Chunk复制策略对我们非常有效，但是我们也在寻找其<strong>它形式的跨服务器的冗余解决方案</strong>，比如使用奇偶校验、或者Erasure codes（<em>Erasure codes</em>用来解决链接层中不相关的错误，以及网络拥塞和<em>buffffer</em>限制造成的丢包错误）来解决我们日益增长的只读存储需求。我们的系统主要的工作负载是追<strong>加方式的写入和读取操作</strong>，很少有随机的写入操作，因此，我们认为在我们这个高度解耦合的系统架构下实现这些复杂的冗余方案很有挑战性，但并非不可实现。</p><h3 id="5-1-3、Matser服务器的复制"><a href="#5-1-3、Matser服务器的复制" class="headerlink" title="5.1.3、Matser服务器的复制"></a>5.1.3、Matser服务器的复制</h3><p>​    为了保证Master服务器的可靠性，Master服务器的状态也要复制。Master服务器所有的操作日志和checkpoint文件都被复制到多台机器上。对Master服务器状态的修改操作能够提交成功的前提是，<strong>操作日志写入到Master服务器的备节点和本机的磁盘</strong>。简单说来，一个Master服务进程负责所有的修改操作，包括后台的服务，比如垃圾回收等改变系统内部状态活动。当它失效的时，几乎可以立刻重新启动。如果Master进程所在的机器或者磁盘失效了，<strong>处于GFS系统外部的监控进程会在其它的存有完整操作日志的机器上启动一个新的Master进程。</strong>客户端使用规范的名字访问Master（比如gfs-test）节点，这个名字类似DNS别名，因此也就可以在Master进程转到别的机器上执行时，通过更改别名的实际指向访问新的Master节点。</p><p>​    此外，GFS中还有些“影子”Master服务器，这些“影子”服务器在“主”Master服务器宕机的时候提供文件系统的<strong>只读访问</strong>。它们是影子，而不是镜像，所以<strong>它们的数据可能比“主”Master服务器更新要慢</strong>，通常是不到1秒。对于那些不经常改变的文件、或者那些允许获取的数据有少量过期的应用程序，“影子”Master服务器能够提高读取的效率。事实上，因为文件内容是从Chunk服务器上读取的，因此，应用程序不会发现过期的文件内容。在这个短暂的时间窗内，过期的可能是文件的元数据，比如目录的内容或者访问控制信息。</p><p>​    “影子”Master服务器为了保持自身状态是最新的，它会<strong>读取一份当前正在进行的操作的日志副本</strong>，并且<strong>依照和主Master服务器完全相同的顺序来更改内部的数据结构</strong>。和主Master服务器一样，“影子”Master服务器在启动的时候也会从Chunk服务器轮询数据（之后定期拉数据），数据中包括了Chunk副本的位置信息；“影子”Master服务器也会定期和Chunk服务器“握手”来确定它们的状态。<strong>在主Master服务器因创建和删除副本导致副本位置信息更新时，“影子”Master服务器才和主Master服务器通信来更新自身状态。</strong></p><h2 id="5-2、数据完整性"><a href="#5-2、数据完整性" class="headerlink" title="5.2、数据完整性"></a>5.2、数据完整性</h2><p>​    每个Chunk服务器都使用Checksum来检查保存的数据是否损坏。考虑到一个GFS集群通常都有好几百台机器、几千块硬盘，磁盘损坏导致数据在读写过程中损坏或者丢失是非常常见的（第7节讲了一个原因）。我们可以通过别的Chunk副本来解决数据损坏问题，但是跨越Chunk服务器比较副本来检查数据是否损坏很不实际。另外，GFS允许有歧义的副本存在：<strong>GFS修改操作的语义，特别是早先讨论过的原子纪录追加的操作，并不保证副本完全相同</strong>(副本不是<em>byte-wise</em>完全一致的)。因此，每个Chunk服务器必须独立维护Checksum来校验自己的副本的完整性。</p><p>​    我们把每个Chunk都分成64KB大小的块。每个块都对应一个32位的Checksum。和其它元数据一样，Checksum与其它的用户数据是分开的，并且保存在内存和硬盘上，同时也记录操作日志。</p><p>​    对于读操作来说，在把数据返回给客户端或者其它的Chunk服务器之前，Chunk服务器会校验<strong>读取操作涉及的范围内的块的Checksum</strong>。因此Chunk服务器不会把错误数据传递到其它的机器上。如果发生某个块的Checksum不正确，<strong>Chunk服务器返回给请求者一个错误信息，并且通知Master服务器这个错误</strong>。作为回应，请求者应当从其它副本读取数据，Master服务器也会从其它副本克隆数据进行恢复。<strong>当一个新的副本就绪后，Master服务器通知副本错误的Chunk服务器删掉错误的副本</strong>。</p><p>​    Checksum对读操作的性能影响很小，可以基于几个原因来分析一下。因为大部分的读操作都至少要读取几个块，而我们只需要读取一小部分额外的相关数据进行校验。GFS客户端代码通过每次把读取操作都对齐在Checksum block的边界上，进一步减少了这些额外的读取操作的负面影响。另外，在Chunk服务器上，<strong>Checksum的查找和比较不需要I/O操作，Checksum的计算可以和I/O操作同时进行</strong>。</p><p>​    Checksum的计算针对在Chunk尾部的追加写入操作作了高度优化（与之对应的是覆盖现有数据的写入操作），因为这类操作在我们的工作中占了很大比例。<strong>我们只增量更新最后一个不完整的块的Checksum，并且用所有的追加来的新Checksum块来计算新的Checksum</strong>。即使是最后一个不完整的Checksum块已经损坏了，而且我们不能够马上检查出来，由于新的Checksum和已有数据不吻合，在下次对这个块进行读取操作的时候，会检查出数据已经损坏了。</p><p>​    相比之下，如果写操作覆盖已经存在的一个范围内的Chunk，我们必须读取和校验被覆盖的第一个和最后一个块，然后再执行写操作；操作完成之后再重新计算和写入新的Checksum。<strong>如果我们不校验第一个和最后一个被写的块，那么新的Checksum可能会隐藏没有被覆盖区域内的数据错误</strong>。</p><p>​    在Chunk服务器空闲的时候，它会<strong>扫描和校验每个不活动的Chunk的内容</strong>。这使得我们能够发现很少被读取的Chunk是否完整。一旦发现有Chunk的数据损坏，Master可以创建一个新的、正确的副本，然后把损坏的副本删除掉。这个机制也避免了非活动的、已损坏的Chunk欺骗Master节点，使Master节点认为它们已经有了足够多的副本了。</p><h2 id="5-3、诊断工具"><a href="#5-3、诊断工具" class="headerlink" title="5.3、诊断工具"></a>5.3、诊断工具</h2><p>​    详尽的、深入细节的诊断日志，在问题隔离、调试、以及性能分析等方面给我们带来无法估量的帮助，同时也只需要很小的开销。没有日志的帮助，我们很难理解短暂的、不重复的机器之间的消息交互。<strong>GFS的服务器会产生大量的日志，记录了大量关键的事件（比如，Chunk服务器启动和关闭）以及所有的RPC的请求和回复</strong>。这些诊断日志可以随意删除，对系统的正确运行不造成任何影响。然而，我们在存储空间允许的情况下会尽量的保存这些日志。</p><p>​    <strong>RPC日志包含了网络上发生的所有请求和响应的详细记录，但是不包括读写的文件数据</strong>。通过匹配请求与回应，以及收集不同机器上的RPC日志记录，我们可以重演所有的消息交互来诊断问题。<strong>日志还用来跟踪负载测试和性能分析</strong>。</p><p>​    日志对性能的影响很小（远小于它带来的好处），因为这些日志的写入方式是顺序的、异步的。最近发生的事件日志保存在内存中，可用于持续不断的在线监控。</p><h1 id="6、度量"><a href="#6、度量" class="headerlink" title="6、度量"></a>6、度量</h1><p>本节中，我们将使用一些小规模基准测试来展现GFS系统架构和实现上的一些固有瓶颈，还有些来自Google内部使用的真实的GFS集群的基准数据。</p><h2 id="6-1、小规模基准测试"><a href="#6-1、小规模基准测试" class="headerlink" title="6.1、小规模基准测试"></a>6.1、小规模基准测试</h2><p>​    我们在一个包含1台Master服务器，2台Master服务器复制节点，16台Chunk服务器和16个客户机组成的GFS集群上测量性能。注意，采用这样的集群配置方案只是为了易于测试。典型的GFS集群有数百个Chunk服务器和数百个客户机。</p><p>​    所有机器的配置都一样：两个PIII 1.4GHz处理器，2GB内存，两个80G/5400rpm的硬盘，以及100Mbps全双工以太网连接到一个HP2524交换机。GFS集群中所有的19台服务器都连接在一个交换机，所有16台客户机连接到另一个交换机上。两个交换机之间使用1Gbps的线路连接。</p><h3 id="6-1-1、读取"><a href="#6-1-1、读取" class="headerlink" title="6.1.1、读取"></a>6.1.1、读取</h3><p>​    N个客户机从GFS文件系统同步读取数据。每个客户机从320GB的文件集合中随机读取4MB region的内容。读取操作重复执行256次，因此，每个客户机最终都读取1GB的数据。所有的Chunk服务器加起来总共只有32GB的内存，因此，我们预期只有最多10%的读取请求命中Linux的文件系统缓冲。我们的测试结果应该和一个在没有文件系统缓存的情况下读取测试的结果接近。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251720898.png" alt="image-20230325171652772"></p><p>图3（a）显示了N个客户机整体的读取速度以及这个速度的理论极限。当连接两个交换机的1Gbps的链路饱和时，整体读取速度达到理论的极限值是125MB/S，或者说每个客户机配置的100Mbps网卡达到饱和时，每个客户机读取速度的理论极限值是12.5MB/s。实测结果是，当一个客户机读取的时候，读取的速度是10MB/s，也就是说达到客户机理论读取速度极限值的80%。对于16个客户机，整体的读取速度达到了94MB/s，大约是理论整体读取速度极限值的75%，也就是说每个客户机的读取速度是6MB/s。读取效率从80%降低到了75%，主要的原因是当读取的客户机增加时，多个客户机同时读取一个Chunk服务器的几率也增加了，导致整体的读取效率下降。</p><h3 id="6-1-2、写入"><a href="#6-1-2、写入" class="headerlink" title="6.1.2、写入"></a>6.1.2、写入</h3><p>​    N个客户机同时向N个不同的文件中写入数据。每个客户机以每次1MB的速度连续写入1GB的数据。图3（b）显示了整体的写入速度和它们理论上的极限值。理论上的极限值是67MB/s，因为我们需要把每一byte写入到16个Chunk服务器中的3个上，而每个Chunk服务器的输入连接速度是12.5MB/s。</p><p>​    一个客户机的写入速度是6.3MB，大概是理论极限值的一半。导致这个结果的主要原因是我们的网络协议栈。它与我们推送数据到Chunk服务器时采用的管道模式不相适应。<strong>从一个副本到另一个副本的数据传输延迟降低了整个的写入速度。</strong></p><p>​    16个客户机整体的写入速度达到了35MB/s（即每个客户机2.2MB/s），大约只是理论极限值的一半。和多个客户机读取的情形很类型，随着客户机数量的增加，多个客户机同时写入同一个Chunk服务器的几率也增加了。而且，16个客户机并行写入可能引起的冲突比16个客户机并行读取要大得多，因为每个写入都会涉及三个不同的副本。</p><p>​    写入的速度比我们想象的要慢。在实际应用中，这没有成为我们的主要问题，因为即使在单个客户机上能够感受到延时，它也不会在有大量客户机的时候对整体的写入带宽造成显著的影响</p><h3 id="6-1-3、记录追加"><a href="#6-1-3、记录追加" class="headerlink" title="6.1.3、记录追加"></a>6.1.3、记录追加</h3><p>​    图3（c）显示了记录追加操作的性能。N个客户机同时追加数据到一个文件。记录追加操作的性能受限于保存文件最后一个Chunk的Chunk服务器的带宽，而与客户机的数量无关。记录追加的速度由一个客户机的6.0MB/s开始，下降到16个客户机的4.8MB/s为止，速度的下降主要是由于不同客户端的网络拥塞以及网络传输速度的不同而导致的。</p><p>​    我们的程序倾向于同时处理多个这样的文件。换句话说，即N个客户机同时追加数据到M个共享文件中，这里N和M都是数十或者数百以上。所以，在我们的实际应用中，Chunk服务器的网络拥塞并没有成为一个严重问题，如果Chunk服务器的某个文件正在写入，客户机会去写另外一个文件。</p><h2 id="6-2、实际应用中的集群"><a href="#6-2、实际应用中的集群" class="headerlink" title="6.2、实际应用中的集群"></a>6.2、实际应用中的集群</h2><p>​    我们现在来仔细评估一下Google内部正在使用的两个集群，它们具有一定的代表性。集群A通常被上百个工程师用于研究和开发。典<strong>型的任务是被人工初始化后连续运行数个小时。它通常读取数MB到数TB的数据，之后进行转化或者分析，最后把结果写回到集群中</strong>。<strong>集群B主要用于处理当前的生产数据</strong>。集群B的任务持续的时间更长，在很少人工干预的情况下，持续的生成和处理数TB的数据集。在这两个案例中，一个单独的”任务”都是指运行在多个机器上的多个进程，它们同时读取和写入多个文件。</p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251721795.png" alt="image-20230325172121663" style="zoom:67%;" /><h3 id="6-2-1、存储"><a href="#6-2-1、存储" class="headerlink" title="6.2.1、存储"></a>6.2.1、存储</h3><p>​    如上表前五行所描述的，两个集群都由上百台Chunk服务器组成，支持数TB的硬盘空间；两个集群虽然都存储了大量的数据，但是还有剩余的空间。“已用空间”包含了所有的Chunk副本。实际上所有的文件都复制了三份。因此，集群实际上各存储了18TB和52TB的文件数据。</p><p>​    两个集群存储的文件数量都差不多，但是集群B上有大量的死文件。所谓“死文件”是指文件被删除了或者是被新版本的文件替换了，但是存储空间还没有来得及被回收。由于集群B存储的文件较大，因此它的Chunk数量也比较多。</p><h3 id="6-2-2、元数据"><a href="#6-2-2、元数据" class="headerlink" title="6.2.2、元数据"></a>6.2.2、元数据</h3><p>​    Chunk服务器总共保存了十几GB的元数据，大多数是来自用户数据的、64KB大小的块的Checksum。保存在Chunk服务器上其它的元数据是Chunk的版本号信息，我们在4.5节描述过。</p><p>​    在Master服务器上保存的元数据就小的多了，大约只有数十MB，或者说平均每个文件100字节的元数据。这和我们设想的是一样的，Master服务器的内存大小在实际应用中并不会成为GFS系统容量的瓶颈。大多数文件的元数据都是以<strong>前缀压缩模式</strong>存放的文件名。Master服务器上存放的<strong>其它元数据包括了文件的所有者和权限、文件到Chunk的映射关系，以及每一个Chunk的当前版本号。</strong>此外，针对每一个Chunk，我们都保存<strong>了当前的副本位置以及对它的引用计数</strong>，这个引用计数用于实现<strong>写时拷贝</strong>（即<em>COW</em>，<em>copy-on-write</em>）。</p><p>​    对于每一个单独的服务器，无论是Chunk服务器还是Master服务器，都只保存了50MB到100MB的元数据。因此，恢复服务器是非常快速的：在服务器响应客户请求之前，只需要花几秒钟时间从磁盘上读取这些数据就可以了。不过，Master服务器会持续颠簸一段时间–通常是30到60秒–直到它完成轮询所有的Chunk服务器，并获取到所有Chunk的位置信息。</p><h3 id="6-2-3、读写速率"><a href="#6-2-3、读写速率" class="headerlink" title="6.2.3、读写速率"></a>6.2.3、读写速率</h3><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251735340.png" alt="image-20230325173508199" style="zoom:67%;" /><p>​    表三显示了不同时段的读写速率。在测试的时候，这两个集群都运行了一周左右的时间。（这两个集群最近都因为升级新版本的GFS重新启动过了）。</p><p>​    集群重新启动后，平均写入速率小于30MB/s。当我们提取性能数据的时候，集群B正进行大量的写入操作，写入速度达到了100MB/s，并且因为每个Chunk都有三个副本的原因，网络负载达到了300MB/s。<strong>读取速率要比写入速率高的多</strong>。正如我们设想的那样，总的工作负载中，读取的比例远远高于写入的比例。两个集群都进行着繁重的读取操作。特别是，集群A在一周时间内都维持了580MB/s的读取速度。集群A的网络配置可以支持750MB/s的速度，显然，它有效的利用了资源。集群B支持的峰值读取速度是1300MB/s，但是它的应用只用到了380MB/s。</p><h3 id="6-2-4、Master服务器的负载"><a href="#6-2-4、Master服务器的负载" class="headerlink" title="6.2.4、Master服务器的负载"></a>6.2.4、Master服务器的负载</h3><p>​    表3的数据显示了发送到Master服务器的操作请求大概是每秒钟200到500个。Master服务器可以轻松的应付这个请求速度，所以Master服务器的处理能力不是系统的瓶颈。</p><p>​    在早期版本的GFS中，Master服务器偶尔会成为瓶颈。它大多数时间里都在顺序扫描某个很大的目录（包含数万个文件）去查找某个特定的文件。因此我们修改了Master服务器的数据结构，<strong>通过对名字空间进行二分查找来提高效率。</strong>现在Master服务器可以轻松的每秒钟进行数千次文件访问。如果有需要的话，<strong>我们可以通过在名称空间数据结构之前设置名称查询缓冲的方式进一步提高速度。</strong></p><h3 id="6-2-5、恢复时间"><a href="#6-2-5、恢复时间" class="headerlink" title="6.2.5、恢复时间"></a>6.2.5、恢复时间</h3><p>​    <strong>当某个Chunk服务器失效了，一些Chunk副本的数量可能会低于复制因子指定的数量，我们必须通过克隆副本使Chunk副本数量达到复制因子指定的数量。</strong>恢复所有Chunk副本所花费的时间取决于资源的数量。在我们的试验中，我们把集群B上的一个Chunk服务器Kill掉。这个Chunk服务器上大约有15000个Chunk，共计600GB的数据。为了减小克隆操作对正在运行的应用程序的影响，以及为GFS调度决策提供修正空间，我们缺省的把集群中并发克隆操作的数量设置为91个（Chunk服务器的数量的40%），每个克隆操作最多允许使用的带宽是6.25MB/s（50mbps）。所有的Chunk在23.2分钟内恢复了，复制的速度高达440MB/s。</p><p>​    在另外一个测试中，我们Kill掉了两个Chunk服务器，每个Chunk服务器大约有16000个Chunk，共计660GB的数据。这两个故障导致了266个Chunk只有单个副本。这266个Chunk被GFS优先调度进行复制，在2分钟内恢复到至少有两个副本；现在集群被带入到另外一个状态，在这个状态下，系统可以容忍另外一个Chunk服务器失效而不丢失数据。</p><h2 id="6-3、工作负荷分析"><a href="#6-3、工作负荷分析" class="headerlink" title="6.3、工作负荷分析"></a>6.3、工作负荷分析</h2><p>本节中，我们展示了对两个GFS集群工作负载情况的详细分析，这两个集群和6.2节中的类似，但是不完全相同。集群X用于研究和开发，集群Y用于生产数据处理。</p><h3 id="6-3-1、方法论和注意事项"><a href="#6-3-1、方法论和注意事项" class="headerlink" title="6.3.1、方法论和注意事项"></a>6.3.1、方法论和注意事项</h3><p>​    本章节列出的这些结果数据只包括客户机发起的原始请求，因此，这些结果能够反映我们的应用程序对GFS文件系统产生的全部工作负载。它们不包含那些为了实现客户端请求而在服务器间交互的请求，也不包含GFS内部的后台活动相关的请求，比如前向转发的写操作，或者重新负载均衡等操作。</p><p>​    <strong>我们从GFS服务器记录的真实的RPC请求日志中推导重建出关于IO操作的统计信息</strong>。例如，GFS客户程序可能会把一个读操作分成几个RPC请求来提高并行度，我们可以通过这些RPC请求推导出原始的读操作。因为我们的访问模式是高度程式化，所以我们认为任何不符合的数据都是误差<em>（</em>Since our*access patterns are highly stylized, we expect any error to be in the noise)*。应用程序如果能够记录更详尽的日志，就有可能提供更准确的诊断数据；但是为了这个目的去重新编译和重新启动数千个正在运行的客户机是不现实的，而且从那么多客户机上收集结果也是个繁重的工作。</p><p>​    <strong>应该避免从我们的工作负荷数据中过度的归纳出普遍的结论</strong><em>(alex</em>注：即不要把本节的数据作为基础的指导性数据*)*。因为Google完全控制着GFS和使用GFS的应用程序，所以，应用程序都针对GFS做了优化，同时，GFS也是为了这些应用程序而设计的。这样的相互作用也可能存在于一般程序和文件系统中，但是在我们的案例中这样的作用影响可能更显著。</p><h3 id="6-3-2、Chunk服务器工作负荷"><a href="#6-3-2、Chunk服务器工作负荷" class="headerlink" title="6.3.2、Chunk服务器工作负荷"></a>6.3.2、Chunk服务器工作负荷</h3><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251748703.png" alt="image-20230325174828561" style="zoom:67%;" /><p>​    表4显示了操作按涉及的数据量大小的分布情况。<strong>读取操作按操作涉及的数据量大小呈现了双峰分布</strong>。小的读取操作（小于64KB）一般是由查找操作的客户端发起的，目的在于<strong>从巨大的文件中查找小块的数据</strong>。大的读取操作（大于512KB）一般是<strong>从头到尾顺序的读取整个文件。</strong></p><p>​    在集群Y上，有相当数量的读操作没有返回任何的数据。在我们的应用中，尤其是在生产系统中，经常使用文件作为生产者-消费者队列。生产者并行的向文件中追加数据，同时，消费者从文件的尾部读取数据。某些情况下，消费者读取的速度超过了生产者写入的速度，这就会导致没有读到任何数据的情况。集群X通常用于短暂的数据分析任务，而不是长时间运行的分布式应用，因此，集群X很少出现这种情况。</p><p>​    写操作按数据量大小也同样呈现为<strong>双峰分布</strong>。大的写操作（超过256KB）通常是由于Writer使用了缓存机制导致的。Writer缓存较小的数据，通过频繁的Checkpoint或者同步操作，或者只是简单的统计小的写入（小于64KB）的数据量*(即汇集多次小的写入操作，当数据量达到一个阈值，一次写入*)，之后批量写入。</p><p>​    再来观察一下记录追加操作。<strong>我们可以看到集群Y中大的记录追加操作所占比例比集群X多的多，这是因为集群Y用于我们的生产系统，针对GFS做了更全面的调优。</strong></p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251751230.png" alt="image-20230325175154096" style="zoom:67%;" /><p>表5显示了按操作涉及的数据量的大小统计出来的总数据传输量。在所有的操作中，大的操作（超过256KB）占据了主要的传输量。小的读取（小于64KB）虽然传输的数据量比较少，但是在读取的数据量中仍占了相当的比例，这是因为在文件中<strong>随机Seek的工作负荷而导致的</strong>。</p><h3 id="6-3-3、记录追加vs写操作"><a href="#6-3-3、记录追加vs写操作" class="headerlink" title="6.3.3、记录追加vs写操作"></a>6.3.3、记录追加vs写操作</h3><p>​    记录追加操作在我们的生产系统中大量使用。对于集群X，记录追加操作和普通写操作的比例按照字节比是108:1，按照操作次数比是8:1。对于作为我们的生产系统的集群Y来说，这两个比例分别是3.7:1和2.5:1。更进一步，这一组数据说明在我们的两个集群上，<strong>记录追加操作所占比例都要比写操作要大</strong>。对于集群X，在整个测量过程中，记录追加操作所占比率都比较低，因此结果会受到一两个使用某些特定大小的buffffer的应用程序的影响。</p><p>​    如同我们所预期的，我们的数据修改操作主要是记录追加操作而不是覆盖方式的写操作。我们测量了第一个副本的数据覆盖写的情况。这近似于一个客户机故意覆盖刚刚写入的数据，而不是增加新的数据。对于集群X，覆盖写操作在写操作所占据字节上的比例小于0.0001%，在所占据操作数量上的比例小于0.0003%。对于集群Y，这两个比率都是0.05%。虽然这只是某一片断的情况，但是仍然高于我们的预期。<strong>这是由于这些覆盖写的操作，大部分是由于客户端在发生错误或者超时以后重试的情况</strong>。这在本质上应该不算作工作负荷的一部分，而是重试机制产生的结果。</p><pre><code>### 6.3.4、Matser的工作负荷</code></pre><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303251803831.png" alt="image-20230325180359715" style="zoom:67%;" /><p>表6显示了Master服务器上的请求按类型区分的明细表。大部分的请求都是读取操作查询Chunk位置信息（FindLocation）、以及修改操作查询lease持有者的信息（FindLease-Locker）。</p><p>集群X和Y在删除请求的数量上有着明显的不同，因为<strong>集群Y存储了生产数据，一般会重新生成数据以及用新版本的数据替换旧有的数据</strong>。数量上的差异也被隐藏在了Open请求中，因为旧版本的文件可能在以重新写入的模式打开时，隐式的被删除了（类似UNIX的open函数中的“w”模式）。</p><p>FindMatchingFiles是一个模式匹配请求，支持“ls”以及其它类似的文件系统操作。不同于Master服务器的其它请求，它可能会检索namespace的大部分内容，因此是非常昂贵的操作。<strong>集群Y的这类请求要多一些，因为自动化数据处理的任务进程需要检查文件系统的各个部分，以便从全局上了解应用程序的状态。与之不同的是，集群X的应用程序更加倾向于由单独的用户控制，通常预先知道自己所需要使用的全部文件的名称。</strong></p><h1 id="7、经验"><a href="#7、经验" class="headerlink" title="7、经验"></a>7、经验</h1><p>​    在构建和部署GFS的过程中，我们遇到了各种各样的问题，包括一些操作问题和一些技术问题。</p><p>​    最初，GFS被设想为我们生产系统的后端文件系统。随着时间的推移，其用途逐渐发展到包括研究和开发任务。在设计之初，它几乎不支持<strong>权限控制（permissions）和限额（quotas）</strong>。但现在，它包括了这些内容的初步形态。虽然生产系统有很好的纪律和控制，但用户有时却不一定。需要更多的基础设施来防止用户相互干扰。</p><p>​    我们最大的一些问题是与磁盘和Linux相关的。我们的许多磁盘都向Linux驱动程序声称，它们支持一系列IDE协议版本，但实际上只对最近的版本作出了可靠的响应。由于协议版本非常相似，这些驱动器大多可以工作，但偶尔不匹配会导致驱动器对自身的状态和内核对驱动器的状态之间存在分歧。这将由于内核中的问题而悄无声息地破坏数据。<strong>这个问题促使我们使用checksum来检测数据损坏，同时我们修改了内核来处理这些协议不匹配</strong>。（<em>GFS会提出数据校验的初衷，便是用来解决OS和磁盘之间状态不一致的问题的，否则磁盘本身是有错误校验的，理应无需OS自行判断</em>）</p><p>​    之前，由于fsync()的成本，我们在Linux2.2内核中遇到了一些问题。它的成本与文件的大小成正比，而不是修改部分的大小。这对于我们的大型操作日志来说是一个问题，特别是在我们实现checkpoint之前。我们通过使用同步写操作解决这个问题了一段时间，并最终迁移到Linux2.4。</p><p>​    另一个Linux问题是一个读写锁，当一个地址空间中的任何线程，从磁盘换入内存页（读锁）或在调用mmap()修改地址空间（写锁）时，都必须持有它。我们看到系统在轻负载下出现了瞬态超时，并努力寻找资源瓶颈或零星的硬件故障。最终，我们发现，当磁盘线程在以前映射的数据中分页时，这个锁阻止了<strong>主网络线程将新数据映射到内存</strong>中。由于我们主要受到网络接口的限制，而不是内存复制带宽，我们通过用pread()替换mmap()，代价是额外的副本。</p><p>​    尽管偶尔会出现问题，但Linux代码的可用性已经帮助我们不断地探索和理解系统行为。在适当的情况下，我们会改进内核，并与开源社区共享这些更改。</p><h1 id="8、相关工作"><a href="#8、相关工作" class="headerlink" title="8、相关工作"></a>8、相关工作</h1><p>​    与AFS[5]等其他大型分布式文件系统一样，GFS提供了一个位置独立的名称空间，<strong>允许数据透明地移动，以实现负载平衡或容错</strong>。与AFS不同，GFS以一种更类似于xFS[1]和Swift[3]的方式跨存储服务器传播文件的数据，以提供总体性能和更强的容错能力。</p><p>​    由于磁盘相对便宜，而且复制比更复杂的RAID[9]方法更简单，因此GFS目前只使用复制来进行冗余，因此比xFS或Swift消耗更多的原始存储。</p><p>​    与AFS、xFS、Frangipani[12]和Intermezzo[6]等系统相比，GFS不在文件系统接口下面提供任何缓存。我们的目标工作负载在单个应用程序运行中很少被重用，因为它们要么在大数据集上进行流式操作，要么在其中随机查找，每次读取少量数据。</p><p>​    一些分布式文件系统，如Frangipani、xFS、Minnesota的GFS[11]和GPFS[10]，删除了集中式服务器，并依赖于分布式算法来实现一致性和管理。我们选择集中式的方法是为了简化设计，增加其可靠性，并获得灵活性。特别是，集中式master使实现复杂的块放置和复制策略变得更加容易，因为master已经拥有了大部分相关信息并控制它如何更改。<strong>我们通过保持主状态较小并在其他机器上完全复制来解决容错问题</strong>。可伸缩性和高可用性（对读操作而言）目前是由我们的shadow master机制提供的（<em>即主备架构，热备</em>）。通过附加到预写日志（write-ahead log, WAL），使对主状态的更新持久化。因此，我们可以采用像Harp[7]中那样的primary-copy方案，以提供比我们当前的方案更强的高可用性和一致性保证。</p><p>​    我们正在解决一个类似于Lustre[8]的问题，即向大量客户提供总体性能。然而，我们通过<strong>关注应用程序的需求</strong>，而不是构建一个兼容POSIX的文件系统，从而大大简化了这个问题。此外，GFS假设有大量不可靠的组件，因此<strong>容错是我们设计的核心</strong>。</p><p>​    GFS最接近于NASD架构[4]。虽然NASD架构是基于网络连接的磁盘驱动器，但GFS使用商品机器作为chunkserver，就像在NASD原型中所做的那样。与NASD工作不同，我们的chunkserver使用延迟分配的固定大小的块，而不是可变长度的对象。此外，GFS还实现了生产环境中需要的再平衡、复制和恢复等特性。</p><p>​    与Minnesota的GFS和NASD不同，我们并不改变存储设备的模型。我们专注于解决包含既有商品组件的复杂分布式系统的日常数据处理需求。</p><p>​    由原子追加写操作（Atomic Record Appends, Section 3.3）实现的生产者-消费者队列，解决了与River[2]中的分布式队列类似的问题。<strong>River使用分布在机器上的基于内存的队列和细致的数据流控制，而GFS使用一个持久的文件，许多生产者可以并发地附加到该文件中</strong>。River模型支持m到n个分布式队列，但缺乏持久存储所附带的容错能力，而GFS只有效地支持m到1个队列。多个使用者可以读取同一个文件，但它们必须相互协调，以划分传入的负载。</p><h1 id="9、结束语"><a href="#9、结束语" class="headerlink" title="9、结束语"></a>9、结束语</h1><p>​    Google文件系统展示了一个使用普通硬件支持大规模数据处理的系统的特质。虽然一些设计要点都是针对我们的特殊的需要定制的，但是还是有很多特性适用于类似规模的和成本的数据处理任务。</p><p>​    首先，我们根据我们当前的和可预期的将来的应用规模和技术环境来评估传统的文件系统的特性。我们的评估结果将我们引导到一个使用完全不同于传统的设计思路上。根据我们的设计思路，我们认为<strong>组件失效是常态而不是异常</strong>，针对采用追加方式（有可能是并发追加）写入、然后再读取（通常序列化读取）的大文件进行优化，以及扩展标准文件系统接口、放松接口限制来改进整个系统。</p><p>​    我们系统通过<strong>持续监控，复制关键数据，快速和自动恢复提供灾难冗余</strong>。Chunk复制使得我们可以对Chunk服务器的失效进行容错。高频率的组件失效要求系统具备在线修复机制，能够周期性的、透明的修复损坏的数据，也能够第一时间重新建立丢失的副本。此外，我们使用<strong>Checksum</strong>在磁盘或者IDE子系统级别检测数据损坏，在这样磁盘数量惊人的大系统中，损坏率是相当高的。</p><p>​    我们的设计保证了在有大量的并发读写操作时能够提供很高的合计吞吐量。我们通过<strong>分离控制流和数据流</strong>来实现这个目标，<strong>控制流在Master服务器处理，而数据流在Chunk服务器和客户端处理</strong>。当一般的操作涉及到Master服务器时，由于GFS选择的Chunk尺寸较大*(从而减小了元数据的大小*)，以及通过Chunk Lease将控制权限移交给主副本，这些措施将Master服务器的负担降到最低。<strong>这得一个简单、中心的Master不会成为成为瓶颈</strong>。我们相信我们对网络协议栈的优化可以提升当前对于每客户端的写入吞吐量限制。</p><p>​    GFS成功的实现了我们对存储的需求，在Google内部，无论是作为研究和开发的存储平台，还是作为生产系统的数据处理平台，都得到了广泛的应用。它是我们持续创新和处理整个WEB范围内的难题的一个重要工具。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>krpc规范</title>
      <link href="/2023/032336853.html"/>
      <url>/2023/032336853.html</url>
      
        <content type="html"><![CDATA[<h1 id="KRPC简介"><a href="#KRPC简介" class="headerlink" title="KRPC简介"></a>KRPC简介</h1><p>KRPC 协议是一种简单的 RPC 机制，由通过 UDP 发送的编码字典组成。发送单个查询数据包并发送单个数据包作为响应。没有重试。共有三种消息类型：<strong>查询、响应和错误</strong>。对于 DHT 协议，有四种查询：<strong>ping、find_node、get_peers 和 announce_peer</strong>。</p><p>KRPC 消息是一个字典，每个消息都有三个通用的键，并且根据消息的类型还有其他键。</p><p>每条消息都有一个键“t”和一个代表交易 ID 的字符串值。该事务 ID 由查询节点生成并在响应中回显，因此响应可能与对同一节点的多个查询相关联。交易 ID 应编码为二进制数字的短字符串，通常 2 个字符就足够了，因为它们涵盖 2^16 个未完成的查询。每条消息还有一个键“y”，带有描述消息类型的单个字符值。“y”键的值是查询的“q”、响应的“r”或错误的“e”之一。每个带有客户端版本字符串的消息中都应包含一个键“v”。后跟两个字符的版本标识符。并非所有实现都包含“v”键，因此客户端不应假定它存在。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"t"</span> <span class="token operator">:</span> <span class="token string">"ID"</span><span class="token punctuation">,</span> <span class="token comment">//交易ID——string 编码为二进制数字的短字符串</span>    <span class="token property">"y"</span> <span class="token operator">:</span> <span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token comment">//消息类型 "q"查询/"r"响应/"e"错误 </span>    <span class="token property">"v"</span> <span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//版本标识符（两个字符）</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="接触编码-Contact-Encoding"><a href="#接触编码-Contact-Encoding" class="headerlink" title="接触编码(Contact Encoding)"></a>接触编码(Contact Encoding)</h1><p>peers之间的交互信息被编码为一个 6 字节的字符串。也称为“协议 IP 地址/端口信息”(Compact IP-address/port info)，</p><p>4 字节 IP 地址按网络字节顺序排列，2 字节端口按网络字节顺序排列在末尾。</p><p>节点的交互信息被编码为 26 字节的字符串。也称为“协议节点信息”(Compact node info)，网络字节顺序的 20 字节节点 ID 具有连接到末尾的协议 IP 地址/端口信息。</p><h1 id="查询-Queries"><a href="#查询-Queries" class="headerlink" title="查询(Queries)"></a>查询(Queries)</h1><p>“y”值为“q”的查询或 KRPC 消息字典包含两个附加键；“q”和“a”。键“q”有一个包含查询方法名称的字符串值。键“a”有一个字典值，其中包含查询的命名参数。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"q"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//查询方法名称——字符串</span>    <span class="token property">"a"</span><span class="token operator">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//查询命名参数</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="响应-Responses"><a href="#响应-Responses" class="headerlink" title="响应(Responses)"></a>响应(Responses)</h1><p>“y”值为“r”的响应或 KRPC 消息字典包含一个附加键“r”。“r”的值是一个包含命名返回值的字典。成功完成查询后发送响应消息。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"e"</span><span class="token operator">:</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment">//返回值</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="错误-Errors"><a href="#错误-Errors" class="headerlink" title="错误(Errors)"></a>错误(Errors)</h1><p>“y”值为“e”的错误或 KRPC 消息字典包含一个附加键“e”。“e”的值是一个列表。第一个元素是一个表示错误代码的整数。第二个元素是包含错误消息的字符串。当查询无法完成时发送错误。下表描述了可能的错误代码：</p><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>201</td><td>一般错误</td></tr><tr><td>202</td><td>服务器错误</td></tr><tr><td>203</td><td>协议错误，例如格式错误的数据包、无效参数或错误令牌</td></tr><tr><td>204</td><td>未知的方法</td></tr></tbody></table><pre class="line-numbers language-json" data-language="json"><code class="language-json"><span class="token punctuation">&#123;</span>    <span class="token property">"e"</span><span class="token operator">:</span><span class="token punctuation">[</span>        code<span class="token punctuation">,</span> <span class="token comment">//错误代码</span>        message<span class="token punctuation">,</span> <span class="token comment">//错误信息</span>    <span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="DHT查询"><a href="#DHT查询" class="headerlink" title="DHT查询"></a>DHT查询</h1><p>所有查询都有一个“id”键和值，其中包含查询节点的节点 ID。所有响应都有一个“id”键和值，其中包含响应节点的节点 ID。</p><h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>最基本的查询是 ping。”q” = “ping” ping 查询有一个参数，”id” 值是一个 20 字节的字符串，包含按网络字节顺序排列的发送方节点 ID。对 ping 的适当响应具有单个键“id”，其中包含响应节点的节点 ID。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">arguments<span class="token operator">:</span>  <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;querying nodes id>"</span><span class="token punctuation">&#125;</span>response<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;queried nodes id>"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例数据包</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">ping Query = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span><span class="token string">"ping"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span><span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>ad2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij0123456789e1<span class="token operator">:</span>q4<span class="token operator">:</span>ping1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>qeResponse = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token property">"r"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"mnopqrstuvwxyz123456"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>rd2<span class="token operator">:</span>id20<span class="token operator">:</span>mnopqrstuvwxyz123456e1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="find-node"><a href="#find-node" class="headerlink" title="find_node"></a>find_node</h2><p>查找节点用于查找给定 ID 的节点的联系信息。”q” == “find_node” find_node 查询有两个参数，”id” 包含查询节点的节点 ID，”target” 包含查询者查找的节点的 ID。当一个节点收到一个 find_node 查询时，它应该用一个键“nodes”和一个字符串的值来响应，该字符串包含目标节点或它自己的路由表中 K (8) 个最接近的好节点的紧凑节点信息。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">arguments<span class="token operator">:</span>  <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;querying nodes id>"</span><span class="token punctuation">,</span> <span class="token property">"target"</span> <span class="token operator">:</span> <span class="token string">"&lt;id of target node>"</span><span class="token punctuation">&#125;</span>response<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;queried nodes id>"</span><span class="token punctuation">,</span> <span class="token property">"nodes"</span> <span class="token operator">:</span> <span class="token string">"&lt;compact node info>"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>示例数据包</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">find_node Query = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span><span class="token string">"find_node"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">,</span> <span class="token property">"target"</span><span class="token operator">:</span><span class="token string">"mnopqrstuvwxyz123456"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>ad2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij01234567896<span class="token operator">:</span>target20<span class="token operator">:</span>mnopqrstuvwxyz123456e1<span class="token operator">:</span>q9<span class="token operator">:</span>find_node1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>qeResponse = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token property">"r"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"0123456789abcdefghij"</span><span class="token punctuation">,</span> <span class="token property">"nodes"</span><span class="token operator">:</span> <span class="token string">"def456..."</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>rd2<span class="token operator">:</span>id20<span class="token operator">:</span>0123456789abcdefghij5<span class="token operator">:</span>nodes9<span class="token operator">:</span>def456...e1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="get-peers"><a href="#get-peers" class="headerlink" title="get_peers"></a>get_peers</h2><p>获取与 torrent infohash 关联的peer节点。”q” = “get_peers” get_peers 查询有两个参数，”id” 包含查询节点的节点 ID，”info_hash” 包含 torrent 的 infohash。如果查询的节点有 infohash 的对等节点，它们将作为字符串列表在键“值”中返回。每个字符串包含单个对等点的“紧凑”格式对等点信息。如果查询的节点没有 infohash 的对等节点，则返回一个键“nodes”，其中包含查询节点路由表中最接近查询中提供的 infohash 的 K 个节点。在任何一种情况下，“令牌”键也包含在返回值中。令牌值是未来 announce_peer 查询的必需参数。令牌值应该是一个短的二进制字符串。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">arguments<span class="token operator">:</span>  <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;querying nodes id>"</span><span class="token punctuation">,</span> <span class="token property">"info_hash"</span> <span class="token operator">:</span> <span class="token string">"&lt;20-byte infohash of target torrent>"</span><span class="token punctuation">&#125;</span>response<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;queried nodes id>"</span><span class="token punctuation">,</span> <span class="token property">"token"</span> <span class="token operator">:</span><span class="token string">"&lt;opaque write token>"</span><span class="token punctuation">,</span> <span class="token property">"values"</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"&lt;peer 1 info string>"</span><span class="token punctuation">,</span> <span class="token string">"&lt;peer 2 info string>"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>or<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;queried nodes id>"</span><span class="token punctuation">,</span> <span class="token property">"token"</span> <span class="token operator">:</span><span class="token string">"&lt;opaque write token>"</span><span class="token punctuation">,</span> <span class="token property">"nodes"</span> <span class="token operator">:</span> <span class="token string">"&lt;compact node info>"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例数据包</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">get_peers Query = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span><span class="token string">"get_peers"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">,</span> <span class="token property">"info_hash"</span><span class="token operator">:</span><span class="token string">"mnopqrstuvwxyz123456"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>ad2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij01234567899<span class="token operator">:</span>info_hash20<span class="token operator">:</span>mnopqrstuvwxyz123456e1<span class="token operator">:</span>q9<span class="token operator">:</span>get_peers1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>qeResponse with peers = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token property">"r"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">,</span> <span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"aoeusnth"</span><span class="token punctuation">,</span> <span class="token property">"values"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"axje.u"</span><span class="token punctuation">,</span> <span class="token string">"idhtnm"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>rd2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij01234567895<span class="token operator">:</span>token8<span class="token operator">:</span>aoeusnth6<span class="token operator">:</span>valuesl6<span class="token operator">:</span>axje.u6<span class="token operator">:</span>idhtnmee1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>reResponse with closest nodes = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token property">"r"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">,</span> <span class="token property">"token"</span><span class="token operator">:</span><span class="token string">"aoeusnth"</span><span class="token punctuation">,</span> <span class="token property">"nodes"</span><span class="token operator">:</span> <span class="token string">"def456..."</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>rd2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij01234567895<span class="token operator">:</span>nodes9<span class="token operator">:</span>def456...<span class="token number">5</span><span class="token operator">:</span>token8<span class="token operator">:</span>aoeusnthe1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="announce-peer"><a href="#announce-peer" class="headerlink" title="announce_peer"></a>announce_peer</h2><p>announce_peer 有四个参数：“id”包含查询节点的节点 ID，“info_hash”包含 torrent 的 infohash，“port”是整数类型的端口，以及响应先前 get_peers 查询收到的“token” . 被查询节点必须验证令牌之前是否已发送到与查询节点相同的 IP 地址。然后，被查询节点应将查询节点的 IP 地址和提供的端口号存储在其对等联系信息存储中的 infohash 下。</p><p>有一个名为<code>implied_port</code>的可选参数，其值为 0 或 1。如果它存在且非零，则<code>端口</code>参数应被忽略，UDP 数据包的源端口应用作对等端口。这对于可能不知道其外部端口的 NAT 后面的对等点很有用，并且支持 UTP，它们在与 DHT 端口相同的端口上接受传入连接。</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">arguments<span class="token operator">:</span>  <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;querying nodes id>"</span><span class="token punctuation">,</span>  <span class="token property">"implied_port"</span><span class="token operator">:</span> &lt;<span class="token number">0</span> or <span class="token number">1</span>><span class="token punctuation">,</span>  <span class="token property">"info_hash"</span> <span class="token operator">:</span> <span class="token string">"&lt;20-byte infohash of target torrent>"</span><span class="token punctuation">,</span>  <span class="token property">"port"</span> <span class="token operator">:</span> &lt;port number><span class="token punctuation">,</span>  <span class="token property">"token"</span> <span class="token operator">:</span> <span class="token string">"&lt;opaque token>"</span><span class="token punctuation">&#125;</span>response<span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span> <span class="token operator">:</span> <span class="token string">"&lt;queried nodes id>"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例数据包</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">announce_peers Query = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"q"</span><span class="token punctuation">,</span> <span class="token property">"q"</span><span class="token operator">:</span><span class="token string">"announce_peer"</span><span class="token punctuation">,</span> <span class="token property">"a"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"abcdefghij0123456789"</span><span class="token punctuation">,</span> <span class="token property">"implied_port"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token property">"info_hash"</span><span class="token operator">:</span><span class="token string">"mnopqrstuvwxyz123456"</span><span class="token punctuation">,</span> <span class="token property">"port"</span><span class="token operator">:</span> <span class="token number">6881</span><span class="token punctuation">,</span> <span class="token property">"token"</span><span class="token operator">:</span> <span class="token string">"aoeusnth"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>ad2<span class="token operator">:</span>id20<span class="token operator">:</span>abcdefghij012345678912<span class="token operator">:</span>implied_porti1e9<span class="token operator">:</span>info_hash20<span class="token operator">:</span>mnopqrstuvwxyz1234564<span class="token operator">:</span>porti6881e5<span class="token operator">:</span>token8<span class="token operator">:</span>aoeusnthe1<span class="token operator">:</span>q13<span class="token operator">:</span>announce_peer1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>qeResponse = <span class="token punctuation">&#123;</span><span class="token property">"t"</span><span class="token operator">:</span><span class="token string">"aa"</span><span class="token punctuation">,</span> <span class="token property">"y"</span><span class="token operator">:</span><span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token property">"r"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span><span class="token property">"id"</span><span class="token operator">:</span><span class="token string">"mnopqrstuvwxyz123456"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>bencoded = d1<span class="token operator">:</span>rd2<span class="token operator">:</span>id20<span class="token operator">:</span>mnopqrstuvwxyz123456e1<span class="token operator">:</span>t2<span class="token operator">:</span>aa1<span class="token operator">:</span>y1<span class="token operator">:</span>re<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> krpc DHT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>raft</title>
      <link href="/2023/03068545.html"/>
      <url>/2023/03068545.html</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="拜占庭将军问题"><a href="#拜占庭将军问题" class="headerlink" title="拜占庭将军问题"></a>拜占庭将军问题</h2><blockquote><p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p></blockquote><p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p><p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p><p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p><p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p><p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p><p>适用于实际系统的共识算法通常具有以下特性：</p><ul><li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li><li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li><li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li><li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p><ul><li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li><li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li><li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li></ul><p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303011650171.png" alt="image-20230301164706801"></p><h2 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h2><p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p><p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</p><p><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</p><h1 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h1><p>raft 使用心跳机制来触发 Leader 的选举。</p><p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p><p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p><p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p><ul><li>赢得选举</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p><p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p><ul><li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li><li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li></ul><p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p><p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p><h1 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h1><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p><p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p><p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p><p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称为这个 entry 是 committed 的，并且向客户端返回执行结果。</p><p>raft 保证以下两个性质：</p><ul><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li></ul><p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p><p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p><p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p><p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p><h1 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h1><h2 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h2><p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p><p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p><p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p><h2 id="节点崩溃"><a href="#节点崩溃" class="headerlink" title="节点崩溃"></a>节点崩溃</h2><p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p><p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p><h2 id="时间与可用性"><a href="#时间与可用性" class="headerlink" title="时间与可用性"></a>时间与可用性</h2><p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p><pre class="line-numbers language-none"><code class="language-none">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code>：选举超时时间；</li><li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li></ul><p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p><p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p><p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>]]></content>
      
      
      <categories>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raft </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文明6过神</title>
      <link href="/2023/030628831.html"/>
      <url>/2023/030628831.html</url>
      
        <content type="html"><![CDATA[<h1 id="记录第一次过文明6的神难度"><a href="#记录第一次过文明6的神难度" class="headerlink" title="记录第一次过文明6的神难度"></a>记录第一次过文明6的神难度</h1><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303061523363.png" alt="image-20230306152244612"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303061523869.png" alt="image-20230306152302306"></p><p><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202303061524499.png" alt="image-20230306152430403"></p><h1 id="攻略"><a href="#攻略" class="headerlink" title="攻略"></a>攻略</h1><ol><li>彼得大帝yyds</li><li>半冻土 + 淡水 + 有二粮二锤坐城最好</li><li>极光之舞 + 职业道德</li><li>拉夫拉造的越早越好，宗教越早发越好</li><li>两狗一建造一开拓开局，最好能探到奇观吃尤里卡，探不到就裸冲</li><li>我一般喜欢古典共和 + 商人共和国 + 民生主义，市政广场选祠堂 + 骑士礼拜 + 随意</li><li>最重要！古典时代最好能开到黄金时代，开拓者能用信仰买很重要</li><li>骑士礼拜出了之后就可以爆兵去征服了，尽可能的去打多个城，但是要保证能压得住忠诚度</li><li>后期看谁发展的比你好你就打谁，打到没有你发展的好为止</li><li>虽然征服胜利也可以，但是我感觉大图花费时间长，所以就没有继续征服</li><li>总督点我喜欢先点出来两级老马（开拓者不花费人口那个），再点平伽拉</li></ol><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><ol><li>图挺重要，非常重要</li><li>古典开黄金非常重要，极大的影响到你的铺城效率</li><li>其实打神难度前期别的国家必打你的，你就只要守住这一波，早几个弓箭手，苟着发育，等到骑士礼拜出来之后就可以为所欲为了</li></ol>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文明6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马原</title>
      <link href="/2023/022836447.html"/>
      <url>/2023/022836447.html</url>
      
        <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><blockquote><p>@ 重要</p><p>￥ 考的话</p></blockquote><p><strong>马克思主义的基本组成部分</strong></p><ul><li>马克思主义哲学</li><li>马克思主义政治经济学</li><li>科学社会主义</li></ul><p><strong>马克思主义的基本方法</strong></p><p>建立在==辩证唯物主义和历史唯物主义世界观和方法论==基础上，指导我们正确认识世界和改造世界的思想方法和工作方法</p><p><strong>马克思主义的创立社会背景</strong></p><ul><li>社会两极分化，工人极端困苦</li><li>周期性经济危机频繁爆发</li><li>三大工人运动<ol><li>1831、1834法国里昂工人起义—推翻富人政权，争取民主共和国</li><li>1836-1848英国宪章运动—要求普选权，工人参与国家管理</li><li>1844德意志西里西亚织工起义—反对私有制社会</li></ol></li></ul><p><strong>马克思主义创立理论来源</strong></p><ul><li>德国古典哲学—辩证法</li><li>英国古典政治经济学—对资本主义生产关系的分析和关于劳动创造价值的思想</li><li>英法两国的空想社会主义—对资本主义社会的批判和对未来新社会的展望</li></ul><blockquote><p>唯物史观和剩余价值学说是马克思一生的两个伟大发现</p></blockquote><p><strong>马克思主义的发展</strong></p><p>背景：</p><p>19世纪70年代到20世纪初，是西方科学技术取得重要成果的时期</p><p>1917年，俄国十月社会主义革命胜利，使社会主义从理想开始变为现实，从而开创了世界历史的新纪元</p><p><strong>马克思主义的鲜明特征</strong></p><ul><li><p>科学性</p><ol><li>批判地继承了人类全部优秀文化遗产</li><li>是对世界本来面貌的全面而深刻的反映</li><li>随着时代和实践前进的永葆青春活力的科学真理</li></ol></li><li><p>实践性（区别旧的最主要） </p><ol><li>阐明实践观点的基础和核心作用</li><li>经过实践检验并随着实践发展的科学真理</li><li>强调其改造世界的实践功能</li></ol></li><li><p>人民性</p><p>​    ==人民至上是马克思主义的政治立场==</p><ol><li>马克思主义的人民性是由阶级性和实践性所决定</li><li>无产阶级解放和全人类解放的一致性</li><li>人民性是唯物史观和唯心史观的分水岭，也是判断马克思主义政党的试金石</li></ol></li><li><p>发展性</p><ul><li>马克思主义是时代的产物</li><li>与时俱进的理论品质</li></ul></li></ul><p>==马克思主义的鲜明特征，如果用一句话来概括就是科学性与革命性的统一==</p><blockquote><p><strong>世界上第一个无产阶级政党的党纲——《共产党宣言》1848年2月，《共产党宣言》发表，标志着马克思主义的公开问世</strong></p></blockquote><p><strong>马克思主义的当代价值</strong></p><ol><li>观察当代世界变化的认识工具</li><li>指引当代中国发展的行动指南</li><li>引领人类社会进步的科学真理</li></ol><h1 id="第一章-世界的物质性和发展规律"><a href="#第一章-世界的物质性和发展规律" class="headerlink" title="第一章 世界的物质性和发展规律"></a>第一章 世界的物质性和发展规律</h1><h2 id="世界多样性和物质多样性"><a href="#世界多样性和物质多样性" class="headerlink" title="世界多样性和物质多样性"></a>世界多样性和物质多样性</h2><p><strong>哲学的基本问题：</strong></p><ol><li><p>存在和思维、物质和意识何为本原（第一性）的问题</p><p>分为了唯物主义和唯心主义</p></li><li><p>存在和思维、物质和意识是否具有同一性的问题</p><p>产生了可知论和不可知论的理论分野</p></li></ol><p><strong>物质概念</strong></p><p>物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映</p><blockquote><p><strong>马克思主义的物质概念是与实践的观点内在统一的</strong></p></blockquote><p>马克思主义的物质范畴抽象出了==客观实在性==，其<strong>理论意义</strong>：</p><ol><li>坚持唯物主义一元论，同唯心主义一元论和二元论划清界限</li><li>坚持能动的反映论和可知论，批判了不可知论</li><li>体现了唯物论和辩证法的统一，克服了形而上学唯物主义的缺陷</li><li>体现了唯物主义自然观与唯物主义历史观的统一，为彻底的唯物主义奠定了基础</li></ol><blockquote><p><em>形而上学的缺陷</em></p><ol><li><em>机械性，把一切运动归结为机械运动。</em></li><li><em>形而上学性，即用孤立、静止、片面的观点看问题。</em></li><li><em>不彻底性，即自然观是唯物的，但历史观是唯心的；</em></li></ol></blockquote><blockquote><p><strong>物质的根本属性是运动</strong></p><p><strong>运动是标志一切事物和现象的变化及其过程的哲学范畴。物质和运动是不可分割的</strong></p><p><strong>物质世界的运动是绝对的，而物质在运动过程中又有某种相对的静止</strong></p></blockquote><p><strong>时间和空间的概念</strong></p><p>时间和空间是运动着的物质的基本存在形式。</p><ul><li>时间是指物质运动的持续性、顺序性，特点是一维性</li><li>空间是指物质运动的广延性、伸张性，特点是三维性</li></ul><p><strong>物质对意识的决定作用</strong></p><blockquote><p><strong>意识是人脑的机能和属性，是客观世界的主观映像。</strong></p></blockquote><p>物质对意识的决定作用表现在意识的起源和本质上</p><p>起源：</p><ul><li>意识是自然界长期发展的产物</li><li>意识是社会历史发展的产物</li></ul><p>本质：</p><ul><li><p>意识是人脑这样一种特殊物质的机能和属性，是客观世界的主观映像</p><p><code>马克思：观念的东西不外是移入人的头脑并在人的头脑中改造过的物质的东西而已</code></p></li></ul><p><strong>意识对物质的反作用（能动作用）</strong></p><ol><li><p>意识具有目的性和计划性</p><p><code>马克思：人在劳动过程结束时得到的结果，在这个过程开始时就已经在劳动者的表象中存在着，即已经观念地存在着</code></p></li><li><p>意识具有创造性</p></li><li><p>意识具有指导实践改造客观世界的作用</p><p><code>列宁：世界不会满足人，人决心以自己的行动来改变世界</code></p></li><li><p>意识具有调控人的行为和生理活动的作用</p></li></ol><p><strong>主观能动性和客观规律性的辩证统一</strong></p><ol><li>尊重客观规律是正确发挥主观能动性的前提</li><li>只有发挥主观能动性，才能正确认识和利用客观规律</li></ol><p><strong>发挥主观能动性的前提和条件</strong></p><ol><li>从实际出发是正确发挥人的主观能动性的前提</li><li>实践是正确发挥人的主观能动性的根本途径</li><li>正确发挥人的主观能动性，还要依赖于一定的物质条件和物质手段</li></ol><p><strong>人工智能为什么永远不会超过人类智能</strong></p><ol><li>人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展</li><li>社会性是人的意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性</li><li>人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力</li></ol><p><strong>为什么说世界的物质具有统一性</strong></p><ol><li>自然界是物质的</li><li>人类社会本质上也是物质的</li><li>人的意识统一于物质</li></ol><blockquote><p>世界的物质统一性原理是辩证唯物主义最基本最核心的观点</p></blockquote><h2 id="事物的普遍联系和变化发展"><a href="#事物的普遍联系和变化发展" class="headerlink" title="事物的普遍联系和变化发展"></a>事物的普遍联系和变化发展</h2><blockquote><p><strong>联系和发展的观点是唯物辩证法的总观点，集中体现了唯物辩证法的总特征</strong></p></blockquote><p><strong>联系的特点</strong></p><ol><li>客观性</li><li>普遍性</li><li>多样性</li><li>条件性</li></ol><p><strong>新旧事物的概念</strong></p><p>新事物是指合乎历史前进方向、具有远大前途的东西；旧事物是丧失历史必然性、日趋灭亡的东西</p><blockquote><p><strong>物质世界的发展，特别是人类社会的发展，其实质是新事物的产生和旧事物的灭亡</strong></p></blockquote><blockquote><p><strong>判断一个事物是新事物还是旧事物，并不取决与其形式的新旧与出现时间的前后</strong></p></blockquote><p><strong>为什么说新事物是不可战胜的</strong></p><ol><li>新事物已经适应了变化了的环境和条件</li><li>新事物是在旧事物的“母体”中孕育出来的，它既否定了旧事物中消极腐朽的东西，又保留了旧事物中合理的、适应新条件的因素，并添加了旧事物所不能容纳的新内容</li></ol><p><strong>对立统一规律的地位</strong></p><ol><li>唯物辩证法的实质和核心</li><li>揭示了事物普遍联系的根本内容和变化发展的根本动力，从根本上回答了事物为什么会发展的问题</li><li>是贯穿量变质变规律，否定之否定规律以及唯物辩证法基本范畴的中心线索，也是理解哲学规律的“钥匙”</li><li>提供了==人们认识世界和改造世界的根本方法—矛盾分析方法==</li></ol><blockquote><p><strong>对立统一规律是事物发展的根本规律</strong></p></blockquote><blockquote><p><strong>唯物辩证法揭示了事物变化发展的一般规律——对立统一规律（根本规律）、量变质变规律、否定之否定规律</strong></p></blockquote><p><strong>矛盾的同一性和斗争性在事物发展中的作用</strong></p><p>同一性：</p><blockquote><p><strong>矛盾的统一属性，指矛盾着的对立面相互依存，相互贯通的性质和趋势</strong></p></blockquote><ol><li>同一性是事物存在和发展的前提</li><li>同一性使矛盾双方相互吸取有利于自身的因素，在相互作用中各自得到发展</li><li>同一性规定着事物转化的可能和发展的趋势</li></ol><p>斗争性：</p><blockquote><p><strong>矛盾的对立属性，矛盾着的对立面相互排斥，相互分离的性质和趋势</strong></p></blockquote><ol><li>矛盾双方的斗争促进矛盾双方力量的变化，造成双方力量发展的不平衡，为对立面的转化、事物的质变创造条件</li><li>矛盾双方的斗争是一种矛盾统一体向另一种矛盾统一体过渡的决定性力量</li></ol><p><strong>矛盾的普遍性和特殊性概念</strong></p><ul><li>矛盾的普遍性是指矛盾存在于一切事物中，存在于一切事物发展过程的始终，旧的矛盾解决了，新的矛盾又产生，事物始终在矛盾中运动</li><li>矛盾的特殊性是指各个具体事物的矛盾，每一个矛盾的各个方面在发展的不同阶段上各有其特点</li></ul><blockquote><p>矛盾的特殊性是区分和认识事物的前提</p></blockquote><p><strong>主要矛盾和次要矛盾</strong></p><ul><li>主要矛盾是矛盾体系中处于支配地位、对事物发展起决定作用的矛盾</li><li>次要矛盾是矛盾体系中处于从属地位、对事物发展起次要作用的矛盾</li></ul><blockquote><p><strong>把主要矛盾和次要矛盾，矛盾的主要方面和次要方面的辩证关系运用到实际工作中，就是要坚持“两点论”和“重点论”的统一</strong></p></blockquote><p><strong>矛盾的普遍性和特殊性的辩证统一的关系</strong></p><ol><li>矛盾的普遍性即矛盾的共性，矛盾的特殊性即矛盾的个性。矛盾的共性是无条件的、绝对的，矛盾的个性是有条件的、相对的</li><li>任何现实存在的事物的矛盾都是共性和个性的有机统一，共性寓于个性之中，没有离开个性的共性，也没有离开共性的个性</li><li>矛盾的共性和个性相统一的关系，既是客观事物固有的辩证法，也是科学的认识方法</li></ol><p><strong>量变与质变的概念</strong></p><ul><li>量变是事物数量的增减和组成要素排列次序的变动，是保持事物的质的相对稳定性的不显著变化，体现了事物发展渐进过程的连续性</li><li>质变是事物性质的根本变化，是事物由一种质态向另一种质态的飞跃，体现了事物发展渐进过程和连续性的中断</li></ul><p><strong>量变和质变的辩证关系</strong></p><ol><li>量变是质变的必要准备</li><li>质变是量变的必然结果，并为新的量变开辟道路</li><li>量变和质变是相互渗透的</li></ol><blockquote><p>量变质变规律体现了事物发展的渐进性和飞跃性的统一</p></blockquote><p><strong>否定之否定规律是什么</strong></p><p>肯定 — 否定 — 否定之否定</p><blockquote><p><strong>事物的发展是通过其内在矛盾运动以自我否定的方式而实现的</strong></p></blockquote><p><strong>事物内部的肯定因素与否定因素</strong></p><ul><li>肯定因素：维持现存事物存在的因素</li><li>否定因素：促使现存事物灭亡的因素</li></ul><p><strong>唯物辩证法的否定观如何揭示否定的深刻内涵的（否定观的基本内容）</strong></p><ol><li>否定是事物的自我否定、自我发展，是事物内部矛盾作用的结果</li><li>否定是事物发展的环节，是旧事物向新事物的转变，是从旧质到新质的飞跃</li><li>否定是新旧事物联系的环节，新事物孕育产生于旧事物，新旧事物是通过否定环节联系起来的</li><li>辩证否定的实质是“扬弃”，即新事物对旧事物既批判又继承，既克服其消极因素又保留其积极因素</li></ol><blockquote><p><strong>否定之否定规律揭示了事物发展的前进性与曲折性的统一</strong></p></blockquote><p><strong>否定之否定规律对于人们的认识和实践活动具有哪些重要的指导意义</strong></p><ol><li>树立辩证的否定观，反对形而上学地肯定一切或否定一切</li><li>正确看待事物发展的过程，既要看到道路的曲折，又要看到道路的光明</li></ol><p><strong>事物联系和发展的基本环节</strong></p><ol><li>内容与形式 —— 构成要素和表现形式<ul><li>内容是事物存在的基础，形式对内容有反作用</li></ul></li><li>本质与现象 —— 事物内在联系和外在表现<ul><li>本质是事物的根本性质，是构成事物诸要素之间的内在联系</li><li>现象是事物的外部联系和表面特征，是事物的外在表现</li><li>本质决定现象，现象表现本质</li></ul></li><li>原因与结果 —— 事物引起与被引起关系<ul><li>原因与结果是相互区别的</li><li>原因与结果是相互依存和相互转化的</li></ul></li><li>必然与偶然 —— 事物产生、发展和衰亡过程中的不同趋势<ul><li>必然是指事物联系与发展中确定不移的趋势</li><li>偶然是事物发展中不确定的趋势</li><li>必然与偶然相互依存，且相互转化</li></ul></li><li>现实与可能 —— 事物的过去、现在和将来<ul><li>现实是指相互联系着的实际存在的事物的综合</li><li>可能是指包含在事物中、预示事物发展前途的种种趋势，是潜在的尚未实现的东西</li><li>现实与可能相互区别，且相互转化</li></ul></li></ol><h2 id="唯物辩证法是认识世界和改造世界的根本方法"><a href="#唯物辩证法是认识世界和改造世界的根本方法" class="headerlink" title="唯物辩证法是认识世界和改造世界的根本方法"></a>唯物辩证法是认识世界和改造世界的根本方法</h2><blockquote><p><strong>在马克思主义世界观和方法论中，唯物辩证法是其核心内容，为人们认识世界和改造世界提供了根本方法</strong></p></blockquote><blockquote><p><strong>唯物辩证法是客观辩证法与主观辩证法的统一</strong></p></blockquote><p><strong>客观辩证法与主观辩证法的概念</strong></p><ul><li>客观辩证法：客观事物或客观存在的辩证法，即客观事物以相互作用、相互联系的形式呈现出的各种物质形态的辩证运动和发展规律</li><li>主观辩证法：人类认识和思维运动的辩证法，即以概念作为思维细胞的辩证思维运动和发展规律</li></ul><blockquote><p>主观辩证法是客观辩证法在人的思维中的反映，客观辩证法与主观辩证法在本质上是统一的，但在表现形式上却是不同的</p></blockquote><p><strong>两者的表现形式</strong></p><ul><li>客观辩证法：外部必然性形式，不以人的意志为转移</li><li>主观辩证法：观念的、逻辑的形式</li></ul><p><strong>三大规律的启示（作用）</strong></p><ol><li>对立与统一规律 —— 为人们的认识活动提供了方法上的遵循</li><li>量变与质变规律 —— 指导人们在科学研究中把定量分析和定性分析结合起来，遵照“量变—质变—新的量变”的客观进程，去认识和把握事物运动变化发展的阶段性与不同发展状态的转化</li><li>否定之否定规律 —— 任何现实事物都将在其发展过程中实现自我否定，周期性的向更高级的存在形态前进，应从前进性和曲折性相统一中把握事物发展本质及其发展方向</li></ol><blockquote><p><strong>矛盾分析方法是对立统一规律在方法论上的体现</strong>’</p></blockquote><p><code>毛泽东：辩证法的宇宙观，主要地就是教导人们要善于去观察和分析各种事物矛盾的运动，并根据这种分析，指出解决矛盾的方法</code></p><blockquote><p><strong>矛盾分析方法的核心要求是善于分析矛盾的特殊性，做到具体矛盾具体分析，对具体情况，作具体分析</strong></p></blockquote><h1 id="第二章-实践与认识及其发展规律"><a href="#第二章-实践与认识及其发展规律" class="headerlink" title="第二章 实践与认识及其发展规律"></a>第二章 实践与认识及其发展规律</h1><h2 id="实践与认识"><a href="#实践与认识" class="headerlink" title="实践与认识"></a>实践与认识</h2><blockquote><p><strong>实践性是马克思主义理论区别于其他理论的根本特征</strong></p></blockquote><blockquote><p><strong>实践的观点是马克思主义的基本观点</strong></p></blockquote><p><strong>科学实践观的意义</strong></p><ol><li>克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的基础</li><li>建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革</li><li>在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础</li><li>为人们能动地认识世界和改造世界提供了基本的思想方法和工作方法</li></ol><p><strong>实践的基本特征</strong></p><ol><li>客观实在性</li><li>自觉能动性</li><li>社会历史性</li></ol><p><strong>实践的基本结构</strong></p><ol><li>实践主体 — 具有一定的主体能力、从事现实社会实践活动的人，有个体主题、群体主体和人类主题三种基本形态</li><li>实践客体 — 实践活动所指向的形象</li><li>实践中介 — 各种形式的工具、手段以及运用、操作这些工具、手段的程序和方法，中介系统分为物质性工具系统和语言符号工具系统</li></ol><blockquote><p><strong>实践的主体和客体之间的关系，包括实践关系（最根本的关系）、认识关系和价值关系</strong></p></blockquote><p><strong>实践的形式</strong></p><ol><li>物质生产实践 — 人类最基本的实践活动</li><li>社会政治实践 — 处理各种政治关系的实践</li><li>科学文化实践 — 创造精神文化产品的实践活动</li></ol><blockquote><p>物质生产实践是最基本的实践活动，构成全部社会生活的基础；社会政治实践和科学文化实践在物质生产实践基础上产生和发展，受物质生产实践的制约并对其产生能动的反作用</p></blockquote><blockquote><p>虚拟实践 — 伴随信息化和网络化发展而产生的，其实质是主体和客体之间通过数字化中介系统在虚拟空间进行的双向对象化的活动</p></blockquote><p><strong>@@实践对认识的决定作用</strong></p><blockquote><p><strong>实践是认识的基础，实践在认识活动中起着决定性作用</strong></p></blockquote><ol><li><p>实践是认识的来源</p><p><code>习近平：我们党现阶段提出和实施的理论和路线方针政策，之所以正确，就是因为它们都是以我国现时代的社会存在为基础的</code></p></li><li><p>实践是认识发展的动力</p><p><code>恩格斯：社会一旦有技术上的需要，这种需要就会比十所大学更能把科学推向前进</code></p></li><li><p>实践是认识的目的</p></li><li><p>实践是检验认识真理性的唯一标准</p></li></ol><p><strong>￥各个派别对于认识的不同观点</strong></p><ul><li>唯物主义和唯心主义对认识本质的不同回答</li></ul><blockquote><p><strong>唯物主义和唯心主义存在的根本对立的认识路线</strong></p><ol><li><strong>坚持从物到感觉和思想的唯物主义认识路线</strong></li><li><strong>坚持从思想和感觉到物的唯心主义认识路线</strong></li></ol></blockquote><ul><li>旧唯物主义对认识本质的回答。旧唯物主义和辩证唯物主义都坚持反映论，但有着本质区别</li></ul><blockquote><p><strong>旧唯物主义的直观、消极被动的反映论缺陷</strong></p><ol><li><strong>离开实践考察认识问题，不了解实践对认识的决定作用</strong></li><li><strong>不了解认识的辩证本性，离开辩证法来考察认识问题，因而把复杂的认识过程简单化，把活生生的认识运动凝固化，把多方面的认识要素片面化</strong></li><li><strong>最根本的是看不到主观和客观之间的矛盾及其相互作用，没有把认识看做一个不断发展的过程，而是认为认识是一次性完成的</strong></li></ol></blockquote><ul><li>辩证唯物主义对认识本质的科学回答</li></ul><p><strong>辩证唯物主义认识论的特点</strong></p><ol><li>把实践的观点引入认识论</li><li>把辩证法应用于反映论考察认识的发展过程</li></ol><blockquote><p><strong>认识的本质是主体在实践基础上对客体的能动反映</strong></p></blockquote><p><strong>如何理解主体对客体的能动反映</strong></p><blockquote><p><strong>这种能动反映不但是反映客体内容的反映性特征，而且具有实践所要求的主体能动的、创造性的特征</strong></p></blockquote><ol><li>认识的反映特性是人类认识的基本规定性</li><li>认识的能动反映具有创造性</li></ol><p><strong>为什么反映特性与能动的创造特性是不可分割的？</strong></p><ol><li>创造离不开反映，创造存在于反映之中，创造过程是在相互联系的多个方面的反映基础上实现的</li><li>反映也离不开创造，反映是在创造过程中实现的</li></ol><blockquote><p>人的认识是反映性或摹写性与创造性的统一</p></blockquote><blockquote><p><strong>人们认识一定事物的过程，是一个从实践到认识、再到认识到实践的过程</strong></p></blockquote><p>感性认识三种形式</p><ul><li>感觉</li><li>知觉</li><li>表象</li></ul><p>理性认识三种形式</p><ul><li>概念</li><li>判断</li><li>推理</li></ul><blockquote><p>实践到认识的过程，主要表现在实践基础上认识活动由感性认识能动地飞跃到理性认识</p></blockquote><p><strong>@@感性认识和理性认识关系</strong></p><blockquote><p>辩证统一</p></blockquote><ol><li>理性认识依赖于感性认识</li><li>感性认识有待于发展和深化为理性认识</li><li>感性认识和理性认识相互渗透、相互包含</li><li>感性认识和理性认识的辩证统一关系是在实践的基础上形成的，也需要在实践中发展</li></ol><p><strong>感性认识上升到理性认识的基本条件</strong></p><ol><li>投身实践，深入调查，获取十分丰富和合乎实际的感性材料（实现由感性认识上升到理性认识的基础）</li><li>经过思考的作用，运用理论思维和科学抽象，将丰富的感性材料加以去粗取精、去伪存真、由此及彼、由表及里的处理加工，形成概念和理论的系统</li></ol><blockquote><p>第一次飞跃：感性认识到理性认识</p><p>第二次飞跃：认识到实践</p></blockquote><p><strong>认识到实践的飞跃的重要性</strong></p><ol><li>认识世界的目的是改造世界</li><li>认识的真理性只有在实践中才能得到检验和发展</li></ol><p><strong>为什么说经历了两次飞跃之后，实践与认识的运动既完成了又没有完成？</strong></p><ol><li>完成了，是针对具体事物的认识而言的。</li><li>没有完成，是针对实践和认识运动过程的向前推移、向前发展而言的。</li></ol><h2 id="真理与价值"><a href="#真理与价值" class="headerlink" title="真理与价值"></a>真理与价值</h2><blockquote><p><strong>真理是标志主观与客观相符合的哲学范畴，是对客观事物及其规律的正确反映</strong></p></blockquote><blockquote><p>一切唯物主义都认为真理是客观的，一切唯心主义都认为真理是主观的</p></blockquote><p><strong>真理的客观性含义</strong></p><p>真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖于人和人的意识的客观内容</p><blockquote><p>真理是客观的，凡真理都是客观真理。这是真理问题上的唯物论。一切唯物主义认识论都承认和强调真理的客观性。它是唯物主义认识论即反映论的一般原理在真理问题上的贯彻</p><p><code>列宁：认为我们的感觉是外部世界的映像；承认客观真理；坚持唯物主义认识论的观点，——这都是一回事</code></p></blockquote><blockquote><p>真理的客观性决定了真理的一元性</p></blockquote><p><strong>真理一元性的含义</strong></p><blockquote><p>在同一条件下对于特定的认识客体的真理性认识只有一个，而不能有多个</p></blockquote><blockquote><p>认识是多元的，但真理是一元的</p></blockquote><blockquote><p>真理是内容上的一元性与形式上的多样性的统一</p></blockquote><p><strong>@@真理的绝对性和相对性</strong></p><ol><li>真理的绝对性是指真理主客观统一的确定性和发展的无限性<ul><li>任何真理都标志着主观和客观相符合，都包含着不依赖于人和人的意识的客观内容，都同谬误有原则的界限。绝对的，无条件的。承认了真理的客观性（绝对性）</li><li>人类认识按其本性来说，能够正确认识无限发展着的物质世界，认识每前进一步，都是对无限发展的物质世界的接近。也是绝对的，无条件的。承认了世界的可知性</li></ul></li><li>真理的相对性是指人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限度的、不完善的<ul><li>任何真理都只是对客观世界的某一阶段、某一部分的正确认识，人类已经达到的认识的广度总是有限的。认识有待扩展</li><li>就特定事物而言，任何真理都只是对客观对象一定方面、一定层次和一定程度的正确认识，认识反映事物的深度是有限度的，或是近似性的。认识有待深化</li></ul></li><li>真理的绝对性和相对性是辩证统一的</li></ol><blockquote><p><strong>真理的绝对性与相对性根源于人类认识世界能力的无限性与有限性、绝对性与相对性的矛盾</strong></p></blockquote><p><strong>真理与谬误的关系</strong></p><ol><li>真理与谬误相互对立</li><li>真理与谬误的对立又是相对的，它们在一定条件下能够相互转化</li><li>真理总是同谬误向比较而存在、相斗争而发展的</li></ol><p><strong>为什么说实践是检验真理的唯一标准？</strong></p><ol><li>从真理的本性看，真理是人们对客观事物及其发展规律的正确反映，它的本性在于主观和客观相符合，检验真理就是检验人的主观认识同客观实际是否相符合以及符合的程度</li><li>从实践的特点来看，实践具有直接现实性，实践的直接现实性是它的客观实在性的具体表现</li></ol><p><strong>为什么逻辑证明只能是实践检验真理的补充？</strong></p><p>逻辑证明只能回答前提与结论的关系是不是符合逻辑的问题，而不能回答结论是不是符合客观实际的问题。已被逻辑证明了的问题，还必须经过实践的检验，并最终服从实践检验的结果</p><p><strong>什么是实践标准的确定性和不确定性？</strong></p><ul><li>实践标准的确定性即绝对性，是指实践作为检验真理的唯一性、归根到底性、最终性，离开实践，再也没有其他公正合理的标准</li><li>实践标准的不确定性即相对性，是指实践作为检验真理标准的条件性</li></ul><p><strong>为什么实践对真理的检验不可能一次完成？</strong></p><p>实验检验真理是一个永无止境的发展过程。实践不断发展，真理不断发展，在发展的实践中不断验证认识的真理性</p><p><strong>价值的本质</strong></p><p>价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义</p><blockquote><p>在价值的本质问题上，存在着客观主义价值论和主观主义价值论的对立</p></blockquote><p><strong>价值的基本特性</strong></p><ol><li>主体性</li><li>客观性</li><li>多维性</li><li>社会历史性</li></ol><p><strong>价值评价的特点</strong></p><ol><li>评价以主客体的价值关系为认识对象</li><li>评价结果与评价主体直接相关</li><li>评价结果的正确与否依赖于对客体状况和对主体需要的认识</li><li>价值评价有科学与非科学之分</li></ol><p><strong>价值观的概念</strong></p><p>人们关于价值本质的认识以及对人和事物的评价标准、评价原则和评价方法的观点的体系</p><blockquote><p><strong>富强、民主、文明、和谐，自由、平等、公正、法治，爱国、敬业、诚信、友善</strong></p></blockquote><p><strong>实践价值尺度和真理尺度</strong></p><ul><li>实践的真理尺度是指实践中人们必须遵循正确反映客观事物本质和规律的真理。</li><li>实践的价值尺度是指在实践中人们都是按照自己的尺度和需要去认识世界和改造世界</li></ul><blockquote><p><strong>任何实践活动都是在这两种尺度共同制约下进行的，任何成功的实践都是真理尺度和价值尺度的统一，是合规律性和合目的性的统一</strong></p><p><code>屠呦呦的例子</code></p></blockquote><p><strong>真理尺度和价值尺度的关系</strong></p><ol><li>紧密联系、不可分割的辩证统一关系  <code>新时代中国特色社会主义的伟大实践</code></li><li>价值尺度必须以真理为前提</li><li>人类自身需要的内在尺度，推动着人们不断发现新的真理</li></ol><h2 id="认识世界和改造世界"><a href="#认识世界和改造世界" class="headerlink" title="认识世界和改造世界"></a>认识世界和改造世界</h2><p><strong>认识世界和改造世界的含义</strong></p><ol><li>认识世界，就是主体能动地反映客体，获得关于事物的本质和发展规律的科学知识，探索和掌握真理</li><li>改造世界，就是人类按照有利于自己生存和发展的需要，改变事物的现存形式，创造自己的理想世界和生活方式</li></ol><p><strong>认识世界和改造世界的关系</strong></p><ol><li>相互依赖、相互制约的辩证统一关系</li><li>认识世界有助于改造世界，正确认识世界是有效改造世界的必要前提</li><li>人们只有在改造世界的实践中才能不断地深化、拓展对世界的正确认识</li></ol><p><strong>客观世界和主观世界的含义</strong></p><ol><li>客观世界是指“物质的、可以感知的世界”，包含自然存在和社会存在两个部分。</li><li>主观世界是指人的意识、观念世界，是人的头脑反映和把握物质世界的精神活动的总和，是人的知识、情感、意志即知情意的统一体。</li></ol><p><strong>改造客观世界和改造主观世界及其辩证关系</strong></p><ol><li>辩证统一的，二者相辅相成、相互促进、缺一不可</li><li>只有认真改造主观世界，才能更好地改造客观世界</li><li>只有在改造客观世界的实践中，才能深入改造主观世界</li></ol><p><strong>自由的含义</strong></p><p>自由是表示人的活动状态的范畴，是指人在活动中通过认识和利用必然所表现出的一种自觉自主的状态</p><p><strong>自由的条件</strong></p><ol><li>认识条件：要有对客观事物的正确认识</li><li>实践条件：能够将获得的规律性认识运用于指导实践</li></ol><blockquote><p><strong>认识必然和争取自由，是人类认识世界和改造世界的根本目标，是个历史性的过程</strong></p></blockquote><blockquote><p><strong>一切从实际出发是马克思主义认识论的根本要求</strong></p></blockquote><p><strong>@@中国共产党的思想路线</strong></p><ol><li>基本内涵：一切从实际出发，理论联系实际，实事求是，在实践中检验真理和发展真理。</li><li>地位：中国共产党对马克思主义理论发展作出的重大贡献，其核心是实事求是</li></ol><blockquote><p><strong>毛泽东：‘实事’就是客观存在着的一切事物，‘是’就是客观事物的内部联系即规律性，‘求’就是我们去研究</strong></p></blockquote><h1 id="第三章-人类社会及其发展规律"><a href="#第三章-人类社会及其发展规律" class="headerlink" title="第三章 人类社会及其发展规律"></a>第三章 人类社会及其发展规律</h1><h2 id="人类社会的存在与发展"><a href="#人类社会的存在与发展" class="headerlink" title="人类社会的存在与发展"></a>人类社会的存在与发展</h2><blockquote><p><strong>社会存在和社会意识的关系问题，是社会历史观的基本问题</strong></p></blockquote><p><strong>社会存在的含义与组成部分</strong></p><ul><li>含义：社会存在是指社会物质生活条件，是社会生活的物质方面</li><li>组成部分：主要包括自然地理环境、人口因素和物质生产方式</li></ul><p><strong>@物质生产方式（物质生活的生产方式、生产方式）的含义</strong></p><p>是指人们为获取物质生活资料而进行的生产活动的方式，是==生产力和生产关系的统一体==</p><p><strong>@为什么说生产方式是历史发展的决定力量</strong></p><ol><li>首先，物质生产生活及生产方式是人类社会赖以生存和发展的基础，是人类其他一切活动的首要前提</li><li>其次，物质生产生活及生产方式决定着社会的结构、性质和面貌，制约着人们的经济生活、政治生活和精神生活等全部社会生活</li><li>最后，物质生产生活及生产方式的变化发展决定整个社会历史的变化发展，决定社会形态从低级向高级的更替和发展</li></ol><p><strong>社会意识的含义</strong></p><p>社会意识是社会存在的反映，是社会生活的精神方面 </p><p><strong>社会意识形式</strong></p><ol><li><p>意识形态</p><blockquote><p>主要包括政治法律思想、道德、艺术、宗教、哲学等 </p></blockquote></li><li><p>非意识形态</p><blockquote><p>主要包括自然科学和语言学、形式逻辑等一部分社会科学</p></blockquote></li></ol><p><strong>@社会存在和社会意识的关系</strong></p><ol><li>社会存在和社会意识是辩证统一的。社会存在决定社会意识，社会意识是社会存在的反映，并反作用于社会存在。</li><li>社会存在是社会意识内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映。</li><li>社会意识是人们进行社会物质交往的产物。</li><li>社会意识是具体的、历史的。</li></ol><p><strong>社会意识的相对独立性表现在哪些方面？</strong></p><blockquote><p>社会意识的相对独立性是指社会意识在从根本上受到社会存在决定的同时，还具有自身特有的发展形式和发展规律</p></blockquote><ol><li>一是社会意识与社会存在发展的不完全同步性和不平衡性。</li><li>二是社会意识内部各种形式之间存在相互影响且各自具有的历史继承性。</li><li>三是社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现</li><li>社会意识对社会存在有反作用。社会意识的能动作用是通过指导人们的实践生活实现的</li></ol><p><strong>”两个划分“和”两个归结“</strong></p><p>马克思主义==从社会生活各领域中划分出经济领域==，==从一切社会关系中划分出生产关系==，将其作为决定其他一切关系的基本的、原始的关系，==把一切社会关系归结于生产关系==，==并进一步归结于生产力发展==</p><p><strong>文化对社会发展的重要作用表现在哪些方面？</strong></p><ol><li>文化为社会发展提供思想保证</li><li>文化为社会发展提供精神动力</li><li>文化为社会发展提供智力支持</li><li>文化为社会发展提供凝聚力量</li></ol><blockquote><p><strong>生产力和生产关系、经济基础与上层建筑之间的矛盾，是人类社会基本矛盾</strong></p></blockquote><p><strong>生产力的基本要素</strong></p><ol><li>劳动资料（劳动手段），最重要的生产工具</li><li>劳动对象</li><li>劳动者</li></ol><p><strong>为什么科学技术是第一生产力？</strong></p><ol><li>科学技术上的发明创造，会引起劳动资料、劳动对象和劳动者素质的深刻变革和巨大进步</li><li>科学技术应用于生产的组织管理，能够大幅度提高管理效率</li><li>科学技术为劳动者所掌握，可以极大地提高劳动生产率</li></ol><blockquote><p><strong>生产力和生产关系是不可分割地相互联系着的</strong></p></blockquote><p><strong>生产关系的两种基本类型：</strong></p><ol><li>以生产资料公有制为基础的生产关系</li><li>以生产资料私有制为基础的生产关系</li></ol><p><strong>生产力和生产关系的相互关系</strong></p><ol><li>生产力决定生产关系</li><li>生产关系对生产力具有能动反作用</li></ol><blockquote><p><strong>生产力与生产关系的相互作用是一个过程，表现为二者的矛盾运动</strong></p><p>生产力与生产关系矛盾运动规律在人类思想史上彻底否定了单纯以道德作为评判历史功过是非的思想体系，第一次科学地确立了生产力发展是“社会进步的最高标准”</p></blockquote><p><strong>经济基础和上层建筑的含义与构成</strong></p><ol><li><p>经济基础是指由社会一定发展阶段的生产力所决定的生产关系的总和</p></li><li><p>上层建筑是建立在一定经济基础之上的意识形态以及与之相适应的制度、组织和设施</p><p>组成部分：</p><ol><li>政治制度及设施</li><li>政治组织</li></ol></li></ol><blockquote><p><strong>在整个上层建筑中，政治上层建筑居于主导地位，国家政权是政治上层建筑的核心</strong></p></blockquote><blockquote><p><strong>国家是阶级矛盾不可调和的产物</strong></p><p><strong>国家的实质是一个阶级统治另一个阶级的工具，是经济上占支配地位的阶级为维护其根本利益而建立起来的强制性的暴力机关，以保障其在政治上也成为统治阶级</strong></p></blockquote><p><strong>国体与政体的关系：</strong></p><p>国体决定政体，政体服从于国体</p><p><strong>经济基础与上层建筑的关系</strong></p><ol><li>辩证统一的</li><li>经济基础决定上层建筑</li><li>上层建筑对经济基础具有反作用</li><li>经济基础与上层建筑的相互作用构成二者的矛盾运动</li><li>经济基础和上层建筑之间的内在联系构成了上层建筑一定要适合经济基础状况的规律</li></ol><p><strong>交往对社会生活的影响</strong></p><ol><li>促进生产力的发展</li><li>促进社会关系的进步</li><li>促进文化的发展与传播</li><li>促进人的全面发展</li></ol><p><strong>社会形态的构成</strong></p><ol><li>社会的经济形态（基础）</li><li>社会的政治形态</li><li>社会的意识形态</li></ol><p><strong>五种社会形态</strong></p><ol><li>原始社会</li><li>奴隶社会</li><li>封建社会</li><li>资本主义社会</li><li>共产主义社会</li></ol><blockquote><p><strong>生产力与生产关系矛盾运动的规律性，从根本上规定了社会形态更替的客观必然性</strong></p></blockquote><p><strong>社会形态的历史选择性包含的意思</strong></p><ol><li><p>社会发展的客观必然性造成了一定历史阶段社会发展的基本趋势，为人们的历史选择提供了基础、范围和可能性空间</p><p><code>如：新民主主义革命后，中国人民选择了社会主义道路，就是由当时苏联的情形决定的</code></p></li><li><p>社会形态更替的过程也是一个主观能动性与客观规律性相统一的过程</p></li><li><p>人们的历史选择性归根结底是人民群众的选择性</p></li></ol><h2 id="社会历史发展的动力"><a href="#社会历史发展的动力" class="headerlink" title="社会历史发展的动力"></a>社会历史发展的动力</h2><blockquote><p><strong>物质生产方式是社会发展的基础，在此基础上形成的生产力和生产关系的矛盾、经济基础和上层建筑的矛盾是社会发展的基本矛盾和根本动力。</strong></p></blockquote><blockquote><p><strong>生产力和生产关系、经济基础与上层建筑的矛盾，规定并反映了社会基本结构的性质和基本面貌，涉及社会的基本领域，囊括社会结构的主要方面</strong></p></blockquote><p><strong>社会基本结构</strong></p><ol><li>经济结构</li><li>政治结构</li><li>观念结构</li></ol><blockquote><p><strong>经济结构</strong></p><ol><li>广义：生产方式，包含生产力和生产关系两个方面</li><li>狭义：经济关系或经济制度</li></ol></blockquote><p><strong>为什么说社会基本矛盾是历史发展的根本动力？</strong></p><ol><li>生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量</li><li>社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展</li><li>社会基本矛盾具有不同的表现形式和解决形式，并从根本上影响和促进社会形态的变化和发展</li></ol><blockquote><p><strong>社会基本矛盾是生产力和生产关系、经济基础和上层建筑的矛盾</strong></p></blockquote><blockquote><p><strong>社会基本矛盾 ≠ 社会主要矛盾</strong></p><p><strong>社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展，社会主要矛盾是社会基本矛盾的具体体现</strong></p><p>当前社会主要矛盾是<strong>人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾</strong></p></blockquote><p><strong>@阶级的概念</strong></p><p>所谓阶级，就是这样一些集团，由于它们在一定社会经济结构中所处的地位不同，其中一个集团能够占有另一个集团的劳动</p><blockquote><p><strong>阶级斗争对社会发展的推动作用突出地表现在社会形态的更替中</strong></p></blockquote><blockquote><p><strong>阶级斗争及其作用受到一定历史条件的制约</strong></p></blockquote><blockquote><p>阶级斗争是社会发展的直接动力</p></blockquote><blockquote><p><strong>马克思主义的阶级斗争方法是认识阶级社会的科学方法</strong></p></blockquote><p><strong>社会革命的实质</strong></p><ol><li>广义：社会基本矛盾运动基础上的社会生活的全面变革</li><li>狭义：社会形态的变更</li></ol><blockquote><p><strong>社会革命根源于社会基本矛盾的尖锐化</strong></p></blockquote><p><strong>革命对社会发展的作用</strong></p><ol><li>社会革命是实现社会形态更替的重要手段和决定性环节</li><li>社会革命能充分发挥人民群众创造历史的积极性和伟大作用</li><li>社会革命还能够极大地教育和锻炼包括革命阶级在内的广大人民群众</li><li>无产阶级革命将为消除阶级对抗，并充分利用全人类的文明成果促进社会全面进步创造条件</li></ol><blockquote><p><strong>改革是同一种社会形态发展过程中的量变和部分质变，是推动社会发展的又一重要动力</strong></p></blockquote><blockquote><p>每一次科技革命，都不同程度地引起了<strong>生产方式、生活方式和思维方式</strong>的深刻变化和社会的巨大进步</p></blockquote><p><strong>科学技术的社会作用</strong></p><ol><li>正面：科学技术的发展标志着人类改造自然能力的增强，意味着人们能够创造出更多的物质财富，对社会发展有巨大的推动作用</li><li>反面：<ul><li>自然规律和人与自然的关系认识不够，或缺乏对科学技术消极后果的强有力的控制手段</li><li>互联网可以迅速、广泛地传播大量有用的信息，但也存在大量垃圾信息和虚假信息，并可能会侵害国家安全，企业经营秘密以及个人隐私</li><li>在资本主义条件下，科学技术常常被资产阶级用作剥削压迫人民的工具，并非都能使人摆脱贫困，促进人的身心健康发展</li></ul></li></ol><h2 id="人民群众在历史发展中的作用"><a href="#人民群众在历史发展中的作用" class="headerlink" title="人民群众在历史发展中的作用"></a>人民群众在历史发展中的作用</h2><blockquote><p><strong>唯物史观与唯心史观的对立，在历史创造者问题上表现为群众史观与英雄史观的对立</strong></p></blockquote><p><strong>唯物史观在考察谁是历史的创造者时坚持的原则</strong></p><ol><li>唯物史观立足于现实的人及其本质来把握历史的创造者</li><li>唯物史观立足于整体的社会历史过程来探究谁是历史的创造者</li><li>唯物史观从社会历史发展的必然性入手来考察和说明谁是历史的创造者</li><li>最后，唯物史观从人与历史关系的不同层次上考察谁是历史的创造者</li></ol><p><strong>为什么说人民群众是社会历史的主体？</strong></p><ol><li>从质上看，人民群众是指一切对社会历史发展起推动作用的人</li><li>从量上看，人民群众是指社会人口中的绝大多数</li></ol><blockquote><p><strong>在社会历史发展过程中，人民群众起着决定性的作用</strong></p><p><strong>人民群众是社会历史实践的主体，在创造历史中起决定性作用</strong></p></blockquote><blockquote><p><strong>在社会基本矛盾的解决过程中，人民群众是顺应生产力发展要求的社会力量，是具有变革旧的生产关系愿望的社会力量，是主张变革旧的社会制度和旧的思想观念的社会力量</strong></p></blockquote><p><strong>人民群众在创造有哪些方面？</strong></p><ol><li>人民群众是社会物质财富的创造者</li><li>人民群众是社会精神财富的创造者</li><li>人民群众是社会变革的决定力量</li><li>人民群众创造历史的活动受到一定社会历史条件的制约</li></ol><p><strong>马克思主义群众观点的主要内容</strong></p><ol><li>坚持人民群众自己解放自己的观点</li><li>全心全意为人民服务的观点</li><li>一切向人民群众负责的观点</li><li>虚心向群众学习的观点</li></ol><p><strong>@无产阶级政党的群众路线是什么</strong></p><p>一切为了群众，一切依靠群众；从群众中来，到群众中去</p><p><strong>@群众路线的地位</strong></p><p>群众路线是我们党在革命、建设、改革时期不断取得胜利的不可须臾离开的重要法宝</p><blockquote><p>根据历史人物所具有的历史特征和阶级特点，唯物史观主张，评价历史人物时应该坚持<strong>历史分析方法</strong>和<strong>阶级分析方法</strong></p></blockquote><p><strong>历史分析方法和阶级分析方法</strong></p><ol><li>历史分析方法要求从特定的历史背景出发，根据当时的历史条件，对历史人物的是非功过进行具体的、全面的考察</li><li>阶级分析方法要求把历史人物置于一定的阶级关系中，同他们所属的阶级联系起来加以考察和评价</li></ol><p><strong>群众、阶级、政党、领袖的关系</strong></p><ol><li>群众是划分为阶级的</li><li>阶级通常是由政党领导的</li><li>政党是由领袖来主持的</li></ol><h1 id="第四章-资本主义的本质及其规律"><a href="#第四章-资本主义的本质及其规律" class="headerlink" title="第四章 资本主义的本质及其规律"></a>第四章 资本主义的本质及其规律</h1><h2 id="商品经济和价值规律"><a href="#商品经济和价值规律" class="headerlink" title="商品经济和价值规律"></a>商品经济和价值规律</h2><blockquote><p>简单商品经济以生产资料私有制和个体劳动为基础</p><p>资本主义商品经济以生产资料私有制和雇佣劳动为基础</p></blockquote><p><strong>商品经济的含义：</strong>以交换为目的而进行生产的经济形式，是一定社会历史条件的产物</p><p><strong>商品经济产生的历史条件：</strong></p><ol><li>存在社会分工</li><li>生产资料和劳动产品属于不同的所有者</li></ol><p><strong>商品的含义：</strong>商品是用来交换，能满足人的某种需要的劳动产品，具有使用价值和价值两个因素或属性，是使用价值和价值的统一体</p><p><strong>商品的二因素关系：</strong></p><ol><li>对立统一的关系</li><li>对立性表现在：商品的使用价值和价值是相互排斥的，二者不可兼得</li><li>统一性表现在：作为商品，必须同时具有使用价值和价值两个因素</li></ol><p><strong>劳动的二重性：</strong>具体劳动和抽象劳动</p><p><strong>劳动的二重性的关系</strong></p><ol><li>对立统一的</li><li>时间上和空间上是统一的，是商品生产者的统一劳动过程不可分割的两个方面</li><li>具体劳动和抽象劳动又分别反映劳动的不同属性，具体劳动所反映的是人与自然的关系，是劳动的自然属性，而抽象劳动所反映的是商品生产者的社会关系，是劳动的社会属性</li></ol><blockquote><p>商品的价值量由<strong>社会必要劳动时间</strong>决定</p><p>商品的价值量是以<strong>简单劳动</strong>为尺度的</p></blockquote><p><strong>货币职能：</strong>==价值尺度==、==流通手段==、==贮藏手段==、==支付手段==和==世界货币==等</p><blockquote><p>价值尺度和流通手段是最基本的职能</p></blockquote><p><strong>价值规律：</strong></p><ol><li><strong>概念</strong>：价值规律是商品生产和交换的基本规律</li><li><strong>主要内容</strong>：商品的价值量由生产商品的社会必要劳动时间决定，商品交换以价值量为基础，按照等价交换的原则进行</li><li><strong>对市场配置资源的作用</strong>：<ol><li>自发地调节生产资料和劳动力在社会各生产部门之间的分配比例</li><li>自发地刺激社会生产力的发展</li><li>自发地调节社会收入的分配</li><li>在对经济活动自发调节时，也会造成一些消极的后果<ul><li>导致社会资源浪费</li><li>阻碍社会进步</li><li>导致收入两极分化</li></ul></li></ol></li></ol><blockquote><p>私人劳动和社会劳动的矛盾是商品经济的基本矛盾</p></blockquote><p><strong>为什么说私人劳动和社会劳动的矛盾是商品经济的基本矛盾</strong></p><ol><li>私人劳动和社会劳动的矛盾决定着商品经济的本质及发展过程</li><li>私人劳动和社会劳动的矛盾是商品经济其他一切矛盾的基础</li><li>私人劳动和社会劳动的矛盾决定着商品生产者的命运</li></ol><p><strong>马克思劳动价值论的理论和实践意义</strong></p><ol><li>马克思劳动价值论扬弃了英国古典政治经济学的观点，为剩余价值论的创立奠定了基础</li><li>马克思劳动价值论揭示了私有制条件下商品经济的基本矛盾、为从物与物的关系背后揭示人与人的关系提供了理论依据</li><li>马克思劳动价值论揭示了商品经济的一般规律，对理解社会主义市场经济具有指导意义</li></ol><p><strong>如何深化对马克思劳动价值论的认识</strong></p><ol><li>深化对创造价值的劳动的认识，对生产性劳动做出新的界定</li><li>深化对科技人员、经营管理人员在社会生产和价值创造中所起的作用</li><li>深化对价值创造与价值分配关系的认识</li></ol><h2 id="资本主义经济制度的本质"><a href="#资本主义经济制度的本质" class="headerlink" title="资本主义经济制度的本质"></a>资本主义经济制度的本质</h2><p><strong>资本主义产生的途径</strong></p><ol><li>小商品经济分化出来</li><li>商人和高利贷者转化而来</li></ol><blockquote><p><strong>剩余价值学说</strong>是马克思主义政治经济学的基石</p></blockquote><p><strong>劳动力成为商品的基本条件</strong></p><ol><li>劳动者在法律上是自由人，能够把自己的劳动力当做自己的商品来支配</li><li>劳动者没有任何生产资料，没有生活资料来源，因而不得不依靠出卖劳动力为生</li></ol><p><strong>劳动力商品的构成</strong></p><ol><li>维持劳动者被人生存所必要的生活资料的价值</li><li>维持劳动者家属的生存所必需的生活资料的价值</li><li>劳动者接受教育和训练所支出的费用</li></ol><p><strong>资本主义生产过程的二重性</strong></p><ol><li>生产物质资料的劳动过程</li><li>生产剩余价值的过程，即价值增殖过程</li></ol><p><strong>劳动的三要素</strong></p><ol><li>劳动者的劳动</li><li>劳动对象</li><li>劳动资料</li></ol><blockquote><p><strong>价值增殖</strong>过程是剩余价值的生产过程，这是资本主义生产过程的主要方面</p></blockquote><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141653190.png" alt="image-20230214165306024" style="zoom: 50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141653028.png" alt="image-20230214165334928" style="zoom:50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141654961.png" alt="image-20230214165411878" style="zoom:50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141654490.png" alt="image-20230214165432384" style="zoom:50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141654515.png" alt="image-20230214165456437" style="zoom:50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141655435.png" alt="image-20230214165509359" style="zoom:50%;" /><img src="https://charminghacker-blog-pic.oss-cn-chengdu.aliyuncs.com/202302141655015.png" alt="image-20230214165529930" style="zoom:50%;" /><p><strong>产业资本的三个阶段以及产业资本执行的三种职能</strong></p><ol><li>购买阶段 —— 货币资本</li><li>生产阶段 —— 生产资本</li><li>售卖阶段 —— 商品资本</li></ol><p><strong>产业资本的运动的基本前提条件</strong></p><ol><li>产业资本的三种职能形式必须在空间上并存</li><li>产业资本的三种职能形式必须在时间上继起</li></ol><p><strong>社会生产的两大部类</strong></p><ol><li>生产生产资料的部门所构成，产品进入生产领域</li><li>生产消费资料的部门所构成，产品进入生活消费领域</li></ol><blockquote><p>生产社会化和生产资料资本主义私人占有之间的矛盾，是资本主义的基本矛盾</p></blockquote><h2 id="资本主义政治制度和意识形态"><a href="#资本主义政治制度和意识形态" class="headerlink" title="资本主义政治制度和意识形态"></a>资本主义政治制度和意识形态</h2><p><strong>资本主义的宪法的基本原则</strong></p><ol><li>私有制原则</li><li>主权在民原则</li><li>分权制衡原则 —— 立法权、行政权、司法权</li><li>人权原则</li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>毛概</title>
      <link href="/2023/02283319.html"/>
      <url>/2023/02283319.html</url>
      
        <content type="html"><![CDATA[<h1 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h1><p><strong>关键词</strong>：马克思主义中国化</p><p><strong>马克思主义中国化的提出</strong></p><ul><li>时间：1938年</li><li>人物：毛泽东</li><li>地点：党的六届六中全会作《论新阶段》的报告</li><li>内涵：坚持把马克思主义基本原理同中国具体实际相结合，同中华优秀传统文化相结合</li><li>原因：<ol><li>理论创造是为了服务于现实，是为了解决和回应现实问题</li><li>马克思主义中国化既是解决中国实际问题的客观需要</li><li>又是马克思主义理论本身发展的内在要求</li></ol></li></ul><p><strong>四个伟大成就</strong></p><ol><li>创造了新民主主义革命的伟大成就</li><li>创造了社会主义革命和建设的伟大成就</li><li>创造了改革开放和社会主义现代化建设的伟大成就</li><li>创造了新时代中国特色社会主义的伟大成就</li></ol><p><strong>三个时代课题</strong></p><ol><li>新时代坚持和发展什么样的中国特色社会主义</li><li>怎样坚持和发展中国特色社会主义</li><li>建设什么样的社会主义现代化强国</li></ol><p><strong>毛泽东思想、中国特色社会主义理论体系与马克思列宁主义的关系</strong></p><p>​    毛泽东思想和中国特色社会主义理论体系，都是马克思主义中国化的理论成功，都是中国化的马克思主义，它们同马克思列宁主义一起，是中国共产党长期坚持的指导思想和全国各族人民团结奋斗的共同思想基础</p><p><strong>毛泽东思想的历史地位</strong></p><ol><li>是马克思主义中国化的第一个重大理论成果</li><li>是中国革命和建设的科学指南</li><li>中国共产党和中国人民宝贵的精神财富</li></ol><h1 id="第一章-毛泽东思想及其历史地位"><a href="#第一章-毛泽东思想及其历史地位" class="headerlink" title="第一章 毛泽东思想及其历史地位"></a>第一章 毛泽东思想及其历史地位</h1><h2 id="毛泽东思想的形成和发展"><a href="#毛泽东思想的形成和发展" class="headerlink" title="毛泽东思想的形成和发展"></a>毛泽东思想的形成和发展</h2><p><strong>毛泽东思想形成条件</strong></p><ol><li>时代条件：19世纪末20世纪初，世界进入帝国主义和无产阶级革命时代；1917年俄国十月革命的胜利开辟了世界无产阶级社会主义革命的新时代</li><li>实践基础：中国共产党领导人民进行革命和建设的成功实践</li></ol><p><strong>毛泽东思想的形成过程</strong></p><ol><li><p>毛泽东思想的形成</p><ul><li>第一次国内革命战争时期，分析了中国社会各阶级在革命中的地位和作用，提出了新民主主义革命的基本思想</li><li>土地革命战争时期，提出并阐述了农村包围城市，武装夺取政权的思想，标志着毛泽东思想的初步形成</li></ul></li><li><p>毛泽东思想的成熟</p><ul><li>遵义会议确立了毛泽东在党中央和红军的领导地位</li><li>新民主主义革命理论的系统阐述，实现了马克思主义与中国革命实践相结合的历史飞跃，标志着毛泽东思想得到多方面展开而趋于成熟</li><li>1945年<strong>党的七大</strong>将毛泽东思想写入党章，确立为党必须长期坚持的指导思想</li></ul></li><li><p>毛泽东思想的继续发展</p><ul><li>解放战争时期和中华人民共和国成立后继续发展</li><li>毛泽东明确提出了把马克思列宁主义的基本原理同中国革命和建设的具体实际进行“第二次结合，找出在中国怎样建设社会主义的道路“的任务，并为开辟适合中国国情的社会主义道路进行了艰辛探索</li></ul></li></ol><h2 id="毛泽东思想的主要内容和活的灵魂"><a href="#毛泽东思想的主要内容和活的灵魂" class="headerlink" title="毛泽东思想的主要内容和活的灵魂"></a>毛泽东思想的主要内容和活的灵魂</h2><p><strong>毛泽东建党学说解决了什么问题</strong></p><p>在无产阶级人数很少而战斗力很强，农民和其他小资产阶级占人口大多数的国家，建设一个具有广泛群众性的、马克思主义的无产阶级政党，是极其艰巨的任务</p><p><strong>毛泽东思想的活的灵魂</strong></p><p>即贯穿于毛泽东思想各个组成部分的立场、观点和方法</p><ol><li>实事求是</li><li>群众路线</li><li>独立自主</li></ol><p><strong>实事求是</strong></p><ul><li>概念（是什么）：实事求是，就是一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理</li><li>重要性（为什么）：实事求是是马克思主义的根本观点，是中国共产党人认识世界、改造世界的根本要求，是我们党的基本思想方法、工作方法、领导方法</li><li>基本要求（怎么做）：<ol><li>坚持实事求是，就要深入实际了解事物的本来面貌</li><li>坚持实事求是，就要清醒认识和正确把握我国基本国情</li><li>坚持实事求是，就要不断推进实践基础上的理论创新</li></ol></li></ul><p><strong>群众路线</strong></p><ul><li>概念：群众路线，就是一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动</li><li>重要性：群众路线本质上体现的是马克思主义关于人民群众是历史的创造者这一基本原理，群众路线是党的生命线和根本工作路线</li><li>基本要求：<ol><li>坚持群众路线，就要坚持人民是推进历史发展的根本力量</li><li>坚持群众路线，就要坚持全心全意为人民服务的根本宗旨</li><li>坚持群众路线，就要保持党同人民群众的血肉联系</li></ol></li></ul><p><strong>独立自主</strong></p><ul><li>概念：独立自主，就是坚持独立思考，走自己的路，就是坚定不移地维护民族独立，捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物</li><li>重要性：独立自主是中华民族的优良传统，是中国共产党、中华人民共和国立党立国的重要原则，是我们党从中国实际出发，依靠党和人民力量进行革命、建设、改革的必然结论</li><li>基本要求：<ol><li>坚持独立自主，就要坚持中国的事情必须由中国人民自己处理</li><li>坚持独立自主，就要坚持独立自主的和平外交政策，坚定不移走和平发展道路</li></ol></li></ul><h1 id="第二章-新民主主义革命理论"><a href="#第二章-新民主主义革命理论" class="headerlink" title="第二章 新民主主义革命理论"></a>第二章 新民主主义革命理论</h1><h2 id="新民主主义革命理论形成的依据"><a href="#新民主主义革命理论形成的依据" class="headerlink" title="新民主主义革命理论形成的依据"></a>新民主主义革命理论形成的依据</h2><p><strong>近代中国革命的时代特征</strong></p><ol><li>以俄国十月革命的胜利为标志，中国资产阶级民主革命的时代背景发生了根本转换。使中国的资产阶级民主主义革命，从原来属于旧的世界资产阶级民主主义革命的范畴，属于旧的世界资产阶级民主主义革命的一部分，转变为属于新的资产阶级民主主义革命的范畴，属于世界无产阶级社会主义革命的一部分</li><li>在十月革命的影响下，以五四运动为标志，中国无产阶级开始以独立的政治力量登上历史舞台，成为革命的领导力量，马克思主义逐步成为中国革命的指导思想，中国进入新民主主义革命阶段</li></ol><h2 id="新民主主义革命的总路线和基本纲领"><a href="#新民主主义革命的总路线和基本纲领" class="headerlink" title="新民主主义革命的总路线和基本纲领"></a>新民主主义革命的总路线和基本纲领</h2><p><strong>总路线</strong>：</p><ol><li>毛泽东</li><li>1948年</li><li>《在晋绥干部会议上的讲话》</li><li><strong>内容</strong>：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命</li></ol><p><strong>新民主主义革命的动力</strong></p><ol><li>==无产阶级==是中国革命最基本的动力</li><li>==农民==是中国革命的主力军，其中的贫雇农是无产阶级最可靠的同盟军，中农是无产阶级可靠的同盟军</li><li>==城市小资产阶级==是无产阶级的可靠同盟者</li><li>==民族资产阶级==也是中国革命的动力之一</li></ol><p><strong>近代中国革命的性质</strong>：不是无产阶级社会主义革命，而是==资产阶级民主主义革命==</p><p><strong>新民主主义革命 vs 旧民主主义革命</strong></p><p>联系：</p><ol><li>都有资产阶级参加</li><li>经济政策是保护私有财产，具体地说是要把封建地主土地私有制变为农民土地私有制</li></ol><p>区别：</p><ol><li>中国革命处于世界无产阶级社会主义革命的时代，是世界无产阶级社会主义革命的一部分</li><li>革命的领导力量是中国无产阶级及其先锋队——共产党</li><li>革命的指导思想是马克思列宁主义</li><li>革命的前途是社会主义而不是资本主义</li></ol><p><strong>新民主主义革命 vs 社会主义革命</strong></p><p>区别：</p><ol><li>新民主主义仍属于资产阶级民主主义革命的范畴。</li><li>它为了推翻帝国主义、封建主义和官僚资本主义的反动统治，在政治上争取和联合民族资产阶级去反对共同的敌人，在经济上保护民族工商业，容许有利于国计民生的私人资本主义发展。</li><li>它要建立的是无产阶级领导的各革命阶级的联合专政，而不是无产阶级专政</li><li>社会主义革命是无产阶级性质的革命，它所要实现的目标是消除资本主义剥削制度和改造小生产的私有制</li></ol><p>新民主主义革命与社会主义革命又是互相联系，紧密衔接的，中间不容横插一个资产阶级专政</p><p><strong>新民主主义的政治纲领</strong></p><p>推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的，各革命阶级联合专政的新民主主义的共和国</p><p><strong>新民主主义的经济纲领</strong></p><p>“两没收一保护”：没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归新民主主义的国家所有，保护民族工商业</p><p>原因（重要性）：</p><ol><li>没收封建地主阶级的土地归农民所有，是新民主主义革命的主要内容</li><li>没收官僚资本归新民主主义国家所有，是新民主主义革命的题中应有之义</li><li>保护民族工商业，是新民主主义经济纲领中极具特色的一项内容</li></ol><p><strong>新民主主义的文化纲领</strong></p><p>新民主主义文化是无产阶级领导的人民大众的反帝反封建的文化，即民族的科学的大众的文化</p><h2 id="新民主主义革命的道路和基本经验"><a href="#新民主主义革命的道路和基本经验" class="headerlink" title="新民主主义革命的道路和基本经验"></a>新民主主义革命的道路和基本经验</h2><p><strong>新民主主义革命的三大法宝</strong></p><p>毛泽东在《&lt;共产党人&gt;发刊词》提出</p><ol><li>统一战线</li><li>武装斗争</li><li>党的建设</li></ol><p><strong>统一战线</strong></p><ul><li>必要性：<ol><li>统一战线是无产阶级政党策略思想的主要内容</li><li>建立广泛的统一战线，也是由中国革命的长期性、残酷性及其发展的不平衡性所决定的</li></ol></li><li>可能性：在半殖民地半封建的中国社会，诸多矛盾交织在一起，客观上为无产阶级及其政党利用这些矛盾建立和发展统一战线提供了可能性</li><li>新民主主义革命时期，中国共产党领导的统一战线经过的时期：<ul><li>第一次国共合作的统一战线</li><li>工农民主统一战线</li><li>抗日民族统一战线</li><li>人民民主统一战线</li></ul></li><li>实践经验<ol><li>建立巩固的工农联盟</li><li>正确对待资产阶级，尤其是民族资产阶级</li><li>采取区别对待的方针</li><li>坚持独立自主的原则</li></ol></li></ul><p><strong>武装斗争</strong></p><ul><li>革命经验<ol><li>坚持党对军队的绝对领导</li><li>建设全心全意为人民服务的人民军队</li><li>坚持正确的战略战术原则</li></ol></li></ul><p><strong>党的建设</strong></p><ul><li>必要性：中国共产党要领导革命取得胜利，必须要不断加强党的思想建设、组织建设和作风建设</li><li>党的建设经验<ol><li>必须把思想建设始终放在党的建设的首位</li><li>必须在任何时候都重视党的组织建设</li><li>必须重视党的作风建设</li><li>必须联系党的政治路线加强党的建设</li></ol></li></ul><h1 id="第三章-社会主义改造理论"><a href="#第三章-社会主义改造理论" class="headerlink" title="第三章 社会主义改造理论"></a>第三章 社会主义改造理论</h1><h2 id="从新民主主义到社会主义的转变"><a href="#从新民主主义到社会主义的转变" class="headerlink" title="从新民主主义到社会主义的转变"></a>从新民主主义到社会主义的转变</h2><p><strong>为什么说新民主主义社会是一个过渡性的社会</strong></p><ol><li>经济上的三种主要经济成分<ul><li>社会主义经济</li><li>个体经济</li><li>资本主义经济</li></ul></li><li>政治上的阶级构成<ul><li>工人阶级</li><li>农民阶级</li><li>其他小资产阶级、民族资产阶级等</li></ul></li><li>在新民主主义社会中，社会主义的因素不论在经济上还是政治上都已经居于领导地位，但非社会主义因素仍有很大比重</li></ol><p><strong>党在过渡时期的总路线和总任务</strong></p><p>要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造</p><blockquote><p>“一化三改”：社会主义工业化；个体农业、手工业和资本主义工商业的社会主义改造</p></blockquote><h2 id="社会主义改造道路和历史经验"><a href="#社会主义改造道路和历史经验" class="headerlink" title="社会主义改造道路和历史经验"></a>社会主义改造道路和历史经验</h2><p><strong>农业、手工业的社会主义改造策略</strong></p><ol><li>积极引导农民组织起来，走互助合作道路</li><li>遵循自愿互利、典型示范和国家帮助的原则，以互助合作的优越性吸引农民走互助合作道路</li><li>正确分析农村的阶级和阶层状况，制定正确的阶级政策</li><li>坚持积极领导、稳步前进的方针、采取循序渐进的步骤。</li></ol><p><strong>农业社会主义改造的阶段</strong>：互助组、初级社和高级社三个发展阶段</p><p><strong>手工业社会主义改造的阶段</strong></p><ol><li>办手工业供销小组</li><li>办手工业供销合作社</li><li>建立手工业生产合作社</li></ol><p><strong>资本主义工商业的社会主义改造策略</strong></p><ol><li><p>用和平赎买的方法改造资本主义工商业</p><blockquote><p>赎买，就是国家有偿地将私营企业改变为国营企业，将资本主义私有制改为社会主义公有制。它不是由国家支付一笔巨额补偿资金，而是让资本家在一定年限内从企业经营所得中获取一部分利润</p></blockquote></li><li><p>采取从低级到高级的国家资本主义的过渡形式</p><blockquote><p>国家资本主义：在国家直接控制和支配下的资本主义经济</p><p>初级：国家对私营工商业实行委托加工、计划订货、统购包销，经营代销等</p><p>高级：公私合营，包括个别企业的公私合营和全行业的公私合营</p></blockquote></li><li><p>把资本主义工商业者改造成自食其力的社会主义劳动者</p></li></ol><p><strong>资本主义工商业改造的阶段</strong></p><ol><li>初级形式的国家资本主义</li><li>主要实行个别企业的公私合营</li><li>实行全行业的公私合营</li></ol><h2 id="社会主义制度在中国的确立"><a href="#社会主义制度在中国的确立" class="headerlink" title="社会主义制度在中国的确立"></a>社会主义制度在中国的确立</h2><p><strong>社会主义基本制度确立的理论依据</strong></p><p>==社会主义改造的基本完成和由此带来的社会各方面的变化==，表明社会主义制度已经在我国的经济领域、政治领域及社会生活其他领域基本确立</p><p><strong>确立社会主义基本制度的重大意义</strong></p><ol><li>极大地提高了工人阶级和广大劳动人民的积极性、创造性、极大地促进了我国社会生产力的发展</li><li>完成了中华民族有史以来最为广泛而深刻的社会变革</li><li>为当代中国一切发展进步奠定了根本政治前提和制度基础，实现了中华民族由近代不断衰落到根本扭转命运、持续走向繁荣富强的伟大飞跃</li><li>使占世界人口1/4的东方大国进入了社会主义社会，这是世界社会主义发展史上又一个历史性的伟大胜利</li></ol><h1 id="第四章-社会主义建设道路初步探索的理论成果"><a href="#第四章-社会主义建设道路初步探索的理论成果" class="headerlink" title="第四章 社会主义建设道路初步探索的理论成果"></a>第四章 社会主义建设道路初步探索的理论成果</h1><h2 id="初步探索的重要理论成果"><a href="#初步探索的重要理论成果" class="headerlink" title="初步探索的重要理论成果"></a>初步探索的重要理论成果</h2><p><strong>1、调动一切积极因素为社会主义服务</strong></p><p>1956年4月和5月，毛泽东先后在中央政治局扩大会议和最高国务会议上，作了《论十大关系》的报告</p><p>确定了<strong>基本方针</strong>：努力把党内党外、国内国外的一切积极的因素，直接的、间接的积极因素，全部调动起来，为社会主义建设服务</p><p><strong>调动哪些积极因素</strong></p><ol><li>既包括党内的因素，也包括党外的因素</li><li>既包括国内的因素，也包括国外的因素</li><li>既包括直接因素，也包括间接因素</li></ol><p><strong>基本要求（怎么做）</strong></p><ol><li>调动一切积极因素为社会主义事业服务，必须坚持中国共产党的领导</li><li>调动一切积极因素为社会主义事业服务，必须发展社会主义民主政治</li><li>调动一切积极因素为社会主义事业服务，有一个如何认识社会主义发展阶段和社会主义建设规律的问题</li></ol><p><strong>2、正确认识和处理社会主义社会矛盾的思想</strong></p><p><strong>关于社会主义的矛盾学说</strong></p><ol><li>基本矛盾学说</li><li>主要矛盾学说</li><li>社会主义社会存在两类不同性质社会矛盾学说</li></ol><p><strong>基本矛盾</strong></p><ol><li>概念：在社会主义社会中，基本的矛盾仍然是生产关系和生产力之间的矛盾，上层建筑和经济基础之间的矛盾</li><li>特点<ul><li>非对抗性的矛盾</li><li>“又相适应又相矛盾”的特点：和生产力的发展相适应，不完善的方面和生产力发展又是相矛盾的</li></ul></li><li>解决<ul><li>经过社会主义制度本身，不断地得到解决</li></ul></li></ol><p><strong>主要矛盾</strong></p><ol><li>概念：人民对于建立先进的工业国的要求同落后的农业国的现实之间的矛盾，人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾</li><li>解决：将党和国家的工作重点转到技术革命和社会主义建设上来</li></ol><p><strong>社会主义社会存在两类不同性质社会矛盾学说</strong></p><ol><li>概念：敌我矛盾：对抗性；人民内部矛盾：非对抗性</li><li>特点：在一定条件下，两类不同性质的矛盾可以相互转化</li><li>解决：<ul><li>对于敌我之间的矛盾，采取专政的方法</li><li>对于人民内部的矛盾，采取民主的方法</li></ul></li></ol><p><strong>3、走中国工业化道路的思想</strong></p><ul><li><p>总方针：以农业为基础，以工业为主导，以农轻重为序发展国民经济的总方针</p></li><li><p>基本要求</p><ol><li><p>走中国工业化道路，必须明确战略目标和战略步骤</p><blockquote><p>两步走：第一步建成一个独立的比较完整的工业体系和国民经济体系，第二步全面实现工业、农业、国防和科学技术现代化，使中国走在世界前列</p></blockquote></li><li><p>走中国工业化道路，必须采取正确的经济建设方针</p></li><li><p>走中国工业化道路，必须发展科学技术和文化教育</p><blockquote><p>刘少奇提出“两种劳动制度、两种教育制度”：一种是全日制的劳动制度、全日制的教育制度；一种是半日制的劳动制度，半日制的教育制度</p><p>促进我国社会主义文化繁荣的方针：“百花齐放，百家争鸣”</p></blockquote></li><li><p>走中国工业化道路，必须重视知识分子工作</p></li><li><p>走中国工业化道路，必须调整和完善所有制结构</p></li><li><p>走中国工业化道路，必须积极探索适合我国情况的经济体制和运行机制</p></li></ol></li></ul><h2 id="初步探索的意义和经验教训"><a href="#初步探索的意义和经验教训" class="headerlink" title="初步探索的意义和经验教训"></a>初步探索的意义和经验教训</h2><p><strong>初步探索的意义</strong></p><ol><li>巩固和发展了我国的社会主义制度</li><li>为开创中国特色社会主义提供了宝贵经验、理论准备、物质基础</li><li>丰富了科学社会主义的理论和实践</li></ol><p><strong>初步探索的背景</strong></p><ol><li>以苏为鉴</li><li>中国即将开始社会主义建设</li><li>马克思主义和中国实践相结合</li></ol><h1 id="第五章-邓小平理论"><a href="#第五章-邓小平理论" class="headerlink" title="第五章 邓小平理论"></a>第五章 邓小平理论</h1><h2 id="邓小平理论的形成"><a href="#邓小平理论的形成" class="headerlink" title="邓小平理论的形成"></a>邓小平理论的形成</h2><p><strong>形成条件</strong></p><ol><li>和平与发展成为时代主题是邓小平理论形成的时代背景</li><li>社会主义建设的经验教训是邓小平理论形成的历史根据</li><li>改革开放和现代化建设的实践是邓小平理论形成的现实依据</li></ol><h2 id="邓小平理论的基本问题和主要内容"><a href="#邓小平理论的基本问题和主要内容" class="headerlink" title="邓小平理论的基本问题和主要内容"></a>邓小平理论的基本问题和主要内容</h2><p><strong>首要的基本的理论问题</strong>：什么是社会主义、怎样建设社会主义</p><p><strong>社会主义本质理论：</strong></p><p>搞清楚什么是社会主义、怎样建设社会主义，关键要在坚持社会主义基本制度的基础上进一步认清社会主义的本质</p><p><strong>社会主义基本制度：</strong></p><ol><li>坚持以公有制为基础、实行按劳分配原则的社会主义基本经济制度</li><li>坚持共产党领导、实行人民民主专政的社会主义基本政治制度</li><li>坚持以马克思列宁主义、毛泽东思想为指导的社会主义意识形态</li></ol><p><strong>社会主义的本质</strong></p><ol><li>1992年，邓小平在南方谈话中提出</li><li>概念：社会主义的本质，是解放生产力，发展生产力，消灭剥削，消除两极分化，最终达到共同富裕</li><li>意义：<ul><li>遵循了科学社会主义的基本原则</li><li>反映了人民的利益和时代的要求</li><li>廓清了不合乎时代进步和社会发展规律的模糊观念</li><li>摆脱了长期以来拘泥于具体模式而忽略社会主义本质的错误倾向</li><li>深化了对科学社会主义的认识</li></ul></li></ol><p><strong>社会主义初级阶段理论</strong></p><ol><li>党的十三大提出</li><li>概念：社会主义初级阶段，就是指我国在生产力落后，商品经济不发达条件下建设社会主义必然要经历的特定阶段，即从我国进入社会主义到基本实现社会主义现代化的整个历史阶段</li></ol><p><strong>党的基本路线</strong></p><ol><li>党的十三大报告提出</li><li>概念：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗</li></ol><p><strong>社会主义根本任务</strong></p><p>发展生产力</p><blockquote><p>新时期最鲜明的特点是改革开放</p></blockquote><p><strong>如何理解改革是中国的第二次革命？</strong></p><ol><li>性质：改革作为一次新的革命，不是也不允许否定和抛弃我们建立起来的社会主义基本制度，它是社会主义制度的自我完善和发展</li><li>特点：改革不是一个阶级推翻另一个阶级那种原来意义上的革命，也不是原有经济体制的细枝末节的修补，而是对体制的根本性变革</li><li>实质和目标：要从根本上改变束缚我国生产力发展的经济体制，建立充满生机和活力的社会主义新经济体制，同时相应地改革政治体制和其他方面的体制，以实现中国的社会主义现代化</li></ol><blockquote><p>改革是社会主义社会发展的直接动力</p></blockquote><p><strong>社会主义市场经济理论</strong></p><ul><li>党的十二届三中全会，提出了社会主义经济是”公有制基础上的有计划的商品经济“</li><li>党的十四大根据改革开放实践发展的要求和邓小平关于社会主义也可以搞市场经济的思想，特别是南方谈话的精神，确定了建立社会主义市场经济体制的改革目标</li><li>要点<ol><li>计划经济和市场经济不是划分社会制度的标志，计划经济不等于社会主义，市场经济也不等于资本主义</li><li>计划和市场都是经济手段，对经济活动的调节各有优势和长处，社会主义实行市场经济要把两者结合起来</li><li>市场经济作为资源配置的一种方式本身不具有制度属性，可以和不同的社会制度结合，从而表现出不同的性质</li></ol></li></ul><p><strong>“和平统一，一国两制”</strong></p><ul><li>在解决台湾问题时提出的</li><li>在实践中首先运用于解决香港问题、澳门问题</li></ul><p><strong>邓小平理论的历史地位</strong></p><ol><li>是马克思列宁主义、毛泽东思想在新的历史条件下的继承和发展</li><li>是中国特色社会主义理论体系的开篇之作</li><li>对改革开放和社会主义现代化建设具有长远的指导意义</li></ol><h1 id="第六章-“三个代表”重要思想"><a href="#第六章-“三个代表”重要思想" class="headerlink" title="第六章 “三个代表”重要思想"></a>第六章 “三个代表”重要思想</h1><h2 id="“三个代表”重要思想的核心观点和主要内容"><a href="#“三个代表”重要思想的核心观点和主要内容" class="headerlink" title="“三个代表”重要思想的核心观点和主要内容"></a>“三个代表”重要思想的核心观点和主要内容</h2><p><strong>三个代表重要思想</strong></p><ul><li>我们党必须始终代表中国先进生产力的发展要求</li><li>代表中国先进文化的前进方向</li><li>代表中国最广大人民的根本利益</li></ul><p><strong>始终代表中国先进生产力的发展要求</strong></p><ul><li>为什么<ul><li>始终代表中国先进生产力的发展要求，大力促进先进生产力的发展，是我们党站在时代前列，保持先进性的根本体现和根本要求</li></ul></li><li>怎么做<ol><li>广大工人、农民和知识分子始终是推动我国先进生产力发展和社会全面进步的根本力量</li><li>科学技术是第一生产力，是先进生产力的集中体现和主要标志</li></ol></li></ul><p><strong>始终代表中国先进文化的前进方向</strong></p><ul><li>是什么<ol><li>发展先进文化，就是建设社会主义精神文明</li><li>发展先进文化，就是发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化</li></ol></li><li>为什么<ul><li>大力发展社会主义先进文化，必须牢牢把握先进文化的前进方向，建设社会主义精神文明，不断满足人民群众日益增长的精神文化需求，不断丰富人民的精神世界，增强人民的精神力量</li></ul></li><li>怎么做<ol><li>发展社会主义先进文化，必须弘扬民族精神</li><li>发展社会主义先进文化，必须加强社会主义思想道德建设，这是发展先进文化的重要内容和中心环节</li><li>发展社会主义先进文化，必须做好思想政治工作</li></ol></li></ul><p><strong>始终代表中国最广大人民的根本利益</strong></p><ul><li>怎么做<ul><li>要努力使工人、农民、知识分子和其他群众共同享受到经济社会发展的结果</li><li>在我国社会深刻变革、党和国家事业快速发展的进程中，妥善处理各方面的利益关系，把一切积极因素充分调动和凝聚起来，至关重要</li></ul></li></ul><p><strong>发展的重要性</strong></p><ol><li><em>政治意义</em>：离开发展，坚持党的先进性、发挥社会主义制度的优越性和实现民富国强都无从谈起</li><li><em>外部环境</em>：只有加快发展，增强经济实力，提高综合国力，才能在风云变幻的国际局势中处于主动地位，立于不败之地</li><li><em>本身意义</em>：只有发展，才能实现全面建设小康社会的宏伟目标，进一步提高人民的物质文化生活水平；才能增强我国的综合国力，实现中华民族伟大复兴</li></ol><p><strong>全面建设小康社会</strong></p><p>党的十五大报告初步勾画了实现三步战略目标的蓝图</p><ol><li>21世纪第一个十年实现国民生产总值比2000年翻一番，使人民的小康生活更加宽裕，形成比较完善的社会主义市场经济体制</li><li>再过十年的努力，到建党一百年时，使国民经济更加发展，各项制度更加完善</li><li>21世纪中叶新中国成立一百年时，基本实现现代化，建成富强民主文明的社会主义国家</li></ol><p><strong>三个代表重要思想的历史地位</strong></p><ol><li>中国特色社会主义理论体系的丰富发展</li><li>加强和改进的党的建设，推进中国特色社会主义事业的强大理论武器</li></ol><h1 id="第七章-科学发展观"><a href="#第七章-科学发展观" class="headerlink" title="第七章 科学发展观"></a>第七章 科学发展观</h1><h2 id="科学发展观的科学内涵和主要内容"><a href="#科学发展观的科学内涵和主要内容" class="headerlink" title="科学发展观的科学内涵和主要内容"></a>科学发展观的科学内涵和主要内容</h2><p><strong>科学发展观的科学内涵</strong></p><ol><li>第一要义：发展</li><li>核心立场：以人为本</li><li>基本要求：全面协调可持续</li><li>根本方法：统筹兼顾</li></ol><p><strong>推动经济社会发展是科学发展观的第一要义</strong></p><ul><li>为什么<ul><li>发展是人类文明的基础，也是马克思主义最基本的范畴之一</li><li>科学发展观是用来指导发展的理论，中国特色社会主义是靠发展来不断巩固和前进的</li><li>在当代中国，坚持发展是硬道理的本质要求就是坚持科学发展</li></ul></li><li>怎么做<ol><li>坚持科学发展，必须加快转变经济发展方式</li><li>坚持科学发展，必须善于抓住和用好机遇</li></ol></li></ul><p><strong>以人为本是科学发展观的核心立场</strong></p><ul><li>为什么<ul><li>以人为本是科学发展观的核心立场，集中体现了马克思主义的基本原理，体现了我们党全心全意为人民服务的根本宗旨和推动经济社会发展的根本目的</li></ul></li><li>是什么<ul><li>以人为本就是以最广大人民的根本利益为本</li></ul></li><li>怎么做<ul><li>坚持以人为本，就要坚持发展为了人民，始终把最广大人民的根本利益放在第一位</li><li>坚持以人为本，就要坚持发展依靠人民，从人民群众的伟大创造中汲取智慧和力量</li><li>坚持以人为本，就要坚持发展成果由人民共享，着力提高人民物质文化生活水平</li><li>坚持以人为本，最终是为了实现人的全面发展</li></ul></li></ul><h2 id="科学发展观的历史地位"><a href="#科学发展观的历史地位" class="headerlink" title="科学发展观的历史地位"></a>科学发展观的历史地位</h2><p><strong>科学发展观的历史地位</strong></p><ol><li>中国特色社会主义理论体系的接续发展</li><li>全面建设小康社会，加快推进社会主义现代化的根本指针</li></ol><p><strong>为什么说是接续发展？</strong></p><ol><li>科学发展观最鲜明的精神是指是解放思想、实事求是、与时俱进、求真务实</li><li>这个精神实质充分体现了马克思列宁主义、毛泽东思想、邓小平理论、“三个代表”重要思想和科学发展观的历史逻辑和内在联系</li></ol><p><strong>科学发展观与邓小平理论、三个代表重要思想关系</strong></p><ol><li>它们在理论主题、思想基础、政治理想、根本立场上一以贯之</li><li>科学发展观是对邓小平理论、三个代表重要思想的创造性发展，把中国特色社会主义理论体系推进到新境界，赋予当代中国马克思主义勃勃生机</li></ol><p><strong>科学发展观的理论意义</strong></p><p>科学发展观涉及生产力和生产关系、经济基础和上层建筑的各个环节，贯通中国特色社会主义伟大事业和党的建设新的伟大工程的各个方面，进一步深化了对共产党执政规律、社会主义建设规律和人类社会发展规律的认识，是我们党执政理念的丰富和发展，是全面建设小康社会、加快推进社会主义现代化的根本指针</p><p><strong>科学发展观的指导意义</strong></p><ol><li>不仅是指导经济建设的理论，而且是指导各方面建设的理论</li><li>不仅是指导发展的理论，而且是指导党和国家各项工作的理论</li><li>不仅是指导实践、推动工作的有力武器，而且是帮助人们认识和把握社会发展规律的世界观方法论</li></ol><h1 id="毛泽东思想"><a href="#毛泽东思想" class="headerlink" title="毛泽东思想"></a>毛泽东思想</h1><ol><li>新民主主义革命理论</li><li>社会主义革命和社会主义建设理论</li><li>革命军队建设和军事战略的理论</li><li>政策和策略的理论</li><li>思想政治工作和文化工作的理论</li><li>党的建设理论</li></ol><h1 id="邓小平理论"><a href="#邓小平理论" class="headerlink" title="邓小平理论"></a>邓小平理论</h1><ol><li>解放思想、实事求是的思想路线</li><li>社会主义初级阶段理论</li><li>党的基本路线理论</li><li>社会主义的根本任务的理论</li><li>“三步走”战略</li><li>改革开放理论</li><li>社会主义市场经济理论</li><li>“两手抓，两手都要硬”</li><li>“一国两制”</li><li>中国问题的关键在于党</li></ol><h1 id="“三个代表”重要思想"><a href="#“三个代表”重要思想" class="headerlink" title="“三个代表”重要思想"></a>“三个代表”重要思想</h1><ol><li>发展是党执政兴国第一要务</li><li>建立社会主义市场经济体制</li><li>全面建成小康社会</li><li>建设社会主义政治文明</li><li>推进党的建设新的伟大工程</li></ol><h1 id="科学发展观"><a href="#科学发展观" class="headerlink" title="科学发展观"></a>科学发展观</h1><ol><li>加快转变经济发展方式</li><li>发展社会主义民主政治</li><li>推进社会主义文化强国建设</li><li>构建社会主义和谐社会</li><li>推进生态文明建设</li><li>全面提高党的建设科学化水平</li></ol><h1 id="路线"><a href="#路线" class="headerlink" title="路线"></a>路线</h1><ol><li><strong>新民主主义革命</strong>：无产阶级领导的，人民大众的，反对帝国主义、封建主义和官僚资本主义的革命</li><li><strong>过渡时期：</strong>要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、对手工业和对资本主义工商业的社会主义改造</li><li><strong>党的基本路线</strong>：领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生，艰苦创业，为把我国建设成为富强、民主、文明的社会主义现代化国家而奋斗</li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毛概 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="/2023/022863394.html"/>
      <url>/2023/022863394.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、数据库系统基础"><a href="#一、数据库系统基础" class="headerlink" title="一、数据库系统基础"></a>一、数据库系统基础</h1><h2 id="1、数据库及系统基本概念"><a href="#1、数据库及系统基本概念" class="headerlink" title="1、数据库及系统基本概念"></a>1、数据库及系统基本概念</h2><p>数据模型是一种描述事务对象数据特征及其结构的形式化表示，通常由<strong>数据结构</strong>、<strong>数据操作</strong>、<strong>数据约束</strong>三个部分组成</p><ol><li>数据结构用于描述事物对象的静态特征</li><li>数据操作用于描述事物对象的动态特征</li><li>数据约束用于描述事物对象的数据之间语义的联系</li></ol><p>传统数据模型：</p><ol><li>层次数据模型——“树结构”</li><li>网状数据模型——“图结构”</li><li>关系数据模型——“关系二维表”</li></ol><p>数据库系统由<strong>用户</strong>、<strong>数据库应用程序</strong>、<strong>数据库管理程序</strong>和<strong>数据库</strong>四个部分组成</p><h2 id="2、数据库技术发展"><a href="#2、数据库技术发展" class="headerlink" title="2、数据库技术发展"></a>2、数据库技术发展</h2><ol><li>人工数据管理阶段</li><li>文件系统管理阶段</li><li>数据库管理阶段</li></ol><p>发展时代</p><ol><li>20世纪60年代末出现的层次模型数据库技术和网状数据模型</li><li>20世纪70年代出现的关系模型数据库技术</li><li>20世纪90年代出现的面向对象数据库技术和对象-关系数据库技术</li><li>本世纪初期出现的半结构化数据库技术，以及当今面向互联网应用的非结构化数据库技术、大规模分布式数据库技术</li></ol><h2 id="3、数据库应用系统"><a href="#3、数据库应用系统" class="headerlink" title="3、数据库应用系统"></a>3、数据库应用系统</h2><p>数据库应用系统类型</p><ul><li>业务处理系统</li><li>管理信息系统</li><li>决策支持系统</li></ul><p>数据库应用系统结构</p><ol><li>单用户结构</li><li>集中式结构</li><li>客户/服务器结构</li><li>分布式结构</li></ol><p>数据库应用系统的生命周期</p><ol><li>系统需求分析</li><li>系统设计</li><li>系统实现</li><li>系统测试</li><li>系统运行与维护</li></ol><h2 id="4、典型数据库管理系统"><a href="#4、典型数据库管理系统" class="headerlink" title="4、典型数据库管理系统"></a>4、典型数据库管理系统</h2><ol><li>Microsoft SQL Server</li><li>Oracle Database</li><li>Mysql</li><li>Postgresql</li></ol><h2 id="5、PostgreSQL"><a href="#5、PostgreSQL" class="headerlink" title="5、PostgreSQL"></a>5、PostgreSQL</h2><p>数据库对象</p><ol><li>schema</li><li>表</li><li>视图</li><li>序列</li><li>函数</li><li>触发器</li></ol><h1 id="二、数据库关系模型"><a href="#二、数据库关系模型" class="headerlink" title="二、数据库关系模型"></a>二、数据库关系模型</h1><h2 id="1、关系及其相关概念"><a href="#1、关系及其相关概念" class="headerlink" title="1、关系及其相关概念"></a>1、关系及其相关概念</h2><p>实体：指包含数据特征的事物对象在概念模型世界中的抽象名称</p><p>关系模型：一种采用关系二维表的数据结构形式存储实体及其实体间联系的数据模型</p><p><strong>关系键定义：</strong></p><ol><li>复合键</li><li>候选键</li><li>主键</li></ol><h2 id="2、关系模型原理"><a href="#2、关系模型原理" class="headerlink" title="2、关系模型原理"></a>2、关系模型原理</h2><p>数据结构、操作方式、数据约束</p><h3 id="模型操作："><a href="#模型操作：" class="headerlink" title="模型操作："></a>模型操作：</h3><h4 id="（1）传统集合运算"><a href="#（1）传统集合运算" class="headerlink" title="（1）传统集合运算"></a>（1）传统集合运算</h4><ol><li>并运算</li><li>差运算</li><li>交运算</li><li>广义笛卡尔积</li></ol><h4 id="（2）专门关系运算"><a href="#（2）专门关系运算" class="headerlink" title="（2）专门关系运算"></a>（2）专门关系运算</h4><ol><li><p>选择运算</p></li><li><p>投影运算</p></li><li><p>连接运算</p><ul><li>θ连接</li><li>自然连接</li><li>外连接<ul><li>左外连接</li><li>右外连接</li><li>全外连接</li></ul></li></ul></li><li><p>除运算</p><h3 id="数据完整性约束："><a href="#数据完整性约束：" class="headerlink" title="数据完整性约束："></a>数据完整性约束：</h3></li><li><p>实体完整性——主键唯一非空性</p></li><li><p>参照完整性——主外键一致性、级联更新、级联删除</p></li><li><p>用户自定义完整性</p></li></ol><h1 id="三、数据库操作语言SQL"><a href="#三、数据库操作语言SQL" class="headerlink" title="三、数据库操作语言SQL"></a>三、数据库操作语言SQL</h1><p>类型</p><ol><li>数据定义语言（Data Definition Language ,DDL）</li><li>数据操纵语言（Data Manipulation Language,DML）</li><li>数据查询语言（Data Query Language,DQL）</li><li>数据控制语言（Data Control Language,DCL）</li><li>事务处理语言（Transaction Process Language,TPL）</li><li>游标控制语言（Cursor Control Language,CCL）</li></ol><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库表名<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token keyword">option</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token operator">&lt;</span>数据库名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span>    <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>列完整性约束<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>列完整性约束<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token operator">&lt;</span>列名<span class="token number">3</span><span class="token operator">></span> <span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>列完整性约束<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token operator">&lt;</span>修改方式<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token operator">&lt;</span>基本表<span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">&lt;</span>列名表<span class="token operator">></span><span class="token punctuation">]</span> <span class="token keyword">VALUES</span><span class="token punctuation">(</span>列值表<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>基本表<span class="token operator">></span> <span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token operator">|</span><span class="token keyword">DISTINCT</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>内置函数<span class="token punctuation">)</span>目标列<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>别名<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">INTO</span> <span class="token operator">&lt;</span>新表<span class="token operator">></span> <span class="token punctuation">]</span><span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token punctuation">(</span><span class="token operator">LIKE</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token operator">AND</span><span class="token operator">/</span><span class="token operator">OR</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span><span class="token operator">/</span><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">LEFT</span><span class="token operator">/</span><span class="token keyword">RIGHT</span><span class="token operator">/</span><span class="token keyword">ALL</span><span class="token punctuation">]</span><span class="token keyword">JOIN</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span>别名<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span> <span class="token operator">|</span> <span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DISTINCT 关键字过滤重复元组</li><li>通配符 ‘_’表示一个字符 ‘%’表示一个或多个字符</li><li>默认ORDER BY 为升序</li><li>内连接：只有关联表相关字段的列值满足等值连接条件时，这些关联表中提取数据组合成新的数据集</li><li>外连接：<ul><li>左外连接：即使右表没有匹配，也从左表返回所有的行</li><li>右外连接：即使左表没有匹配，也从右表返回所有的行</li><li>全外连接：只要其中一个表中存在匹配，就返回行</li></ul></li></ul><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">GRANT</span> <span class="token operator">&lt;</span>权限列表<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>数据库对象<span class="token operator">></span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户或角色<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">WITH</span> <span class="token keyword">GRANT</span> <span class="token keyword">OPTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">REVOKE</span> <span class="token operator">&lt;</span>权限列表<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>数据库对象<span class="token operator">></span> <span class="token keyword">FROM</span> <span class="token operator">&lt;</span>用户或列表<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">DENY</span> <span class="token operator">&lt;</span>权限列表<span class="token operator">></span> <span class="token keyword">ON</span> <span class="token operator">&lt;</span>数据库对象<span class="token operator">></span> <span class="token keyword">TO</span> <span class="token operator">&lt;</span>用户或角色<span class="token operator">></span> <span class="token comment">//用于防止用户或角色通过其组或角色成员继承权限</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>权限列表：SELECT、INSERT、UPDATE、DELETE</p><h2 id="VIEW视图"><a href="#VIEW视图" class="headerlink" title="VIEW视图"></a>VIEW视图</h2><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">(</span>列名<span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>列名<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token operator">&lt;</span><span class="token keyword">SELECT</span> 查询<span class="token operator">></span><span class="token punctuation">;</span><span class="token keyword">DROP</span> <span class="token keyword">VIEW</span> <span class="token operator">&lt;</span>视图名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>视图通过虚拟视窗映射到基础表中的数据</p><p>视图的好处：</p><ol><li>简化复杂SQL查询操作</li><li>提高数据访问安全性</li><li>提供一定程度的数据逻辑独立性</li><li>集中展示用户所感兴趣的特定数据</li></ol><h1 id="四、数据库设计与实现"><a href="#四、数据库设计与实现" class="headerlink" title="四、数据库设计与实现"></a>四、数据库设计与实现</h1><h2 id="1、数据库的设计概念"><a href="#1、数据库的设计概念" class="headerlink" title="1、数据库的设计概念"></a>1、数据库的设计概念</h2><p>数据库设计方案</p><ol><li>概念数据模型（Conceptual Data Mode ，CDM）</li><li>逻辑数据模型（Logic Data Mode，LDM）</li><li>物理数据模型（Physical Data Model， PDM）</li></ol><table><thead><tr><th>概念数据模型</th><th>逻辑数据模型</th><th align="left">物理数据模型</th></tr></thead><tbody><tr><td>实体</td><td>实体</td><td align="left">表</td></tr><tr><td>属性</td><td>属性</td><td align="left">列</td></tr><tr><td>标识符</td><td>标识符</td><td align="left">键</td></tr><tr><td>联系</td><td>联系</td><td align="left">参照完整性约束</td></tr></tbody></table><p>数据库设计策略</p><ol><li>自底向上策略：适合规模小、业务数据简单的数据库设计</li><li>自顶向下策略：适合规模大、业务数据关系错综复杂的数据库设计</li><li>由内至外策略：自底向上的特例</li><li>混合设计策略</li></ol><h2 id="2、E-R模型"><a href="#2、E-R模型" class="headerlink" title="2、E-R模型"></a>2、E-R模型</h2><p>实体-联系模型</p><ol><li>实体</li><li>属性：唯一标识不同实体或实例的称为标识符</li><li>联系</li></ol><h3 id="实体间联系分类"><a href="#实体间联系分类" class="headerlink" title="实体间联系分类"></a>实体间联系分类</h3><ol><li>多重性分类<ul><li>一对一分类</li><li>一对多分类</li><li>多对多分类</li></ul></li><li>参与性分类</li><li>继承性分类<ul><li>非互斥继承</li><li>互斥继承</li><li>完整继承</li><li>非完整继承</li></ul></li></ol><p><img src="https://s2.loli.net/2022/05/02/bhCF1MjlndPIAZU.png" alt="image-20220502212533026"></p><p><img src="https://s2.loli.net/2022/05/02/p4JId3OhmRYfD1i.png" alt="image-20220502212558826"></p><h3 id="强弱实体"><a href="#强弱实体" class="headerlink" title="强弱实体"></a>强弱实体</h3><p>某些实体对另一些实体有逻辑上的依赖联系，即一个实体的存在必须以另一个实体的存在为前提，前者就被称为<strong>弱实体</strong>，而被依赖的实体被称为<strong>强实体</strong></p><p>弱实体又被分为<strong>标识符依赖弱实体</strong>和<strong>非标识符依赖弱实体</strong></p><ul><li>标识符依赖弱实体：弱实体的标识符含有所依赖实体的标识符</li><li>非标识符依赖弱实体：有自己的标识符</li></ul><p>对标识符依赖弱实体的联系连线图形符号，在弱实体的一侧<strong>有一个三角形的符号</strong></p><p>对非标识符依赖弱实体的联系连线图形符号，在弱实体的一侧<strong>仅为基本鸟足符号</strong></p><h2 id="3、数据库建模设计"><a href="#3、数据库建模设计" class="headerlink" title="3、数据库建模设计"></a>3、数据库建模设计</h2><p>概念数据模型</p><ol><li>抽取与标识实体</li><li>分析与标识实体联系</li><li>定义实体属性与标识符</li><li>检查与完善数据模型</li></ol><p>逻辑数据模型</p><ol><li>CDM/LDM转换</li><li>规范化与完善数据模型设计</li></ol><p>物理数据模型设计</p><ol><li><p>实体到关系表的转换</p><ul><li>代理键设置</li><li>列特性设置<ul><li>空值状态</li><li>默认值</li><li>数据约束</li></ul></li></ul></li><li><p>弱实体到关系表的切换</p><ul><li>非标识依赖：在弱实体转换的关系表中加入强实体标识符作为外键列</li><li>标识符依赖：不仅在弱实体转换的关系表中加入强实体标识符作为外键列，同时也作为该表的主键列</li></ul></li><li><p><strong>实体联系的切换</strong></p><ul><li><strong>1:1实体联系转换</strong>：将一个表的主键放到另一个表中当外键</li><li><strong>1:N实体联系转换</strong>：将1端关系表的主键放到N端关系表中作为外键</li><li><strong>M:N实体联系转换</strong>：增加一个关系表，作为关系表与实体的关系建立参照约束</li><li><strong>实体继承关系的转换</strong>：父表属性放到子表中作为外键</li><li><strong>实体递归关系的转换</strong>：（1:N) 在表中加入另一个外键属性参照本表主键属性 （M:N）派生出一个新的关联表，其表名是联系的名称</li></ul></li></ol><h2 id="4、数据库规范化设计"><a href="#4、数据库规范化设计" class="headerlink" title="4、数据库规范化设计"></a>4、数据库规范化设计</h2><p>数据冗余指一组数据重复出现在数据库的多个表中。在数据库表设计中，我们应尽量避免表间的重复数据列。</p><p><strong>非规范化关系表的问题</strong></p><ol><li>插入数据异常</li><li>删除数据异常</li><li>修改数据异常</li></ol><p><strong>函数依赖理论</strong></p><ol><li>平凡函数依赖</li><li>部分函数依赖</li><li>传递函数依赖</li><li>多值依赖</li></ol><h3 id="规范化设计范式"><a href="#规范化设计范式" class="headerlink" title="规范化设计范式"></a>规范化设计范式</h3><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><p>关系表的属性列不能重复，并且每个属性列都是不可分割的基本数据项</p><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><p>（消除部分函数依赖）</p><p>满足第一范式，且关系表中所有数据都要和该关系表的主键有完全函数依赖</p><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><p>（消除传递函数依赖）</p><p>满足第二范式，且所有非主键属性均不存在传递函数依赖</p><h4 id="巴斯-科德（BCNF）范式"><a href="#巴斯-科德（BCNF）范式" class="headerlink" title="巴斯-科德（BCNF）范式"></a>巴斯-科德（BCNF）范式</h4><p>满足第三范式，且所有函数依赖的决定因子必须是候选键</p><h4 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h4><p>满足BCNF范式，且消除了多值依赖</p><h4 id="第五范式"><a href="#第五范式" class="headerlink" title="第五范式"></a>第五范式</h4><p>如果一个关系为消除其中连接依赖，进行投影分解，所分解的各个关系均包含原关系的一个候选键，则这些分解后的关系满足第五范式</p><h3 id="逆规范化处理"><a href="#逆规范化处理" class="headerlink" title="逆规范化处理"></a>逆规范化处理</h3><ol><li>关系表的合并</li><li>冗余列的增加</li><li>抽取表的创建</li><li>关系表分区的创建</li></ol><h1 id="五、数据库管理"><a href="#五、数据库管理" class="headerlink" title="五、数据库管理"></a>五、数据库管理</h1><h2 id="1、数据库管理的目标与内容"><a href="#1、数据库管理的目标与内容" class="headerlink" title="1、数据库管理的目标与内容"></a>1、数据库管理的目标与内容</h2><p><img src="https://s2.loli.net/2022/05/02/o2mATdLrHJEwq7j.png" alt="image-20220502222237917"></p><p><img src="https://s2.loli.net/2022/05/02/kp9FGf2twozYKmV.png" alt="image-20220502222338585"></p><h2 id="2、事务管理"><a href="#2、事务管理" class="headerlink" title="2、事务管理"></a>2、事务管理</h2><p>事务：由构成单个逻辑处理单元的一组数据库访问操作，这些操作的SQL语句被封装在一起，要么都被执行，要么都不执行</p><ul><li>事务是DBMS执行的最小任务单元</li><li>事务是DBMS最小的故障恢复任务单元</li><li>事务是DBMS最小的并发控制任务单元</li></ul><p><strong>事务特性：</strong>ACID原则</p><p>（1）<strong>原子性</strong>：Atomicity</p><p>事务中SQL语句对数据的修改操作，要么全都被正确执行，要么全都不被正确执行</p><p>（2）<strong>一致性</strong>：Consistency</p><p>事务执行的结果使数据库从一种正确数据状态变迁到另一种正确数据状态</p><p>（3）<strong>隔离性</strong>：Isolation</p><p>多个事务并发执行时，一个事务的执行不能被其他事务干扰，即另一个事务对数据所做的修改对其他并发事务是隔离的，各个并发事务之间不能相互影响</p><p>（4）<strong>持续性</strong>：Durability</p><p>事务持续性指一个事务一旦提交，它对数据中数据的改变应该是永久性的</p><p>并发执行事务好处：</p><ol><li>改善系统的资源利用率</li><li>减少事务执行的平均等待时间</li></ol><p>事务SQL语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">BEGIN</span><span class="token punctuation">;</span><span class="token keyword">SQL</span> 语句<span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">SQL</span> 语句<span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">SQL</span> 语句n<span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span>或<span class="token keyword">ROLLBACK</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、并发控制"><a href="#3、并发控制" class="headerlink" title="3、并发控制"></a>3、并发控制</h2><p><strong>（1）脏读</strong></p><p>多个事务并发运行，并操作访问共享数据，其中一个事务读取了被另一个事务所修改所修改后的共享数据，但修改数据的事务因某种原因失败，数据未被提交到数据库文件，而读取共享数据的事务则读取得到一个垃圾数据，即脏数据。</p><p>脏数据——对未提交的修改数据的统称</p><p><strong>（2）不可重复读</strong></p><p>不可重复读指一个事务对同一共享数据先后重复读取两次，但是发现原有数据改变或丢失。</p><p>原因——多个事务并发运行时，一些事务对共享数据进行多次读操作，但其中一个事务对共享数据进行了修改或删除操作</p><p><strong>（3）幻想读</strong></p><p>幻想读指一个事务对同一共享数据重复读取两次，但是发现第2次读取比第1次读取的结果中新增了一些数据</p><p>原因——多个事务并发运行，其中一个事务同时在对共享数据进行添加操作</p><p><strong>（4）丢失更新</strong></p><p>一个事务对一共享数据进行更新处理，但是以后查询该共享数据值时，发现该数据与自己的更新值不一致</p><p>原因——多个事务并发执行，其中一个事务对共享数据进行了更新，并改变了前面事务的更新值</p><h3 id="并发事务调度"><a href="#并发事务调度" class="headerlink" title="并发事务调度"></a>并发事务调度</h3><p><img src="https://s2.loli.net/2022/05/03/z29ZdQKNYrX1LVk.png" alt="image-20220503113942172"></p><p>在DBMS中，事务管理器将并发执行事务的SQL数据操作请求提交给并发控制调度器。由并发控制调度器将各个事务的SQL数据操作请求按照一定顺序进行调度执行，并完成对数据库缓冲区的读写操作。</p><p>在事务并发执行中，只有当事务中数据操作调度顺序的执行结果与事务串行执行结果一样时，该并发事务调度才能保证数据操作的正确性和一致性。符合这样效果的调度称为<strong>可串行化调度</strong>。</p><h3 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h3><p>锁机制与并发控制调度器结合，实现共享资源的锁定访问</p><p><img src="https://s2.loli.net/2022/05/03/yNhutqixnQ7fwda.png" alt="image-20220503114415217"></p><p><strong>排它锁定</strong>(Lock-X)——又称写锁。若事务T对数据对象A加上X锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的锁。这保证了其他事务在T释放A上的锁之前不能再加锁读取和修改A。</p><p><strong>共享锁定</strong>(Lock-S)——又称读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</p><h3 id="基于锁的并发控制协议"><a href="#基于锁的并发控制协议" class="headerlink" title="基于锁的并发控制协议"></a>基于锁的并发控制协议</h3><p><strong>事务可串行化调度</strong>是确保数据库一致性的基本方法</p><p><strong>（1）锁操作相容性</strong></p><table><thead><tr><th>类型</th><th>排他锁</th><th>共享锁</th><th>无锁</th></tr></thead><tbody><tr><td>排他锁</td><td>否</td><td>否</td><td>是</td></tr><tr><td>共享锁</td><td>否</td><td>是</td><td>是</td></tr><tr><td>无锁</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><p><strong>（2）加锁协议</strong></p><p><strong>1、一级加锁协议</strong></p><p>任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。</p><p>防止“<strong>丢失更新</strong>”不一致问题</p><p><strong>2、二级加锁协议</strong></p><p>在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即刻释放共享锁定。</p><p>防止出现“<strong>丢失更新</strong>”不一致问题，“<strong>脏数据</strong>“问题</p><p><strong>3、三级加锁协议</strong></p><p>在一级加锁协议基础上，针对并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。</p><p>防止出现“<strong>丢失更新</strong>”不一致问题，“<strong>脏数据</strong>“问题，“<strong>不可重复读</strong>”问题</p><table><thead><tr><th><strong>加锁协议级别</strong></th><th><strong>排它锁</strong></th><th><strong>共享锁</strong></th><th>不丢失更新</th><th><strong>不脏读</strong></th><th><strong>可重复读</strong></th></tr></thead><tbody><tr><td><strong>一级</strong></td><td>全程加锁</td><td>不加</td><td>是</td><td>否</td><td>否</td></tr><tr><td><strong>二级</strong></td><td>全程加锁</td><td>开始时加锁，读完数据释放锁定</td><td>是</td><td>是</td><td>否</td></tr><tr><td><strong>三级</strong></td><td>全程加锁</td><td>全程加锁</td><td>是</td><td>是</td><td>是</td></tr></tbody></table><h3 id="两阶段锁定协议"><a href="#两阶段锁定协议" class="headerlink" title="两阶段锁定协议"></a>两阶段锁定协议</h3><p>并发事务的正确调度准则：<br>一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。</p><p>保证可串行化的一个协议是：<strong>二阶段锁定协议</strong></p><p>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请：</p><ul><li>增长阶段，事务只能获得锁，但不能释放锁。</li><li>缩减阶段，事务只能释放锁，但不能获得新锁。</li></ul><h3 id="并发事务死锁解决"><a href="#并发事务死锁解决" class="headerlink" title="并发事务死锁解决"></a>并发事务死锁解决</h3><p>死锁必要条件：</p><p>（1）互斥条件</p><p>（2）请求和保持条件</p><p>（3）不剥夺条件</p><p>（4）环路等待条件</p><p>解决死锁问题的两类策略：</p><p>（1）在并发事务执行时，预防死锁</p><p>（2）在死锁出现后，其中一个事务释放资源以解除死锁</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p><img src="https://s2.loli.net/2022/05/03/69Mxd8QjhRuwWKe.png" alt="image-20220503122201038"></p><p>事务隔离级别设置是在DBMS中执行<code>SET TRANSACTION</code>命令来实现或通过管理工具设置。事务隔离级别设置越高，出现数据不一致的可能性越小，但系统吞吐量也越小。</p><h2 id="4、安全管理"><a href="#4、安全管理" class="headerlink" title="4、安全管理"></a>4、安全管理</h2><h3 id="数据库安全模型"><a href="#数据库安全模型" class="headerlink" title="数据库安全模型"></a>数据库安全模型</h3><p><img src="https://s2.loli.net/2022/05/03/4NijpxGnCV7gmzq.png" alt="image-20220503122410693"></p><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>用户创建</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token operator">&lt;</span>用户账号名<span class="token operator">></span> <span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token keyword">option</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户修改</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">USER</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token keyword">option</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用户删除</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>（1）权限类别</p><ol><li>数据库对象访问操作权限</li><li>数据库对象定义操作权限</li></ol><p>（2）权限管理</p><ol><li>执行sql控制语句进行权限管理</li><li>运行数据库管理工具进行权限管理</li></ol><h3 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> ROLE <span class="token punctuation">[</span>角色名<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token keyword">option</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">ALTER</span> ROLE <span class="token punctuation">[</span>角色名<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token keyword">WITH</span><span class="token punctuation">]</span> <span class="token keyword">option</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">DROP</span> ROLE <span class="token operator">&lt;</span>角色名<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="5、备份与恢复"><a href="#5、备份与恢复" class="headerlink" title="5、备份与恢复"></a>5、备份与恢复</h2><p><strong>备份方式</strong></p><ol><li>完整数据库备份</li><li>差异数据库备份</li><li>事务日志备份</li><li>文件备份</li></ol><p>又分为 热备份 与 冷备份</p><p><strong>备份设备</strong></p><ol><li>磁盘阵列</li><li>磁带库</li><li>光盘库</li></ol><p><strong>备份方法</strong></p><ol><li>使用实用程序工具进行数据库备份<ul><li><code>pg_dump [连接选项] [一般选项] [输出控制选项] 数据库名称</code></li><li><code>pg_dumpall [连接选项] [一般选项] [输出控制选项]</code></li></ul></li><li>使用管理工具GUI操作进行备份</li></ol><p><strong>备份恢复</strong></p><ol><li>使用实用程序工具恢复数据库备份<ul><li><code>psql [连接选项] -d 恢复的数据库 -f 备份文件</code>——对应<code>pg_dump</code></li><li><code>pg_restore [连接选项] [一般选项] [恢复控制选项] 备份文件</code>——对应<code>pg_dumpall</code></li></ul></li><li>使用管理工具GUI操作恢复数据库备份</li></ol><h1 id="六、数据库应用编程"><a href="#六、数据库应用编程" class="headerlink" title="六、数据库应用编程"></a>六、数据库应用编程</h1><h2 id="1、JDBC"><a href="#1、JDBC" class="headerlink" title="1、JDBC"></a>1、JDBC</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"org.postgresql.Driver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Connection</span> conn <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>user<span class="token punctuation">,</span>password<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Statement</span> st <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Statement</span><span class="token punctuation">)</span>conn<span class="token punctuation">.</span>createStatement<span class="token punctuation">;</span><span class="token class-name">ResultSet</span> rs <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">excuteQuery</span><span class="token punctuation">(</span>sql<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">String</span> result <span class="token operator">=</span> rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token string">"xxx"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2、MyBatis"><a href="#2、MyBatis" class="headerlink" title="2、MyBatis"></a>2、MyBatis</h2><p>三层功能框架</p><ol><li>API接口层</li><li>数据处理层</li><li>基础支撑层</li></ol><p>访问数据库的基本过程</p><ol><li>读取配置文件SqlMapConfig.xml，此文件作为MyBatis的全局配置文件，配置了MyBatis的运行环境等信息</li><li>SqlSessionFactoryBuilder通过Configuration生成sqlSessionFactory对象</li><li>通过sqlSessionFactory打开一个数据库会话sqlSession，操作数据库需要通过sqlSession进行</li><li>MyBatis底层自定义了Executor执行器接口操作数据库，Executor接口负责动态SQL的生成和查询缓存的维护，将MappedStatement对象进行解析，sql参数转化，动态SQL拼接，生成JDBC Statement对象，通过Satement进行输入和输出</li></ol><h2 id="3、存储过程编程"><a href="#3、存储过程编程" class="headerlink" title="3、存储过程编程"></a>3、存储过程编程</h2><p>​    存储过程是一种数据库的对象，由一组能完成特定功能的SQL语句集构成。它把经常会被重复使用的SQL语句逻辑块封装起来，经编译后，存储在数据库服务器端，它被再次调用时，不需要再次编译；当客户端连接到数据库时，用户通过指定存储过程的名称并给出参数，数据库就可以找到相应的存储过程并予以调用。</p><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token operator">OR</span> <span class="token keyword">REPLACE</span><span class="token punctuation">]</span> <span class="token keyword">FUNCTION</span>Name <span class="token punctuation">(</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span>argmode<span class="token punctuation">]</span> <span class="token punctuation">[</span>argname<span class="token punctuation">]</span> argtype <span class="token punctuation">[</span> &#123;<span class="token keyword">DEFAULT</span> <span class="token operator">|</span> <span class="token operator">=</span> &#125; default_expr <span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">[</span> <span class="token keyword">RETURNS</span> retype <span class="token operator">|</span> <span class="token keyword">RETURNS</span> <span class="token keyword">TABLE</span> <span class="token punctuation">(</span> column_name column_type <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token keyword">AS</span> $<span class="token keyword">DECLARE</span> <span class="token comment">--声明段</span><span class="token keyword">BEGIN</span> <span class="token comment">--函数体语句</span><span class="token keyword">END</span><span class="token punctuation">;</span>$$ <span class="token keyword">LANGUAGE</span> lang_name<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>OR REPLACE：如果没有该名称，则创建存储过程</li><li>argmode：参数：IN、OUT、INOUT</li><li>argname：形式参数名称</li><li>argtype：该函数值的返回类型</li><li>default_expr：指定参数默认值的表达式。该表达式的类型必须是可转化为参数的类型</li><li>retype：指示RETURNS返回值的数据类型</li><li>RETURNS TABLE：指示存储过程返回值的类型是由多列构成的二维表</li><li>AS $$：声明存储过程代码的开始</li><li>DECLARE：指示声明存储过程的局部变量</li><li>BEGIN…END：定义存储过程的执行体语句</li><li>LANGUAGE：指明存储过程使用的编程语言</li></ol><h3 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">FUNCTION</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name <span class="token punctuation">(</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span> argmode <span class="token punctuation">]</span> <span class="token punctuation">[</span> argname <span class="token punctuation">]</span> argtype <span class="token punctuation">[</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> <span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">[</span> <span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">RESTRICT</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>CASCADE：级联删除依赖于函数的对象（如操作符或触发器）</li><li>RESTRICT：如果有任何依赖对象存在，则拒绝删除该函数；这个是默认值</li></ol><h2 id="4、触发器编程"><a href="#4、触发器编程" class="headerlink" title="4、触发器编程"></a>4、触发器编程</h2><p>触发器是在某个事件发生时自动地隐式运行</p><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">CONSTRAINT</span><span class="token punctuation">]</span> <span class="token keyword">TRIGGER</span> name&#123; BEFORE <span class="token operator">|</span> <span class="token keyword">ALTER</span> <span class="token operator">|</span> INSTEAD <span class="token keyword">OF</span> &#125; &#123; event <span class="token punctuation">[</span> <span class="token operator">OR</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span> &#125;<span class="token keyword">ON</span> table_name<span class="token punctuation">[</span> <span class="token keyword">FROM</span> referenced_table_name <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">FOR</span> <span class="token punctuation">[</span> EACH <span class="token punctuation">]</span> &#123; <span class="token keyword">ROW</span> <span class="token operator">|</span> STATEMENT &#125; <span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token keyword">WHEN</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token keyword">EXECUTE</span> <span class="token keyword">PROCEDURE</span> function_name <span class="token punctuation">(</span> arguments <span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>table_name：触发器所作用的表</li><li>referenced_table_name：主要用于有外键约束的两张表</li><li>function_name：用户提供的函数名</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="根据执行次数"><a href="#根据执行次数" class="headerlink" title="根据执行次数"></a>根据执行次数</h4><p>1、语句级触发器</p><p>关键字<code>FOR EACH STATEMENT</code>声明，在触发器作用的表上执行一条SQL语句时，该触发器只执行一次，即使修改了零行数据的SQL，也会导致相应的触发器执行</p><p>2、行级触发器</p><p>关键字<code>FOR EACH ROW</code>标记，当特定事件导致触发器作用的表的数据发生变化时，每变化一行就会执行一次触发器。</p><h4 id="根据引发的时间"><a href="#根据引发的时间" class="headerlink" title="根据引发的时间"></a>根据引发的时间</h4><p>1、BEFORE触发器</p><p>事件前</p><p>2、AFTER触发器</p><p>事件后</p><p>3、INSTEAD OF 触发器</p><p>当触发事件发生后，数据库管理系统不执行引起事件触发的SQL语句，而执行相应触发器的函数，这类触发器通常定义在视图上</p><h3 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h3><ol><li>NEW：record，该变量为行级触发器中的INSERT/UPDATE操作，保存在新数据行</li><li>OLD：record，该变量为行级触发器中的UPDATE/DELETE操作，保存在旧数据行</li><li>TG_NAME：name，该变量包含实际触发的触发器名称</li><li>TG_WHEN：text，值为BEFORE、AFTER或INSTEAD OF的一个字符串，取决于触发器的定义</li><li>TG_LEVEL：text，值为ROW、STATEMENT的一个字符串，取决于触发器的定义</li><li>TG_OP：text，值为INSERT、UPDTAE、TRUNCATE的一个字符串，它说明触发器由哪个操作引发</li><li>TG_RELID：old，引发触发器调用的表的对象的ID</li><li>TG_RELNAME：name，导致触发器调用的表的名称（将被废弃）</li><li>TG_TABLE_NAME：name，导致触发器调用的表的名称</li><li>TG_TABLE_SCHEMA：name，触发器调用的表的模式名称</li><li>TG_NARGS：integer，在CREATE TRIGGER语句中给触发器过程的参数数量</li><li>TG_ARGV[]：text数组，来自CREATE TRIGGER语句的参数。</li></ol><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TRIGGER</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name <span class="token keyword">ON</span> table_name <span class="token punctuation">[</span> <span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">RESTRICT</span> <span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5、事件触发器"><a href="#5、事件触发器" class="headerlink" title="5、事件触发器"></a>5、事件触发器</h2><p>针对一个特定的数据库的全局触发器，并且可以捕获DDL事件</p><p><strong>三类：</strong></p><ol><li>ddl_command_start：在DDL开始前触发、</li><li>ddl_command_end：在DDL结束后触发</li><li>sql_drop：删除一个数据库对象前被触发，删除的数据库对象的详细信息，可以通过pg_event_trigger_dropped_objects()函数记录下来</li></ol><h4 id="创建事件触发器"><a href="#创建事件触发器" class="headerlink" title="创建事件触发器"></a>创建事件触发器</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> EVENT <span class="token keyword">TRIGGER</span> name<span class="token keyword">ON</span> event<span class="token punctuation">[</span> <span class="token keyword">WHEN</span> filter_variable <span class="token operator">IN</span> <span class="token punctuation">(</span>filter_value <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">[</span> <span class="token operator">AND</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">]</span> <span class="token punctuation">]</span><span class="token keyword">EXECUTE</span> <span class="token keyword">PROCEDURE</span> function_name<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>name：定义的新触发器的名称</li><li>event：触发调用的触发器函数的名称</li><li>filter_variable：筛选事件的变量名称，指定它所支持的触发该触发器的时间子集</li><li>filter_value：可以触发该触发器的filter_variable的值，相关TAG所限定的命令列表</li><li>function_name：用户声明的不带参数的函数，返回event_trigger类型</li></ol><h4 id="支持变量"><a href="#支持变量" class="headerlink" title="支持变量"></a>支持变量</h4><ol><li>tg_event：为ddl_command_start、ddl_command_end、sql_drop之一。</li><li>tg_tag：实际执行的DDL操作，如CREATE TABLE、DROP TABLE等</li></ol><h4 id="删除触发器-1"><a href="#删除触发器-1" class="headerlink" title="删除触发器"></a>删除触发器</h4><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">DROP</span> EVENT <span class="token keyword">TRIGGER</span> <span class="token punctuation">[</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">]</span> name <span class="token punctuation">[</span> <span class="token keyword">CASCADE</span> <span class="token operator">|</span> <span class="token keyword">RESTRICT</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6、游标编程"><a href="#6、游标编程" class="headerlink" title="6、游标编程"></a>6、游标编程</h2><p>游标是一种临时的数据库对象，用来存放从数据库表中查询返回的数据行副本，提供了从包括多条数据记录的结果集中每次提取一条记录的机制，也为逐行处理数据库表中的数据提供了一种新的处理方法</p><h3 id="1、声明游标变量"><a href="#1、声明游标变量" class="headerlink" title="1、声明游标变量"></a>1、声明游标变量</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">curVars1 recfcursor <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>不推荐使用，因为没有绑定查询语句</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">name <span class="token keyword">CURSOR</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token punctuation">]</span> <span class="token keyword">FOR</span> query<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，arguments是传入的参数，query是查询语句</p><h3 id="2、打开游标"><a href="#2、打开游标" class="headerlink" title="2、打开游标"></a>2、打开游标</h3><p>1、open for</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">OPEN</span> unbound_cursor <span class="token keyword">FOR</span> query<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于未绑定的游标变量</p><p>2、open for execute</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">OPEN</span> unbound_cursor <span class="token keyword">FOR</span> EXCUTE query<span class="token operator">-</span>string<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于未绑定的游标变量，可以执行动态查询字符串</p><p>3、open bound_cursor</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">OPEN</span> bound_cursor <span class="token punctuation">[</span> <span class="token punctuation">(</span>argument_values<span class="token punctuation">)</span> <span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用于绑定的游标变量</p><h3 id="3、使用游标"><a href="#3、使用游标" class="headerlink" title="3、使用游标"></a>3、使用游标</h3><p>1、fetch</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">FETCH</span> <span class="token keyword">cursor</span> <span class="token keyword">INTO</span> target<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>从游标中读取下一行记录的数据到目标中</p><p>2、close</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CLOSE</span> cursorName<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h1><p>1、is null判定，不能用 = null</p><p>2、where xxx  [not] in xxx</p><p>3、left/right join 新的理解</p><p>4、执行顺序</p><p><img src="https://s2.loli.net/2022/05/28/s7L5XoPSwYhizTd.png" alt="image-20220528160333659"></p><p>5、union使用</p><p>6、if的使用，if(a,b,c)，a成立则为b，否则为c</p><p>7、group_concat([distinct] 要连接的字段 [order by 排序字段 asc/desc] [separator ‘分隔符’])</p><p>8、left(字段,num)返回左边num个字符</p><p>9、substr(字段,first,end)返回第first到第end个字符</p><p>10、单表联查，select * from table as a,table as b</p><p>11、select distinct Salary from Employee order by Salary desc limit 1,1查找第二高的薪水</p><p>12、dateDiff(日期1，日期2) 返回日期1-日期2</p><p>13、<code>A not in B</code>的原理是拿<code>A</code>表值与<code>B</code>表值做是否不等的比较, 也就是<code>a != b</code>. 在sql中, <code>null</code>是缺失未知值而不是空值(详情请见<a href="https://leetcode.cn/link/?target=https://dev.mysql.com/doc/refman/8.0/en/working-with-null.html">MySQL reference</a>).</p><p>当你判断任意值<code>a != null</code>时, 官方说, “You cannot use arithmetic comparison operators such as =, &lt;, or &lt;&gt; to test for NULL”, 任何与<code>null</code>值的对比都将返回<code>null</code>. 因此返回结果为否,这点可以用代码 <code>select if(1 = null, &#39;true&#39;, &#39;false&#39;)</code>证实.</p><p>14、</p><p>case 语句： case when …. then … when … then … else …end as …</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id<span class="token punctuation">,</span><span class="token keyword">case</span> <span class="token keyword">when</span> p_id <span class="token operator">is</span> <span class="token boolean">null</span> <span class="token keyword">then</span> <span class="token string">"Root"</span>     <span class="token keyword">when</span> id  <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> p_id <span class="token keyword">from</span> tree<span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token string">"Inner"</span>     <span class="token keyword">else</span> <span class="token string">"Leaf"</span><span class="token keyword">end</span> <span class="token keyword">as</span> <span class="token keyword">Type</span> <span class="token keyword">from</span> tree<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>15、</p><p>sum(xxx)，返回满足条件的总数</p>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2023/02281079.html"/>
      <url>/2023/02281079.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux结构"><a href="#Linux结构" class="headerlink" title="Linux结构"></a>Linux结构</h1><img src="https://s2.loli.net/2022/04/10/f4bjWYcFtByv6eS.png" alt="image-20220410145624703" style="zoom:67%;" /><p><strong>进程调度子系统</strong></p><p>功能：</p><ul><li>决定CPU的归属</li><li>处理中断，将其发送给合适的子系统</li><li>发送信号给用户进程</li><li>管理定时器</li><li>支持模块动态装入</li></ul><p><strong>内存管理子系统</strong></p><p>功能：</p><ul><li>扩大地址空间</li><li>进程保护</li><li>内存映射</li><li>实现虚存</li></ul><h1 id="一、操作系统引论"><a href="#一、操作系统引论" class="headerlink" title="一、操作系统引论"></a>一、操作系统引论</h1><img src="https://s2.loli.net/2022/04/10/xX2it5IvjpWhgHC.png" alt="image-20220410150944601" style="zoom:67%;" /><h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p><strong>特性：</strong>自动性、顺序性、单道性</p><p><strong>优点：</strong>减少人工操作，解决了作业的自动接续。</p><p><strong>缺点：</strong></p><ul><li>资源利用率不高：CPU，内存</li><li>平均周转时间长</li><li>没有交互能力</li></ul><img src="https://s2.loli.net/2022/04/10/FoIlKp95S7dhRDj.png" alt="image-20220410152047886" style="zoom:67%;" /><h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p>同时驻留多个作业</p><p><strong>优点：</strong></p><ul><li>提高CPU利用率</li><li>提高内存和I/O设备的利用率</li><li>提高了系统吞吐量</li></ul><p><strong>缺点：</strong></p><ul><li>资源利用率高</li><li>系统吞吐量大</li><li>平均周转时间长</li><li>无交互能力</li></ul><img src="https://s2.loli.net/2022/04/10/HFQ8DIWyMETR6Yh.png" alt="image-20220410152926183" style="zoom:67%;" /><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p><strong>指一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户共享主机中的资源，各个用户都可通过自己的终端以交互方式使用计算机</strong></p><p>类型：</p><ul><li>单道分时系统</li><li>具有前、后台的分时系统</li><li>多道分时系统</li></ul><p>特征：</p><ul><li>多路性</li><li>独立性</li><li>及时性</li><li>交互性</li></ul><p>典型系统：MIT、<strong>UNIX</strong>、<strong>Linux</strong></p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>及时处理</p><p>实时任务类型：</p><p>按程序运行是否呈现周期性：</p><ul><li>周期性</li><li>非周期性</li></ul><p>根据对截止时间的要求来划分：</p><ul><li>硬实时任务</li><li>软实时任务</li></ul><p><strong>实时 vs 分时</strong></p><ul><li>多路性：相同</li><li>独立性：相同</li><li>及时性：实时系统要求更高</li><li>交互性：分时系统要求更高</li><li>可靠性：实时系统要求更高</li></ul><h2 id="微机操作系统"><a href="#微机操作系统" class="headerlink" title="微机操作系统"></a>微机操作系统</h2><p>单用户单任务操作系统：CP/M，<strong>MS-DOS</strong></p><p>单用户多任务操作系统：Windows（不会Server版）</p><p>多用户多任务操作系统：<strong>Unix</strong>、Solaris、<strong>Linux</strong></p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h3><ul><li>并发性</li><li>共享性：互斥共享、同时访问</li><li>虚拟性：时分复用：虚拟处理机技术/虚拟设备技术、空分复用：虚拟存储</li><li>异步性</li></ul><p><strong>并发和共享是最基本的特征</strong></p><blockquote><p>并发：指两个或多个事件在<strong>同一时间间隔</strong>内发生</p><p>并行：指两个或多个事件在<strong>同一时刻</strong>发生</p></blockquote><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>方便用户使用的用户接口</li></ol><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><p>1、整体式操作系统：Linux</p><p>2、模块化操作系统：</p><p>提升了<strong>易维护性、开发效率、适应性</strong>；没有提升运行效率</p><p>3、分层式操作系统</p><p>易于验证新开发功能的正确性</p><h2 id="微内核操作系统结构"><a href="#微内核操作系统结构" class="headerlink" title="微内核操作系统结构"></a>微内核操作系统结构</h2><p>优点：</p><ul><li>提高了<strong>可扩展性</strong></li><li>增强了<strong>可靠性</strong></li><li><strong>可移植性</strong>强</li><li>提供了对<strong>分布式</strong>系统的支持</li><li>融入了<strong>面向对象</strong>技术</li></ul><p>问题：</p><ul><li>性能代价</li></ul><h2 id="做题"><a href="#做题" class="headerlink" title="做题"></a>做题</h2><p>1、在OS中为实现多道程序设计需要有<strong>更大的内存</strong></p><p>2、推动微机OS发展的主要动力是<strong>计算机硬件的不断更新换代</strong></p><p>3、在多道批处理系统中，为了充分利用各种资源，系统总是优先选择<strong>计算型和I/O型均衡的</strong>的多个作业投入运行</p><p>4、在分时系统中，为使多个用户能够同时与系统交互，最关键的问题是<strong>能在一较短的时间内，使所有用户程序都得到运行</strong></p><p>5、分时系统和实时系统都具有交互性，实时系统的交互性允许用户访问<strong>专用服务程序</strong>，分时系统的交互性运行用户请求系统提供<strong>多方面的服务</strong></p><p>6、<strong>中断处理模块</strong>是必须包含在操作系统内核中的模块</p><h1 id="二、进程描述与控制"><a href="#二、进程描述与控制" class="headerlink" title="二、进程描述与控制"></a>二、进程描述与控制</h1><h2 id="1、前趋图"><a href="#1、前趋图" class="headerlink" title="1、前趋图"></a>1、前趋图</h2><p><strong>描述进程之间执行的前后关系</strong></p><img src="https://s2.loli.net/2022/04/10/7gPO8sYCDQeAyN2.png" alt="image-20220410161510200" style="zoom:67%;" /><p><strong>顺序执行：</strong>顺序性、封闭性、可再现性</p><p><strong>并发执行：</strong>间断性、失去封闭性、不可再现性</p><h2 id="2、进程"><a href="#2、进程" class="headerlink" title="2、进程"></a>2、进程</h2><h3 id="引入原因"><a href="#引入原因" class="headerlink" title="引入原因"></a>引入原因</h3><p>为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>进程映像：<strong>程序段、数据段和PCB</strong></p><p>PCB（Process Controll Block）:进程控制块，用与描述进程的基本情况和活动过程，进而控制和管理进程</p><blockquote><p>创建进程就是创建进程实体中的PCB</p><p>撤销进程就是撤销进程实体中的PCB</p></blockquote><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>动态性：最基本特征</li><li>并发性</li><li>独立性</li><li>异步性</li></ul><p>操作系统的<strong>并发性和异步性</strong>特征来自进程的特征</p><h3 id="基本状态"><a href="#基本状态" class="headerlink" title="基本状态"></a>基本状态</h3><p>就绪状态、执行状态、堵塞状态</p><img src="https://s2.loli.net/2022/04/10/enlkhKL3wHJA19C.png" alt="image-20220410163438759" style="zoom:67%;" /><p>在单CPU的主机上，有N个进程</p><p>最大就绪进程数为N-1</p><p>最大运行进程数为1</p><p>最大阻塞进程数为N</p><h3 id="创建和终止状态"><a href="#创建和终止状态" class="headerlink" title="创建和终止状态"></a>创建和终止状态</h3><p>创建状态：未完成创建的进程不能被调度</p><p>终止状态：</p><ul><li>1、等待进程终止的善后处理；2、撤销进程的PCB</li><li>避免再被调度</li></ul><img src="https://s2.loli.net/2022/04/10/IzAMFj5evQkELXh.png" alt="image-20220410164039998" style="zoom:67%;" /><h3 id="挂起状态"><a href="#挂起状态" class="headerlink" title="挂起状态"></a>挂起状态</h3><p>使执行的进程暂停执行，静止下来，使就绪状态的进程暂不接受调度</p><p>原因：</p><ul><li>终端用户的请求</li><li>父进程的请求</li><li>负荷调节的需要。当实时系统中的工作负荷较重，把一些不重要的进程挂起，以保证系统能正常运行。</li><li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li></ul><img src="https://s2.loli.net/2022/04/10/mdYkNwJ6gcXRKFM.png" alt="image-20220410164511250" style="zoom:67%;" /><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>1、用于管理控制的数据结构</p><p>四大表：内存表、设备表、文件表、进程表</p><p>2、PCB作用</p><p>提供进程<strong>管理和调度</strong>所需的信息，实现与其他进程的<strong>同步和通信</strong></p><p><strong>PCB是进程存在的唯一标志</strong></p><h3 id="PCB中的信息"><a href="#PCB中的信息" class="headerlink" title="PCB中的信息"></a>PCB中的信息</h3><p><strong>（1）进程标识符</strong></p><ul><li>内部标识符：唯一，系统使用</li><li>外部标识符：创建者提供，用户使用</li></ul><p><strong>（2）处理机状态</strong></p><ul><li>通用寄存器</li><li>指令计数器</li><li>程序状态字PSW</li><li>用户栈指针</li></ul><p><strong>中断和进程切换所需要保护的内容</strong></p><p><strong>（3）进程调度信息</strong></p><ul><li>进程状态</li><li>进程优先级</li><li>进程调度所需要的其他信息：如进程已等待CPU的时间总和</li><li>事件</li></ul><p><strong>（4）进程控制信息</strong></p><ul><li>程序和数据的地址</li><li>进程同步和通信机制</li><li>资源清单</li><li>链接指针</li></ul><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul><li>线性</li><li>链接</li><li>索引</li></ul><h2 id="3、进程控制"><a href="#3、进程控制" class="headerlink" title="3、进程控制"></a>3、进程控制</h2><h3 id="操作系统内核"><a href="#操作系统内核" class="headerlink" title="操作系统内核"></a>操作系统内核</h3><blockquote><p><strong>处理机的执行态</strong></p><ul><li>系统态/管态/内核态</li><li>用户态/目态</li></ul></blockquote><p><strong>内核功能：</strong></p><p>（1）支撑功能</p><ul><li>中断处理</li><li>时钟管理</li><li>原语操作</li></ul><p>（2）资源管理操作</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul><blockquote><p><strong>原语：</strong>由若干条指令组成，用于完成一定功能的一个过程，并在执行中不可分割</p><p>操作系统内核的功能大都通过执行各种原语实现</p><p><strong>原子操作：</strong>在一个操作中的所有动作，要么全做，要么全不做</p><p>在单机系统中采用<strong>屏蔽中断</strong>的方式来保证操作的原子性</p></blockquote><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>进程的层次结构</p><ul><li>创建形成的父子进程关系</li><li>子进程继承父进程的资源</li><li>父进程终止会导致子进程终止</li><li>PCB中记录家族关系</li><li>Windows中没有进程层次关系</li></ul><p>进程图</p><img src="https://s2.loli.net/2022/04/10/NYH1DzUKTMS5R9a.png" alt="image-20220410174654636" style="zoom:67%;" /><p><strong>创建进程的事件</strong></p><ol><li>用户登录</li><li>作业调度</li><li>提供服务</li><li>应用请求</li></ol><p>fork()：复制父进程全部资源</p><p>clone()：有选择的复制父进程资源</p><p>Vfork()：创建线程。复制除task_struct和系统空间堆栈外的所有资源</p><blockquote><p>fork()函数</p><p>失败返回负值</p><p>成功：</p><ul><li>父进程返回创建子进程的ID</li><li>子进程返回0</li></ul></blockquote><h3 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h3><p>引起进程终止的三类事件</p><ol><li><p>正常结束</p><p>return：结束函数的执行</p><p>exit：先进行清除工作，再进入内核</p><p>_exit：立刻进入内核</p></li><li><p>异常结束</p><p>调用abort函数</p><p>收到某个信号使程序终止</p></li><li><p>外界干预</p></li></ol><h3 id="进程阻塞和唤醒"><a href="#进程阻塞和唤醒" class="headerlink" title="进程阻塞和唤醒"></a>进程阻塞和唤醒</h3><p>引起阻塞和唤醒的事件</p><ol><li>请求系统服务而得不到满足</li><li>启动某种操作而需同步时</li><li>新数据尚未到达</li><li>无新工作可做</li></ol><p>唤醒原语流程：</p><p>首先把被阻塞的进程从该等待事件的阻塞队列中移出，将其PCB中的现行状态由<strong>阻塞改为就绪</strong></p><p>然后再将该PCB插入到<strong>就绪队列</strong>中</p><h3 id="进程挂起与激活"><a href="#进程挂起与激活" class="headerlink" title="进程挂起与激活"></a>进程挂起与激活</h3><p>挂起：</p><ul><li>活动就绪-&gt;静止就绪</li><li>活动阻塞-&gt;静止阻塞</li></ul><p>激活：</p><ul><li>静止就绪-&gt;活动就绪</li><li>静止阻塞-&gt;活动阻塞</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>进程调度：把处理机分配给不同的进程占用执行</p><p>调度程序：实现分配处理机的程序</p><p>进程的上下文：进程切换时要保护执行现场</p><h2 id="4、进程同步"><a href="#4、进程同步" class="headerlink" title="4、进程同步"></a>4、进程同步</h2><ul><li><strong>硬件同步机制</strong></li><li><strong>信号量机制</strong></li><li><strong>管程机制</strong></li><li><strong>经典同步问题</strong></li></ul><p>资源的<strong>共享和协作</strong>导致相关进程间形成制约</p><p>例一：银行储蓄问题</p><p>例二：<strong>生产者消费者问题</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>     产生数据到临时变量nextp；      ……<span class="token punctuation">.</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span> n <span class="token punctuation">)</span> <span class="token punctuation">;</span>      buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>      in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>      counter<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>counter <span class="token operator">==</span>  <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>         out <span class="token operator">=</span> <span class="token punctuation">(</span>out <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span>n<span class="token punctuation">;</span>         counter<span class="token operator">--</span><span class="token punctuation">;</span>          消费取出的数据；      <span class="token punctuation">&#125;</span>；<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>问题 ：</strong>没有对counter进行并发访问控制</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>各个进程要保证互斥的进入自己的临界区，从而实现临界资源的访问</p><h3 id="同步机制的准则（重要）"><a href="#同步机制的准则（重要）" class="headerlink" title="同步机制的准则（重要）"></a>同步机制的准则（重要）</h3><ol><li><strong>空闲让进</strong>：如果临界区空闲，则只要有进程申请就立即让其进入，以有效利用资源</li><li><strong>忙则等待</strong>：每次仅允许一个进程处于临界区，保证对临界资源的“互斥”访问</li><li><strong>有限等待</strong>：进程只能在临界区内逗留有限时间，不得让其他进程在临界区外陷入“死等”</li><li><strong>让权等待</strong>：进程不能进入临界区时，应立即释放处理机，以免陷入“忙等状态</li></ol><h3 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h3><blockquote><p>软件方法始终不能解决“忙等”现象，降低系统效率，同时很难控制多个进程的互斥</p></blockquote><p><strong>1、关中断</strong></p><ul><li>影响效率</li><li>不能保证互斥同步</li></ul><p><strong>2、Test-and-Set指令和Swap指令</strong></p><p>本质：确保对锁的检测和关锁操作的原子性</p><p>Test-and-Set</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">boolean <span class="token function">TS</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>lock<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    boolean old <span class="token operator">=</span> <span class="token operator">*</span>lock<span class="token punctuation">;</span>    lock <span class="token operator">=</span> TRUE<span class="token punctuation">;</span>    <span class="token keyword">return</span> old<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">while</span> <span class="token function">TS</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>    临界区    lock <span class="token operator">=</span> FALSE<span class="token punctuation">;</span>    其他区域<span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Swap</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    boolean key<span class="token operator">=</span>TRUE<span class="token punctuation">;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span><span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>key<span class="token operator">!=</span>FALSE<span class="token punctuation">)</span><span class="token punctuation">;</span>    临界区    lock<span class="token operator">=</span>FALSE<span class="token punctuation">;</span>    其他区域<span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>本质：lock是真死循环，lock是否跳出循环，最后都要置lock为否</strong></p></blockquote><p>缺点：</p><ul><li>忙等</li><li>饥饿现象</li><li>死锁</li></ul><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><h4 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h4><p><strong>P操作/Wait(s):</strong><code>while s&lt;=0; s=s-1</code></p><p><strong>V操作/Signal(s):</strong><code>s=s+1</code></p><p>未遵循让权等待原则</p><h4 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">process_controll_block</span> <span class="token operator">*</span>list<span class="token punctuation">;</span><span class="token punctuation">&#125;</span>semaphore<span class="token punctuation">;</span><span class="token function">wait</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    S<span class="token operator">-></span>vlaue<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    S<span class="token operator">-></span>value <span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token operator">-></span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-></span>list<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>s.value初值：表示系统中某类资源的数目</p><p>s.value&lt;0：表示信号量链表中已阻塞进程的数目</p><ul><li><strong>资源信号量：</strong>用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数</li><li><strong>互斥信号量：</strong>用于申请或释放资源的使用权，常初始化为1</li></ul><p>资源信号量和互斥信号量使用相同的底层机制</p><h4 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h4><p>要么全分配，要么一个也不分配</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">Swait</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>Si<span class="token operator">>=</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&amp;&amp;</span> Sn<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> Si<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">else</span><span class="token punctuation">&#123;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">Ssignal</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>sn<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            Si<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="信号集量"><a href="#信号集量" class="headerlink" title="信号集量"></a>信号集量</h4><p>为提高效率而对AND信号的补充（略）</p><h3 id="信号量应用"><a href="#信号量应用" class="headerlink" title="信号量应用"></a>信号量应用</h3><ul><li>实现进程互斥</li><li>实现前趋关系</li></ul><h3 id="管程机制"><a href="#管程机制" class="headerlink" title="管程机制"></a>管程机制</h3><p><strong>一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据</strong></p><p>特点：</p><ol><li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li><li>一个进程通过调用管程的一个过程进入管程</li><li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被挂起，以等待管程变成可用的。 从而实现进程互斥。</li></ol><p>同步工具：<strong>条件变量</strong></p><p>管程通过使用条件变量提供对同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问 ，每个条件维护一个链表</p><p>①x.wait：调用进程的执行在条件x上挂起，插入x等待队列，并释放管程给另一个进程使用。</p><p>②x.signal：恢复在x条件挂起的进程的执行。如果有多个这样的进程，选择其中一个；如果没有这样的进程，什么也不做。</p><h2 id="5、经典进程同步问题"><a href="#5、经典进程同步问题" class="headerlink" title="5、经典进程同步问题"></a>5、经典进程同步问题</h2><h3 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h3><h4 id="（1）记录型信号量"><a href="#（1）记录型信号量" class="headerlink" title="（1）记录型信号量"></a>（1）记录型信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>empty<span class="token operator">=</span>n<span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        producer an item nextp<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">wait</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//empty缓冲区为空的数量</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>        in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//full缓冲区为满的数量</span>        <span class="token function">wait</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>        out <span class="token operator">=</span> <span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer the item in nextc<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>进程应该先申请资源信号量，再申请互斥信号量</li><li>对任何信号量的wait与signal操作必须配对。</li><li>对同一个资源信号量的wait与signal可以不在同一个进程中</li></ol><h4 id="（2）AND信号量"><a href="#（2）AND信号量" class="headerlink" title="（2）AND信号量"></a>（2）AND信号量</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> in<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>item buffer<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>semaphore mutex<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span>empty<span class="token operator">=</span>n<span class="token punctuation">,</span>full<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        producer an item nextp<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">Swait</span><span class="token punctuation">(</span>empty<span class="token punctuation">,</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        buffer<span class="token punctuation">[</span>in<span class="token punctuation">]</span> <span class="token operator">=</span> nextp<span class="token punctuation">;</span>        in<span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>        <span class="token function">Ssignal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token function">Swait</span><span class="token punctuation">(</span>full<span class="token punctuation">,</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        nextc <span class="token operator">=</span> buffer<span class="token punctuation">[</span>out<span class="token punctuation">]</span><span class="token punctuation">;</span>        out <span class="token operator">=</span> <span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>n<span class="token punctuation">;</span>        <span class="token function">Ssignal</span><span class="token punctuation">(</span>mutex<span class="token punctuation">,</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer the item in nextc<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>True<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="（3）管程"><a href="#（3）管程" class="headerlink" title="（3）管程"></a>（3）管程</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c">Procedure entry <span class="token function">put</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>begin  <span class="token keyword">if</span> count ≥n then notfull<span class="token punctuation">.</span>wait<span class="token punctuation">;</span>    <span class="token function">buffer</span><span class="token punctuation">(</span>in<span class="token punctuation">)</span><span class="token operator">:</span><span class="token operator">=</span>nextp<span class="token punctuation">;</span>    in<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span>in<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod n    count<span class="token operator">:</span><span class="token operator">=</span>count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> notempty<span class="token punctuation">.</span>queue then notempty<span class="token punctuation">.</span>signal<span class="token punctuation">;</span>endProcedure entry <span class="token function">get</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>begin  <span class="token keyword">if</span> count ≤ <span class="token number">0</span> then notempty<span class="token punctuation">.</span>wait<span class="token punctuation">;</span>    nextc<span class="token operator">:</span><span class="token operator">=</span><span class="token function">buffer</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">;</span>    out<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span>out<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod n    count<span class="token operator">:</span><span class="token operator">=</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> notfull<span class="token punctuation">.</span>queue then notfull<span class="token punctuation">.</span>signal<span class="token punctuation">;</span>endBegin in<span class="token operator">:</span><span class="token operator">=</span>out<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> count<span class="token operator">:</span><span class="token operator">=</span><span class="token number">0</span> end<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>记录型信号量</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span><span class="token punctuation">&#123;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">wait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    …   <span class="token comment">//eat</span>    …   <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token function">signal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    …   <span class="token comment">//think;</span>    …<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Q：死锁</p><p>A：仅当哲学家的左右两只筷子同时可以时才允许他拿起筷子</p><p><strong>AND信号量</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Var chopstick<span class="token operator">:</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> …<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span> of semaphore<span class="token operator">:</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>processiRepeat   think<span class="token punctuation">;</span>   <span class="token function">Sswait</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    eat    <span class="token function">Ssignal</span><span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>mod <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Until false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="读写者问题"><a href="#读写者问题" class="headerlink" title="读写者问题"></a>读写者问题</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">semphore rmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>wmutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>nt readcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">//如果有人在读则说明绝对不在写，因此只有没人在读时需要判断是否在写</span>            <span class="token function">wait</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//保证第一个读进程来，写进程就不能进行</span>        readcount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        perform read operation        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token function">wait</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>readcount <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token punctuation">&#123;</span>            <span class="token function">signal</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>rmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">do</span><span class="token punctuation">&#123;</span>        <span class="token function">wait</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>        perform write operation<span class="token punctuation">;</span>        <span class="token function">signal</span><span class="token punctuation">(</span>wmutex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">while</span><span class="token punctuation">(</span>TRUE<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6、进程的通信"><a href="#6、进程的通信" class="headerlink" title="6、进程的通信"></a>6、进程的通信</h2><h2 id="7、线程的基本概念"><a href="#7、线程的基本概念" class="headerlink" title="7、线程的基本概念"></a>7、线程的基本概念</h2><p><strong>线程是资源调度和分派的基本单位</strong></p><ul><li>进程的终止或挂起会导致进程中的所有线程的终止或线程</li><li>进程比线程有更好的独立性</li><li>进程中的所有线程共享该进程的状态和资源</li><li>线程阻塞不一定引起进程阻塞（系统调用进入核心态时，若线程阻塞则其所在进程也会被阻塞）</li><li>同一进程中的线程切换不会引起进程切换，在不同进程中的线程切换会引起进程切换</li></ul><p><strong>线程状态变化的4种基本操作：</strong></p><ol><li>派生</li><li>阻塞</li><li>解除阻塞</li><li>结束</li></ol><p><strong>线程控制块：</strong></p><p>线程标识符、一组寄存器、线程运行状态、优先级、专有存储区、用户栈、信号屏蔽</p><blockquote><p>线程运行状态不是线程的上下文</p></blockquote><h2 id="8、做题"><a href="#8、做题" class="headerlink" title="8、做题"></a>8、做题</h2><p>1、某进程所要求的一次打印输出结束，该进程被<strong>唤醒</strong>，其进程的状态将从<strong>阻塞到就绪</strong></p><p>2、在批处理系统中，导致进程创建的典型事件是<strong>作业调度</strong></p><p>3、由系统专门为运行中的应用进程创建新进程的事件是<strong>提供服务</strong></p><p>4、wait,signal操作可以解决一切互斥问题</p><h1 id="三、处理机调度和死锁"><a href="#三、处理机调度和死锁" class="headerlink" title="三、处理机调度和死锁"></a>三、处理机调度和死锁</h1><h2 id="1、一些基本概念"><a href="#1、一些基本概念" class="headerlink" title="1、一些基本概念"></a>1、一些基本概念</h2><table><thead><tr><th>层次</th><th>别名</th><th>对象</th><th>功能</th><th>频度</th><th>实现者</th><th>应用范围</th></tr></thead><tbody><tr><td>高级</td><td>作业调度、长程调度、接纳调度</td><td>作业</td><td>决定外存作业上处于后备队列中的哪几个作业调入内存，创建进程，分配资源，插入就绪队列</td><td>最低，分钟级</td><td>作业管理程序</td><td>批处理系统</td></tr><tr><td>中级</td><td>内存调度</td><td>挂起的进程</td><td>把外存上那些已经具备运行条件的就绪进程重新载入内存（从静止就绪到活动就绪），将暂时不能运行的进程调至外存等待</td><td>中等</td><td>内存管理中的对换进程</td><td>具有对换功能的操作系统</td></tr><tr><td>低级</td><td>进程调度、短程调度</td><td>就绪进程/内核进程</td><td>决定就绪队列中的哪个进程应获得处理机，并将处理机分配给选中的进程</td><td>最频繁，毫秒级</td><td>分派程序</td><td>都有</td></tr></tbody></table><p>CPU利用率 = CPU的有效工作时间/（CPU有效工作时间+ CPU空闲等待时间）</p><p><strong>周转时间：接纳等待、执行等待、执行时间、I/O时间</strong></p><p>面向用户的准则：<strong>平均周转时间</strong></p><p><strong>带权周转时间</strong>：作业的周转时间T与系统为它服务的时间（执行加IO）之比  （必定&gt;1）</p><p>吞吐量：单位时间内系统完成的作业数</p><p>响应时间：输入时间、处理时间、显示时间  </p><p>响应时间快：分时系统的重要准则</p><h2 id="2、作业与作业调度"><a href="#2、作业与作业调度" class="headerlink" title="2、作业与作业调度"></a>2、作业与作业调度</h2><p>作业管理系统用于管理和控制作业运行的数据结构</p><h3 id="先来先服务算法FCFS"><a href="#先来先服务算法FCFS" class="headerlink" title="先来先服务算法FCFS"></a>先来先服务算法FCFS</h3><p>first come fist serve</p><p>每次调度从就绪队列中选择一个最先进入该队列的进程</p><h3 id="短作业优先算法SJF"><a href="#短作业优先算法SJF" class="headerlink" title="短作业优先算法SJF"></a>短作业优先算法SJF</h3><p>shortest job first</p><p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p><h3 id="优先级调度算法PSA"><a href="#优先级调度算法PSA" class="headerlink" title="优先级调度算法PSA"></a>优先级调度算法PSA</h3><p>Priority-scheduling algorithm</p><p>外部赋予作业（进程）相应的优先级，例如以作业的紧迫程度作为优先级</p><h3 id="高响应比优先调度算法HRRN"><a href="#高响应比优先调度算法HRRN" class="headerlink" title="高响应比优先调度算法HRRN"></a>高响应比优先调度算法HRRN</h3><p>Highest   Response   Ratio   Next</p><p>赋予作业动态优先级，优先级随作业等待时间延长而增加，从而使长作业的优先级在等待期间不断增加。</p><p>优先权=（等待时间+要求服务时间）/要求服务时间</p><p>在作业完成时以及新作业到达时计算响应比</p><p><strong>不用于进程</strong></p><h2 id="3、进程调度"><a href="#3、进程调度" class="headerlink" title="3、进程调度"></a>3、进程调度</h2><p>抢占式</p><p>非抢占式</p><h3 id="轮转调度算法（抢占式）"><a href="#轮转调度算法（抢占式）" class="headerlink" title="轮转调度算法（抢占式）"></a>轮转调度算法（抢占式）</h3><ul><li>每个进程仅运行一个时间片即被强占CPU</li><li>原理：FCFS策略+时钟中断+时间片原则</li><li>切换时机：时间片内进程结束，进程结束事件激活进程调度，新进程可运行一个时间片；时间片用完，时钟中断激活调度，旧进程到就绪队列尾，队头进程投入运行一个时间片</li></ul><p>时间片大小默认为100ms</p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><p>静态优先权</p><p>动态优先权：响应比Rp = （等待时间+服务时间）/服务时间</p><h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><ul><li>设置多个就绪队列，并为各个队列赋予不同的优先级。</li><li>优先级愈高的队列的进程的执行时间片就愈小。</li><li>新进程首先进入最高优先级的队列。每个队列采用FCFS算法。队列中的进程运行一个时间片后未结束则降级排到下一个队列的末尾。最低优先权队列中的进程则按RR方式运行。</li><li>按队列优先级调度。只有比队列的优先级高的队列均空时，才运行该队列中的进程。</li></ul><p><strong>未执行完时间片的进程被抢占后应不降级，到队列末尾</strong></p><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol><li>保证调度算法：如N个进程平均分配时间</li><li>公平分享调度算法：按照用户数量平均分配时间</li></ol><h2 id="4、实时系统与实时任务调度"><a href="#4、实时系统与实时任务调度" class="headerlink" title="4、实时系统与实时任务调度"></a>4、实时系统与实时任务调度</h2><p><img src="https://s2.loli.net/2022/04/14/vaCTKStoruB7JZ5.png" alt="image-20220414212457224"></p><h3 id="最早截止时间优先算法（EDF）"><a href="#最早截止时间优先算法（EDF）" class="headerlink" title="最早截止时间优先算法（EDF）"></a>最早截止时间优先算法（EDF）</h3><p>Earliest Deadline First</p><p>具有最早截止时间的任务排在队列的最前面</p><h3 id="最低松弛度优先算法（LLF）"><a href="#最低松弛度优先算法（LLF）" class="headerlink" title="最低松弛度优先算法（LLF）"></a>最低松弛度优先算法（LLF）</h3><p>Least Laxity First</p><p>松弛度=完成截止时间-剩余运行时间-当前时间</p><p>松弛度最小的任务排在队列最前面</p><h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>存在高中低三个优先级的进程，高和低共享同一个临界资源，低优先级进程先进入临界区，阻止高优先级进程进入临界区，中优先级进程抢占低优先级进程的CPU，使得低优先级进程无法从临界区退出，从而间接阻止更高优先级进程运行。</p><p>解决办法：优先级继承</p><h2 id="5、死锁"><a href="#5、死锁" class="headerlink" title="5、死锁"></a>5、死锁</h2><p>死锁：多个进程在运行过程中因争夺资源而造成的一种僵局</p><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的</p><h3 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h3><ol><li>竞争资源</li><li>进程间推进顺序非法</li></ol><h3 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h3><ol><li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用 。</li><li><strong>请求和保持条件</strong>：指进程已经保持了至少一个资源，但又提出了新的资源请求 。 </li><li><strong>不剥夺条件</strong>：进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链 。（充要条件）</li></ol><h3 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h3><ol><li>预防死锁：预防2,3,4条件</li><li>避免死锁</li><li>检测死锁</li><li>解除死锁</li></ol><p>请求保持：资源的预分配</p><p>不剥夺条件：死锁时把保持的资源释放</p><p>循环等待：资源有序分配</p><h2 id="6、避免死锁"><a href="#6、避免死锁" class="headerlink" title="6、避免死锁"></a>6、避免死锁</h2><p>安全状态：没有死锁的状态</p><p>非安全状态：可能有死锁的状态</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>当一个进程申请使用资源的时候，银行家算法通过先 <strong>试探</strong> 分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待。</p><p>避免死锁的限制条件：</p><ul><li>预先必须声明每个进程需要的资源总量</li><li>进程之间相互独立，其执行顺序取决于系统安全，而非进程间的同步要求</li><li>系统必须提供固定数量的资源供进程使用</li></ul><blockquote><p>n个进程共享m个同种资源，若每个进程都需要该类资源，而且各进程对该类资源的最大需求量之和小于m+n，说明该系统不会因竞争该类资源而死锁</p></blockquote><h3 id="死锁检测算法"><a href="#死锁检测算法" class="headerlink" title="死锁检测算法"></a>死锁检测算法</h3><p><strong>资源分配图：</strong></p><p><img src="https://s2.loli.net/2022/04/14/1TLuN4AEnVP6Hsd.png" alt="image-20220414222643886"></p><p>若能消去资源分配图中所有结点的连接边，使全部结点都成为孤立结点，则称该图是可完全简化图；若不能使该图完全简化，则称该图是不可完全化简图。</p><h3 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h3><p>（1）剥夺资源</p><p>（2）撤销进程（最简单常用）</p><h2 id="7、做题"><a href="#7、做题" class="headerlink" title="7、做题"></a>7、做题</h2><p>1、<strong>截止时间的保证</strong>是选择实时调度算法的重要准则，<strong>响应时间快</strong>是选择分时系统中进程调度算法的重要准则</p><p>2、<strong>FCFS</strong>只能采用非抢占式调度，<strong>时间片轮转</strong>只能采用抢占调度</p><p>3、为了实现人机交互采用<strong>时间片轮转法</strong>，为了兼顾短作业和长时间等待作业，采用<strong>高响应比优先</strong>，为了使作业的平均周转时间最短，应采用<strong>短作业优先算法</strong></p><p>4、最容易引起进程长期等待的是<strong>抢占式静态优先权优先算法</strong></p><p>5、<strong>有新进程进入就绪队列</strong>不是引起操作系统选择新进程的直接原因</p><p>6、产生死锁的基本原因是<strong>系统资源不足</strong>和<strong>进程推进顺序不当</strong></p><p>7、在多道程序的环境中，不会因竞争<strong>可被抢占的资源</strong>而产生死锁</p><h1 id="四、存储器管理"><a href="#四、存储器管理" class="headerlink" title="四、存储器管理"></a>四、存储器管理</h1><h2 id="1、存储系统结构"><a href="#1、存储系统结构" class="headerlink" title="1、存储系统结构"></a>1、存储系统结构</h2><p><img src="https://s2.loli.net/2022/06/02/KG2rnXfhN7SEspu.png" alt="image-20220602185202370"></p><ul><li>寄存器、高速缓存、主存储器、磁盘缓存：属于操作系统存储管理的管辖范畴，掉电后存储信息不再存在</li><li>磁盘、可移动存储介质：设备管理和文件系统的管辖范畴，存储信息长期保存</li></ul><blockquote><p>高速缓存能有效提升指令访问内存的原因：<strong>程序执行的局部性原理</strong></p><p>参与指令执行的存储器：<strong>寄存器、高速缓存、内存</strong></p></blockquote><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>逻辑地址（相对地址、虚地址）</li><li>物理地址（绝对地址、实地址）</li><li>名空间： 一个用高级语言编制的源程序，我们说它存在于由程序员建立的符号名字空间（简称名空间）</li><li>地址空间：程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。</li><li>存储空间：主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。</li></ol><p><img src="https://s2.loli.net/2022/06/02/KiVhbq6vLTm1FoW.png" alt="image-20220602190927329"></p><ul><li>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。</li><li>一个作业在编译、装入前后存在于不同的空间。</li></ul><p><img src="https://s2.loli.net/2022/06/02/67f8rDHbLMGzJcK.png" alt="image-20220602191156473"></p><p>编辑—编译—链接—装入—运行</p><h2 id="2、程序的装入和链接"><a href="#2、程序的装入和链接" class="headerlink" title="2、程序的装入和链接"></a>2、程序的装入和链接</h2><h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>编译时即产生实际存储地址的目标代码，程序中的逻辑地址与实际内存地址完全相同</p><p>通常采用符号地址，编译或汇编时再将符号地址转换为绝对地址（转换在链接时候进行）  </p><p>缺点：只能将目标模块装入到内存中实现指定的位置，这只适用于单道程序环境</p><h4 id="可重定位装入方式"><a href="#可重定位装入方式" class="headerlink" title="可重定位装入方式"></a>可重定位装入方式</h4><p>装入内存时，相对地址需要做出修改得到正确的物理地址</p><p>静态重定位：物理地址=相对地址+内存中的起始地址，地址变换在装入内存时一次完成，且以后不能移动</p><h4 id="动态运行时的装入方式"><a href="#动态运行时的装入方式" class="headerlink" title="动态运行时的装入方式"></a>动态运行时的装入方式</h4><p>动态重定位：装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序执行时进行。即在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换</p><p>利用<strong>重定位寄存器</strong>实现：值由进程调度根据作业分配到的存储空间起始地址来设定的，将有效地址与重定位寄存器中的内容相加后得到的值作为访问主存的地址</p><h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p><p>根据<strong>链接时间的不同</strong>，可把链接分成三种</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。</p><p>解决问题：</p><ul><li>修改相对地址</li><li>变换外部调用符号</li></ul><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>在装入内存时再链接需要的其他模块</p><p>优点：</p><ul><li>便于对目标模块进行修改和更新</li><li>实现了对目标模块共享</li></ul><p><img src="https://s2.loli.net/2022/06/02/b6FsKGw5vE4ByPV.png" alt="image-20220602212609976"></p><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>在执行过程中，若发现一个被调用的模块尚未装入内存时，由操作系统去找到该模块，将它装入内存，并链接到调用模块上</p><p>优点：</p><p>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p><blockquote><p>当程序经过编译或者汇编后，形成了一种由机器指令组成的集合，被称为目标程序</p><p>若调用指令LOAD A Data，经动态重新定位后，其对应指令代码保持不变</p></blockquote><h2 id="3、连续分配存储管理方式"><a href="#3、连续分配存储管理方式" class="headerlink" title="3、连续分配存储管理方式"></a>3、连续分配存储管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存分为系统区和用户区，系统区仅提供给OS使用，用户区仅装有一道用户程序，整个内存的用户空间由该程序独占</p><p>只适用于单用户、单任务</p><h3 id="固定分区"><a href="#固定分区" class="headerlink" title="固定分区"></a>固定分区</h3><p>有n个分区，则可同时装入n个作业/任务。</p><p><strong>1、分区大小</strong></p><ul><li>相等：缺乏灵活性</li><li>不相等：利用率高</li></ul><p><strong>2、内存分配</strong></p><p>将分区按大小排序，并将其地址、分配标识作记录</p><p><strong>3、特点</strong></p><p>简单，有碎片（内零头）</p><blockquote><p>内零头：分配给进程没用到的空间</p><p>外零头：不能分配给任何一个进程的空间</p></blockquote><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>空闲分区表</li><li>空闲分区链</li></ol><p><img src="https://s2.loli.net/2022/06/02/rFcSmMQEXjY97bx.png" alt="image-20220602222126659"></p><h4 id="顺序分配算法"><a href="#顺序分配算法" class="headerlink" title="顺序分配算法"></a>顺序分配算法</h4><p><strong>1、首次适应算法（First Fit / FF）</strong></p><ul><li><p>要求：分区按地址递增排序</p></li><li><p>方法：每次链首开始，直到找到满足大小的空闲分区，分割该分区</p></li><li><p>特点：有外零头，低址内存使用频繁，查找慢。高地址区保留大分区</p></li></ul><p><strong>2、循环首次适应算法（next fit / NF）</strong></p><ul><li>方法：从上次找到的空闲分区的下一个开始查找，直到找到满足大小的空闲分区，分割该分区。</li><li>特点：空闲分区分布均匀，提高了查找速度；缺乏大的空闲分区</li></ul><p><strong>3、最佳适应算法（best fit / BF）</strong></p><ul><li>要求：分区按大小递增排序；分区释放时需插入到适当位置。</li><li>方法：从小分区开始，找大小满足要求，但空余最小的分区。</li><li>特点：单次分配看似最优，但存在许多难以利用的碎片。总体未必最优。</li></ul><p><strong>4、最坏适应算法 （worst fit / WF）</strong></p><ul><li><p>要求：分区按大小递减排序</p></li><li><p>方法：总是选择最大的分区来分割分配。</p></li><li><p>特点：缺乏大的空闲分区。对中小作业有利。查找效率高。</p></li></ul><h4 id="分区合并"><a href="#分区合并" class="headerlink" title="分区合并"></a>分区合并</h4><p>（1）上邻空闲区：合并，改大小</p><p>（2）下邻空闲区：合并，改大小，首址。</p><p>（3）上、下邻空闲区：合并，改大小。</p><p>（4）不邻接，则建立一新表项。</p><h4 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h4><h5 id="1、快速适应算法（分类搜索法）（quick-fit）"><a href="#1、快速适应算法（分类搜索法）（quick-fit）" class="headerlink" title="1、快速适应算法（分类搜索法）（quick fit）"></a>1、快速适应算法（分类搜索法）（quick fit）</h5><p>对于每一类相同容量的空闲分区单独设立一个空闲分区链表；设置管理索引表，每个表项对应一种空闲分区类型，并记录该类空闲分区链表表头指针。</p><p>优点：</p><ul><li>查找效率高</li><li>不会对任何分区产生分割，能保留大的分区，也不会产生碎片</li></ul><p>缺点：</p><ul><li>分区归还主存时算法复杂，系统开销较大</li><li>内零头</li></ul><h5 id="2、伙伴系统（buddy-system）"><a href="#2、伙伴系统（buddy-system）" class="headerlink" title="2、伙伴系统（buddy system）"></a>2、伙伴系统（buddy system）</h5><p>在伙伴系统中，可用内存块的大小为2k(1≤k≤m)</p><p>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成k（0 ≤k≤m）个链表。</p><p>$$<br>buddy_{k}(x)=\left{\begin{matrix}x+2^{k}(若xMOD~~~2^{k+1}=0)<br> \x-2^{k}(若xMOD~~~2^{k+1}=2^{k})<br>\end{matrix}\right.<br>$$<br><img src="https://s2.loli.net/2022/06/02/zxlQNnPgiKGwVLc.png" alt="image-20220602225047117"></p><ul><li>优点：分配和回收内存速度快，且不会产生很多小碎片</li><li>缺点：内存利用率不高，分配的内存大小为2的幂</li></ul><h5 id="3、哈希算法"><a href="#3、哈希算法" class="headerlink" title="3、哈希算法"></a>3、哈希算法</h5><p>按照分区链表的大小建立哈希数组，从而快速找到需要大小的空闲分区链表。</p><h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><p>引入原因：连续式分配中，总量大于作业大小的多个小分区不能容纳作业。</p><p><strong>紧凑</strong></p><ul><li>通过作业移动将原来分散的小分区拼接成一个大分区</li><li>作业的移动需重定位。是动态（因作业已经装入）</li></ul><p>引入重定位寄存器</p><blockquote><p>当程序执行时，由相对地址与重定位寄存器中的<strong>起始地址</strong>相加得到物理地址访问内存</p></blockquote><h2 id="4、对换"><a href="#4、对换" class="headerlink" title="4、对换"></a>4、对换</h2><ul><li>以整个进程为单位：整体对换/进程对换</li><li>以“页”和“段”为单位：页面对换/分段对换/部分兑换</li></ul><h3 id="对换空间管理"><a href="#对换空间管理" class="headerlink" title="对换空间管理"></a>对换空间管理</h3><p>外存：</p><ul><li>文件区：为提高存储空间利用率，采用离散分配方式</li><li>对换区：为提高进程换入换出的速度，采用连续分配方式</li></ul><p>分配算法、对换空间的分配与回收与内存动态分区雷同。</p><h3 id="进程换出"><a href="#进程换出" class="headerlink" title="进程换出"></a>进程换出</h3><p>进程选择：</p><ul><li>先阻塞状态的，后选择就绪的挂起状态优先被换出，但不是一定被换出）</li><li>尽量选择优先级低的</li><li>考虑内存驻留时间长短</li></ul><p>换出进程：</p><ul><li>只能换出<strong>非共享的程序和数据段</strong>，共享段有其他进程使用时不能换出</li><li>先申请对换空间，然后启动磁盘将要换出的内容写出，最后才回收内存空间，并修改进程控制块和内存分配表等数据结构</li></ul><h3 id="进程换入"><a href="#进程换入" class="headerlink" title="进程换入"></a>进程换入</h3><ul><li>系统定时地查看所有进程的状态，从中找出就绪状态但已换出的进程；</li><li>将其中换出时间最久的进程作为换入进程；</li><li>有能满足进程需要的内存时可将之换入。</li></ul><blockquote><p>进程被换出时，非共享的程序段和数据段将被换出到外存</p></blockquote><h2 id="5、分页存储方式"><a href="#5、分页存储方式" class="headerlink" title="5、分页存储方式"></a>5、分页存储方式</h2><p>离散分配：程序在内存中不一定连续存放</p><p>引入原因</p><ul><li>连续分配会产生内外零头</li><li>为解决零头问题要进行紧凑等高开销活动</li></ul><p>根据基本单位不同：</p><ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>页面/页 ： 将一个进程的逻辑地址空间分为若干大小相等的片</li><li>（物理）块/页框 ： 将内存空间分成与页面相同大小的若干个存储块</li><li>为进程分配内存时，以块为单位将进程中的若干个页装入到多个可以不相邻接的物理块中</li><li>最后一页不满一块会产生“内零头”（页内碎片）</li></ul><h3 id="页面大小"><a href="#页面大小" class="headerlink" title="页面大小"></a>页面大小</h3><ul><li>页面小：页表长，页面换入换出效率低</li><li>页面大：页内碎片增大</li><li>应为2的幂，通常为512B~8KB</li></ul><h3 id="空间组织"><a href="#空间组织" class="headerlink" title="空间组织"></a>空间组织</h3><p><img src="https://s2.loli.net/2022/06/03/ksU7OgEj1PwhlAZ.png" alt="image-20220603112036852"></p><p>若逻辑地址空间地址为A，页面大小为L，则页号P和页内地址d：<br>$$<br>P=INT[\frac{A}{L}]<br>\d=[A]MOD~L<br>$$</p><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>页表：每个进程对应一个页表，描述该进程的各页面在内存中的物理块号（还可能有存取控制字段）</li><li>作业表：整个系统一张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息</li><li>空闲块表：整个系统一张，记录主存当前空闲块</li></ul><blockquote><p>全部页表集中存放在<strong>主存</strong>的系统专用区中，只有系统有权访问页表，保证安全。</p></blockquote><p><img src="https://s2.loli.net/2022/06/03/2JsyvTUrkxNWIK5.png" alt="image-20220603113510282"></p><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><p><strong>硬件机制：实现逻辑地址到物理地址的转换</strong></p><p>页表寄存器PTR：存放当前运行的进程的页表在内存中的起始地址，和此进程的页表长度</p><p><img src="https://s2.loli.net/2022/06/03/PRFi8umj3OzKGpZ.png" alt="image-20220603114700882"></p><p>执行检索前比较页号与页表长度，若页号大于页表长度，则表示本次所访问的地址已超越进程的地址空间，即产生越界中断，未出现则将页表始址与页号和页表项长度的乘积相加，得到物理块号</p><h3 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h3><p>分页系统：处理机每次存取指令或数据至少需要访问两次物理内存：</p><p><strong>第一次访问页表，第二次存取指令或数据</strong></p><p>为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表、TLB(Translation Lookaside Buffer)或联想存储器(Associative Memory)</p><p>工作原理：专门保存当前进程最近访问过的一组页表项（类似于高速缓存），根据逻辑地址中的页号，查找快表中是否存在对应的页表项</p><ul><li>若存在，称为命中(hit)，取出页框号，加上页内偏移量，计算出物理地址</li><li>若不存在，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中，并计算物理地址。</li></ul><p><img src="https://s2.loli.net/2022/06/03/wReVMvkObrxWzTF.png" alt="image-20220603144839827"></p><p>内存有效访问时间EAT(Effective Access Time)：</p><ul><li>无快表：EAT = 2t</li><li>有快表：EAT=a * λ + ( t + λ )(1-a) + t = 2t + λ – t x a</li></ul><p>其中，t为一次内存访问需要时间，λ 为查找快表所需时间，a为命中率</p><h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><p>大逻辑地址空间，页表非常大，需要占用相当大的内存空间</p><ol><li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题（即引入两级页表）</li><li>只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入</li></ol><p>对于4GB的进程，若采用二级页表，则对应的二级页表结构如图：</p><p><img src="https://s2.loli.net/2022/06/03/Qlo8FU9YgT5mz4w.png" alt="image-20220603150128825"></p><p>增设外层页表寄存器，用于存放外层页表的始址</p><p>利用逻辑地址中的外层页号，作为外层页表的索引，从中找到指定页表分页的始址，再利用指定页表分页的索引，找到指定的页表项，即该页在内存的物理块号</p><p><img src="https://s2.loli.net/2022/06/03/VaQb6E1neIwrFtS.png" alt="image-20220603153130046"></p><p>对于64位的机器就需采用多级页表</p><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>现代计算机系统中通常允许一个进程的逻辑地址空间非常大</p><p>反置页表为每一个物理块设置一个页表项，并将它们按物理块的编号排序，其中的内容则是页号和其所属进程的标志符。</p><p>地址变换：根据进程标志符和页号检索反置页表，如果找到则页表项中的序号就是该页所在的物理块号。如果检索未找到则失败或者必须请求调页。</p><p>虽然反置页表占用内存空间可以更小，但是仍然需要为每个进程保存完整的页表，以便实现请求调页。这样无法真正节约内存。</p><blockquote><p>反置页表不适用于大物理内存</p></blockquote><h3 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h3><ul><li>彻底消除了外零头，仅存在很少的内零头，提高了内存利用率</li><li>分页操作由系统自动进行，一个页面不能实现某种逻辑功能。用户看到的逻辑地址是一维的，无法调试执行其中的某个子程序或子函数。</li><li>采用分页技术不易于实现存储共享，也不便于程序的动态链接。</li></ul><h2 id="6、分段存储管理方式"><a href="#6、分段存储管理方式" class="headerlink" title="6、分段存储管理方式"></a>6、分段存储管理方式</h2><h3 id="引入原因-1"><a href="#引入原因-1" class="headerlink" title="引入原因"></a>引入原因</h3><ul><li>方便编程</li><li>信息共享</li><li>信息保护</li><li>动态增长</li><li>动态链接</li></ul><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>作业地址空间按逻辑信息的完整性被划分为若干个段，每段有段名/段号，从0开始编址，段内的地址空间是连续的</p><p>地址空间的访问：段名+段内地址</p><p><img src="https://s2.loli.net/2022/06/03/TK1BW7uJVjd8Exv.png" alt="image-20220603160918810"></p><h3 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h3><p>实现分段管理的关键：保证分段（二维）地址空间中的一个作业在线性（一维）的存储空间中正常运行</p><p>建立段映射表（段表）—每个段在表中占有一个表项，记录了该段在内存中的起始地址（基址）和段的长度</p><p>作用：实现从逻辑段到物理内存区的映射</p><h3 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h3><ol><li>根据段表寄存器的内容找到该作业的段表地址</li><li>利用有效地址中的段号作为检索段表的索引，得到该段在主存的起始地址</li><li>将段的主存起始地址和位移量W相加，即得访问主存的物理地址</li></ol><h3 id="评价-1"><a href="#评价-1" class="headerlink" title="评价"></a>评价</h3><p>优点：</p><ul><li>没有内碎片，外碎片可以通过内存紧凑来消除</li><li>便于改变进程占用空间大小</li></ul><p>缺点：</p><ul><li>进程全部装入内存</li></ul><h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><p><strong>分页系统中：</strong></p><p>对于数据页面，实现起来比较简单。因为这个数据页面可以安排在诸作业地址空间中的任何一页面上。</p><p>对于代码页面，它必须把共享的代码安排到所有共享它的作业地址空间中相同页号的页面中。即共享代码所在的地址空间必须重叠</p><p>之所以有这种要求，是因为一个作业在运行前必须链接好，而链接后，一个例程的所占页号就确定了。如果其它作业要共享该例程，则必须使它具有相同的页号，才能正确运行。</p><p><strong>分段系统中：</strong></p><p>分段的共享是通过两个作业段表的相应表目都指向COS过程的同一物理副本来实现的。</p><p>说明：段号是在动态链接过程中分配的，而且，系统不可能事先知道某个过程将为哪些作业所调用，因此，一个公共过程不一定也无需赋相同的段号</p><h2 id="7、段页式存储管理方式"><a href="#7、段页式存储管理方式" class="headerlink" title="7、段页式存储管理方式"></a>7、段页式存储管理方式</h2><p><img src="https://s2.loli.net/2022/06/03/7EKgYUmfCwcb2FJ.png" alt="image-20220603162444264"></p><p> 先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。</p><p>地址空间由段号S、段内页号P和页内相对地址（位移量）W构成</p><ul><li>首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表。</li><li>然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址。</li><li>再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号。</li><li>最后，用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址。 </li></ul><p><img src="https://s2.loli.net/2022/06/03/gKsBP16AXwCyrND.png" alt="image-20220603163053657"></p><p>每访问一次数据，需访问三次内存：</p><ol><li>访问内存中的段表</li><li>访问内存中的页表</li><li>访问相应数据</li></ol><p>可以设置快表，表项包括段号，页号，物理块号</p><blockquote><p>引入分段存储管理的原因不包括提升内存利用率</p></blockquote><h2 id="8、分页分段区别"><a href="#8、分页分段区别" class="headerlink" title="8、分页分段区别"></a>8、分页分段区别</h2><p>（1）</p><p>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。</p><p>段则是信息的逻辑单位，它含有一组意义相对完整的信息。分段的目的是为了能更好地满足用户的需要。 </p><p>（2）</p><p>页的大小固定且由系统决定，因而在系统中只能有一种大小的页面</p><p>段的长度却不固定，决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</p><p>（3）</p><p>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；</p><p>分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。   </p><p>段页式的虚拟空间地址也是二维的</p><p>（4）</p><p>分页不利于实现程序的共享和保护，分段利于实现</p><h2 id="9、连续分配vs离散分配"><a href="#9、连续分配vs离散分配" class="headerlink" title="9、连续分配vs离散分配"></a>9、连续分配vs离散分配</h2><table><thead><tr><th>技术性能</th><th>连续分配</th><th>离散分配</th></tr></thead><tbody><tr><td>大批量数据的存取速度</td><td>较快</td><td>较慢</td></tr><tr><td>机制的复杂性</td><td>较简单</td><td>较复杂</td></tr><tr><td>内存碎片</td><td>较大</td><td>较小</td></tr><tr><td>实现虚拟技术</td><td>较难</td><td>较易</td></tr><tr><td>实现动态链接</td><td>较难</td><td>较易</td></tr></tbody></table><h1 id="五、虚拟存储器"><a href="#五、虚拟存储器" class="headerlink" title="五、虚拟存储器"></a>五、虚拟存储器</h1><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>常规存储管理方式的特征：</p><ul><li>“一次性”：要求将一个作业全部装入内存中才能运行</li><li>“驻留性”：作业装入后一直驻留内存直到作业完成</li></ul><p>一次性和驻留性严重降低内存利用率，减少系统吞吐量。</p><p>解决方法：</p><ul><li>物理扩充</li><li>逻辑扩充<ul><li>覆盖：应用程序手动把需要的指令和数据保存在内存中</li><li>对换：操作系统自动把暂时不能执行的程序保存到外存中</li><li>虚拟存储</li></ul></li></ul><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>程序执行的局部性原理：程序的执行总是呈现局部性。即，在一个较短的时间段内，程序的执行仅限于某个部分；相应的，它所访问的存储空间也局限于某个区域。</p><p>因此，只要保证进程执行所需的部分程序和数据驻留在内存，一段时间内进程都能顺利执行。</p><ul><li>时间局限性：存在大量循环操作</li><li>空间局限性：访问地址集中在一定的范围内</li></ul><h3 id="虚拟存储器定义与特征"><a href="#虚拟存储器定义与特征" class="headerlink" title="虚拟存储器定义与特征"></a>虚拟存储器定义与特征</h3><p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。</p><ul><li>逻辑容量由内存容量和外存容量之和所决定</li><li>运行速度接近于内存速度，而每位的成本却又接近于外存</li></ul><p>特征</p><ol><li>多次性</li><li>对换性</li><li>虚拟性</li></ol><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>（1）<strong>请求分页存储管理方式</strong></p><ol><li>硬件支持<ul><li>请求分页的页表机制上增加若干项，作为请求分页的数据结构</li><li>缺页中断机构：当要访问的页面尚未调入内存时，便产生缺页中断，请求调页</li><li>地址变换机构：虚地址到物理地址转换</li></ul></li><li>软件<ul><li>实现请求调页的软件</li><li>实现页面置换的软件</li></ul></li></ol><p>（2）<strong>请求分段系统</strong></p><ul><li>请求分段的段表机制，这是在纯分段的段表机制基础上增加若干项而形成的</li><li>缺段中断机构</li><li>地址变换机构</li><li>相应软件支持</li></ul><p>（3）<strong>段页式虚拟存储系统</strong></p><h2 id="2、请求分页存储管理方式"><a href="#2、请求分页存储管理方式" class="headerlink" title="2、请求分页存储管理方式"></a>2、请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>建立在基本分页基础上</p><p>主要数据结构是页表</p><p>页表项：</p><p><img src="https://s2.loli.net/2022/06/03/EtF2Gl3sp7HuMQR.png" alt="image-20220603202056830"></p><ul><li><strong>状态位</strong>：也称存在位，标志该页是否驻留内存。 </li><li><strong>访问位</strong>：记录一段时间内该页被访问的情况，如一段时间内该页被访问的次数或者多长时间未被访问。</li><li><strong>修改位</strong>：标记该页是否被修改过。注：为减少置换开销，通常选择未被修改过的页面置换。 </li><li><strong>外存地址</strong>：用于记录该页在外存上的存储地址。</li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断，请求OS将所缺之页调入内存。 </p><p>地址转换时，检查页面的页表项中的存在位，如果为0，则产生一个缺页中断。</p><p>由于缺页中断的独特性，系统中需要提供硬件寄存器或其它机构，在出现页面故障时，保存部分完成的指令的状态。此外，还需要使用一条特殊的返回指令，确保在出现缺页中断处恢复该指令的处理。</p><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><img src="https://s2.loli.net/2022/06/03/JpjcdMFHGEwKSQ4.png" alt="image-20220603204521684"></p><h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol><li>最小物理块数：保证进程正常运行所需的最小物理块数</li><li>物理块的分配策略<ul><li>固定分配局部置换</li><li>可变分配全局置换</li><li>可变分配局部置换</li></ul></li></ol><p>（1）<strong>固定分配局部置换</strong></p><p>为每个进程分配一定数目的物理块，在整个运行期间都不再改变</p><p>困难：应为每个进程分配多少物理块难以确定</p><p>（2）<strong>可变分配全局置换</strong>（常用）</p><p>在采用这种策略时，先为系统中的每个进程分配一定数目的物理块，而OS自身也保持一个空闲物理块队列。</p><p>当某进程发现缺页时，由系统从空闲物理块队列中，取出一个物理块分配给该进程，并将欲调入的（缺）页装入其中</p><blockquote><p>可能引起抖动问题</p></blockquote><p>（3）<strong>可变分配局部置换</strong></p><p>为每个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其它进程运行</p><p>在进程运行过程中统计进程的缺页率，如果缺页率高，则为其增加一定的内存页，否则适当减少其内存的页面数</p><p>困难：对进程的缺页情况统计需要额外开销</p><h3 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h3><p>（1）平均分配算法</p><p>（2）按比例分配</p><p>按进程的页面数占页面数总和的比例进行分配</p><p>（3）考虑优先权的分配算法</p><p>将内存中可供分配的所有物理块分为两部分，一部分按比例分配，另一部分根据各进程的优先权，适当增加其相应份额后，分配给各进程</p><h3 id="页面调入策略"><a href="#页面调入策略" class="headerlink" title="页面调入策略"></a>页面调入策略</h3><p>1、何时调入</p><ul><li>预调页：当进程创建时，预先为进程装入多个页面。 缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。</li><li>请求调页：仅当进程执行过程中，通过检查页表发现相应页面不在内存时，才装入该页面。</li></ul><blockquote><p>预调页总比请求调页高效</p></blockquote><p>2、何处调入</p><p>外存分为两部分：</p><ul><li>用于存放文件的文件区</li><li>用于存放对换页面的对换区</li></ul><p>三种情况</p><ul><li>系统拥有足够的对换区空间：进程运行前需将全部有关文件从文件区拷贝到对换区。</li><li>系统缺少足够的对换区空间：这时凡是不会被修改的文件，都直接从文件区调入； 而当换出这些页面时，若未被修改则直接丢弃，以后再调入时，仍从文件区调入。 但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li><li>UNIX方式：由于与进程有关的文件都放在文件区，应从文件区调入。 凡是未运行过的页面，都应从文件区调入。 而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。  允许页面共享</li></ul><h3 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h3><p><img src="https://s2.loli.net/2022/06/03/E2FQTIrxg86ap7j.png" alt="image-20220603204521684"></p><blockquote><p>整个页面的调入过程对用户是透明的</p></blockquote><h2 id="3、页面置换算法"><a href="#3、页面置换算法" class="headerlink" title="3、页面置换算法"></a>3、页面置换算法</h2><h3 id="最佳置换算法（Optimal）"><a href="#最佳置换算法（Optimal）" class="headerlink" title="最佳置换算法（Optimal）"></a>最佳置换算法（Optimal）</h3><p>所选择的被淘汰页面，将是以后永不使用的，或是在最长(未来)时间内不再被访问的页面</p><p>理想化的算法，具有最好的性能，但很难实现</p><h3 id="先进先出算法（FIFO"><a href="#先进先出算法（FIFO" class="headerlink" title="先进先出算法（FIFO)"></a>先进先出算法（FIFO)</h3><p>该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰 </p><h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><p>选择最近最久未使用的页面予以淘汰（Least Recently Used）</p><p>该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当须淘汰一个页面时，选择现有页面中其t值最大的，即最近最久未使用的页面予以淘汰。</p><p>要求有硬件支持：寄存器/栈</p><p><strong>寄存器实现：</strong></p><p>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：                 </p><p>R=Rn-1Rn-2Rn-3···R2R1RO    </p><p>当进程访问某物理块时，要将相应寄存器的最高位Rn-1位置成1。</p><p>系统每隔一定时间（例如100  ms）将寄存器右移一位。     </p><p>如果我们把n位寄存器的数看作是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。 </p><p><img src="https://s2.loli.net/2022/06/03/kjvtlNuZsLwOba2.png" alt="image-20220603213919654"></p><p>此时应置换第3个页面</p><p><strong>栈实现：</strong></p><p>利用一个特殊的栈来保存当前使用的各个页面的页面号。每当进程访问某页面时，便将该页面的页面号从栈中移出，将它压入栈顶。 </p><p>栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。 </p><h3 id="最少使用算法（LFU-算法"><a href="#最少使用算法（LFU-算法" class="headerlink" title="最少使用算法（LFU)算法"></a>最少使用算法（LFU)算法</h3><p>选择自某时刻开始以来，访问次数最少的页面予以淘汰</p><h3 id="Clock置换算法（NRU）"><a href="#Clock置换算法（NRU）" class="headerlink" title="Clock置换算法（NRU）"></a>Clock置换算法（NRU）</h3><h4 id="简单Clock置换算法"><a href="#简单Clock置换算法" class="headerlink" title="简单Clock置换算法"></a>简单Clock置换算法</h4><p>循环地检查各页面的使用情况，又称为<strong>最近未使用算法NRU</strong>（Not Recently Used）</p><p>为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。 </p><p>当某页被访问时，其访问位被置1。</p><p> 置换程序从上次停止位置开始检查页面的访问位。 </p><ul><li>如果是0，就选择该页换出；</li><li>若为1，则重新将它置0，暂不换出，而给该页第二次驻留内存的机会。</li></ul><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>在置换范围内首选在最近没有被使用过、在驻留内存期间没有被修改过的页面作为被置换页面</p><p>由访问位A和修改位M可以组合成下面四种类型的页面：   </p><ul><li> 1类（A=0，M=0：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。    </li><li> 2类（A=0，M=1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。    </li><li> 3类（A=1，M=0）：最近已被访问，但未被修改：该页有可能再被访问。   </li><li> 4类（A=1，M=1）：最近已被访问且被修改，该页可能再被访问。 </li></ul><p>执行过程：</p><p>（1）从指针所指示的当前位置开始，扫描循环队列，寻找A=0且M=0的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位A。    </p><p>（2）如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找A=0且M＝1的第二类页面，将所遇到的第一个这类页面作为淘汰页。<strong>在第二轮扫描期间，将所有扫描过的页面的访问位都置0</strong>。     </p><p>（3）如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复0。然后重复第一步，如果仍失败，必要时再重复第二步，此时就一定能找到被淘汰的页 </p><h3 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h3><p>最少使用（LFU： Least Frequently Used）算法</p><p>页面缓冲算法（PBA: Page Buffering Algorithm)</p><h3 id="访问内存有效时间"><a href="#访问内存有效时间" class="headerlink" title="访问内存有效时间"></a>访问内存有效时间</h3><p>三种情况：</p><p>（1）被访问页在内存中，且对应页表项在快表中</p><p>​    EAT = λ + t     </p><p> λ 是查找快表时间，t为访问实际物理内存需要的时间</p><p> (2) 被访问页在内存，但对应的页表项不在快表中：</p><p>查找快表，查找页表，修改快表，修改页表</p><p> EAT = 2 * (λ + t) </p><p>(3) 被访问页不在内存中 ：    EAT = ε + 2 * (λ + t)        </p><p>ε 为缺页中断的处理时间</p><p>再考虑快表命中率a，访问缺页率f</p><p>EAT=查找快表时间+a * 根据物理地址访存时间+（1-a）* [查找页表时间+f * (处理缺页时间+查找快表时间+根据物理地址访存时间)+（1-f）* (修改快表时间+根据物理地址访存时间)]      </p><p>EAT = λ + a<em>t + (1-a)</em>[ t + f * (ε + λ  + t) + (1-f) * (λ  + t) ]</p><p>若没有快表，λ和a都为0</p><p>EAT = t + f * (ε  +t)  + (1 – f) * t</p><h3 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h3><p>如果成功访问的次数为S，访问页面发生缺页的次数为F，则缺页率为：f = F / （S + F）</p><p>影响因素：</p><ul><li>页面大小，页面越大越小；</li><li>进程所分配的物理页数，越多越少； </li><li>页面置换算法；</li><li>程序的访问局部性。</li></ul><h2 id="4、抖动与工作集"><a href="#4、抖动与工作集" class="headerlink" title="4、抖动与工作集"></a>4、抖动与工作集</h2><p>抖动：如果运行进程的大部分时间都用于页面的换入/换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸。</p><p>分为：</p><ul><li>局部抖动</li><li>全局抖动</li></ul><p>产生原因：</p><ul><li>进程分配的物理块太少</li><li>置换算法选择不当</li><li>全局置换使抖动传播</li></ul><p>工作集略·</p><h2 id="5、请求分段存储管理方式"><a href="#5、请求分段存储管理方式" class="headerlink" title="5、请求分段存储管理方式"></a>5、请求分段存储管理方式</h2><h3 id="段表机制"><a href="#段表机制" class="headerlink" title="段表机制"></a>段表机制</h3><p>在请求分段式管理中所需的主要数据结构是段表，段表项有新的扩展。</p><p><img src="https://s2.loli.net/2022/06/03/Wltv6QOq91aoHId.png" alt="image-20220603221508144"></p><h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p><img src="https://s2.loli.net/2022/06/03/Akv6GxpElayjQcm.png" alt="image-20220603221544218"></p><h3 id="地址变换机构-1"><a href="#地址变换机构-1" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><p><img src="https://s2.loli.net/2022/06/03/bcqKT6PUGznMBpW.png" alt="image-20220603221616752"></p><h3 id="共享段的分配与回收"><a href="#共享段的分配与回收" class="headerlink" title="共享段的分配与回收"></a>共享段的分配与回收</h3><p>简单来说就是分配的时候count+1，回收的时候count-1</p><h3 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h3><p>（1）越界检查</p><p>（2）存取控制检查</p><p>（3）环保护机构</p><p>低编号的环具有高优先权。OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序在外环上。</p><p>基本原则：</p><ul><li>一个程序可以访问驻留在相同环或较低特权环中的数据； </li><li>一个程序可以调用驻留在相同环或较高特权环中的服务。</li></ul><p><img src="https://s2.loli.net/2022/06/03/kfeV1iPUSL4vqMl.png" alt="image-20220603222232692"></p><h2 id="6、做题"><a href="#6、做题" class="headerlink" title="6、做题"></a>6、做题</h2><p>1、由于有了虚拟存储器，于是允许用户使用比内存更大的地址空间</p><p>2、状态位-&gt;程序访问；修改位-&gt;换出页面；访问位-&gt;置换算法;外存始址-&gt;调入页面</p><p>3、Belady现象：当分配到的内存块数增加时，缺页中断的次数有可能反而增加；-&gt;FIFO</p><p>4、凡未装入过内存的页都应从<strong>文件区</strong>调入，已运行过的页主要从<strong>对换区</strong>调入，有时也从<strong>页面缓冲区</strong>调入</p><p>5、虚拟存储器的功能由<strong>软硬件结合</strong>完成。在虚拟存储器系统中，采用<strong>高速缓冲存储器</strong>提高<strong>动态地址翻译</strong>的速度</p><p>6、Linux采用<strong>请求分页</strong>的存储管理方式，采用<strong>伙伴系统算法</strong>进行页框的分配和回收</p><h1 id="六、输入输出系统"><a href="#六、输入输出系统" class="headerlink" title="六、输入输出系统"></a>六、输入输出系统</h1><h2 id="1、I-O系统简介"><a href="#1、I-O系统简介" class="headerlink" title="1、I/O系统简介"></a>1、I/O系统简介</h2><ul><li><p>设备管理的对象：主要是I/O设备。 </p></li><li><p>设备管理的基本任务：完成用户提出的I/O请求，提高I/O速率以及改善I/O设备的利用率。  </p></li><li><p>设备管理的主要功能有：缓冲区管理、设备分配、设备处理、虚拟设备及实现设备独立性等。 </p></li><li><p>I/O系统基本功能：</p><ul><li>设备管理</li><li>设备映射</li><li>设备驱动</li><li>I/O缓冲区的管理</li></ul></li><li><p>通用设备管理分层模型</p></li></ul><p><img src="https://s2.loli.net/2022/06/04/4p6n7fSOvUGFs9R.png" alt="image-20220604145914720"></p><p>设备通常通过数据信号线、状态信号线、控制信号线与设备控制器连接</p><p><strong>设备控制器</strong></p><ul><li>设备控制器是CPU与I/O设备之间的接口，它接收从CPU发来的命令，并去控制I/O设备工作，以使处理机从繁杂的设备控制事务中解脱出来。</li><li>设备控制器主要职责是控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换。 </li><li>若控制器可连接多个设备时，则应含有多个设备地址，并使每一个设备地址对应一个设备。 </li></ul><p><strong>I/O通道</strong></p><p> I/O通道设备的引入目的是使一些原来由CPU处理的I/O任务转由通道来承担，从而把CPU从繁杂的I/O任务中解脱出来。  </p><p>采用通道有以下特点：</p><ol><li> DMA（直接存储器存取）方式显著地减少了CPU的干预。</li><li> 只需向I/O通道发送一条I/O指令，即可完成一组相关的读（或写）操作及有关控制。</li><li> 可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</li></ol><h2 id="2、中断处理程序"><a href="#2、中断处理程序" class="headerlink" title="2、中断处理程序"></a>2、中断处理程序</h2><p>中断和陷入—CPU外部事件和内部事件导致</p><p>基本概念：</p><ul><li>中断源</li><li>中断请求</li><li>中断响应</li><li>关中断/开中断</li><li>中断屏蔽</li></ul><p>中断处理层主要工作：</p><ul><li>进行进程上下文的切换</li><li>对处理中断信号源进行测试</li><li>读取设备状态和修改进程状态等</li></ul><p>中断处理程序的过程</p><ul><li>测定是否有未响应的中断信号</li><li>保护被中断进程的CPU环境</li><li>转入相应的设备处理程序</li><li>中断处理</li><li>恢复被中断进程的现场</li></ul><h2 id="3、设备驱动程序"><a href="#3、设备驱动程序" class="headerlink" title="3、设备驱动程序"></a>3、设备驱动程序</h2><p>对I/O设备的控制方式</p><h3 id="使用轮询的可编程I-O方式"><a href="#使用轮询的可编程I-O方式" class="headerlink" title="使用轮询的可编程I/O方式"></a>使用轮询的可编程I/O方式</h3><ul><li>程序I/O（Programmed  I/O）方式，或称为忙 – 等待方式。处理机向控制器发出一条I/O指令启动输入设备输入数据时，同时把busy置为1，再不断循环测试busy。 </li><li>Busy=0，完成输入，处理机读取数据，送入指定单元，完成一次I/O。</li><li>对状态寄存器中的忙/闲标志busy的检查实现控制。</li></ul><p><img src="https://s2.loli.net/2022/06/04/9IhUSMDtqlZrgYz.png" alt="image-20220604152035857"></p><p>CPU的绝大部分时间都处在等待I/O设备完成数据I/O的循环测试中，会造成对CPU的极大浪费</p><h3 id="使用中断的可编程I-O方式"><a href="#使用中断的可编程I-O方式" class="headerlink" title="使用中断的可编程I/O方式"></a>使用中断的可编程I/O方式</h3><p><img src="https://s2.loli.net/2022/06/04/pJvhkPnxaFiyNVf.png" alt="image-20220604152046148"></p><p>效率高</p><h3 id="直接存储器访问方式"><a href="#直接存储器访问方式" class="headerlink" title="直接存储器访问方式"></a>直接存储器访问方式</h3><p>（1）DMA控制方式</p><p>减少了CPU对I/O的干预</p><p>特点：</p><ol><li>数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；</li><li>所传送的数据是从设备直接送入内存的，或者相反； </li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。</li></ol><p>提高了CPU与I/O设备的并行操作程度</p><p><img src="https://s2.loli.net/2022/06/04/sfCBdySHANT9O4P.png" alt="image-20220604152308659"></p><h3 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h3><ul><li>I/O通道方式是DMA方式的发展，它可进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。 </li><li>可实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。 </li></ul><p><img src="https://s2.loli.net/2022/06/04/5qOX3NgfWHozByC.png" alt="image-20220604152516703"></p><p><strong>中断vsDMA</strong></p><p>1、中断方式是在数据缓冲寄存区满后，发中断请求，CPU进行中断处理；</p><p>   DMA方式则是以数据块为单位传输的，在所要求传送的数据块全部传送开始或结束时需要CPU的干预，这样大大减少CPU进行中断处理的次数。</p><p>   DMA方式不需CPU干预传送操作，不占用CPU任何资源，中断方式是程序切换，每次操作需要保护和恢复现场，中断次数多，CPU需要花较多的时间处理中断，中断次数多也会导致数据丢失。</p><p>2、中断方式的数据传送方向是由设备到CPU再到内存，或者相反。</p><p>   DMA方式的数据传送则是将所传输的数据由设备直接送入内存，或是由内存直接送到设备。</p><h2 id="4、与设备无关的I-O软件"><a href="#4、与设备无关的I-O软件" class="headerlink" title="4、与设备无关的I/O软件"></a>4、与设备无关的I/O软件</h2><p>为了实现<strong>设备独立性</strong>而引入了<strong>逻辑设备</strong>和<strong>物理设备</strong>这两个概念。</p><p>在应用程序中，使用逻辑设备名称来请求使用某类设备；</p><p>而系统在实际执行时，还必须使用物理设备名称。</p><p>设备独立性好处：</p><ol><li>设备分配时的灵活性</li><li>易于实现I/O重定向</li></ol><p>由于驱动程序与硬件紧密相关，为了实现设备独立性，必须在驱动程序之上设置一层软件，称为设备独立性软件</p><p>主要功能：</p><ol><li>公有操作<ul><li>对独立设备的分配与回收</li><li>将逻辑设备名映射为物理设备名，进一步可以找到相应物理设备的驱动程序；</li><li>对设备进行保护，禁止用户直接访问设备；</li><li>缓冲管理</li><li>差错控制</li><li>提供独立于设备的逻辑块</li></ul></li><li>向用户层（或文件层）软件提供统一接口</li></ol><h2 id="5、虚拟设备域SPOOLing技术"><a href="#5、虚拟设备域SPOOLing技术" class="headerlink" title="5、虚拟设备域SPOOLing技术"></a>5、虚拟设备域SPOOLing技术</h2><p>虚拟设备技术是指把每次仅允许一个进程使用的物理设备，改造为能同时供多个进程共享的虚拟设备的技术，或者说将一个物理设备变为多个对应的逻辑设备。</p><p><strong>SPOOLing技术也称假脱机操作，是指在多道程序的环境下，利用多道程序中的一道或两道程序来模拟外围控制机。从而在联机的条件下实现脱机I/O的功能。</strong></p><p><strong>SPOOLing系统的组成</strong></p><ol><li>输入井和输出井。这是在磁盘上开辟的两个大存储空间。输入井是模拟脱机输入时的磁盘设备，用于暂存I/O设备输入的数据；输出井是模拟脱机输出时的磁盘，用于暂存用户程序的输出数据。</li><li>输入缓冲区和输出缓冲区。为了缓和和CPU和磁盘之间速度不匹配的矛盾，在内存中要开辟两个缓冲区；输入缓冲区和输出缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用与暂存从输出井送来的数据，以后在传送给输出设备。</li><li>输入进程SPi和输出进程SP0。这里利用两个进程来模拟脱机I/O时的外围控制机。其中，进程SPi模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井，当CPU需要输入数据时，直接从输入井读入内存；进程SP0模拟脱机输出时的外围控制机，把用户要求输出的数据从先内存送到输出井，待输出设备空闲时，在将输出井中的数据经过输出缓冲区送到输出设备上。</li><li>井管理程序。用于控制作业与磁盘井之间信息的交换</li></ol><p><strong>SPOOLing系统的特点</strong></p><ol><li>提高了I/O的速度</li><li>将独占设备改造为共享设备</li><li>实现了虚拟设备功能</li></ol><p><strong>假脱机打印机系统</strong></p><ol><li>磁盘缓冲区</li><li>打印缓冲区</li><li>假脱机管理进程和假脱机打印进程</li></ol><p>两件事：</p><ul><li>在输出井中为之申请一个空闲的磁盘块区，并将要打印的数据送入其中</li><li>为用户进程申请一张空白的用户请求打印表，并将用户的打印要求填入其中，然后将表挂到假脱机文件队列上</li></ul><h2 id="6、缓冲区管理"><a href="#6、缓冲区管理" class="headerlink" title="6、缓冲区管理"></a>6、缓冲区管理</h2><h3 id="引入-1"><a href="#引入-1" class="headerlink" title="引入"></a>引入</h3><ol><li>缓和CPU与I/O设备速度不匹配的矛盾</li><li>减少对CPU的中断频率</li><li>提高CPU和I/O设备之间的并行性</li></ol><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。</li><li>使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</li><li>一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区。</li></ul><h3 id="单缓冲"><a href="#单缓冲" class="headerlink" title="单缓冲"></a>单缓冲</h3><ul><li>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>单缓冲</strong>的策略，操作系统会<strong>在主存中为其分配一个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）。</li><li>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</li><li>处理一块数据平均耗时Max(C,T)+M</li></ul><blockquote><p>从磁盘把一块数据输入到缓冲区的时间为T</p><p>OS将该缓冲区的数据传送到用户区的时间为M</p><p>CPU对这一块数据的处理时间为C</p></blockquote><p>缺点：</p><ol><li>生产者与消费者在使用缓冲区时必须互斥。如果消费者尚未取出缓冲区的数据，即使生产者又生产出了新的数据，也无法将它送到缓冲区</li><li>若两台机器之间只有单缓冲，则它们之间在任一时刻只能实现单方向的数据传输</li></ol><h3 id="双缓冲"><a href="#双缓冲" class="headerlink" title="双缓冲"></a>双缓冲</h3><ul><li>假设某用户进程请求某种块设备读入若干块的数据。若采用<strong>双缓冲</strong>的策略，操作系统会<strong>在主存中为其分配两个缓冲区</strong>（若题目中没有特别说明，一个缓冲区的大小就是一个块）</li><li>对一块数据的处理时间max(T,M+C)</li></ul><h3 id="环形缓存"><a href="#环形缓存" class="headerlink" title="环形缓存"></a>环形缓存</h3><ul><li>将多个<strong>大小相等</strong>的缓冲区链接成一个<strong>循环队列</strong>。</li></ul><p><img src="https://s2.loli.net/2022/06/05/ya3kOQ8NT5SIRKD.png" alt="image-20220605204212300"></p><p>使用：</p><ol><li>Getbuf过程</li><li>Releasebuf过程</li></ol><p><img src="https://s2.loli.net/2022/06/05/KVhpD4qutiRNbol.png" alt="image-20220605204700423"></p><p>两种特殊情况：</p><ol><li>Nexti指针追上Nextg指针，无缓冲区使用，输入进程应阻塞</li><li>Nextg指针追上Nexti指针，无装有数据的缓冲区供计算进程使用，计算进程阻塞</li></ol><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>系统较大时，循环缓冲要消耗大量内存空间，利用率不高，为了提高缓冲区的利用率，引入了缓冲池</p><p>公有缓冲池即可用于输入又可用于输出，在池中设置了多个可供若干个进程共享的缓冲区</p><p><strong>与缓冲区区别：</strong></p><ul><li>缓冲区仅仅是一组内存块的链表</li><li>缓冲池是包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区</li></ul><p><strong>组成：</strong></p><ol><li>空白缓冲队列emq</li><li>输入队列inq</li><li>输出队列outq</li><li>四种工作缓冲区<ul><li>用于收容输入数据的工作缓冲区</li><li>用于提取输入数据的工作缓冲区</li><li>用于收容输出数据的工作缓冲区</li><li>用于提取输出数据的工作缓冲区</li></ul></li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">:</span>互斥信号量</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token expression"><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token operator">:</span>资源信号量</span></span><span class="token keyword">void</span> <span class="token function">Getbuf</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> type<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">B</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Takebuf</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">Putbuf</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token function">Wait</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Addbuf</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> number<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">MS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">Signal</span><span class="token punctuation">(</span><span class="token function">RS</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/06/05/OrIgF7NzsfWdBYQ.png" alt="image-20220605204828680">    </p><ol><li><strong>收容输入</strong>。输入进程可调用Getbuf(emg)过程，从空缓冲队列emq 的队首摘下一空缓冲区，把它作为收容输入工作缓冲区 hin。然后，把数据输入其中，装满后再调用 Putbuf(inq,hin)过程，将它挂在输入队列 inq 队列上。</li><li><strong>提取输入</strong>。计算进程可调用 Getbuf(inq)过程，从输入队列 inq 的队首取得一缓冲区，作为提取输入工作缓冲区(sin)，计算进程从中提取数据。计算进程用完该数据后，再调用 Putbuf(emq,sin)过程，将它挂到空缓冲队列emq 上。</li><li><strong>收容输出</strong>。计算进程可调用 Getbuf(emq)，从空缓冲队列 emq 的队首取得一空缓冲，作为收容输出工作缓冲区hout。当其中装满输出数据后，又调用 Putbuf(outq,hout)过程，将它挂在outq末尾。 **</li><li><strong>提取输出</strong>。输出进程可调用 Getbuf(outq)过程，从输出队列的队首取得一装满输出数据的缓冲区，作为提取输出工作缓冲区sout。在数据提取完后，再调用 Putbuf(emq,sout) 过程，将它挂在空缓冲队列末尾。</li></ol><h2 id="7、磁盘系统与磁盘调度"><a href="#7、磁盘系统与磁盘调度" class="headerlink" title="7、磁盘系统与磁盘调度"></a>7、磁盘系统与磁盘调度</h2><h3 id="磁盘系统"><a href="#磁盘系统" class="headerlink" title="磁盘系统"></a>磁盘系统</h3><p>提高磁盘I/O速度的主要途径： </p><p>（1）选择性能好的磁盘</p><p>（2）采用好的<strong>磁盘调度算法</strong> </p><p>（3）设置<strong>磁盘高速缓存</strong>（Disk Cache） </p><p>（4）其它方法 </p><p>（5）采用高度可靠、快速的容量磁盘系统–<strong>磁盘冗余阵列</strong></p><p>数据的组织与格式</p><ul><li>存储面</li><li>磁道</li><li>柱面</li><li>扇区</li></ul><p>磁道访问时间：</p><p><strong>（1）寻道时间Ts：</strong></p><p>指把磁臂（磁头）移动到指定磁道上所经历的时间<br>$$<br>T_{s} = m * n+s<br>$$<br>s：启动磁臂时间</p><p>n：磁头移动n条磁道</p><p>m：移动每一条磁道所花费时间</p><p><strong>（2）旋转延迟时间Tτ：</strong></p><p>指定扇区移动到磁头下面所经历的时间</p><p><strong>（3）传输时间Tt</strong></p><p>指把数据从磁盘读出或向磁盘写入数据所经历的时间</p><p>Tt 的大小与每次所读/写的字节数b 和旋转速度有关：<br>$$<br>T_{t}=\frac{b}{rN}<br>$$<br>r为磁盘每秒钟转数；N为一条磁道上的字节数</p><h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><h4 id="先来先服务FCFS"><a href="#先来先服务FCFS" class="headerlink" title="先来先服务FCFS"></a>先来先服务FCFS</h4><p>根据进程请求访问磁盘的先后次序进行调度</p><p><img src="https://s2.loli.net/2022/06/04/9Ne1ncmasEfCRkv.png" alt="image-20220604155225269"></p><h4 id="最短寻道优先SSTF"><a href="#最短寻道优先SSTF" class="headerlink" title="最短寻道优先SSTF"></a>最短寻道优先SSTF</h4><p>选择这样的进程，其要求访问的磁道，与当前磁头所在的磁道距离最近，以使每次的寻道时间最短</p><p><img src="https://s2.loli.net/2022/06/04/pceVwCd5ga9UnAk.png" alt="image-20220604155535144"></p><p>可能会导致某个进程发生“饥饿”现象</p><h4 id="扫描（SCAN）算法"><a href="#扫描（SCAN）算法" class="headerlink" title="扫描（SCAN）算法"></a>扫描（SCAN）算法</h4><p>优先考虑的是磁头当前的移动方向。</p><p>例如，磁头自里向外移动, 并同时自里向外地访问，直至再无更外的磁道需要访问时，才将磁臂换向自外向里移动。（又常称之为<strong>电梯调度算法</strong>）</p><p><img src="https://s2.loli.net/2022/06/04/RjUJm3I1rbTy2QF.png" alt="image-20220604155748969"></p><p>当磁头刚从里向外（或刚从外向里）移动而越过了某一磁道时，恰好又有一进程请求访问此磁道，那它必须等待磁头到达磁盘的另一端，反向回来后，才能得到处理。</p><h4 id="循环扫描算法（CSCAN"><a href="#循环扫描算法（CSCAN" class="headerlink" title="循环扫描算法（CSCAN)"></a>循环扫描算法（CSCAN)</h4><p>磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描。 </p><p><img src="https://s2.loli.net/2022/06/04/8tyIcrw7GkW5Mle.png" alt="image-20220604155849604"></p><blockquote><p>磁道由外向里编号</p></blockquote><h2 id="8、做题-1"><a href="#8、做题-1" class="headerlink" title="8、做题"></a>8、做题</h2><p>1、通道控制控制器，设备在控制器控制下工作</p><p>2、共享设备必须是可寻址的和可随机访问的设备</p><p>3、通道是一种特殊的<strong>处理机</strong>，具有<strong>执行I/O指令集</strong>的能力。主机的CPU和通道可以并行工作，并通过<strong>I/O指令和I/O中断</strong>实现彼此的通信和同步</p><p>4、在I/O控制方式的发展过程中，最重要的推动因素是<strong>减少主机对I/O控制的干预</strong>。提高I/O速度和设备利用率，在OS中主要依靠<strong>缓冲管理</strong>功能</p><p>5、打印机的I/O控制主要采取<strong>程序中断</strong>的方式</p><p>6、在程序I/O方式中，对于输出设备，准备就绪是指<strong>输出缓冲区已空</strong></p><p>7、在单用户系统中可为<strong>整个系统</strong>设置一张<strong>逻辑设备表</strong>，在多用户系统中应为<strong>每个用户</strong>设置一张<strong>逻辑设备表</strong></p><p>8、为实现设备分配，应为每个设备设置一张<strong>设备控制表</strong>，在系统中设置一张<strong>系统设备表</strong>，为实现设备独立性，系统中应设置一张<strong>逻辑设备表</strong></p><p>9、SPOOLing系统实现了对I/O设备的虚拟，只要输入设备空闲，SPOOLing可预先将输入数据从设备传送到输入井中供用户程序随时读取</p><p>在SPOOLing系统中，用户程序可随时将输出数据送到输出井中，待输出设备空闲时再执行数据输出操作</p><p>10、同一用户所使用的I/O设备也可以并行操作</p><h1 id="七、文件管理"><a href="#七、文件管理" class="headerlink" title="七、文件管理"></a>七、文件管理</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>文件是存储和管理数据的容器</p><p>文件时指由创建者所定义的，具有文件名的一组相关元素的集合</p><ul><li>有结构的文件：文件由若干个相关记录组成</li><li>无结构文件：看成一个字符流</li></ul><p>文件在文件系统是一个基本的管理单元，这个管理单元必然有一组属性</p><p><strong>属性：</strong></p><ul><li>文件类型</li><li>文件长度</li><li>文件的物理位置</li><li>文件的建立时间</li></ul><p><strong>文件类型</strong></p><p>按用途：</p><ol><li>系统文件：可调用，不可读，不允许修改</li><li>用户文件</li><li>库文件</li></ol><p>按文件中的数据形式：</p><ol><li>源文件</li><li>目标文件</li><li>可执行文件</li></ol><p>按存取控制属性：</p><ol><li>只执行文件</li><li>只读文件</li><li>读写文件</li></ol><p>按组织形式和处理方式：</p><ol><li>普通文件</li><li>目录文件</li><li>特殊文件：特指系统中的各类I/O设备</li></ol><p><strong>文件系统：</strong></p><p>操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合</p><p>功能：</p><ul><li>有效地管理文件的存储空间；</li><li>管理文件目录； </li><li>完成文件的读/写操作； </li><li>实现文件共享与保护； </li><li>为用户提供交互式命令接口和程序调用接口</li></ul><h3 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h3><p><img src="https://s2.loli.net/2022/06/04/KqxC1c4yHIi8XPk.png" alt="image-20220604180023179"></p><p>不完整，一般为下图</p><p><img src="https://s2.loli.net/2022/06/04/pD1OUBluiwrJgA4.png" alt="image-20220604180002609"></p><p><strong>（1）对象及其属性</strong></p><ul><li>文件</li><li>目录</li><li>磁盘（磁带）存储空间</li></ul><blockquote><p>对目录的组织和管理是方便用户和提高对文件存取速度的关键</p></blockquote><p><strong>（2）对对象操纵和管理的软件集合</strong></p><p>核心部分</p><ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>用于将文件的逻辑地址转换为物理地址的机制</li><li>对文件读和写的管理</li><li>以及对文件的共享与保护等功能。</li></ul><p><strong>（3）文件系统接口</strong></p><ul><li>命令接口：用户与文件系统交互</li><li>程序接口：用户程序与文件系统交互</li></ul><h2 id="2、文件基本操作"><a href="#2、文件基本操作" class="headerlink" title="2、文件基本操作"></a>2、文件基本操作</h2><ol><li>最基本：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置</li><li>文件的“打开”和“关闭”操作</li><li>其他文件操作：对文件属性的操作，改变文件名、改变文件的拥有者，查询文件的状态等</li></ol><h2 id="3、文件系统目录管理"><a href="#3、文件系统目录管理" class="headerlink" title="3、文件系统目录管理"></a>3、文件系统目录管理</h2><p>管理要求：</p><ol><li>实现“按名存取”</li><li>提高对目录的检索速度</li><li>文件共享</li><li>允许文件重名</li></ol><p><strong>文件控制块</strong>（FCB）：用于描述和控制文件的数据结构</p><p><strong>文件目录</strong>：文件控制块的有序集合</p><p>通常，一个文件目录也被看做是一个文件，称为目录文件。</p><p>FCB内容：</p><ul><li>基本信息：文件名、文件类型等；</li><li>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。</li><li>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等；</li><li>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</li></ul><p><strong>目录项的两种组织方式：</strong></p><ol><li>FCB存储全部目录内容</li><li>存储部分目录信息，如文件名、索引节点指针等，其余部分保存在索引节点（i节点）。打开文件时将索引节点从磁盘读到内存中。</li></ol><p>索引节点：文件描述信息单独形成一个数据结构。文件名与索引节点分开。</p><p>文件目录保存：文件名和对应的文件索引节点</p><p>每个文件都在磁盘上保存一个磁盘索引节点，当文件被打开时，文件的索引节点从磁盘读入内存，称为内存索引节点。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项</p><p><img src="https://s2.loli.net/2022/06/04/Ku41gQFpja7Gdy9.png" alt="image-20220604200725593"></p><p>实现目录管理的基本功能—按名存取</p><p>缺点：</p><ul><li>查找速度慢</li><li>不允许重名</li><li>不便于实现文件共享</li></ul><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p><img src="https://s2.loli.net/2022/06/04/QsLUfG4lY9TepEy.png" alt="image-20220604200857875"></p><ul><li>一定程度解决了重名问题</li><li>提高了文件目录检索效率</li><li>简单的文件共享</li></ul><blockquote><p>在文件系统中，用户以<strong>虚拟地址</strong>方式使用外存</p></blockquote><h4 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h4><p>多级目录结构</p><p>主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。</p><p><img src="https://s2.loli.net/2022/06/04/1wTuGhQUm72AXYq.png" alt="image-20220604201510504"></p><blockquote><p>用户的<strong>主目录</strong>就是用户注册进入系统时的初始基本目录</p><p>UNIX的文件目录系统采用<strong>可装卸式多级树型目录</strong></p></blockquote><h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><ol><li>创建目录</li><li>删除目录：不删除非空目录、可删除非空目录</li><li>改变目录</li><li>移动目录</li><li>查找</li></ol><h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><h4 id="线性检索法"><a href="#线性检索法" class="headerlink" title="线性检索法"></a>线性检索法</h4><p>顺序检索法</p><ul><li>在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。</li><li>在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。</li></ul><blockquote><p>在操作系统中，将文件名转换为文件存储地址，对文件实施控制管理都是通过文件目录来实现的</p></blockquote><h4 id="Hash法"><a href="#Hash法" class="headerlink" title="Hash法"></a>Hash法</h4><p>略</p><h2 id="4、文件系统外存管理"><a href="#4、文件系统外存管理" class="headerlink" title="4、文件系统外存管理"></a>4、文件系统外存管理</h2><p>磁盘管理的主要任务和目标是；</p><ul><li>有效地利用外存空间</li><li>提高对文件的访问速度</li><li>提高磁盘系统的可靠性</li></ul><p>目前，常见的文件磁盘块的组织方法有:</p><ul><li>连续组织</li><li>链接组织</li><li>索引组织</li></ul><h3 id="连续组织"><a href="#连续组织" class="headerlink" title="连续组织"></a>连续组织</h3><p>连续分配(Continuous Allocation)要求为每一个文件分配一组相邻接的盘块。一组盘块的地址定义了磁盘上的一段线性地址。</p><p>把逻辑文件中的数据顺序地存储到物理上邻接的各个数据块中，这样形成的物理文件可以进行顺序存取。</p><p>文件目录中为每个文件建立一个表项，其中记载文件的<strong>第一个数据块地址</strong>及<strong>文件长度</strong>。</p><p>对于顺序文件，连续读/写多个数据块内容时，性能较好。</p><p><img src="https://s2.loli.net/2022/06/04/udTYHp81j35zacZ.png" alt="image-20220604202723614"></p><p>优点：</p><ol><li>顺序访问容易</li><li>顺序访问速度快</li></ol><p>缺点：</p><ol><li>要求有连续的存储空间</li><li>必须事先知道文件的长度</li></ol><h3 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h3><p>链接文件：采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，把这样形成的物理文件称为链接文件。</p><p>优点：</p><ul><li>消除磁盘外部碎片，提高了利用率</li><li>对插入、删除和修改记录都非常容易；</li><li>能适应文件的动态增长，无需事先知道文件的大小。</li></ul><h4 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h4><p>在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。</p><p><img src="https://s2.loli.net/2022/06/04/N8doAvIRGFQ4O9k.png" alt="image-20220604203144371"></p><p>缺点：只适合于顺序访问，它对随机访问是极其低效的。</p><p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇(cluster)</p><p>比如，一个簇可包含4 个盘块，在进行盘块分配时，是以簇为单位进行的。在链接文件中的每个元素也是以簇为单位的。</p><p>减少查找时间和指针所占空间，但增大了内部碎片</p><h4 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h4><p>指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。</p><p>整个磁盘仅设置一张文件分配表（FAT File Allocation Table）</p><p>缺点：FAT需要占用较大的内存空间</p><h3 id="索引组织"><a href="#索引组织" class="headerlink" title="索引组织"></a>索引组织</h3><h4 id="单级索引"><a href="#单级索引" class="headerlink" title="单级索引"></a>单级索引</h4><p>为每个文件分配一个索引块(表)，再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多盘块号的数组</p><p>优点：</p><ul><li>支持直接访问</li><li>基于数据块的分区能消除外部碎片</li></ul><p>缺点：</p><ul><li>大文件索引项较多</li><li>索引块可能要花费较多的外存空间</li></ul><h4 id="两级索引"><a href="#两级索引" class="headerlink" title="两级索引"></a>两级索引</h4><p>当文件太大，其一级索引块太多时，这种方法是低效的。此时，应为这些索引块再建立一级索引，形成两级索引分配方式。</p><p><img src="https://s2.loli.net/2022/06/04/okJi8scdqaQP9NG.png" alt="image-20220604210210538"></p><h4 id="增量式索引"><a href="#增量式索引" class="headerlink" title="增量式索引"></a>增量式索引</h4><p>全面照顾小、中、大及特大文件的组织需求。</p><p>同时采用：</p><ul><li>直接寻址：10个块号</li><li>一级索引，一次间址：一个索引块</li><li>二级索引，二次间址</li><li>三级索引，三次间址</li></ul><p><img src="https://s2.loli.net/2022/06/04/u1WdyPmIMKncC5S.png" alt="image-20220604210437093"></p><h2 id="5、磁盘空闲空间管理"><a href="#5、磁盘空闲空间管理" class="headerlink" title="5、磁盘空闲空间管理"></a>5、磁盘空闲空间管理</h2><p>存储空间的基本分配单位是<strong>磁盘块</strong>。</p><p>系统应为分配存储空间而设置相应的数据结构；其次，系统应提供对存储空间进行分配和回收的手段。</p><h3 id="空闲分区表"><a href="#空闲分区表" class="headerlink" title="空闲分区表"></a>空闲分区表</h3><p>空闲表法属于连续分配方式，它为每个文件分配一块连续的存储空间，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息</p><p><img src="https://s2.loli.net/2022/06/04/nBiohVres12AO95.png" alt="image-20220604211556454"></p><p>适合于可变大小分区的连续分配方式</p><p>为文件分配存储空间时，首先顺序查找空闲分区表中的各个表项，直至找到第一个大小适合的空闲分区。</p><p>可以采用首次适应分配算法、最佳适应分配算法等。然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项。</p><p>当删除文件释放出空间时，系统回收其存储空间，合并相邻空闲分区.</p><ul><li>优点：实现简单</li><li>缺点：当存储空间中的空闲分区分布较分散且数量较多时，空闲分区表将会很大。需要很大的内存空间，会降低空闲分区表的检索速度。</li></ul><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲链表法是将所有空闲盘区拉成一条空闲链。</p><p>根据构成链所用基本元素的不同，可把链表分成两种形式：</p><ul><li>空闲盘块链</li><li>空闲盘区链</li></ul><h4 id="空闲盘块链"><a href="#空闲盘块链" class="headerlink" title="空闲盘块链"></a>空闲盘块链</h4><p>将磁盘上的所有空闲空间，以盘块为单位拉成一条链。</p><ul><li>当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。</li><li>当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。</li></ul><p>优点：用于分配和回收一个盘块的过程非常简单.</p><h4 id="空闲盘区链"><a href="#空闲盘区链" class="headerlink" title="空闲盘区链"></a>空闲盘区链</h4><p>将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)拉成一条链。</p><p>在每个盘区上含有用于指示<strong>下一个空闲盘区的指针</strong>和能**指明本盘区大小(盘块数)**的信息。</p><p>通常采用首次适应算法</p><p>回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并</p><p>问题：</p><ul><li>一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。</li><li>删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。</li><li>若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。</li></ul><p>适用于非连续存储文件</p><h3 id="位示图"><a href="#位示图" class="headerlink" title="位示图"></a>位示图</h3><p>利用二进制位0、1表示存储空间中存储块的使用状态。空闲分区:0，已分配分区:1（或者相反）</p><p>通常可用m × n 个位数来构成位示图，并使m × n等于磁盘的总块数。</p><p><strong>盘块分配：</strong></p><p>(1) 顺序扫描位示图，从中找出一个或一组其值为“0”的二进制位(“0”表示空闲时)。</p><p>(2) 将所找到的一个或一组二进制位转换成与之相应的盘块号。</p><p>假定找到的其值为“0”的二进制位位于位示图的第i 行、第j列，则其相应的盘块号应按下式计算：<br>$$<br>b=n(i-1)+j<br>$$<br>(3)修改位示图，令map[i,j]=1</p><p><strong>盘块回收</strong></p><p>（1）将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：<br>$$<br>i=(b-1)DIV<del>n+1<br>\j=(b-1)MOD</del>n+1<br>\DIV ~~~~取整<br>$$<br>（2）修改位示图。令map[i,j] =0</p><p><strong>优点：</strong>可以很容易的找到一个或一组连续的空闲分区</p><p>一个位示图需要占用的存储空间：磁盘容量（字节数）/ （8 * 数据块大小）</p><p><strong>缺点：</strong>很难一次性将该位示图全部装入内存。即使内存足够大，可以存放全部或绝大部分位示图数据，搜索一个很大的位示图将会降低文件系统的性能。</p><p>尤其当磁盘空间快用完，剩下的空闲磁盘块很少时，文件系统的性能将严重降低。</p><h3 id="成组链接法"><a href="#成组链接法" class="headerlink" title="成组链接法"></a>成组链接法</h3><ul><li>将磁盘空闲块分成若干组，如将100个盘块作为一组，用索引表表示；</li><li>该组空闲块总数和各空闲块块号存入下一组的第一个空闲块中（从后往前分组），各组通过链接指针连在一起形成链表；</li><li>最后不满100块的那组空闲块总数和各空闲块块号计入磁盘区专用管理块（超级块）的空闲盘块号栈的s_nfree和s_free[100]中</li></ul><p><img src="https://s2.loli.net/2022/06/04/DmMdoUBv7JaHGiz.png" alt="image-20220604220630073"></p><p><strong>分配：</strong></p><ul><li>未到栈底：出栈，将栈顶盘块分配给用户</li><li>已到栈底盘块：调用磁盘读过程将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把原栈底对应的盘块分配出去（其中的有用数据已读入栈中）。然后，再分配一相应的缓冲区作为该盘块的缓冲区。最后，把栈中的空闲盘块数-1并返回</li></ul><p><strong>回收：</strong></p><ul><li>栈未满：进栈，依次将回收盘块号压入栈中</li><li>栈已满：将现有栈中的100个盘块号记入新回收的盘块中，再将其盘块号作为新栈底</li></ul><p>仅适用于离散分配形式，无法用于连续分配</p><p>优点：</p><ul><li>无需占用额外的磁盘空间</li><li>分配回收速度快</li><li>大小磁盘均可采用</li></ul><p>缺点：</p><ul><li>不适用于连续分配</li></ul><h2 id="6、文件共享与保护"><a href="#6、文件共享与保护" class="headerlink" title="6、文件共享与保护"></a>6、文件共享与保护</h2><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><ol><li>同时存取</li><li>存取权限</li></ol><p><strong>同时存取</strong></p><ul><li>允许多个用户同时读文件内容，但不允许同时修改，或同时读且修改文件内容。</li><li>共享用户之一修改文件内容时，可以将整个文件作为临界资源，锁定整个文件，不允许其他共享用户同时读或写文件。</li><li>也可以仅仅锁定指定的一条记录，允许其他共享用户读/写该文件的其它记录。后者的并发性能更好。</li><li>涉及进程的同步与互斥</li></ul><p><strong>存取权限</strong></p><ul><li>无（None） — 用户不知道文件的存在。用户无法获知该文件的目录信息，当然更不会知道文件的内容。</li><li>探知（Knowledge） — 用户可以检测文件的存在和文件的文件主，还可以向文件主申请增加对该文件的存取权限。</li><li>执行（Execution） —  用户可以装载并执行程序，但不允许拷贝程序内容。</li><li>读（Reading）— 允许用户读文件内容，包括拷贝和执行文件。某些系统严格地将浏览文件内容和拷贝权限分开，可以控制文件只能被浏览（显示），不能被拷贝。</li><li>追加（Appending）— 允许用户向文件添加数据，通常只能将数据添加到文件尾。但是，不能修改或删除文件内容。例如，超市收银员只能将新结帐的数据添加到文件中，不允许其修改或删除已有的数据。</li><li>更新（Updating）— 允许用户修改、删除、增加文件内容。包括创建文件、重写文件的全部或部分内容、移动文件的全部或部分数据等操作。</li><li>更改权限 (Changing protection) — 一般只有文件主才能更改共享该文件的其他用户对该文件的存取权限。有的系统允许文件主将更改文件存取权限赋予其他某个用户，但必须限制授权用户更改的权限范围。</li><li>删除 (Deletion) — 允许用户删除文件</li></ul><p>后一种权限包含前一种及前面各种存取权限</p><p>实现文件共享的实质就是<strong>可以从不同地方打开同一个文件</strong></p><p>打开文件的首要步骤就是<strong>找到文件的目录项</strong>，读取文件在外存的起始地址</p><h4 id="链接目录项实现法"><a href="#链接目录项实现法" class="headerlink" title="链接目录项实现法"></a>链接目录项实现法</h4><p>文件目录项中设置一个链接指针，用于指向共享文件的目录项。</p><p>访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。</p><p>每当有用户（进程）共享文件时，共享文件目录项中的“共享计数”加1；当用户不再共享该文件，撤消链接指针时，“共享计数”减1。</p><p>只有当共享文件用户数为1时，才能删除共享文件。</p><h4 id="索引节点实现法"><a href="#索引节点实现法" class="headerlink" title="索引节点实现法"></a>索引节点实现法</h4><p>文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。</p><p>由任何用户对文件进行Append 操作或修改，所引起的相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，都是其他用户可见的，从而也就能提供给其他用户来共享。</p><p>可以通过共享文件索引节点来共享文件，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名(也可用原名)，并将索引节点指针指向共享文件的索引节点。</p><p>在索引结点中还应有一个链接计数count，用于表示链接到本索引结点(亦即文件)上的用户目录项的数目。</p><ul><li>当用户C创建一个新文件时，他便是该文件的所有者，此时将count 置1。</li><li>当有用户B要共享此文件时，在用户B 的目录中增加一目录项，并设置一指针指向该文件的索引结点，此时，文件主仍然是C，count=2。</li></ul><h4 id="符号链实现法"><a href="#符号链实现法" class="headerlink" title="符号链实现法"></a>符号链实现法</h4><p>为使B能共享C的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F并将F写入B的目录中，以实现B的目录与文件F的链接；在新文件中只包含被创文件F的路径名。这样的链接方法被称为符号链接.</p><p>新文件中的路径名，则只被看作是<strong>符号链</strong>。当B要访问被链接的文件F且正要读LINK类新文件时，将被OS截获，  OS根据新文件中的路径名去读该文件，于是就实现了用户B对文件F的共享。</p><p>（快捷方式？？？！！！）</p><p>在利用符号链方式实现文件共享时，只是文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。</p><p>优点：能连接任何机器上的文件</p><p>缺点：</p><ul><li>访问共享文件时要多次读盘，开销大</li><li>建立符号链时仍需要配置索引节点，耗费一定的磁盘空间</li></ul><h4 id="利用URL"><a href="#利用URL" class="headerlink" title="利用URL"></a>利用URL</h4><p>统一资源定位器URL (Uniform Resource Locator)是Internet上用来链接超文本文件的一种方法。</p><p>（在线文档呗）</p><h2 id="7、做题-1"><a href="#7、做题-1" class="headerlink" title="7、做题"></a>7、做题</h2><p>1、文件系统最基本的目标是<strong>按名存取</strong>，它主要是通过<strong>文件共享</strong>功能实现的，文件系统所追求的最重要的目标就是<strong>文件安全性管理</strong></p><p>2、FC通常存放在<strong>该文件的上级目录的数据盘块</strong>中</p><p>3、Windows FAT32的目录项中不会包含<strong>文件控制块的物理位置</strong>，而Unix的磁盘索引节点中不会包含<strong>文件名信息</strong></p><p>4、在执行close的过程时，若系统打开文件表项引用技术f.count=0不成立，应置<strong>用户文件描述符表项为空</strong>；若f.count=0但内存索引节点引用计数i.count=0不成立，应使<strong>用户文件描述符和文件表项皆为空</strong>，若i.count=0，则关闭文件</p><h1 id="八、操作系统接口"><a href="#八、操作系统接口" class="headerlink" title="八、操作系统接口"></a>八、操作系统接口</h1><h2 id="1、操作系统与用户接口"><a href="#1、操作系统与用户接口" class="headerlink" title="1、操作系统与用户接口"></a>1、操作系统与用户接口</h2><ol><li><strong>命令接口</strong>：用户在终端输入命令与系统交互或者是用户通过提交作业控制说明书来控制系统运行。这种方式要求用户记忆所提交的命令。分为：联机用户接口（交互式方式运行的命令）与脱机用户接口（批处理用户接口）；<ul><li>联机命令</li><li>终端处理程序</li><li>命令解释程序</li></ul></li><li><strong>程序接口</strong>：通过系统调用实现，这种接口主要提供给程序员使用，在OS的外层软件或用户程序中，凡是与资源有关的操作都必须通过该接口向操作系统提出服务请求，并由OS完成</li><li><strong>图形接口</strong>：采用了图形化的操作界面，直观，方便，易学，更适合于普通用户使用</li></ol><h2 id="2、系统调用"><a href="#2、系统调用" class="headerlink" title="2、系统调用"></a>2、系统调用</h2><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层，该层的主要作用有两个:</p><p>为用户空间提供了一种硬件的抽象界面，例如，当需要读文件时，应用程序可以不管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型；</p><p>系统调用保证了系统的稳定和安全。</p><p>各种版本的UNIX系统都提供了定义明确、数量有限、可直接进入内核的入口点，这些入口点被称为系统调用</p><p><strong>系统调用和普通调用的区别：</strong></p><p>系统调用本质上是一种过程调用，但它是一种特殊的过程调用，与一般用户程序中的过程调用有明显区别</p><table><thead><tr><th></th><th>系统调用</th><th>一般过程调用</th></tr></thead><tbody><tr><td>运行状态</td><td>主调程序：用户态<br>被调程序：系统态</td><td>主调程序和被调程序<br>同在用户态或系统态</td></tr><tr><td>状态切换</td><td>通过软中断进行状态切换</td><td>不切换</td></tr><tr><td>返回问题</td><td>可能引起调度<br>（与调度算法有关）</td><td>不调度</td></tr><tr><td>嵌套调用</td><td>有深度限制</td><td>不限制调度</td></tr></tbody></table><ol><li>运行在不同的系统状态。一般的过程调用，其调用程序和被调用程序都运行在相同的状态——系统态或用户态；而系统调用与一般调用的最大区别就在于：调用程序是运行在用户态，而被调用程序是运行在系统态</li><li>通过软中断进入。由于一般过程调用不涉及到系统状态的转换，故可直接由调用过程转向被调用过程。但在运行系统调用时，由于调用和被调用过程是工作在不同的系统状态，因而不允许由调用过程直接转向被调用过程，通常都是通过软中断机制，先由用户态转换为系统态，经核心分析后，才能转向相应的系统调用处理子程序</li><li>返回问题。一般的过程调用在被调用过程执行完后，将直接返回到调用过程继续执行。但对系统调用，如果系统采用抢占调度方式，则在被调用过程执行完后，必须对系统中所有要求运行的进程做优先权分析。只有当调用进程仍具有最高优先权时，才返回到调用进程继续执行；否则，将引起重新调度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2023/022828758.html"/>
      <url>/2023/022828758.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、计算机网络和因特网"><a href="#一、计算机网络和因特网" class="headerlink" title="一、计算机网络和因特网"></a>一、计算机网络和因特网</h1><h2 id="1、Internet"><a href="#1、Internet" class="headerlink" title="1、Internet"></a>1、Internet</h2><p>计算机网络：两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体</p><p>因特网服务提供商ISP（Internet  Service  Provider）</p><p>两大功能：<strong>连通性、共享</strong></p><p>具体构成：数以亿计的计算机互连设备、通信链路、分组交换机</p><p>服务描述：提供网络应用基础架构，为分布式应用程序提供的通信服务接口</p><p>组成部分：网络边缘、接入网、网络核心</p><h3 id="分组交换-packet-switching-技术"><a href="#分组交换-packet-switching-技术" class="headerlink" title="分组交换(packet switching)技术"></a>分组交换(packet switching)技术</h3><p>发送端将要发送的数据（报文）分成若干数据块，封装成分组，发送到目的端。目的端解封后恢复原数据。</p><p>路径（route或path）：一个分组从发送端系统传输到接收端系统，所经过的一系列通信链路和分组交换机。</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>定义了两个或多个通信实体间所交换报文的<strong>格式和顺序</strong>，以及在报文发送和/或接收或者其他事件方面所采取的<strong>行动（响应）</strong></p><p><strong>基本要素</strong>：</p><ul><li>语法：报文格式</li><li>语义：每个字段的含义</li><li>同步：报文传输的先后次序</li></ul><h3 id="Internet文档RFC"><a href="#Internet文档RFC" class="headerlink" title="Internet文档RFC"></a>Internet文档RFC</h3><p>RFC(Request For Comments)请求评论</p><p>四个阶段：</p><ul><li>因特网草案（Internet Draft）－不是RFC文档</li><li>建议标准（Proposed Standard） －开始成为RFC文档</li><li>草案标准（Draft Standard）</li><li>因特网标准（Internet Standard）</li></ul><h2 id="2、网络边缘"><a href="#2、网络边缘" class="headerlink" title="2、网络边缘"></a>2、网络边缘</h2><ul><li>端系统 (/主机):<ul><li>运行网络应用程序</li><li>处在网络的边缘</li><li>传统主机/网络计算机和客户</li></ul></li><li>客户/服务器   C/S模型<ul><li>客户请求，并接收服务器提供的服务</li></ul></li><li>端对端模型peer-peer model:<ul><li> 极少或不采用专门服务器</li></ul></li><li>接入网 (network access)：<ul><li>将端系统连接到其边缘路由器的物理链路。         </li><li>是用户连接到网络的基础设施。</li></ul></li><li>边缘路由器(edge router) ：         <ul><li>端系统到任何其他远程端系统的路径上的第一台路由器。</li></ul></li></ul><h3 id="家庭接入网络"><a href="#家庭接入网络" class="headerlink" title="家庭接入网络"></a>家庭接入网络</h3><p>点对点接入</p><p>数字用户线DSL：使用传统的电话线路连接本地中心局，数据通信和电话采用频分多路复用技术。</p><p>线缆调制解调器：cable modems</p><p>HFC：(hybrid fiber coaxial cable)混合光纤同轴电缆</p><p>电缆调制解调器</p><p>非对称</p><p>共享广播媒体：</p><ul><li>光节点发送的分组经下行信道传输到每个家庭：若几个用户同时下载，实际接收速率下降。</li><li>每个家庭发送的分组经上行信道向光节点传输：几个用户同时发送分组将会冲突，需要相应多路访问协议协调</li></ul><p>FTTH(Fiber To the Home) - 光纤到户</p><p>从本地局端直接到每个家庭提供一条光纤路径</p><p>从中心局出来的每根光纤由多个家庭共享，在临近家庭的位置，通过光纤分配器，才为每个家庭提供一根光纤</p><ul><li>ONT光纤网络端接器（家庭端）</li><li>OLT光纤线路端接器（电信公司端）</li></ul><h3 id="企业接入网络"><a href="#企业接入网络" class="headerlink" title="企业接入网络"></a>企业接入网络</h3><p>LAN：local area networks</p><p>WIFI无线接入网路</p><h3 id="广域无线接入网络"><a href="#广域无线接入网络" class="headerlink" title="广域无线接入网络"></a>广域无线接入网络</h3><p>广域无线接入网：wide-area wireless access</p><p>典型技术：</p><ul><li>利用移动电话设施接入：欧洲的无线接入协议WAP 、日本的i模式（i.mode）。</li><li>分组交换接入：第三代无线3G技术、4G技术。</li></ul><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><p>定义：将网络中不同节点(主机和路由器)互相连接起来的物理线路。</p><p>是进行数据传输的物理通路，通过传播电磁波或光脉冲来发送比特流。也称为传输媒体、传输介质或传输媒介。</p><p>分类：</p><ul><li>导引型媒体：电磁波沿着固体媒体传播。如双绞线、同轴电缆或光缆等。</li><li>非导引型媒体：电波在空气或外层空间中传播。如无线电等</li></ul><p><strong>双绞线</strong></p><p>两根彼此绝缘、相互缠绕成螺旋状的铜线。缠绕的目的是减少电磁干扰，提高传输质量。</p><ul><li>屏蔽双绞线（STP， Shielded Twisted Pair）</li><li>非屏蔽双绞线 (UTP， Unshielded Twisted Pair )</li></ul><p><strong>同轴电缆</strong></p><p>两根彼此绝缘的同心导体，双向传输</p><p><strong>光纤电缆</strong></p><ul><li>光纤传导光脉冲, 每个光脉冲代表1位</li><li>高速传输：高速点对点传输 </li><li>低误码率: 中继到更远传输距离 ; 防止电磁干扰，难以被分光窃听。</li><li>多模光纤MMF，单模光纤SMF</li></ul><p><strong>无线电信道</strong></p><ul><li>利用无线电波在自由空间传播实现通信</li><li>传播环境的影响</li><li>无线链路类型</li><li>卫星无线电信道</li></ul><h3 id="端系统上的因特网服务"><a href="#端系统上的因特网服务" class="headerlink" title="端系统上的因特网服务"></a>端系统上的因特网服务</h3><p>面向连接服务TCP</p><p>无连接服务UDP</p><h2 id="3、网络核心"><a href="#3、网络核心" class="headerlink" title="3、网络核心"></a>3、网络核心</h2><h3 id="电路交换-circuit-switching"><a href="#电路交换-circuit-switching" class="headerlink" title="电路交换 (circuit switching)"></a>电路交换 (circuit switching)</h3><p><strong>面向连接的</strong></p><p><strong>预留带宽，独占资源</strong></p><ul><li>预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。</li><li>发送方以恒定速率向接收方传送数据。</li><li>如：电话网络。</li></ul><p>每条链路可有n条电路，能够支持n条同步连接</p><p>通信过程：</p><ul><li>在两台主机A、B之间创建一条专用的端到端连接，分别占用每条链路中的一条电路；</li><li>该连接获得链路带宽的1/n，进行通信。</li></ul><p><strong>多路复用：</strong>在一条传输链路上同时建立多条连接，分别传输数据。</p><ul><li><p><strong>频分多路复用FDM</strong>(frequency-division multiplexing)</p><ul><li>链路的频谱由跨越链路创建的连接所共享。</li><li>按频率划分若干频段，每个频段专用于一个连接。</li><li>带宽bandwidth：频段的宽度，如8kHz。</li></ul></li><li><p><strong>时分多路复用TDM</strong> (time-division multiplexing) </p><ul><li>时间划分为固定区间的帧，每帧再划分为固定数量的时隙，每一个时隙专用于一个连接，用于传输数据。</li></ul></li></ul><p>缺点：</p><ul><li>效率低：静默期（无数据传输）专用电路空闲，网络资源被浪费；</li><li>创建端到端电路及预留端到端带宽的过程复杂。</li></ul><h3 id="分组交换-packet-switching"><a href="#分组交换-packet-switching" class="headerlink" title="分组交换(packet switching)"></a>分组交换(packet switching)</h3><p><strong>共享带宽，竞争资源</strong></p><ul><li>不需要资源预留</li><li>按需使用资源，可能要排队等待：</li><li>如：因特网。</li></ul><p>报文(message)：应用程序要传输的信息</p><p>工作过程：</p><ul><li>源主机将报文划分为一些列较小的数据块，封装成分组（packet）；并将每个分组通过若干链路和分组交换机，传送到目的主机；</li><li>目的主机拆分分组，提出数据块，并按顺序重新组装成报文。</li></ul><p>每个分组使用全部链路带宽：分组以链路的最大传输速率传输。</p><p>传输过程中采用存储转发传输机制：分组交换机先将输入端的整个分组接收下来（存储），再从输出链路转发传输出去（转发）。</p><ul><li>每经过1个节点转发一次</li><li>在1个链路上传输</li><li>转发分组前，要求收到完整分组</li></ul><p><strong>输出缓存</strong> （输出队列）： 用于保存准备发往某个链路的分组。每条相连的链路都对应有一个。</p><p><strong>排队时延</strong>：分组在输出缓存中等待转发的时间。它变化的，与网络中的拥塞有关。</p><p><strong>分组丢失</strong>： 当缓存空间已满时，有分组要被丢弃</p><p><strong>路由器：</strong>接收分组，然后根据分组目的主机地址信息，将分组按自己的转发表查找到相应的输出链路并转发，最终能使分组到达目的主机。</p><p><strong>路由选择协议</strong>：自动的对自己维护的转发表进行设置</p><p><strong>优点</strong>：允许更多用户使用网络</p><p><strong>缺点</strong>：过度竞争导致分组延迟与丢失，需要可靠数据传输，拥塞控制协议</p><p>分类：</p><ul><li>数据报网络：TCP/IP：可以提供面向连接的服务也可以提供无连接服务</li><li>虚电路网络：X.25，FR，ATM：一定面向连接</li></ul><p>几种交换技术：</p><ul><li>电路交换：整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换：整个报文先传送到相邻结点，全部存储下来后，再转发到下一个结点。</li><li>分组交换：单个分组（只是整个报文的一部分）传送到相邻结点，存储下来后，再转发到下一个结点。</li></ul><h2 id="4、ISP"><a href="#4、ISP" class="headerlink" title="4、ISP"></a>4、ISP</h2><p>第一层：国家/国际级ISP</p><p>第二层：区域级ISP</p><p>第三层：本地ISP或接入ISP</p><h2 id="5、分组交换网络的延迟，丢失和吞吐量"><a href="#5、分组交换网络的延迟，丢失和吞吐量" class="headerlink" title="5、分组交换网络的延迟，丢失和吞吐量"></a>5、分组交换网络的延迟，丢失和吞吐量</h2><p><img src="https://s2.loli.net/2022/06/13/zl5a2YDkQjXbSUc.png" alt="image-20220613102703270"></p><ol><li><strong>节点（主机或路由器）处理时延</strong>：nodal processing delay 检查比特级的差错，检查分组头部，选择输出链路</li><li><strong>排队时延</strong>：queueing delay  等待被发送到输出链路上的时间 取决于拥塞程度</li><li><strong>传输时延</strong>：Transimission delay 发送分组比特流的时间 = L/R R=链路带宽 (bps) L=分组长度 (bits)</li><li><strong>传播时延</strong>：propagation delay 传播延迟 = d/s d = 物理链路长度 s = 介质的信号传播速度 (~2x108 m/sec)</li></ol><p>$$<br>d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}<br>$$</p><p><strong>流量强度</strong>(traffic intensity) = La/R  </p><p>a=平均分组到达速率  average packet arrival rate</p><ul><li>La/R ~ 0: 分组稀疏到达,无队列,平均排队延迟极小，接近于0</li><li>La/R -&gt; 1: 分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大</li><li>La/R &gt; 1: 输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大。</li></ul><p><strong>分组丢失</strong></p><ul><li>（1）路由器输入链路和输出链路的缓冲区容量有限</li><li>（2）当分组到达路由器输入链路发现缓冲区已满，则路由器只好丢弃分组</li><li>（3）当分组在路由器内部要转发到输出链路时，发现输出缓冲区队列已满，路由器只好丢弃分组</li></ul><p>丢失的分组可能被前路由节点、源节点重传，或不重传</p><p><strong>丢包率/分组丢失率</strong>（packet loss rate/ratio）= 丢包数÷已发分组总数</p><p>Traceroute可检测和度量端到端时延</p><p><strong>吞吐量</strong>(Throughout)：接收端接收到数据的比特速率 (bps ) <strong>min(Rc,Rs)</strong></p><ul><li>瞬时吞吐量: 某一瞬间的吞吐量</li><li>平均吞吐量: 一段时间内的吞吐量均值</li><li><strong>带宽是一条链路理论上的最大吞吐量</strong></li></ul><p>瓶颈链路(Bottleneck Link)：端到端路径中制约吞吐量的链路</p><h2 id="6、协议及其服务模型"><a href="#6、协议及其服务模型" class="headerlink" title="6、协议及其服务模型"></a>6、协议及其服务模型</h2><ul><li>（1）计算机网络体系结构分为很多层，每层完成一个特定功能，层和层之间相互协作，<strong>底层为上一层提供服务，上层使用底层提供的服务（服务模型），实现本层的功能，再为上一层提供服务。</strong> </li><li>（2）网络设计者以分层的方式组织协议，以及实现这些协议的网络软硬件。</li><li>（3）一个协议层能够用软件、硬件或者两者结合实现</li><li>（4）各层的所有协议称为协议栈，如因特网TCP/IP协议栈</li></ul><p>优点：</p><ul><li>使复杂系统简化</li><li>模块化的分层易于系统更新、维护</li></ul><p>缺点：</p><ul><li>有些功能可能在不同层重复出现：如，基于链路和基于端到端传输的差错恢复</li><li>某层的功能可能需要仅存在其他某层的信息（时间戳值）</li></ul><p><strong>协议栈</strong>(protocol stack)：各层所有协议的集合</p><p><strong>协议vs服务</strong></p><ul><li>（1）协议的实现保证了能够向上一层提供服务。本层的服务用户只能看见服务，而无法看见下面的协议。下 面的协议对上面的服务用户是透明的。</li><li>（2）协议是“水平的”，即协议是控制两个对等实体进行通信的规则。但服务是“垂直的”，即服务是由下层 通过层间接口向上层提供的。</li></ul><p><strong>ISO/OSI七层模型</strong></p><p><img src="https://s2.loli.net/2022/06/10/qHMl8G3aT2peNot.png" alt="image-20220610190503227"></p><p>表示层：通信用户之间数据格式的转换、数据压缩及加解密等。</p><p>会话层：对数据传输进行管理，包括数据交换的定界、同步，建立检查点等。 </p><p><strong>TCP/IP参考模型</strong></p><p><img src="https://s2.loli.net/2022/06/10/QtHeCZEau13jkvT.png" alt="image-20220610190542114"></p><p><img src="https://s2.loli.net/2022/06/10/M5RxgLh3zNri8Im.png" alt="image-20220610190615635"></p><p><strong>实体</strong>: 定义自身功能的硬/软件的集合</p><p><strong>对等实体</strong>: 两台计算机上同一层所属的程序、进程或实体称为该层的对等程序、对等进程或对等实体。</p><p>各层：</p><ul><li><p>分布式</p></li><li><p>在各节点的网络实体(entities) 实现了各层的功能</p><p>主机实现5层功能，路由器和交换机实现2-3层功能。</p></li><li><p>网络实体完成功能动作, 对等实体交换消息</p></li><li><p>传送不同的协议数据单元PDU(Packet Data Unit)</p><ul><li>每层传递的数据分为首部字段和有效载荷字段两部分。</li><li>有效载荷是相邻上层传下来的数据。</li></ul></li></ul><p>PDU：头部+负载，头部主要包括<strong>编址信息</strong>和<strong>控制信息</strong></p><p>PDU中的控制信息主要包括</p><ul><li><strong>地址</strong>（Address）: 标识发送端/接收端 </li><li><strong>差错检测编码</strong>（Error-detecting code）: 用于差错检测或纠正 </li><li><strong>协议控制</strong>（Protocol control）: 实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS）、 和安全控制等 </li></ul><h2 id="7、攻击威胁下的网络"><a href="#7、攻击威胁下的网络" class="headerlink" title="7、攻击威胁下的网络"></a>7、攻击威胁下的网络</h2><p>1、植入恶意软件</p><ul><li>病毒，病毒则在用户运行受感染文件后立即复制</li><li>蠕虫，蠕虫不需要任何人为操作即可复制</li><li>僵尸网络，植入恶意程序，使控制者通过相对集中若干计算机直接向大量计算机发送指令的攻击网络</li></ul><p>2、攻击服务器和网络基础设施</p><ul><li>拒绝服务攻击(Dos)</li><li>三种类型<ul><li>弱点攻击：向目标主机上易受攻击的应用程序和操作系统发送精细的报文</li><li>带宽洪泛：向目标主机发送大量分组</li><li>连接洪泛：利用目标主机创建半开或全开的TCP连接</li></ul></li></ul><p>3、嗅探分组</p><p>4、伪装</p><p>5、修改或删除报文</p><h2 id="8、发展史"><a href="#8、发展史" class="headerlink" title="8、发展史"></a>8、发展史</h2><p>Cerf and Kahn’s 开放网络体系结构的系统设计原则：</p><ul><li><strong>最简单化,自治原则</strong> – 网络独立运作，与其他网络互连时无须进行内部改动</li><li><strong>尽力服务原则</strong>– 提供尽最大努力的端到端服务</li><li><strong>无状态路由器</strong> – 路由器无须维护连接状态信息</li><li><strong>分布式控制</strong></li></ul><p>Bob Kahn和Vint Cerf设计了TCP/IP协议和互联网基础架构而被共同称为“互联网之父”</p><h1 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h1><h2 id="1、应用层协议原理"><a href="#1、应用层协议原理" class="headerlink" title="1、应用层协议原理"></a>1、应用层协议原理</h2><h3 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户/服务器体系结构"></a>客户/服务器体系结构</h3><p><strong>服务器</strong></p><ul><li>总是打开的主机</li><li>具有固定的、众所周知的IP地址</li><li>主机群集常被用于创建强大的虚拟服务器</li></ul><p><strong>客户机</strong></p><ul><li>同服务器端通信</li><li>可以间断的同服务器连接</li><li>可以拥有动态IP地址</li><li>客户机相互之间不直接通信</li></ul><h3 id="纯P2P体系结构"><a href="#纯P2P体系结构" class="headerlink" title="纯P2P体系结构"></a>纯P2P体系结构</h3><ul><li>没有总是打开的服务器</li><li>任意一对主机直接相互通信</li><li>对等方间歇连接并且可以改变IP地址</li></ul><p>优点：自扩展性</p><p>缺点：难以管理</p><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><ul><li>同一主机上的两个进程通过<strong>内部进程通信机制</strong>进行通信</li><li>不同主机上的进程通过<strong>交换报文</strong>相互通信</li><li>客户进程：发起通信的进程</li><li>服务器进程：等待联系的进程</li></ul><p><strong>套接字</strong>：应用程序编程接口API</p><p>进程寻址：IP+端口号</p><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><p><img src="https://s2.loli.net/2022/06/10/DVwNBrOLtRWIc5q.png" alt="image-20220610200124865"></p><h2 id="2、Web应用和HTTP协议"><a href="#2、Web应用和HTTP协议" class="headerlink" title="2、Web应用和HTTP协议"></a>2、Web应用和HTTP协议</h2><ul><li><strong>网页</strong>（Web页，或称文档）由许多对象组成。</li><li>对象就是文件，可以是HTML文件, JPEG图像, Java applet, 音频文件…</li><li>多数网页由单个基本HTML文件和若干个所引用的对象构成</li><li>每个对象被一个<strong>URL</strong>(Uniform Resource Locator统一资源定位符)寻址</li></ul><p><img src="https://s2.loli.net/2022/06/10/dT4DgLNim6xUjfc.png" alt="image-20220610200835934"></p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议  hypertext transfer protocol</p><p>HTTPS：<strong>443端口</strong></p><p>client/server模式</p><ul><li>client: 浏览器browser请求, 接收, “解释显示” Web对象</li><li>server: Web服务器响应请求,发送 Web对象</li></ul><p>使用TCP：</p><ul><li>客户初始化一个与HTTP服务器80端口的TCP连接 (创建套接字)</li><li>HTTP服务器接受来自客户的TCP连接请求, 建立连接</li><li>Browser (HTTP client)和Web服务器 (HTTP server) 交换HTTP消息(应用层协议消息)包括HTTP请求和响应消息</li><li>最后结束(或叫关闭)TCP连接</li></ul><p>HTTP是<strong>无状态协议</strong></p><p>非持久HTTP连接：每个TCP连接上<strong>只传送一个对象</strong>，下载多个对象需要建立多个TCP连接    HTTP/1.0</p><p>持久HTTP连接：一个TCP连接上可以传送<strong>多个对象</strong>  HTTP/1.1默认</p><p>非持久HTTP连接的问题：</p><ul><li><strong>每个对象需要2个RTT</strong></li><li>OS必须为每个TCP连接分配主机资源</li><li>大量客户的并发TCP连接形成服务器的严重负担</li></ul><p>持久HTTP连接：</p><ul><li>服务器发送响应消息后保持连接</li><li>同一客户/服务器的后续HTTP 消息继续在该连接上传送</li></ul><p>不带流水线的持久HTTP连接：</p><ul><li>客户先前响应消息收到,才发出新的请求消息</li><li><strong>每个引用对象经历1个RTT</strong></li></ul><p>带流水线的持久HTTP连接 ：</p><ul><li>HTTP/1.1默认使用</li><li>客户遇到1个引用对象就发送请求消息</li><li><strong>所有引用对象只经历1个RTT</strong></li></ul><h3 id="响应时间模型"><a href="#响应时间模型" class="headerlink" title="响应时间模型"></a>响应时间模型</h3><p><strong>往返时间RTT</strong>(Round-Trip Time)：1个小分组从客户主机到服务器再到客户主机所花费的时间</p><p><strong>响应时间</strong>：</p><ul><li>1个RTT用于建立TCP连接</li><li>1个RTT用于HTTP请求/响应消息的交互</li><li>Html文件传输时间</li><li>total = 2RTT+transmit time</li></ul><p><img src="https://s2.loli.net/2022/06/10/GXm82CeJs3lhoUA.png" alt="image-20220610201638950"></p><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p><strong>请求报文：</strong></p><p><img src="https://s2.loli.net/2022/06/10/wl1HOkfz3BjNhXV.png" alt="image-20220610202556513"></p><p><img src="https://s2.loli.net/2022/06/10/JwzyCfPNZdoVkR1.png" alt="image-20220610202258420"></p><p>HTTP/1.0</p><ul><li>GET</li><li>POST</li><li>HEAD：服务器收到请求时，用HTTP报文进行响应，但不返回请求对象</li></ul><p>HTTP/1.1</p><ul><li>GET, POST, HEAD</li><li>PUT：文件在实体主体中被上载到URL字段指定的路径</li><li>DELETE：删除URL字段指定的文件</li></ul><p><strong>响应报文：</strong></p><p><img src="https://s2.loli.net/2022/06/10/L29agkqr3w7nX8h.png" alt="image-20220610202615314"></p><p><strong>状态码：</strong></p><ul><li>200 OK 请求成功, 所请求信息在响应消息中返回</li><li>301 Moved Permanently 所请求的对象已永久迁移, 新的URL在本响应消息的（location：）头部指出</li><li>400 Bad Request 该请求不能被服务器解读</li><li>404 Not Found 服务器上不存在所请求文档</li><li>505 HTTP Version Not Supported</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>目的：提高用户和服务器的交互性</p><ul><li>cookie头部行在HTTP请求消息中</li><li>cookie头部行在HTTP响应消息中</li><li>cookie文件保存在<strong>用户主机</strong>中并被<strong>用户浏览器</strong>管理</li><li>cookie也保存在Web站点的<strong>后端数据库</strong></li></ul><p>客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个Set-Cookie的响应头，客户端会根据这个响应头存储Cookie信息。再次请求服务器时，客户端会在请求信息中包含一个Cookie请求头，而服务器会根据这个请求头进行用户身份、状态等校验。</p><p><img src="https://s2.loli.net/2022/06/14/qmeISuZ1Y46x8HX.png" alt="image-20220614100343836"></p><h3 id="Web缓存（代理服务器）"><a href="#Web缓存（代理服务器）" class="headerlink" title="Web缓存（代理服务器）"></a>Web缓存（代理服务器）</h3><p>目标:在不访问服务器的前提下满足客户端的HTTP请求</p><p>响应过程：</p><p><strong>浏览器向缓存/代理服务器发送所有的HTTP请求，如果所请求对象在缓存中，缓存器返回对象，否则缓存器向起始服务器发出请求，接收对象后转发给客户机。</strong></p><p><strong>缓存既充当客户端，也充当服务器</strong>，一般由ISP(Internet服务提供商)架设</p><p>优点：</p><ul><li>减少对客户机请求的响应时间</li><li>减少内部网络与接入链路上的通信量</li><li>能从整体上大大降低因特网上的Web流量</li></ul><p>条件GET方法</p><p>目的:证实缓存器中的对象是否为最新</p><p>缓存器：在请求报文中包含对象最后修改时间 <code>If-modified-since: &lt;date&gt;</code></p><p>服务器: 如果对象是最新的则响应报文中不包含对象: <code>HTTP/1.0 304 Not Modified</code></p><h2 id="3、文件传输协议FTP"><a href="#3、文件传输协议FTP" class="headerlink" title="3、文件传输协议FTP"></a>3、文件传输协议FTP</h2><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>File Transfer Protocol</p><p>传输文件到远程主机/从远程主机下载文件</p><p>client/server模式</p><ul><li>client: 发起传输的一方</li><li>server: 远程主机</li></ul><p><strong>端口号：21</strong></p><ul><li>FTP客户首先发起建立1个与FTP服务器端口号21之间的TCP控制连接</li><li>客户在建立的控制连接上获得身份认证</li><li>客户在建立的控制连接上发送命令来浏览远程主机的目录.</li><li>当服务器接收到1个文件传输命令时, 在服务器端口号20创建1个与客户的TCP数据连接1个文件传输后,服务器结束这个TCP数据连接.</li></ul><p>控制连接：</p><ul><li>USER-PI(protocol interpreter)：用户协议解释器</li><li>SERVER-PI：服务器协议解释器</li></ul><p>数据连接：</p><ul><li>user-DTP(Data Transfer Process)：用户数据传输进程</li><li>server-DTP：服务器数据传输进程</li></ul><h3 id="建立方式"><a href="#建立方式" class="headerlink" title="建立方式"></a>建立方式</h3><p>主动模式：</p><ul><li>客户端发送PORT命令<ul><li>PORT h1,h2,h3,h4,p1,p2  （h1-h4是IP地址，p1-p2是端口号）</li></ul></li><li>服务器根据PORT命令指定的客户端地址和端口号发起数据连接</li></ul><p>被动模式：</p><ul><li>客户端发送PASV命令</li><li>服务器返回监听的地址和端口号</li><li>客户端发起数据连接</li></ul><p>为什么有两种模式：很多网络禁止来自于外部的连接请求</p><h2 id="4、电子邮件SMTP、POP3、IMAP"><a href="#4、电子邮件SMTP、POP3、IMAP" class="headerlink" title="4、电子邮件SMTP、POP3、IMAP"></a>4、电子邮件SMTP、POP3、IMAP</h2><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>组成部分：</p><ul><li>用户代理user agents</li><li>邮件服务器mail servers </li><li>简单邮件传送协议和邮件接收协议</li></ul><p><strong>用户代理</strong>：</p><ul><li>允许用户阅读,回复,转发,保存,编辑邮件消息</li><li>发送, 接收邮件消息到/从服务器</li></ul><p><strong>邮件服务器</strong>：</p><p>邮箱mailbox 存放用户接收的邮件消息</p><p><strong>SMTP协议：</strong></p><ul><li>运行邮件服务器之间传递消息所使用的协议</li><li>客户端：发送消息的服务器</li><li>服务器：接收消息的服务器</li><li><strong>端口号：25</strong></li><li><strong>使用持久连接TCP</strong></li><li>要求邮件消息(header &amp; body)必须是7-bit ASCII</li><li>使用CRLF.CRLF 来判断邮件消息的结束</li></ul><p><strong>HTTP vs SMTP</strong></p><ul><li>HTTP：拉协议</li><li>SMTP：推协议</li><li>都有ASCII 命令/应答交互, 状态码</li><li>HTTP: 每个对象封装在它各自的HTTP响应消息中发送</li><li>SMTP: 一个邮件内各个对象置于同一个邮件消息的多目部分发送</li></ul><p><strong>MIME</strong>：Multipurpose Internet mail Extensions，多用途因特网邮件扩展，支持非ASCII码的邮件数据传输</p><h3 id="邮件访问协议POP、IMAP"><a href="#邮件访问协议POP、IMAP" class="headerlink" title="邮件访问协议POP、IMAP"></a>邮件访问协议POP、IMAP</h3><p>从服务器获取邮件信息</p><p><strong>POP</strong></p><ul><li><p>支持使用客户端远程管理在服务器上的电子邮件</p></li><li><p>使用TCP</p></li><li><p><strong>端口号 110</strong></p></li><li><p>身份认证阶段和传输阶段</p></li><li><p>会话是无状态的</p></li></ul><p><strong>IMAP</strong></p><ul><li><p>邮件客户端可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等</p></li><li><p><strong>端口号 143</strong></p></li><li><p>所有邮件消息保存在一个位置: 服务器</p></li><li><p>允许用户利用文件夹组织管理邮件消息</p></li><li><p>支持跨会话(Session)的用户状态</p></li><li><p>它与POP3协议的主要区别是用户可以不用把所有的邮件全部下载，可以通过客户端直接对服务器上的邮件进行操作。</p></li></ul><h2 id="5、DNS：因特网的目录服务"><a href="#5、DNS：因特网的目录服务" class="headerlink" title="5、DNS：因特网的目录服务"></a>5、DNS：因特网的目录服务</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统Domain Name System</p><p><strong>功能：</strong></p><ul><li>主机名到IP地址的转换</li><li>主机别名</li><li>邮件服务器别名</li><li>负载分配</li></ul><p><strong>特点：</strong></p><ul><li>分布式数据库</li><li><strong>应用层</strong>协议：DNS服务器实现域名转换</li><li>请求和回答报文使用<strong>53端口</strong></li><li>基于<strong>UDP</strong></li></ul><p><strong>分层：</strong></p><ul><li><strong>根名字服务器</strong>Root name servers 负责记录顶级域名服务器的信息</li><li><strong>顶级域名服务器</strong>top-level domain servers：负责顶级域名 com, org, net, edu, etc, 和所有国家的顶级域名 uk, fr, ca, jp</li><li><strong>权威DNS服务器</strong>authoritative DNS servers: 在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。组织机构的权威DNS服务器负责保存这些DNS记录</li><li><strong>本地DNS服务器</strong>Local DNS name server每个ISP（如居民区ISP、公司、大学）都有一个本地DNS，也加默认服务器</li></ul><p><strong>DNS查询方法：</strong></p><ul><li><strong>递归查询</strong>(recursive query)</li></ul><p><img src="https://s2.loli.net/2022/06/10/hgBewYoUQfvKNAc.png" alt="image-20220610212901725"></p><ul><li><strong>迭代查询</strong>(iterated query)<ul><li>被查询的名字服务器 回复可以被查询的名字服务器的IP地址</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/10/pudvbRAZ41J2VSI.png" alt="image-20220610213002852"></p><h3 id="DNS缓存和权威DNS记录更新"><a href="#DNS缓存和权威DNS记录更新" class="headerlink" title="DNS缓存和权威DNS记录更新"></a>DNS缓存和权威DNS记录更新</h3><ul><li>一旦名字服务器获得DNS映射, 它将缓存该映射到局部内存</li><li>服务器在一定时间后将丢弃缓存的信息</li><li>本地DNS服务器可以缓存TLD服务器的IP地址</li><li>因此根DNS服务器不会被经常访问</li></ul><p>权威DNS服务器记录更新：<strong>IETF动态更新/通报机制</strong></p><p>DNS: 存储资源记录(RR，Resource Records)的分布式数据库</p><p>假设用一个全新的浏览器（第一次启动的那种），访问百度（<a href="http://www.baidu.com/%EF%BC%89%EF%BC%8C%E5%9C%A8%E6%95%B2%E5%85%A5%E7%BD%91%E5%9D%80%E5%B9%B6%E6%8C%89%E4%B8%8B%E5%9B%9E%E8%BD%A6%E4%B9%8B%E5%90%8E%EF%BC%9A">http://www.baidu.com/），在敲入网址并按下回车之后：</a></p><p><strong>1、获得IP地址</strong></p><p>（1）首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p><p>（2）若没有命中，则继续搜索操作系统的 DNS 缓存（Linux,/etc/hosts; Windows, C:\WINDOWS\system32\drivers\etc\hosts）</p><p>（3）若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p><p>（4）若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p><p>​    本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器地址给本地服务器</p><p>​    本地域名服务器拿到顶级域名服务器地址后，向其发起请求，获取权威域名服务器地址</p><p>​    本地域名服务器根据权威域名服务器地址，向其发起请求，得到该域名对应的 IP 地址</p><p>   本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p><p>（5）操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存。浏览器得到域名对应的 IP 地址，并将 IP 地址缓存（<strong>缓存时间</strong>）。</p><p>2、和起始服务器（或者Web缓存/代理服务器），建立TCP连接</p><p>  得到百度的IP，下一步是使用TCP协议，建立TCP连接。</p><p>3、向起始服务器（或者Web缓存/代理服务器）发送请求报文，用HTTP协议请求网页内容，</p><p>4、浏览器收到响应报文，并解析。</p><p><img src="https://s2.loli.net/2022/06/10/u4HRrJlF289esmc.png" alt="image-20220610213254162"></p><ul><li><p>Type=<strong>A</strong>（Address）</p><ul><li>name = 主机名</li><li>value = IP地址</li></ul></li><li><p>Type=<strong>CNAME</strong>（canonical）</p><ul><li>name = 主机别名<br><a href="http://www.ibm.com的真名为servereast.backup2.ibm.com/">www.ibm.com的真名为servereast.backup2.ibm.com</a> </li><li>value = 真实的规范主机名</li></ul></li><li><p>Type=<strong>NS</strong>（ name server ）</p><ul><li>name = 域名（如foo.com） </li><li>value = 该域权威名字服务器的主机名</li></ul></li><li><p>Type=<strong>MX</strong>（mail exchange）</p><ul><li>name =邮件服务器的主机别名</li><li>value =邮件服务器的真实规范主机名</li></ul></li></ul><h3 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h3><p>查询报文和应答报文有相同的报文格式</p><p><img src="https://s2.loli.net/2022/06/10/LdDZohEe8XM9Qra.png" alt="image-20220610213653392"></p><p>报文头部：</p><ul><li><p>标识符: 16位，查询和应答报文使用相同的标识符</p></li><li><p>标志:有若干个标志构成，分别标识不同的功能</p><ul><li><p>查询/应答－0/ 1</p></li><li><p>查询希望是/非递归查询－1/0</p></li><li><p>应答可/否获得(支持)递归查询－1/0</p></li><li><p>应答是/否来自权威名字服务器－1/ 0</p></li></ul></li><li><p>问题：查询的Name, type</p></li><li><p>回答：对于查询,应答的资源记录。可以有多个资源记录，因为可以有多个IP地址</p></li><li><p>权威：域对应的权威名字服务器的信息</p></li><li><p>附加信息：权威名字服务器的IP地址等其他有帮助的记录</p></li></ul><p><img src="https://s2.loli.net/2022/06/10/T1BexCcqDWY9EVI.png" alt="image-20220610214026978"></p><p><img src="https://s2.loli.net/2022/06/10/xiJhC4HD9zUIuwG.png" alt="image-20220610214048859"></p><h3 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h3><ul><li>DDoS攻击：对根域名服务器或顶级域名服务器发起拒绝服务攻击</li><li>重定向攻击：中间人攻击、DNS中毒攻击（发送欺骗的域名解析结果给DNS服务器</li><li>利用DNS实现DDoS攻击： DNS反弹式拒绝服务攻击(DNS reflector attacks，又称DNS amplification attacks)。伪造客户地址向大量的dns服务器发出请求，导致客户无法访问dns服务器进行域名解析。</li></ul><h2 id="6、内容分发网络CDN"><a href="#6、内容分发网络CDN" class="headerlink" title="6、内容分发网络CDN"></a>6、内容分发网络CDN</h2><p>Content distribution networks</p><ul><li>将内容的拷贝存储在CDN节点中</li><li>用户向CDN请求内容<ul><li>被定向到附近的拷贝，取得内容</li><li>如果网络路径拥塞，则可能选择其他的拷贝</li></ul></li></ul><p>cdn访问流程</p><p><img src="https://s2.loli.net/2022/06/15/thx6A8rHiJ1Wqey.png" alt="image-20220615104559110"></p><h1 id="三、传输层"><a href="#三、传输层" class="headerlink" title="三、传输层"></a>三、传输层</h1><h2 id="1、传输层服务"><a href="#1、传输层服务" class="headerlink" title="1、传输层服务"></a>1、传输层服务</h2><p>在两个不同的主机上运行的<strong>应用程序</strong>（进程）之间提供逻辑通信机制</p><p>传输层协议运行在端系统 </p><ul><li>发送方: 将应用程序报文分成报文段传递给网络层, </li><li>接受方: 将报文段重新组装成报文传递到应用层</li><li>在网络层之上并依赖于网络层</li></ul><p>协议</p><ul><li>可靠按序提交（TCP) —— 拥塞控制、流量控制、连接建立</li><li>不可靠的无序传递（UDP）——“尽力传递”IP的直接扩展</li><li>两种服务均不保证——延迟、带宽</li></ul><h2 id="2、多路复用和多路分解"><a href="#2、多路复用和多路分解" class="headerlink" title="2、多路复用和多路分解"></a>2、多路复用和多路分解</h2><p><img src="https://s2.loli.net/2022/06/11/VJ4gsRHFBfuTObo.png" alt="image-20220611100836556"></p><ul><li>接收主机多路分解：将接收到的数据段传递到正确的套接字（多路分解）</li><li>发送主机多路复用：从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层(多路复用）</li></ul><p><strong>多路分解</strong></p><ul><li>主机收到IP数据报<ul><li>每个数据报有源IP地址，目的IP地址</li><li>每个数据报搬运一个报文段</li><li>每个报文段有源和目的端口号</li></ul></li><li>主机用IP地址和端口号指明报文段属于哪个合适的套接字</li></ul><p><img src="https://s2.loli.net/2022/06/11/hOaXtM79wWAcbzK.png" alt="image-20220611102353174"></p><p><strong>无连接多路分解</strong></p><ul><li>用端口号创建套接字</li><li>UDP 套接字由两个因素指定：(<strong>目的IP地址, 目的端口号</strong>)</li><li>当主机收到UDP报文段：检查报文段中的目的端口号、用端口号指示UDP报文段属于哪个套接字</li><li>来自不同的源IP地址且/或源端口号的IP报文报，导向同一个的套接字</li></ul><p><strong>面向连接的多路分解</strong></p><ul><li>TCP套接字由4部分指定：源IP地址、源端口号、目的IP地址、目的端口号</li><li>接收主机使用所有四个值将报文定位到合适的套接字</li><li>Web服务器对每个连接的客户都有不同的套接字</li></ul><h2 id="3、无连接传输：UDP"><a href="#3、无连接传输：UDP" class="headerlink" title="3、无连接传输：UDP"></a>3、无连接传输：UDP</h2><p>数据包协议：</p><ul><li>基于Internet IP协议<ul><li>复用/分用</li><li>简单的错误校验</li></ul></li><li>“尽最大努力”服务，报文段可能：<ul><li>丢失</li><li>会传递失序的报文到应用程序</li></ul></li><li>无连接：<ul><li>在UDP接收者发送者之间没有握手</li><li>每个UDP 报文段的处理独立于其他报文段</li></ul></li></ul><p>特点：</p><ul><li>不需要建立连接 (减少延迟)</li><li>简单: 在发送者接受者之间不需要连接状态</li><li>很小的报文段首部</li><li>没有拥塞控制: UDP 能够用尽可能快的速度传递</li><li>常用于流式多媒体应用：丢包容忍、速率敏感</li><li>其他UDP应用：DNS、SNMP、RTP</li><li>经UDP的可靠传输：在应用层增加可靠性、应用程序的差错恢复</li><li>UDP 是<strong>面向报文的</strong>。发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。一次发送一个报文。应用程序必须选择合适大小的报文<img src="https://s2.loli.net/2022/06/11/62PuNJvw7IVFnTK.png" alt="image-20220611103820101"></li></ul><p>在计算校验和时，临时把“伪首部”和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。</p><p><img src="https://s2.loli.net/2022/06/11/UVQK1erlvoitP6J.png" alt="image-20220611104425253"></p><h3 id="UDP校验和算法"><a href="#UDP校验和算法" class="headerlink" title="UDP校验和算法"></a>UDP校验和算法</h3><p>目标: 对传输的数据进行差错检测</p><p>发送方：</p><ul><li>将数据段看成16bit的整数序列</li><li>校验和: 数据段内容相加 (1的补码和)</li><li>发送者将校验和值放入UDP的校验和域</li></ul><p>接收方：</p><ul><li>计算接收到数据段的校验和</li><li>检查计算的校验和是否等于校验和域中的值：<ul><li>NO – 检测到错误</li><li>YES – 没有检测到错误</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/11/zDksaAVWeHXLBqC.png" alt="image-20220611104732503"></p><h2 id="4、可靠数据传输"><a href="#4、可靠数据传输" class="headerlink" title="4、可靠数据传输"></a>4、可靠数据传输</h2><p>使用有限状态机（FSM）来定义发送方和接收方</p><h3 id="Rdt1-0：完全可靠信道上的可靠数据传输"><a href="#Rdt1-0：完全可靠信道上的可靠数据传输" class="headerlink" title="Rdt1.0：完全可靠信道上的可靠数据传输"></a>Rdt1.0：完全可靠信道上的可靠数据传输</h3><ul><li><p>在完美可靠的信道上</p><ul><li>没有bit错误</li><li>没有分组丢失</li></ul></li><li><p>发送方，接收方分离的 FSMs :</p><ul><li>发送方发送数据到下层信道</li><li>接收方从下层信道接收数据</li></ul></li></ul><h3 id="Rdt2-0-具有bit错误的信道"><a href="#Rdt2-0-具有bit错误的信道" class="headerlink" title="Rdt2.0: 具有bit错误的信道"></a>Rdt2.0: 具有bit错误的信道</h3><p>下层信道可能让传输分组中的bit受损</p><ul><li>利用校验和检测位错误</li><li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li><li>否认 (NAKs):接收方明确告诉发送方 分组接收出错</li><li>发送方收到NAK后重发这个分组</li></ul><blockquote><p>基于重传机制的rdt协议称为ARQ（Automatic Repeat reQuest）协议</p></blockquote><p>发送方只有接受到ACK时才会继续发送分组 —— <strong>停等协议</strong></p><h3 id="rdt2-1-发送方处理破坏的-ACK-NAKs"><a href="#rdt2-1-发送方处理破坏的-ACK-NAKs" class="headerlink" title="rdt2.1: 发送方处理破坏的 ACK/NAKs"></a>rdt2.1: 发送方处理破坏的 ACK/NAKs</h3><p>发送方：</p><ul><li>发送方给每个分组增加序列号(Sequence number)</li><li>必须检查是否收到混淆的ACK/NAK</li><li>状态加倍：状态必须记住当前的分组是1号还是0号</li></ul><p>接收方：</p><ul><li>必须检查分组是否重复：当前所处的状态提供了期望收到的分组。</li><li>注意:接收方并不知道它的上一个ACK/NAK 是否被发送方正确收到</li></ul><h3 id="rdt2-2-无NAK的消息协议"><a href="#rdt2-2-无NAK的消息协议" class="headerlink" title="rdt2.2: 无NAK的消息协议"></a>rdt2.2: 无NAK的消息协议</h3><ul><li>接收方通过ACK告知最后一个被正确接收的分组</li><li>在ACK消息中显式地加入被确认分组的序列号</li><li>发送方收到重复ACK之后，采取与收到NAK消息相同的动作，即重传当前分组</li></ul><h3 id="rdt3-0-具有出错和丢失的信道"><a href="#rdt3-0-具有出错和丢失的信道" class="headerlink" title="rdt3.0: 具有出错和丢失的信道"></a>rdt3.0: 具有出错和丢失的信道</h3><p> 下层信道还要丢失报文 (数据或者 ACKs)</p><p>发送者等待“合理的”确认时间</p><ul><li>如果在这个时间内没有收到确认就重发</li><li>如果报文（或者确认）只是延迟 (没有丢失)：<ul><li>重发将导致重复，但是使用序号已经处理了这个问题</li><li>接受方必须指定被确认的报文序号</li></ul></li><li>要求<strong>倒计时定时器</strong>：只有在定时器超时时才触发重发</li></ul><p>缺点：性能差</p><h3 id="流水线技术"><a href="#流水线技术" class="headerlink" title="流水线技术"></a>流水线技术</h3><p>流水线: 发送方允许发送多个 “在路上的”, 还没有确认的报文</p><ul><li>序号数目的范围必须增加</li><li>在发送方/接收方必须有缓冲区</li></ul><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><ul><li>滑动窗口协议（ Sliding-window protocol ）</li><li>窗口<ul><li>允许使用的序列号范围</li><li>窗口尺寸为N：最多有N个等待确认的消息</li></ul></li><li>滑动窗口<ul><li>随着协议的运行，窗口在序列号空间内向前滑动</li></ul></li><li>滑动窗口协议：GBN, SR</li></ul><p><img src="https://s2.loli.net/2022/06/11/kF9h4vH8AY6blMP.png" alt="image-20220611113141392"></p><h3 id="Go-Back-N-GBN-协议"><a href="#Go-Back-N-GBN-协议" class="headerlink" title="Go-Back-N(GBN)协议"></a>Go-Back-N(GBN)协议</h3><p><strong>发送方</strong></p><p>分组头部包含k-bit序列号</p><p>窗口尺寸为N，最多允许N个分组未确认</p><p>ACK(n): 确认到序列号n(包含n)的分组均已被正确接收</p><ul><li>可能收到重复ACK</li></ul><p>对<strong>第一个发送未被确认的报文</strong>定时(timer)</p><ul><li>timeout(n):若超时，重传窗口中的分组n及所有更高序号的分组</li></ul><p><strong>接收方</strong></p><p>只有ACK: 对接收的分组总是发送具有最高按序序号的ACK</p><ul><li>可能产生冗余的ACKs</li><li>仅仅需要记住期望的序号值（expectedseqnum）</li></ul><p>对失序的分组: </p><ul><li>丢弃 (不缓存) -&gt; 没有接收缓冲区!</li><li>重新确认具有按序的分组</li></ul><h3 id="选择性重传-Selective-Repeat-SR"><a href="#选择性重传-Selective-Repeat-SR" class="headerlink" title="选择性重传(Selective Repeat,SR)"></a>选择性重传(Selective Repeat,SR)</h3><ul><li>接收方分别确认已经收到的分组<ul><li>必要时，缓冲报文, 最后按序提交给上层</li></ul></li><li>发送者只重发没有收到确认的分组<ul><li>对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器)</li></ul></li><li>发送窗口<ul><li>N 个连续序号</li><li>限制被发送的未确认的分组数量</li></ul></li></ul><p>发送方：</p><ul><li>从上层收到数据 :<ul><li>如果下一个可用的序号在发送方窗口内，则将数据打包并发送,启动定时器</li></ul></li><li>超时(n):<ul><li>重发分组n, 重启定时器</li></ul></li><li>收到ACK(n)在[sendbase,sendbase+N-1]内:<ul><li>标记分组n被接收</li><li>如果n是最小的未确认分组，则增加窗口基序号到下一个未被确认的序号</li></ul></li></ul><p>接收方：</p><ul><li>分组n的序号在[rcvbase, rcvbase+N-1]内<ul><li>发送ACK(n)</li><li>失序分组: 缓冲</li><li>有序分组: 交付上层 (包括已经缓冲的有序分组), 提高窗口到下一个没有接收的分组 </li></ul></li><li>分组n在[rcvbase-N,rcvbase-1]内<ul><li>发送ACK(n)</li></ul></li><li>其他:<ul><li>忽略</li></ul></li></ul><p>问题：</p><p><img src="https://s2.loli.net/2022/06/11/ROlmhL54qPT8owW.png" alt="image-20220611114249247"></p><p>解决方案：<strong>窗口小于或或等于序号空间大小的一半</strong></p><h2 id="5、TCP"><a href="#5、TCP" class="headerlink" title="5、TCP"></a>5、TCP</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>点到点：<ul><li>一个发送者,一个接收者</li></ul></li><li>可靠按序的<strong>字节流</strong>:<ul><li>没有“信息边界”</li></ul></li><li>流水线:<ul><li>TCP 拥塞和流量控制设置窗口大小</li></ul></li><li>收发缓冲区</li><li>全双工数据:<ul><li>同一个连接上的双向数据流</li><li>MSS: 最大报文段长 （maximum segment size)</li></ul></li><li>面向连接: <ul><li>在数据交换前握手(交换控制信息)</li><li>连接状态只在连接的两端中维护，在沿途节点中并不维护状态。</li><li>TCP连接包括：两台主机上的缓存、连接状态变量、socket等</li></ul></li><li>流量控制:<ul><li>发送方不会淹没接收方</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/11/cgpKuobt5yLUQX1.png" alt="image-20220611114935107"></p><h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p><img src="https://s2.loli.net/2022/06/11/RBxW4LoUtwDFsAh.png" alt="image-20220611115022079"></p><ul><li>端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段——占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段——占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>数据偏移（即首部长度）——占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</li><li>保留字段——占 6 位，保留为今后使用，但目前应置为 0</li><li>紧急 URG (URGent)—— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)</li><li>确认 ACK(ACKnowledgment) —— 只有当 ACK =1 时确认号字段才有效。当 ACK = 0 时，确认号无效。</li><li>复位 RST (ReSeT) —— 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接</li><li>同步 SYN(SYNchronize) —— 同步 SYN = 1 表示这是一个连接请求或连接接受报文</li><li>终止 FIN (FINis) —— 用来释放一个连接。FIN= 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</li><li>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节</li><li>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li><li>填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍。 </li></ul><h3 id="TCP序号与确认"><a href="#TCP序号与确认" class="headerlink" title="TCP序号与确认"></a>TCP序号与确认</h3><p>序号：</p><ul><li>数据段中第一个字节在数据流中的位置编号</li><li>建立TCP连接时，双方随机选择序列号</li></ul><p>确认ACKs：</p><ul><li>希望接收到的下一个字节的序列号</li><li>累计确认：该序列号之前的所有字节均已被正确接收到</li></ul><h3 id="TCP往返时延的估计值"><a href="#TCP往返时延的估计值" class="headerlink" title="TCP往返时延的估计值"></a>TCP往返时延的估计值</h3><p>太短：不必要额重传</p><p>太长：对数据段丢失响应慢</p><p>估计RTT：</p><p>样本RTT（SampleRTT）: 测量从报文段发送到收到确认的时间</p><p>样本RTT会变化,因此需要一个样本RTT均值（Estimated RTT）</p><ul><li>对收到的样本RTT要根据以下公式进行均值处理（指数加权移动平均，典型的：α=0.125）</li></ul><p>$$<br>EstimatedRTT = (1-α)<em>EstimatedRTT + α</em>SampleRTT<br>$$</p><ul><li>设置超时<ul><li>EstimtedRTT 加上 “安全余量”</li><li>EstimatedRTT变化大 -&gt; 更大的安全余量</li></ul></li><li>SampleRTT 偏离 EstimatedRTT多少的估计</li></ul><p>$$<br>DevRTT = (1-β)<em>DevRTT + β</em>|SampleRTT - EstimatedRTT|<br>$$</p><p>典型地，β = 0.25</p><ul><li>然后设置超时时间间隔：</li></ul><p>$$<br>TimeoutInterval = EstimatedRTT + 4*DevRTT<br>$$</p><ul><li>设置超时<ul><li>初始时TimeoutInterval设置为1秒</li><li>第一个样本RTT获得后， EstimatedRTT=SampleRTT，DevRTT=SampleRTT/2</li><li>TimeoutInterval = EsitimatedRTT +max(G,K*DevRTT)</li><li>(K=4，G是用户设置的时间粒度)</li></ul></li></ul><h3 id="可靠数据传输"><a href="#可靠数据传输" class="headerlink" title="可靠数据传输"></a>可靠数据传输</h3><p><strong>发送方事件</strong></p><ul><li>从应用程序接收数据：<ul><li>用序号创造一个报文</li><li>序号是报文中第一个数据字节在字节流中的位置编号</li><li>如果没有启动定时器，则启动定时器 （定时器是最早没有被确认的报文发送时启动的）</li><li>设置超时间隔: TimeOutInterval </li></ul></li><li>超时：<ul><li>重发导致超时的报文</li><li>重新开始定时器</li></ul></li><li>收到确认：<ul><li>如果ACK落在窗口之内，则确认对应的报文，并且滑动窗口</li><li>若还有未确认的报文，重新开始定时器</li></ul></li></ul><p><strong>产生TCP ACK的建议[rfc 5681]</strong></p><p><img src="https://s2.loli.net/2022/06/11/DzyutsnZv8BPJdQ.png" alt="image-20220611184948778"></p><h3 id="超时间隔加倍"><a href="#超时间隔加倍" class="headerlink" title="超时间隔加倍"></a>超时间隔加倍</h3><ul><li>TCP每次重传，都会把下一次的超时间隔设置为先前值的两倍。</li><li>但是当<strong>收到上层应用的数据</strong>和<strong>收到ACK</strong>两个事件中的任何一个发生时，定时器的TimeoutInterval值恢复为由近期的EstimatedRTT和DevRTT计算得到。</li><li>这种修改，提供了一种形式受限的拥塞控制。</li><li>缺陷：重传丢失报文之前要等待很长时间，增加了网络时延</li></ul><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><ul><li>发送方可以在超时之前通过重复的ACK检测丢失报文段<ul><li>发送方常常一个接一个地发送很多报文段</li><li>如果报文段丢失,则发送方将可能接收到很多重复的 ACKs</li></ul></li><li>如果发送方收到3次重复确认（4个对同样报文段的确认），则发送方认为该报文段之后的数据已经丢失。</li><li>启动快速重传: 在定时器超时之前重发丢失的报文段</li><li>接受方B会缓存正确接受但失序的报文段</li></ul><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p><img src="https://s2.loli.net/2022/06/11/tAmICkzyowYnM6u.png" alt="image-20220611185931639"></p><p>(假设 TCP 接收方丢弃失序的报文段)<br>缓冲区的剩余空间<br>= RcvWindow<br>= RcvBuffer-[LastByteRcvd - LastByteRead]</p><ul><li>接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间</li><li>Sender限制自己已经发送的但还未收到ACK的数据不超过接收方的空闲RcvWindow尺寸</li></ul><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><strong>三次握手</strong></p><ul><li>Step 1: 客户发送TCP SYN报文段到服务器<ul><li>指定初始的序号</li><li>没有数据</li></ul></li><li>Step 2: 服务器接收SYN, 回复 SYN/ACK 报文段<ul><li>服务器分配缓冲区</li><li>指定服务器的初始序号</li></ul></li><li>Step 3: 客户接收 SYN/ACK, 回复 ACK 报文段, 可能包含数据</li></ul><p><img src="https://s2.loli.net/2022/06/11/RVvkmBOgEShL62p.png" alt="image-20220611190617459"></p><p><strong>关闭连接</strong></p><ul><li>Step 1: 客户发送 TCP FIN 控制报文段到服务器 </li><li>Step 2: 服务器接收 FIN, 回复 ACK. 进入半关闭连接状态； </li><li>Step 3: 服务器发送FIN到客户，客户接收 FIN, 回复 ACK，<ul><li>进入 “time wait”状态</li><li>等待结束时释放连接资源</li></ul></li><li>Step 4: 服务器接收 ACK.  连接关闭</li></ul><p><img src="https://s2.loli.net/2022/06/11/rvDF79eNAoJqaKY.png" alt="image-20220611190631531"></p><h2 id="6、拥塞控制"><a href="#6、拥塞控制" class="headerlink" title="6、拥塞控制"></a>6、拥塞控制</h2><p>拥塞：从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”</p><p>表现：</p><ul><li>丢失分组 (路由器的缓冲区溢出)</li><li>长延迟 (在路由器的缓冲区排队)</li></ul><p>端到端拥塞控制:</p><ul><li>没有从网络中得到明确的反馈</li><li>从端系统观察到的丢失和延迟推断出拥塞</li><li>TCP采用的方法</li></ul><p>网络辅助的拥塞控制:</p><ul><li>路由器给端系统提供反馈</li><li>单bit指示拥塞 (SNA, DECnet, TCP/IP ECN, ATM)</li><li>指明发送者应该发送的速率</li></ul><h2 id="7、TCP拥塞控制"><a href="#7、TCP拥塞控制" class="headerlink" title="7、TCP拥塞控制"></a>7、TCP拥塞控制</h2><p><strong>AIMD(Additive-increase,multiplicative-decrease)</strong></p><ul><li>发送方增加传输速率（窗口大小），探测可用带宽，直到发生丢包事件</li><li>加性递增: 每个RTT内如果没有丢失事件发生，拥塞窗口增加一个MSS</li><li>乘性递减: 发生丢包事件后将拥塞窗口减半</li></ul><p><strong>慢启动(slow start)</strong></p><ul><li><p>连接开始的时候, CongWin = 1 MSS</p><ul><li>Example: MSS = 500 bytes &amp; RTT = 200 msec</li><li>初始速率 = 20 kbps</li></ul></li><li><p>有效带宽将 &gt;&gt; MSS/RTT</p><p>希望尽快达到期待的速率，故将以2的指数方式增加速率。</p></li><li><p>故以指数方式增加速率，直到产生丢失事件，或者达到某个阈值ssthresh</p></li><li><p>当连接开始的时候以指数方式增加速率:</p><ul><li>每收到一个ACK，CongWin =CongWin + 1MSS</li><li>在每个 RTT内倍增 CongWin</li><li>总结: 初始速率慢但是呈指数快速增长</li></ul></li></ul><p><strong>ssthread（阈值）变量</strong></p><ul><li>发送丢失事件后，ssthresh设置为丢失事件事件前的 CongWin 的1/2</li><li>当CongWin达到ssthresh时，从指数增加变为线性增加</li></ul><p>当超时事件发生以后:</p><ul><li>ssthresh= CongWin/2</li><li>CongWin 立即设置为 1个 MSS； </li><li>窗口开始指数增长（进入慢启动）</li></ul><p>收到三个重复的确认时：</p><ul><li>ssthresh= CongWin/2</li><li>CongWin 减半+3 (Reno版) </li><li>然后，进入线性增长（快速恢复）</li></ul><p>注：上述为TCP Reno版本的内容，在TCP Tahoe版本里，无论超时还是三个重复，都直接将CongWin 置为 1个 MSS</p><p>快速恢复阶段：</p><ul><li>对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的ACK，CongWin的值增加一个MSS。</li><li>最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin（cwnd = ssthresh）后，进入拥塞避免状态。</li></ul><p><img src="https://s2.loli.net/2022/06/11/HCaXQwAuq2ek1OR.png" alt="image-20220611194011972"></p><h1 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h1><h2 id="1、引言"><a href="#1、引言" class="headerlink" title="1、引言"></a>1、引言</h2><p>功能：</p><ul><li>从发送方主机传输<strong>报文段</strong>到接收方主机</li><li>发送方主机封装<strong>报文段</strong>(segments)为<strong>数据报</strong>(datagrams)</li><li>接收方主机递交报文段给传输层</li><li>在<strong>每个</strong>主机、路由器上都需要运行网络层协议</li><li>路由器会检查通过它的所有IP数据报的头部字段，然后根据目的IP地址对数据报进行转发</li></ul><p>转发(forwarding): 将分组从路由器的输入端口转移到正确的路由器输出端口<br>路由(routing): 确定分组从发送方传输到接收方(目的主机)所经过的路径(或路由)</p><ul><li><strong>数据平面</strong><ul><li><strong>本地的</strong>，每个路由器自身的功能</li><li>决定抵达路由器输入端口的数据包如何转发到输出端口</li></ul></li><li><strong>控制平面</strong><ul><li><strong>整个网络范围</strong></li><li>决定数据报在端到端路径上的路由器之间如何路由</li><li>两种数据平面的实现方式：</li><li>传统的路由算法: 在路由器内实现</li><li>软件定义网络（software-defined networking, SDN): 在远程服务器上实现</li></ul></li></ul><p>网络层可能提供的服务</p><ul><li><strong>确保交付</strong>：确保分组到达目的地。</li><li><strong>具有时延上界的确保交付</strong>：主机到主机的时延。</li><li><strong>有序分组交付</strong>：按发送顺序到达。</li><li><strong>确保最小带宽</strong>：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li><li><strong>确保最大时延抖动</strong>：发送方发送两个连续分组的时间间隔与接收到的间隔相同</li></ul><p>因特网的网络层提供的服务</p><ul><li>单一服务，即<strong>尽力而为服务</strong>(best-effort service) 。</li><li>分组间的定时不能被保证；</li><li>分组的接收顺序与发送顺序不一定相同；</li><li>传送的分组不能保证最终交付，即网络可能未向目的地交付分组。</li></ul><h2 id="2、虚电路和数据报网络"><a href="#2、虚电路和数据报网络" class="headerlink" title="2、虚电路和数据报网络"></a>2、虚电路和数据报网络</h2><ul><li><strong>数据报</strong> 网络提供网络层的<strong>无连接</strong> 服务</li><li><strong>虚电路</strong> 网络提供网络层的 <strong>连接</strong> 服务</li></ul><p>传输层：面向连接服务在网络边缘的<strong>端系统</strong>中实现。<br>网络层：面向连接服务在<strong>端系统及网络核心的路由器</strong>中实现</p><h3 id="数据报网络"><a href="#数据报网络" class="headerlink" title="数据报网络"></a>数据报网络</h3><ul><li>在网络层<strong>无呼叫</strong>的过程</li><li>路由器： 不需要维护端到端连接的状态</li><li>没有网络等级的“连接”的概念</li><li>使用目的主机的地址进行分组转发</li></ul><p>对于给定目的地址，使用<strong>最长地址</strong>前缀匹配来完成输出端口的查找</p><p>即：用目的地址前缀与转发表的前缀匹配</p><ul><li>存在匹配：向对应链路转发</li><li>不存在匹配：选择“其他”项对应的链路转发。</li><li>存在多个匹配：使用最长前缀匹配规则，即向与最长前缀匹配的链路接口转发分组。</li></ul><p>说明：</p><ul><li>路由器转发表只维持转发状态信息；</li><li>转发表由选路算法修改（1～5分钟更新）；</li><li>一个端系统发送给另一个端系统的<strong>一批分组可能在网络中选择不同的路径，到达的顺序可能不一致</strong>。</li></ul><p>特点：</p><ul><li>网络层模型简单</li><li>端系统功能复杂：高层实现许多功能，如按序传送、可靠数据传输、拥塞控制与DNS名字解析等</li><li>因特网服务模型提供的服务保证最少（可能没有！），对网络层的需求最小，使得互连使用各种不同链路层技术的网络变得更加容易。</li></ul><h2 id="3、路由器工作原理"><a href="#3、路由器工作原理" class="headerlink" title="3、路由器工作原理"></a>3、路由器工作原理</h2><p>体系结构：</p><p><img src="https://s2.loli.net/2022/06/11/sQidL9SINM3Gq1f.png" alt="image-20220611213448382"></p><p>核心功能：</p><ul><li>运行路由算法/协议(OSPF, RIP, BGP)</li><li>将分组从路由器的输入链路传送到正确的输出链路。</li></ul><h3 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h3><p><strong>功能</strong>：</p><ul><li>第一个<strong>线路端接</strong>模块：将一条<strong>物理链路端接到路由器</strong>的物理层；</li><li>第二个<strong>数据链路处理</strong>模块：实现路由器的<strong>数据链路层功能</strong>；</li><li>第三个<strong>查找与转发</strong>模块：实现<strong>查找与转发</strong>功能，通过查找<strong>转发表</strong>分组通过路由器交换结构转发到适当的输出端口；<img src="https://s2.loli.net/2022/06/11/NitMHnGkJoq7sRP.png" alt="image-20220611213720079"></li></ul><p>分布式交换：</p><ul><li><strong>选路处理器</strong>计算转发表，给<strong>每个输入端口存放一份转发表拷贝</strong>。</li><li>在每个输入端口本地做出交换决策，无须激活<strong>中央选路处理器</strong>。</li><li>可避免在路由器中某个单点产生转发处理瓶颈。</li><li>目的：以线速完成输入端口的处理</li><li>排队：如果数据报到达输入端口的速度快于输入端口将数据报转发到交换结构的速度，就会发生排队</li></ul><p><strong>排队</strong></p><ul><li>当交换结构的速度慢于输入端口的速度，就会在输入端口的缓冲区发生排队<ul><li>导致排队延时和由于输入缓冲区溢出导致的丢包！</li></ul></li><li><strong>线头阻塞</strong>（Head-of-the-Line (HOL) blocking）: 在队列前面的被阻塞的数据报会阻止队列中的其他数据报被转发。</li></ul><p><img src="https://s2.loli.net/2022/06/11/Tt3uRw4h2jclafN.png" alt="image-20220611215410902"></p><p><strong>交换结构</strong>：</p><ul><li>将分组从输入端口缓存交换（转发）到恰当的输出端口缓存中</li><li>三种交换结构<ul><li>内存</li><li>总线</li><li>纵横式</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/11/AqyhQBEXi9wYUaS.png" alt="image-20220611214140469"></p><h3 id="经内存的交换结构"><a href="#经内存的交换结构" class="headerlink" title="经内存的交换结构"></a>经内存的交换结构</h3><ul><li>早期用计算机作为路由器时采用的结构(第一代)<ul><li>输入端口与输出端口之间的交换由**CPU(选路处理器)**控制完成；</li></ul></li><li>输入端口与输出端口类似I/O设备：<ul><li>当分组到达输入端口时，通过<strong>中断</strong>向<strong>选路处理器</strong>发出信号，将分组拷贝到<strong>处理器内存</strong>中；</li><li>选路处理器根据分组中的<strong>目的地址</strong>查表找出适当的<strong>输出端口</strong>，将该分组拷贝到<strong>输出端口的缓存</strong>中。</li></ul></li><li>交换速度受<strong>总线带宽</strong>的速度限制 (每个分组穿过两次总线)</li></ul><h3 id="经总线的交换结构"><a href="#经总线的交换结构" class="headerlink" title="经总线的交换结构"></a>经总线的交换结构</h3><ul><li>输入端口通过一条<strong>共享总线</strong>将分组直接传送到输出端口，不需要<strong>选路处理器的干预</strong>。</li><li>每次只能有一个分组通过总线传送。</li><li>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li><li>路由器交换带宽受<strong>总线速率</strong>限制。</li></ul><h3 id="经交换矩阵交换结构"><a href="#经交换矩阵交换结构" class="headerlink" title="经交换矩阵交换结构"></a>经交换矩阵交换结构</h3><ul><li><strong>纵横式交换机</strong>：由2n 条总线组成，n 个输入端口与n 个输出端口连接。</li><li>到达输入端口的分组沿<strong>水平总线</strong>穿行，直至与所希望的输出端口的<strong>垂直总线</strong>交叉点：<ul><li>若该条垂直总线空闲，则分组被传送到输出端口；</li><li>否则，该到达的分组被阻塞，必须在输入端口排队。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/11/3rtICzvF2nlWZ7x.png" alt="image-20220611214847576"></p><p>高级设计: 数据报分割成固定长度信元, 通过交换矩阵来交换信元</p><h3 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h3><ul><li>取出存放在<strong>输出端口内存</strong>中的分组，并将其传输到<strong>输出链路</strong>上。</li><li>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要<strong>排队与缓存管理</strong>功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</li></ul><p><img src="https://s2.loli.net/2022/06/11/WfXlmh9a6sNIcBz.png" alt="image-20220611215156431"></p><h2 id="4、网际协议：因特网中的转发和编址"><a href="#4、网际协议：因特网中的转发和编址" class="headerlink" title="4、网际协议：因特网中的转发和编址"></a>4、网际协议：因特网中的转发和编址</h2><h3 id="IP数据报-IPv4"><a href="#IP数据报-IPv4" class="headerlink" title="IP数据报(IPv4)"></a>IP数据报(IPv4)</h3><p><img src="https://s2.loli.net/2022/06/11/MLzilXPd8gZG2Op.png" alt="image-20220611220202357"></p><ul><li><strong>版本号</strong>：4位，IP协议版本号（4,6）</li><li><strong>首部长度</strong>：4位，IP分组首部长度，以4字节为单位</li><li><strong>服务类型</strong>(TOS,terms of service)字段占8位：指示期望获得哪种类型的服务 <ul><li>1998 年这个字段改名为<strong>区分服务</strong> </li><li>只有在网络提供区分服务(DiffServ)时使用 </li><li>一般情况下不使用，通常IP分组的该字段(第2字节)的值为00H </li></ul></li><li><strong>数据报长度</strong>：16位：IP分组的总字节数（首部+数据）<ul><li>最大IP分组的总长度：65535B ，最小的IP分组首部：20B</li><li>IP分组可以封装的最大数据：65535-20 =65515B</li></ul></li><li><strong>16-bit标识符</strong>：16位，标识一个IP分组<ul><li>IP协议利用一个计数器，每产生IP<strong>分组计数器</strong>加1，作为该IP分组的标识</li></ul></li><li><strong>标志位字段</strong>：3位，第一位保留，第二位<strong>DF</strong>(Don’t Fragment)，第三位<strong>MF</strong>(More Fragment)<ul><li>DF =1：禁止分片； DF =0：允许分片，MF =1：非最后一片； MF =0：最后一片(或未分片) </li></ul></li><li><strong>片位移</strong>：13位，一个IP分组分片封装原IP分组数据的相对偏移量 <ul><li>片偏移字段以8字节为单位 </li></ul></li><li><strong>寿命</strong>(TTL,Time To Live)：8位，IP分组在网络中可以通过的路由器数（或跳步数）<ul><li>路由器转发一次分组，TTL减1 </li><li>如果TTL=0，路由器则丢弃该IP分组 </li></ul></li><li><strong>上层协议</strong>：8位，指示IP分组封装的是哪个协议的数据包 <ul><li>实现复用/分解 </li><li>6 —— TCP，17——UDP</li></ul></li><li><strong>首部校验和</strong>：16位，实现对IP分组首部的差错检测 <ul><li>计算校验和时，该字段置全0 </li><li>采用反码算数运算求和，和的反码作为首部校验和字段</li><li><strong>逐跳</strong>计算并校验</li></ul></li><li><strong>源IP，目的IP</strong>：32位，分组的源主机/路由器(网络接口)和接收分组的目的主机/路由器（网络接口）的IP地址</li><li><strong>选项字段</strong>占长度可变，范围在1~40B之间：携带安全、源选路径、时间戳和路由记录等内容 ，一般不用</li><li><strong>填充字段</strong>占长度可变，范围在0~3B之间：目的是补齐整个首部，符合32位对齐，即保证首部长度是4字节的倍数</li></ul><h3 id="IP数据报分片和重组"><a href="#IP数据报分片和重组" class="headerlink" title="IP数据报分片和重组"></a>IP数据报分片和重组</h3><ul><li>网络链路存在MTU (最大传输单元,Maximum Transmission Unit) —<strong>链路层数据帧</strong>可封装数据的上限</li><li>不同链路的MTU不同</li><li>在因特网中，一个大的分组可能在路由器中被分割为几个<strong>分片</strong>(fragmented)，在最终的目的主机上，将这些分片重新<strong>组装</strong>（reassembled）成一个大的分组</li><li>IP首部的相关字段用 于标识分片以及确定 分片的相对顺序<ul><li>总长度、标识、标志 位和片偏移，见前文数据报文 </li></ul></li></ul><p>假设原IP分组总长度为L，待转发链路的MTU为M，若L&gt;M，且DF=0，则可以/需要分片 。 一个最大分片可封装的数据应该是8的倍数，因此一个最大分片可封装的数据（向下取整）：<br>$$<br>d=\left [ \frac{M-20}{8}  \right ]×8<br>$$<br>需要的总片数（向上取整）为：<br>$$<br>n=\left [ \frac{L-20}{d}  \right ]<br>$$<br>每片的片偏移字段取值为：<br>$$<br>F_{i}= \frac{d}{8}  ×(i-1),1≤i≤n<br>$$</p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>路由器和主机可以有多个接口，每个接口有一个IP地址</p><ul><li>IPV4：32个二进制位长（4字节），常用点分十进制表示；</li><li>IPV6：128个二进制位长（16字节）常用冒号分隔表示</li></ul><p><img src="https://s2.loli.net/2022/06/11/6MNqwQZE7eiK4lU.png" alt="image-20220611223304502"></p><p>早期分成的五类IP地址：</p><ul><li>A类地址的第一位为“0”<ul><li>范围： 1. 0. 0. 1－127.255.255.254</li></ul></li><li>B类地址的前两位为“10”<ul><li>范围：128.0.0.1－191.255.255.254</li></ul></li><li>C类地址的前三位为“110”<ul><li>范围：192.0.0.1－223.255.255.254</li></ul></li><li>D类地址的前四位为“1110”<ul><li>范围：192.0.0.1－223.255.255.254</li><li>用于其他特殊用途，如多播地址Multicasting</li></ul></li><li>E类地址的前五位为“11110”<ul><li>范围：240.0.0.0～255.255.255.255</li><li>用于某些实验和将来使用</li></ul></li></ul><p><strong>前三类</strong>为基本的IP地址</p><p>特殊IP地址：</p><ul><li><strong>本地回环地址</strong><ul><li>范围：127.0.0.1-127.255.255.254 </li><li>预留的一组IP地址，主要是用来识别主机本身的地址。也叫做“localhost”，一般用来测试</li></ul></li><li><strong>私有地址</strong>（Private address）<ul><li>10.x.x.x,  172.16.x.x-172.31.x.x,  192.168.x.x</li><li>这三个地址段被称为私有IP地址段，也就是局域网所使用的地址段，在公网上不能被路由</li></ul></li><li>0.0.0.0<ul><li>严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址</li></ul></li><li>255.255.255.255<ul><li>受限的广播地址。主要指一个网段内的所有主机</li></ul></li></ul><p>IP地址：</p><ul><li>网络号：指明主机所在网络的编号。</li><li>主机号：主机在网络中的编号。</li></ul><p>IP子网(subnet)：</p><ul><li> IP地址具有相同网络号的设备接口 </li><li> 不跨越路由器（第三及以上层网络设备）可以彼此<strong>物理联通</strong>的接口</li></ul><p>路由器总是具有<strong>两个或两个以上IP地址</strong>。</p><p>当两个路由器直接相连时，在连线两端的接口处，可以指明IP地址也可以不指明IP地址。</p><h3 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h3><p><strong>从主机号借用若干个比特作为子网号，剩下的主机位为主机号</strong></p><p><strong>子网掩码</strong>：用来确定网络地址（网络号+子网号）和主机地址的长度</p><p>子网掩码长为32位比特，其中的1对应于IP地址中的网络号和子网号，而子网掩码中的0对应于主机号。</p><h3 id="使用子网掩码的分组转发"><a href="#使用子网掩码的分组转发" class="headerlink" title="使用子网掩码的分组转发"></a>使用子网掩码的分组转发</h3><p>不划分子网时，路由表只有两项：目的网络地址和下一跳地址，例如</p><p><img src="https://s2.loli.net/2022/06/11/8JXg5KHYr1qyTGP.png" alt="image-20220611230336846"></p><p>使用子网划分后，路由表中包括三项：目的网络地址、子网掩码和下一跳地址</p><p><img src="https://s2.loli.net/2022/06/11/4dDvEjua1tnr6hQ.png" alt="image-20220611230456648"></p><p><img src="https://s2.loli.net/2022/06/11/LN8ItaH7pwCXmOR.png" alt="image-20220611230503070"></p><p>主机H1首先要进行的操作时把本子网的子网掩码 255.255.255.128与目的IP 128.30.33.138进行与操作。得到128.30.33.128，它不等于H1的网络地址，所以不在一个子网上。因此H1把分组交互给子网上的默认路由器R1。</p><h3 id="CIDR无分类域间路由"><a href="#CIDR无分类域间路由" class="headerlink" title="CIDR无分类域间路由"></a>CIDR无分类域间路由</h3><p>传统IP地址A类会造成地址浪费，C类又不够用</p><p>Classless Inter-Domain Routing</p><p>CIDR消除了传统的A类、B类和C类地址的概念。网络前缀可以任意长度</p><p>CIDR将<strong>网络前缀都相同的连续的IP地址</strong>组成“CIDR地址块“</p><p>地址格式 a.b.c.d/x，x为前缀长度</p><p><strong>路由聚合</strong>（route aggregation）： 一个CIDR地址块可以表示分类IP的多个分类地址，这种地址的聚合称为路由聚合，又称为构造<strong>超网</strong>（supernetting）</p><p><img src="https://s2.loli.net/2022/06/11/X9twYxJpeKni8Su.png" alt="image-20220611231008807"></p><h3 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h3><p>Dynamic Host Configuration Protocol</p><p>即插即用 plug-and-play</p><p><strong>端口号 67/68</strong></p><ul><li>主机广播 “DHCP DISCOVER” （发现报文）</li><li>DHCP 服务器用 “DHCP OFFER” （提供报文）进行响应</li><li>主机请求IP地址: “DHCP REQUEST” （请求报文）</li><li>DHCP 服务器分配IP地址 “DHCP ACK/NACK” （确认报文）</li><li>DHCP 终止租用期”DHCP RELEASE”（终止报文）</li></ul><p><strong>工作过程</strong></p><p><img src="https://s2.loli.net/2022/06/12/M8T5JSqIk6RYBiW.png" alt="image-20220612094830340"></p><p><img src="https://s2.loli.net/2022/06/12/uLE5pCs6TPtjqRv.png" alt="image-20220612095538533"></p><ol><li>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。</li><li>DHCP 客户从 UDP 端口 68发送 DHCP 发现报文</li><li>凡收到 DHCP 发现报文的 DHCP 服务器都发出 DHCP 提供报文，因此 DHCP 客户可能收到<strong>多个 DHCP 提供报文</strong>。</li><li>DHCP 客户从几个 DHCP 服务器中选择<strong>其中的一个</strong>，并向所选择的 DHCP 服务器发送 DHCP 请求报文。</li><li>被选择的 DHCP 服务器发送确认报文DHCPACK，客户进入已绑定状态，并可开始使用得到的临时 IP 地址了。DHCP 客户根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期</li><li>租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。</li><li>DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤2）</li><li>DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤6），然后又继续后面的步骤。</li><li>DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。</li></ol><p>DHCP分配的不仅仅是IP地址，还可分配：</p><ul><li>客户的第一跳路由器的地址（网关）</li><li>DNS服务器的IP地址或域名</li><li>子网掩码</li></ul><p><strong>DHCP是应用层协议</strong></p><ul><li>请求报文封装到<strong>UDP数据报</strong>中 </li><li>IP广播 </li><li>链路层广播</li></ul><h3 id="NAT网络地址转换"><a href="#NAT网络地址转换" class="headerlink" title="NAT网络地址转换"></a>NAT网络地址转换</h3><p>Network Address Translation</p><p>IP地址中的网络号部分是从ISP的地址空间中划分一块给申请者，而ISP是从ICANN获取到的地址块</p><p>ICANN（Internet Corporation for Assigned Names and Numbers）</p><ul><li>分配IP地址</li><li>管理DNS</li><li>分配域名，解决纠纷</li></ul><p><img src="https://s2.loli.net/2022/06/12/1toZIBCndwG4TS5.png" alt="image-20220612100702651"></p><p>动机: </p><ul><li>只需/能从ISP申请一个IP地址</li><li>IPv4地址耗尽 </li><li>本地网络设备IP地址的变更，无需通告外界网络 </li><li>变更ISP时，无需修改内部网络设备IP地址 </li><li>内部网络设备对外界网络不可见，即不可直接寻址(安全) </li></ul><p>实现：</p><ul><li><strong>替换</strong>：利用(NAT IP地址,新端口号)替换每个外出IP数据报的(源IP地址,源端口号)</li><li><strong>记录</strong> :将每对(NAT IP地址, 新端口号) 与(源IP地址, 源端口号)的替换信息存储到NAT转换表 </li><li><strong>替换</strong> :根据NAT转换表，利用(源IP地址, 源端口号)替换每个进入内网IP数据报的(目的IP地址,目的端口号)，即(NAT IP地址, 新端口号) </li></ul><p><img src="https://s2.loli.net/2022/06/12/pFozxkCV2hnRZ9N.png" alt="image-20220612101016928"></p><ul><li>16-bit 端口号: <ul><li>一个局域网地址可以同时支持60,000个并发连接!</li></ul></li><li>NAT 存在争议<ul><li>路由器只应该处理到第三层（传输层）</li><li>违反了端到端主张</li></ul></li><li>应用程序设计者在设计时不得不将NAT加以考虑，如P2P应用程序</li><li>应使用IPv6来解决地址短缺问题</li></ul><h3 id="因特网控制报文协议ICMP"><a href="#因特网控制报文协议ICMP" class="headerlink" title="因特网控制报文协议ICMP"></a>因特网控制报文协议ICMP</h3><p>Internet Control Message Protocol</p><p>用于主机路由器之间彼此交流网络层信息</p><p>差错报告（5种）</p><ul><li>目的（主机、网络、协议、端口）不可达</li><li>源抑制(Source Quench) </li><li>超时/超期</li><li>参数问题</li><li>重定向</li></ul><p>网络探询(2种）</p><ul><li>回声(Echo)请求与应答报文(Reply)：ping </li><li>时间戳请求与应答报文：tracerouter </li></ul><p><strong>ICMP报文</strong>：</p><p><img src="https://s2.loli.net/2022/06/12/9qJAZLP8QkNblog.png" alt="image-20220612102102654"></p><p><img src="https://s2.loli.net/2022/06/12/XJ3OcxsBmZjHYuh.png" alt="image-20220612102201509"></p><p><strong>Traceroute</strong></p><ul><li><p>源端发送一系列的UDP分组给目的端</p><ul><li>第一个分组  TTL =1</li><li>第二个 TTL=2, 等等</li></ul></li><li><p>当第n个分组到达第n个路由器时</p><ul><li>路由器丢弃该分组</li><li>并给源端发送一个ICMP报文 (type 11, code 0)</li><li>这个报文包含了<strong>路由器的名称</strong>和<strong>IP地址</strong></li></ul></li><li><p>当源端收到ICMP报文时，计算传输往返时间RTT</p><ul><li>对每个TTL作三次</li></ul></li><li><p>停止发送的依据：</p><ul><li>UDP报文最终到达目的端</li><li>目的端返回回应应答的 ICMP 报文(type3, code3)</li><li>源端停止发送</li></ul></li></ul><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>动机：</p><ul><li>32-bit IPv4地址空间即将用尽</li><li>快速处理/转发数据报</li><li>支持QoS（服务质量）</li></ul><p>IPv6 数据报格式：</p><ul><li>固定长度的 40 字节基本首部 </li><li>不允许分片</li></ul><p><img src="https://s2.loli.net/2022/06/12/guwZP78hXMdbn91.png" alt="image-20220612102900340"></p><p><strong>地址表示</strong></p><p>IPv6地址为<strong>128位长</strong>，但通常写作8组，每组为四个十六进制数的形式。例如</p><pre class="line-numbers language-none"><code class="language-none">2001:0db8:85a3:08d3:1319:8a2e:0370:7344<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">2001:0db8:85a3:08d3:1319:8a2e:0370:7344<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是一个合法的IPv6地址。</p><p>如果四个数字都是零，可以被省略。例如：</p><pre class="line-numbers language-none"><code class="language-none">2001:0db8:85a3:0000:1319:8a2e:0370:7344<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>等价于</p><pre class="line-numbers language-none"><code class="language-none">2001:0db8:85a3::1319:8a2e:0370:7344<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>遵从这些规则，如果因为省略而出现了两个以上的冒号的话，可以压缩为一个，但这种零压缩在地址中只能出现一次。因此：</p><pre class="line-numbers language-none"><code class="language-none">2001:0DB8:0000:0000:0000:0000:1428:57ab2001:0DB8:0000:0000:0000::1428:57ab2001:0DB8:0:0:0:0:1428:57ab2001:0DB8:0::0:1428:57ab2001:0DB8::1428:57ab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>都使合法的地址，并且他们是等价的。但</p><pre class="line-numbers language-none"><code class="language-none">2001::25de::cade<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>是非法的。(因为这样会使得搞不清楚每个压缩中有几个全零的分组)</p><p>同时前导的零可以省略，因此：</p><pre class="line-numbers language-none"><code class="language-none">2001:0DB8:02de::0e13等价于2001:DB8:2de::e13<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果这个地址实际上是IPv4的地址，后32位可以用10进制数表示；因此：</p><p>ffff:192.168.89.9 等价于 ::ffff:c0a8:5909, 但不等价于 ::192.168.89.9 和 ::c0a8:5909。</p><p>ffff:1.2.3.4格式叫做 <strong>IPv4映像地址</strong>，是不建议使用的。而::1.2.3.4格式叫做 <strong>IPv4一致地址</strong></p><p>IPv4 地址可以很容易的转化为IPv6格式。举例来说，如果IPv4的一个地址为135.75.43.52(十六进制为0x874B2B34)，它可以被转化为0000:0000:0000:0000:0000:0000:874B:2B34或者::874B:2B34。同时，还可以使用混合符号(IPv4-compatible address)，则地址可以为::135.75.43.52。</p><h2 id="5、路由和选路"><a href="#5、路由和选路" class="headerlink" title="5、路由和选路"></a>5、路由和选路</h2><h3 id="选路算法"><a href="#选路算法" class="headerlink" title="选路算法"></a>选路算法</h3><ul><li>路由算法确定了通过网络的端到端路径</li><li>转发表确定了在路由器上的本地转发</li></ul><p><img src="https://s2.loli.net/2022/06/12/5i6vfQYgmJXZByU.png" alt="image-20220612104207885"></p><p><strong>默认路由器</strong>：与主机直接相连的路由器，又叫<strong>第一跳路由器</strong>。每当主机发送一个分组时，都先传送给它的默认路由器。</p><ul><li><strong>源路由器</strong>：源主机的默认路由器。</li><li><strong>目的路由器</strong>：目的主机的默认路由器。</li><li>从源主机到目的主机的选路归结为从<strong>源路由器到目的路由器</strong>的选路。</li></ul><p>路由算法：是确定一个分组从源路由器到目的路由器所经路径的算法</p><p>路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的“好”路径，即具有“最低费用”的路径</p><p>分类</p><ul><li><p><strong>全局路由算法</strong>：所有路由器拥有完整的网络拓扑信息和链路费用信息。</p><ul><li> <strong>链路状态路由算法LS</strong>(link state routing algorithm)：必须知道网络中每条链路的费用。</li></ul></li><li><p><strong>分布式路由算法</strong>：以迭代的、分布式的方式计算最低费用路径。</p><ul><li>节点只有与其直接相连链路的费用信息：不需拥有所有网络链路费用的完整信息。 </li><li>通过迭代计算，并与相邻节点(邻居节点)交换信息</li><li>逐步计算出到达某目的节点或一组目的节点的最低费用路径。</li><li><strong>距离向量路由算法DV</strong>(distance Vector)：每个节点维护到网络中所有其他节点的费用（距离）的估计向量。</li></ul></li><li><p><strong>静态路由算法</strong>：</p><ul><li>路由确定后基本不再变化。只有人工干预调整时，可能有一些变化。</li></ul></li><li><p><strong>动态路由算法</strong>：</p><ul><li>当网络的流量负载或拓扑发生变化时，路径可能发生改变。</li><li>可以周期性地或直接地响应拓扑或链路费用的变化。</li><li>易受选路循环、路由振荡之类问题的影响。</li></ul></li></ul><h3 id="链路状态路由算法"><a href="#链路状态路由算法" class="headerlink" title="链路状态路由算法"></a>链路状态路由算法</h3><p>Dijkstra最低费用路径算法</p><p><strong>基本思想</strong>：以源节点为起点，每次找出一个到源节点的费用最低的节点，直到把所有的目的节点都找到为止。</p><p><strong>定义</strong>：</p><ul><li><p>c(x,y)：表示从节点x到y的链路费用;  </p><p>​               = ∞ 如果不是直接邻居</p></li><li><p>D(v)：表示从源节点到目的节点v的当前路径的费用；</p></li><li><p>p(v)：表示从源节点到目的节点v的路径上的前驱节点(例如w是v的前驱节点)；</p></li><li><p>N’：表示已经找到最低费用路径的节点集合。</p></li></ul><p><strong>过程</strong>：</p><ol><li>初始化 N‘ = {源节点u}；<ul><li>对所有不在N‘ 中的节点v，标出其D(v)值：</li><li>节点v与源节点u直接相连，D(v) = c(u，v) </li><li>节点v与源节点u不直接相连 ，D(v) = ∞ </li></ul></li><li>找出一个到源节点的费用最低的节点w，并以此更新其它点D(v) 值<ul><li>从不在N’ 中的节点中找出一个D(w)值最小的节点w，并将w加入到N’ 中。</li><li>对不在N‘ 中，但与节点w是邻居的节点v，用新的值更新       </li><li>D(v)=min[D(v)，D(w)+c(w,v)]</li><li>将节点v原值与节点v经节点w到源节点的值比较，取小值。</li></ul></li><li>重复步骤(2)<ul><li>直到所有的网络节点都在N’ 中为止。</li></ul></li></ol><p><img src="https://s2.loli.net/2022/06/13/UsNGR97lS8Lz2Mh.png" alt="image-20220613202623911"></p><ul><li>对于每个节点，都得到从源节点沿着它的最低费用路径的前驱节点；</li><li>每个前驱节点，又可得到它的前驱节点；以此继续，可以得到到所有目的节点的完整路径。</li><li>​            如节点z的前驱节点依次为： z-&gt;y-&gt;x-&gt;u</li><li>得出从源节点u到节点z的最低费用路径为：uxyz，费用为4。</li></ul><p>根据目的节点找出顺序和其费用以及前驱节点，可以画出源节点u到所有目的节点的<strong>最低费用路径树</strong>。</p><p><strong>转发表</strong>：存放从源节点到每个目的节点的最低费用<strong>路径上的下一跳节点</strong>。即指出对于发往某个目的节点的分组，从该节点发出后的下一个节点。</p><p><img src="https://s2.loli.net/2022/06/12/B1IrlWZd4pwJuHq.png" alt="image-20220612111734404"></p><p><strong>默认路由</strong> * ：表示所有具有相同“下一跳”的表项。即将“下一跳”相同的项合并为一项，目的节点用“*”表示。优先级最低，<strong>转发分组时，当找不到对应表项时，才使用默认路由</strong>。</p><p>复杂度：</p><ul><li>所有迭代中需要搜寻的节点总数为n(n+1)/2</li><li><strong>算法复杂性为O(n^2)</strong> </li><li>更有效的执行可能: O(nlogn)</li></ul><h3 id="距离向量路由算法"><a href="#距离向量路由算法" class="headerlink" title="距离向量路由算法"></a>距离向量路由算法</h3><p>收敛较慢。可能会遇到选路回环，或计数到无穷的问题。</p><h2 id="6、层次选路"><a href="#6、层次选路" class="headerlink" title="6、层次选路"></a>6、层次选路</h2><ul><li>一个区域内的路由器组成集合 “<strong>自治系统</strong>” (AS，autonomous system )</li><li>同一个自治系统的路由器运行相同的路由协议——<strong>区域内路由协议</strong></li><li>不同自治系统内的路由器可以运行不同的区域内路由协议</li></ul><p><strong>网关路由器</strong></p><ul><li>和其他自治系统内的路由器直接相连的路由器<ul><li>运行<strong>域间路由协议</strong>，与其他网关路由器交互</li></ul></li><li>同自治系统内的所有其他路由器一样也运行域内路由协议</li></ul><p><strong>AS互连</strong></p><ul><li>转发表根据AS内和AS间选路算法而配置</li><li>AS域内的选路项用于目的端在域内的选路。</li><li>AS域内和AS域间的选路项用于目的端在域外的选路</li></ul><p><strong>AS域间任务</strong></p><ul><li><p>假设AS1中的路由器接收到了目的端是AS1外的分组。路由器将把这个分组转发到哪个网关路由器呢？</p></li><li><p>AS1 需要知道:</p><ul><li>通过AS2和AS3可以到达哪些目的端</li><li>将这些可达信息传播给AS1内的所有路由器</li></ul></li><li><p>这就是<strong>域间选路</strong>的任务</p></li></ul><p><img src="https://s2.loli.net/2022/06/12/RnmG2lhXOA5J6yF.png" alt="image-20220612113536251"></p><p><strong>示例：在router 1d 上设置转发表</strong></p><ul><li>假设AS1运行域间路由协议知道网络X通过网关1c从AS3(而不是AS2) 是可达的<ul><li>通过域内路由协议将可达信息传播给所有域内路由器</li></ul></li><li>Router 1d 由域内路由信息判断自己的接口I 在到达1c的最小开销路径上<ul><li>在转发表里添加一项 (x,I)</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/MUc1eSOIpAfgCzP.png" alt="image-20220612114954338"></p><p><strong>示例：在多个自治系统中选择</strong></p><ul><li>现在假设AS1通过域间选路协议知道子网x从AS3和AS2都可以到达</li><li>为了配置转发表,路由器1d必须决定通过哪个网关将分组转发到目的子网x<ul><li>这同时也是<strong>域内路由协议</strong>的工作</li></ul></li><li><strong>热土豆选路</strong>: 把分组送到两个路由器中最近的一个</li></ul><p><img src="https://s2.loli.net/2022/06/12/7uzQ1ZI9hVtsoY5.png" alt="image-20220612115044865"></p><p><img src="https://s2.loli.net/2022/06/12/l2TuFxODhSMXcIB.png" alt="image-20220612115058489"></p><h3 id="域（自治系统）内路由选择-RIP、OSPF、IGRP"><a href="#域（自治系统）内路由选择-RIP、OSPF、IGRP" class="headerlink" title="域（自治系统）内路由选择(RIP、OSPF、IGRP)"></a>域（自治系统）内路由选择(RIP、OSPF、IGRP)</h3><p>使用域内路由协议，也被称作<strong>内部网关协议</strong> (IGP,interior Gateway Protocols)</p><p>标准的域内路由协议:</p><ul><li>RIP: <strong>路由信息协议</strong>(Routing Information Protocol)</li><li>OSPF: <strong>开放式最短路径优先</strong>(Open Shortest Path First)</li><li>IGRP: <strong>内部网关路由协议</strong> (Interior Gateway Routing Protocol,Cisco 私有)</li></ul><p>RIP略</p><p><strong>OSPF</strong>(Open Shortest Path First)</p><ul><li>用链路状态算法 <ul><li>分发LS 分组（通告）</li><li>每个路由器构造完整的网络（AS）拓扑图</li><li>路由器本地运行 <strong>Dijkstra算法</strong></li></ul></li><li>每个router都广播<strong>OSPF通告</strong>，OSPF通告里为每个邻居路由器设一个表项（记录每个邻居的<strong>链路特征和费用</strong>）。</li><li>通告会散布到整个<strong>自治系统</strong> (通过<strong>洪泛法</strong>) </li><li>OSPF报文直接封装到<strong>IP数据报</strong>中 (不是 TCP 或 UDP）</li></ul><p><strong>优点</strong>（RIP所没有的）</p><ul><li><strong>安全</strong>: 所有OSPF 消息需要认证 (防止恶意入侵) </li><li>允许<strong>多个</strong>相同开销的<strong>路径</strong> (在 RIP中只有一条路径)</li><li>对于每个链路, 有<strong>多个消费尺度</strong>用于不同的服务类型TOS (例如在尽力转发时卫星链路代价设置为 “低” ，而对实时应用设置为高)</li><li>单播和多播<strong>综合支持</strong>: </li><li>多播 OSPF (MOSPF) 使用和 OSPF同样的链路数据库</li><li>OSPF支持对大规模AS<strong>分层</strong></li></ul><p>层次OSPF</p><ul><li>两级层次: <strong>本地区域, 主干区域</strong>（这些区域都是在一个自治系统内）</li><li>只在区域内发送链路状态通告</li><li>每个节点有详细的区域拓扑; 仅知道到达其他区域内网络的方向（即最短路径）</li><li><strong>区域边界路由器</strong>（同时属于本地区域和主干区域）:“汇总”了到本区域内部网络的路径, 并通告给其他区域边界路由器.</li><li><strong>主干路由器</strong>：限于在主干区域内运行OSPF路由协议（本身不是区域边界路由器）</li><li><strong>边界路由器</strong>: 连接到其他自治系统</li></ul><p><img src="https://s2.loli.net/2022/06/12/EeoHWC8qMaA7nrf.png" alt="image-20220612150015448"></p><h3 id="Interne域间路由BGP"><a href="#Interne域间路由BGP" class="headerlink" title="Interne域间路由BGP"></a>Interne域间路由BGP</h3><p>BGP (Border Gateway Protocol)：事实上的标准域间路由协议</p><p>BGP 为每个 AS 提供了一种手段:</p><ul><li>eBGP：从相邻AS获取子网可达信息</li><li>iBGP：向该AS内部的所有路由器传播这些子网的可达信息</li><li>基于该<strong>可达信息</strong>和<strong>AS策略</strong>，决定到达子网的“好”路由</li></ul><p>允许一个子网向Internet的其他部分通告它的存在 “I am here”</p><p><strong>BGP会话</strong>(session)</p><ul><li>两个BGP路由器 (“Peers”)交换BGP报文 </li><li>通告去往不同目的前缀（prefix,代表1个子网）的路径 (“路径向量(path vector)”协议) </li><li>报文交换基于<strong>半永久的TCP连接</strong>(长时间不拆除) </li><li>BGP会话和物理链路无关（并不总是和某条物理链路对应）</li></ul><p><strong>BGP 报文</strong></p><ul><li>OPEN:建立到对方的TCP连接，并对发送者进行认证</li><li>UPDATE:通告新路径 (或者撤销旧路径)</li><li>KEEPALIVE:在没有UPDATES时保持连结活跃; 也对OPEN请求作出应答</li><li>NOTIFICATION:报告前面报文的错误; 也用于关闭连结</li></ul><p><strong>BGP通告</strong></p><ul><li>当AS3通告一个前缀给AS1：<ul><li>AS3承诺能够将数据报转发该子网</li><li>AS3能够在它的通告中汇聚网络前缀</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/FPglQskOvEV418x.png" alt="image-20220612151129693"></p><p><strong>分发路径信息</strong></p><ul><li><p>在3a和1c的<strong>eBGP</strong>会话中，AS3向AS1通告一个前缀可达信息。</p><ul><li>1c通过<strong>iBGP</strong>会话向AS1中的所有路由器发布这个新的前缀可达信息。</li><li>1b可以 (也可能不)将这个可达信息通过1b和2a之间的eBGP会话通告给AS2。</li></ul></li><li><p>当路由器得知一个新的前缀时，就在它的转发表中为该前缀创建一个项。</p></li></ul><p><img src="https://s2.loli.net/2022/06/12/NJ2GdZtYUv15l97.png" alt="image-20220612151142960"></p><p><strong>路径属性 和 BGP 路由</strong></p><ul><li>当通告前缀时，通告包含了BGP属性. <ul><li>前缀+属性=“路由”</li></ul></li><li>两个重要的属性:<ul><li>AS-PATH: 包含了前缀的通告已经通告过的那些AS,如 AS67,AS17 </li><li>NEXT-HOP: 指出到达下一个AS的具体AS间边界路由器（可能存在多条从当前AS到达下一个AS的链路）</li></ul></li><li>当网关路由器接收到路由通告时，使用<strong>输入策略</strong>来决定接收/舍弃该通告。</li></ul><p><img src="https://s2.loli.net/2022/06/12/VbNwKvh9LoFDctk.png" alt="image-20220612151340939"></p><p><strong>BGP路由选择</strong></p><ul><li>网关路由器收到路由通告后，利用其<strong>输入策略</strong>(import policy)决策接受/拒绝该路由<ul><li>e.g., 从不将流量路由到AS x</li><li>基于策略(policy-based) 路由</li></ul></li><li>路由器可能知道到相同前缀的多条路由，路由器必须从中选择，排除规则（应用排除规则直到有一条留下）<ul><li>本地偏好值属性: 具有最高偏好值的路由被选择</li><li>最短AS-PATH的路由 </li><li>最靠近 NEXT-HOP路由器的路由 : 热土豆路由</li><li>其他标准</li></ul></li></ul><p><strong>BGP选路策略</strong></p><ul><li>W,Y是<strong>桩网络</strong>(stub network/AS): 只与一个其他AS相连 </li><li>X是<strong>双宿网络</strong>(dual-homed network/AS): 连接两个其他AS <ul><li>X不期望经过他路由B到C的流量 ，因此，X不会向B通告任何一条到达C的路由 </li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/j3me5UOx7tKu2Tn.png" alt="image-20220612151723175"></p><ul><li>A 向B通告路径 AW </li><li>B 向X通告路由BAW</li><li>但B不会向C通告路由BAW，因为B并不想让C经BAW将流量引导到W，B只想服务它自己的客户，B不想承担在A和C之间传送流量的负担和开销</li></ul><p>为什么AS内选路和AS间选路采用不同的协议 ?</p><p>策略: </p><ul><li>AS间: 管理员想控制本AS内产生的通信流怎样选路，以及什么通信流穿过自己的网络</li><li>AS内:单个管理者, 因此不需要策略</li></ul><p>规模：</p><ul><li>层次路由节省了转发表的大小空间，减少了路由更新的流量</li></ul><p>性能：</p><ul><li>AS内: 集中在性能上</li><li>AS间: 策略可能比性能更加重要</li></ul><h2 id="7、SDN"><a href="#7、SDN" class="headerlink" title="7、SDN"></a>7、SDN</h2><p>软件定义网络（SDN，SoftwareDefinedNetwork）是一种新型网络创新架构，可通过<strong>软件编程</strong>的形式定义和控制网络，具有<strong>控制平面</strong>和<strong>转发平面</strong>分离及开放性可编程的特点。</p><p>SDN的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署，简化网络运维。</p><p>SDN并不是一个具体的技术，它是一种网络设计理念，规划了网络的各个组成部分（软件、硬件、转发面和控制面）及相互之间的互动关系。</p><p>相关组织：</p><ul><li>ONF（open network foundation ）：openflow</li><li>IETF  I2RS interface to route system</li><li>国际主流运营商发起成立的ETSI（欧洲电信标准协会）： 网络功能虚拟化工作组（Network Function Virtualizetion，NFV）</li><li>Opendaylight</li></ul><p>SDN的核心思想是<strong>建立一个通用转发体系</strong>  </p><ul><li>每个交换设备包含一个流表(flow table). 流表由一个逻辑上中心化的控制器（远程控制器）来计算和分发</li><li><strong>首部字段值</strong>：入分组与之匹配，匹配不上分组被丢弃或发往远程控制器。首部字段包括<strong>链路层、网络层、传输层</strong>首部字段。</li><li><strong>计数器</strong>：分组与流表项匹配时更新。包含已经匹配分组数量，以及上次更新以来的时间</li><li><strong>动作</strong>：分组匹配表项时的动作（转发、丢弃、复制、分发到多个端口）</li></ul><p>特征：</p><ul><li>基于流的转发：基于<strong>首部字段值</strong>进行转发</li><li>数据平面与控制平面分离：数据平面由<strong>网络交换机</strong>组成，控制平面由<strong>服务器和管理流表软件</strong>构成。</li><li>网络控制功能：位于数据平面交换机外部，包括SDN控制器和若干网络控制程序。</li><li>可编程的网络：调用API定义和控制网络设备的数据平面。</li></ul><p>SDN控制器组件</p><p><img src="https://s2.loli.net/2022/06/12/h4IpzQKMwPbWe7Z.png" alt="image-20220612154540359"></p><h3 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a>OpenFlow</h3><p>SDN中控制器与转发层之间的通信接口标准</p><ul><li>允许直接访问和操作网络设备的转发平面</li><li>分离控制平面和数据平面，二者间使用标准的协议通信</li><li>数据平面采用<strong>基于流</strong>的方式进行转发</li></ul><p>OpenFlow网络由 <strong>网络设备</strong>（OpenFlow Switch）和<strong>控制器</strong>（OpenFlow Controller）通过OpenFlow通道（OpenFlow Channel）组成</p><h1 id="五、链路层：链路、接入网和局域网"><a href="#五、链路层：链路、接入网和局域网" class="headerlink" title="五、链路层：链路、接入网和局域网"></a>五、链路层：链路、接入网和局域网</h1><h2 id="1、链路层概述"><a href="#1、链路层概述" class="headerlink" title="1、链路层概述"></a>1、链路层概述</h2><ul><li>主机和路由器: <strong>节点</strong>(nodes)</li><li>连接相邻节点的通信信道：<strong>链路</strong>(links)<ul><li><strong>有线链路</strong>(wired links)</li><li><strong>无线链路</strong>(wireless links)</li><li><strong>局域网</strong>(LANs)</li></ul></li><li>第二层的分组: <strong>数据帧</strong>(frame), 它是封装了的数据报</li></ul><p><strong>数据链路层的职责是将数据报从一个节点传送到与该节点直接有物理链路相连的另一个节点。</strong></p><p><strong>提供的服务</strong></p><ul><li><p><strong>组帧</strong> (framing): </p><ul><li>封装数据报为数据帧，增加头部(e.g.,地址信息)，尾部信息（e.g.,差错编码信息）</li><li>帧同步(e.g.,帧定界符)</li></ul></li><li><p><strong>链路接入</strong>( link access)</p><ul><li>如果是共享链路，需要解决信道接入(channel access)</li><li>在数据帧头部中，用<strong>MAC地址</strong>来标识源和目的（不同于IP地址）</li></ul></li><li><p>在相邻节点之间<strong>可靠传输数据帧</strong>（某些链路可能未实现）</p><ul><li>在比特错误率很低的链路(光纤、双绞线)很少使用</li><li>无线链路：高比特错误率，需要可靠交付</li></ul></li><li><p><strong>流量控制</strong>(flow control): </p><ul><li>用于控制发送节点向直接相连的接收节点发送数据帧的频率</li></ul></li><li><p><strong>差错检查</strong>(error detection): </p><ul><li>差错可能由信号衰减、噪声引入</li><li>接收方检测是否出现错误</li><li>通知发送方重传或丢弃数据帧</li></ul></li><li><p><strong>错误纠正</strong>(error correction): </p><ul><li>接收方直接纠正比特错误，而不需要请求重传</li></ul></li><li><p><strong>半双工和全双工</strong>(half-duplex and full-duplex):</p><ul><li>在半双工：链路的两个节点<strong>交替</strong>双向传输，但是不能同时发送</li><li>全双工：链路两个节点<strong>同时</strong>双向传输</li></ul></li></ul><p><strong>链路层实现的位置</strong></p><ul><li>在主机和网络设备(路由器)上实现</li><li>链路层的主体部分是在**网络适配器(**称为网卡)或者一个芯片组上实现<ul><li>以太网卡、802.11卡、以太网芯片组</li><li>实现链路层和物理层的功能</li></ul></li><li>链路主机的系统总线</li><li>硬件、软件与固件的组成</li></ul><p>发送方：</p><ul><li>封装数据报为数据帧</li><li>增加差错检测比特，实现可靠数据传输，流量控制等机制</li></ul><p>接收方：</p><ul><li>执行检查错误、实现可靠数据传输、流量控制等机制</li><li>抽取数据报，将其递交给上层</li></ul><h2 id="2、差错检验和纠错"><a href="#2、差错检验和纠错" class="headerlink" title="2、差错检验和纠错"></a>2、差错检验和纠错</h2><p><strong>发送节点</strong></p><ul><li>将数据D附加若干差错检测和纠错位EDC，一起发送到链路。</li><li>数据D包括网络层传来的数据报，以及链路级寻址信息、序列号和其他字段。</li><li>保护范围包括数据D的所有字段。</li></ul><p><strong>接收节点</strong></p><ul><li>接收比特序列D’和EDC’。</li><li>如果发生传输比特错误（0-&gt;1，1-&gt;0），D’和EDC’可能与发送的D和EDC不同。</li><li>接收方根据D’和EDC’，判断D’是否和初始的D相同（D的传输是否正确）。</li></ul><p><strong>正确</strong>：解封取出数据报，交给网络层；</p><p><strong>出错</strong>：差错处理。</p><p>差错检测和纠正技术不能保证接收方检测到所有的比特差错，即可能出现未检测到的比特差错，而接收方并未发现。</p><p>选择一个合适的差错检测方案使未检测到的情况发生的概率很小即可。</p><p>差错检测和纠错技术越好，越复杂，开销更大。</p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p>最基本的方法</p><h4 id="比特奇偶校验"><a href="#比特奇偶校验" class="headerlink" title="比特奇偶校验"></a>比特奇偶校验</h4><p><img src="https://s2.loli.net/2022/06/12/UpfxgbNiedm1kMK.png" alt="image-20220612165027361"></p><p><strong>发送方</strong>：</p><ul><li>在要发送的信息D（d位）后面附加一个奇偶校验位</li><li>使“1”的个数是奇数（奇校验）或偶数（偶校验）</li><li>一起传输发送（d+1位）。</li></ul><p><strong>接收方</strong>：</p><ul><li>检测收到的信息（d+1位）中“1”的个数。</li><li><strong>偶校验</strong>：发现奇数个“1”，至少有一个比特发生差错（奇数个比特差错）。</li><li><strong>奇校验</strong>：发现偶数个“1”，至少有一个比特发生差错。</li></ul><p>可以查出任意奇数个错误，但不能发现偶数个错误。</p><p>若比特差错概率很小，差错独立发生，一比特奇偶校验可满足要求。</p><p>若差错集中一起“突发”（突发差错），一帧中未检测到的差错的概率达到50%。</p><h4 id="二维奇偶校验"><a href="#二维奇偶校验" class="headerlink" title="二维奇偶校验"></a>二维奇偶校验</h4><p>基本思想：</p><ul><li>将要传信息D（d比特）划分为i行j 列（i 个组，每组j位）；</li><li>对每行和每列分别计算奇偶值；</li><li>结果的i+j+1个奇偶比特构成了帧的差错检测比特。</li></ul><p><img src="https://s2.loli.net/2022/06/12/sERa3h2vZmPeH4g.png" alt="image-20220612165213513"></p><p>特点：</p><ul><li>可以<strong>检测并纠正单个比特差错</strong>（数据或校验位中）。</li><li>能够**检测(但不能纠正)**分组中任意两个比特的差错。</li></ul><h3 id="Internet校验和"><a href="#Internet校验和" class="headerlink" title="Internet校验和"></a>Internet校验和</h3><p>传输层</p><h3 id="循环冗余检测CRC"><a href="#循环冗余检测CRC" class="headerlink" title="循环冗余检测CRC"></a>循环冗余检测CRC</h3><p>CRC (cyclic redundancy check)编码：</p><p>即<strong>多项式编码</strong>，把要发送的比特串看作为系数是0或1的一个多项式，对比特串的操作看作为多项式运算</p><p>基本思想：</p><ul><li>设发送节点要把数据D（d 比特）发送给接收节点。</li><li>发送方和接收方先共同选定一个生成多项式 G（r+1比特），最高有效位 (最左边)是1。</li></ul><p><strong>发送方</strong>：</p><ul><li>计算出一个r位附加比特R，添加到D的后面产生DR（d+r 比特）</li><li>DR能被生成多项式G模2运算整除，一起发送</li></ul><p><strong>接收方</strong>：</p><ul><li>用生成多项式G去除接收到的DR（d+r比特）<ul><li>余数非0：传输发生差错；</li><li>余数为0：传输正确，去掉尾部r位，得所需数据D。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/tZiIGdzJgQB7SXF.png" alt="image-20220612170127494"></p><p>R的计算：将数据D后面添加r个0，除以给定的生成多项式G，所得余数即为R（r位）。</p><p>例子：</p><p><img src="https://s2.loli.net/2022/06/12/Si4m63TlPfjcbg8.png" alt="image-20220612170910374"></p><p>生成多项式G的选择：常见的有8、12、16和32 比特生成多项式G。</p><p>国际标准已经定义了8-、16-、32-位生成多项式G；8-位CRC用于ATM信元首部的保护；32-CRC用于大量链路层IEEE协议。其他检错方法不常用，故不作专门介绍</p><ul><li>CRC8生成多项式为G(x)=x8+x5+x4+1</li><li>CRC16生成多项式为G(x)=x16+x12+x5+1</li><li>CRC-32生成多项式为G(x)=x32+x26+x23+x22+x16+x11+x10+x16+x8+x7+x5+x4+x2+x+1</li></ul><p>CRC特点：</p><p><strong>能检测小于 r+1 位的突发差错、任何奇数个差错</strong>，在适当的假设下，长度大于r+1比特的突发差错以概率1-0.5^r被检测到</p><p>差错检测方法比较</p><ul><li> 奇偶校验能力最弱，CRC校验能力最强。</li><li> 奇偶校验通常用于简单的<strong>串口通信</strong></li><li> Internet校验和通常用于网络层及其之上的层次，要求简单快速的软件实现方式</li><li> CRC通常应用于链路层，一般由<strong>适配器硬件</strong>实现</li></ul><h2 id="3、多路访问链路和协议"><a href="#3、多路访问链路和协议" class="headerlink" title="3、多路访问链路和协议"></a>3、多路访问链路和协议</h2><ul><li>点对点链路：链路两端各一个节点。一个发送和一个接收。<ul><li>拨号接入PPP。</li><li>以太网交换机与主机间的点对点链路 </li></ul></li><li>广播链路（共享介质）： 多个节点连接到一个共享的广播信道。<ul><li><strong>广播</strong>：任何一个节点传输一帧时，信号在信道上广播，其他节点都可以收到一个拷贝。常用于局域网LAN中，如早期的以太网和无线局域网。</li></ul></li></ul><p><strong>广播链路的信道共享技术</strong> —— 多路访问协议（多址访问协议）</p><h3 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h3><p><strong>目的</strong>：<strong>协调多个节点在共享广播信道上的传输</strong></p><p>避免多个节点同时使用信道，发生冲突（碰撞），产生互相干扰。</p><p><strong>冲突</strong>（collide）：两个以上的节点同时传输帧，使接收方收不到正确的帧（所有冲突的帧都受损丢失）。</p><ul><li>造成广播信道时间的浪费。</li><li>多路访问协议可用于许多不同的网络环境，如有线和无线局域网、卫星网等</li></ul><p><strong>期望</strong>：</p><ol><li>当一个节点有数据发送时，它能以R bps的速率发送.</li><li>当有M个节点要发送数据，每个节点的平均发送速率为 R/M</li><li>完全分散:<ul><li>不需要主节点协调传输</li><li>不需要时钟、时隙同步</li></ul></li><li>简单</li></ol><p>分类：</p><ul><li><strong>信道划分协议</strong><ul><li>把信道划分为小“片” (时隙)</li><li>给节点分配专用的小“片” </li></ul></li><li><strong>随机访问协议</strong><ul><li>不划分信道，允许冲突</li><li>能从冲突中“恢复”</li></ul></li><li><strong>轮流协议</strong><ul><li>通过轮流访问信道避免冲突，要发送的节点越多轮流时间越长</li></ul></li></ul><h4 id="信道划分协议"><a href="#信道划分协议" class="headerlink" title="信道划分协议"></a>信道划分协议</h4><ul><li>主要有TDMA、FDMA、CDMA三种。</li><li>设信道支持 N 个节点，传输速率是 R b/s。</li></ul><p><strong>时分多路访问TDMA</strong> (time division multiple access)：</p><p>将时间划分为时间帧，每个时间帧再划分为N个时隙（长度保证发送一个分组），分别分配给N个节点。每个节点</p><p>只在固定分配的时隙中传输。</p><p>特点：</p><ul><li>避免冲突、公平：每个节点专用速率R/N b/s。</li><li>节点速率有限：R/N b/s；</li><li><strong>效率不高</strong>：节点必须等待它的传输时隙。</li></ul><p><strong>频分多路访问FDMA</strong> (frequency division multiple access)：</p><p>将总信道带宽 R b/s划分为 N 个较小信道（频段，带宽为R/N），分别分配给 N 个节点。例： 6个站点的LAN, 频带1、3、4 有分组, 频带2、5、6 空闲</p><p>特点：</p><ul><li>避免冲突、公平：N个节点公平划分带宽；</li><li>节点带宽有限、效率不高：节点带宽为R/N</li></ul><p><strong>码分多路访问CDMA</strong> (frequency division multiple access)：</p><ul><li>每个节点分配一个唯一的编码</li><li>每个节点用它唯一的编码来对它发送的数据进行编码</li><li>允许多个节点“共存” ，信号可叠加，即可以同时传输数据而无冲突 (如果编码是“正交化”的)</li></ul><h4 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h4><ul><li>基本思想：<ul><li>发送节点以信道全部速率（R b/s）发送；</li><li>节点间没有协调者</li><li>发生冲突时，冲突的每个节点分别等待一个随机时间，再重发，直到帧(分组)发送成功</li></ul></li><li>典型随机访问协议：<ul><li>ALOHA协议(纯ALOHA，时隙ALOHA)</li><li>载波监听多路访问CSMA协议</li><li>带<strong>冲突检测</strong>的载波监听多路访问CSMA/CD </li><li>带<strong>冲突避免</strong>的载波监听多路访问CSMA/CA</li></ul></li></ul><p><strong>ALOHA</strong></p><p>夏威夷大学研制的一个无线电广播通信网（20世纪70年代初），采用<strong>星型拓扑结构</strong>，使地理上分散的用户通过无线电来使用中心主机。</p><ul><li>纯ALOHA</li><li>时隙ALOHA</li></ul><p><strong>纯ALOHA</strong></p><ul><li> 非时隙Aloha: 简单，不需同步</li><li> 帧一到达，立即传输</li><li>如果与其他帧产生冲突，在该冲突帧传完之后：<ul><li>以概率p立即重传该帧；</li><li>或等待一个帧的传输时间，再以概率p 传输该帧，或者以概率1-p 等待另一个帧的时间。</li></ul></li><li>冲突概率:<ul><li>在t0发送的帧，和在 [t0-1,t0+1]的发送的其它帧冲突</li></ul></li></ul><p>效率：</p><p>P(给定节点成功传送) = P(节点传送) * P(没有其他节点在[t0-1,t0]内传送) * P(没有其他节点在[t0,t0 +1]内传送)<br>                                     = p * (1-p)^N-1 * (1-p)^N-1<br>                                     = p * (1-p)^2(N-1)  最大值为1/2e  = 0.18</p><p><strong>时隙ALOHA</strong></p><p>假设：</p><ul><li>所有帧大小相同</li><li>时间被划分为相同大小的时隙，每个时隙等于传送1帧的时间</li><li>节点只能在一个时隙的开始才能传送</li><li>节点需要时钟同步</li><li>如果2个或2个以上节点在同一时刻传送，所有节点都能检测到冲突</li></ul><p>实现：</p><ul><li>当节点要发送新帧，它等到下一时隙开始时传送</li><li>没有冲突，节点可以在下一时隙发送新帧</li><li>如果有冲突，节点在随后的时隙以概率p重传该帧，直到成功为止。</li></ul><p>优点：</p><ul><li>单个活跃节点可以持续以全部速率传送帧</li><li>高分散性: 只需节点的时隙同步</li><li>简单</li></ul><p>缺点：</p><ul><li>冲突，浪费时隙</li><li>空闲时隙</li><li>节点只有在传输数据包时才能检测到冲突</li><li>时钟同步</li></ul><p>效率：当有很多节点，每个节点有很多帧要发送时，成功时隙所占的百分比</p><ul><li>假设有N个节点，每个节点在时隙以概率p发送</li><li>一个节点在一个时隙成功传送的概率 = p(1-p)^(N-1)</li><li>任一节点传送成功的概率 = Np(1-p)^(N-1)  </li><li>为了得到N个活跃节点的最大效率，必须找出使表达式Np(1-p)N-1 取最大值的p*</li><li>为了得到大量活跃节点的最大效率， 我们求N趋近无穷时Np*(1-p*)N-1 极限值，计算可知最大效率为1/e =0 .37</li></ul><p><strong>CSMA(载波侦听多路访问)</strong></p><p>Carrier Sense Multiple Access with Collision Avoid</p><ul><li>载波侦听：某个节点在发送之前，先监听信道。<ul><li>信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道。<ul><li>1-坚持CSMA（以概率p=1，一直侦听信道）</li><li>非坚持CSMA（随机等待一段时间侦听信道）</li><li>P-坚持CSMA（以概率p侦听信道）</li></ul></li></ul></li><li>信道空：该节点开始传输整个数据帧。</li><li>CSMA 的特点：<ul><li>发前监听，可减少冲突。</li><li>由于传播时延的存在，仍有可能出现冲突，并造成信道浪费。</li></ul></li></ul><p><strong>带冲突检测的CSMA(CSMA/CD)</strong></p><p>=== <strong>以太网所采用的</strong> ===</p><p>增加“<strong>载波侦听</strong>”和“<strong>冲突检测</strong>”两个规则。</p><ul><li>基本原理： 传送前侦听<ul><li>信道忙：延迟传送</li><li>信道闲：传送整个帧</li></ul></li><li>发送同时进行冲突检测：一旦检测到冲突就立即停止传输， 尽快重发。</li><li>目的：缩短无效传送时间，提高信道的利用率。</li><li>冲突检测：<ul><li>有线局域网易于实现：测量信号强度，比较发射信号与接收信号 </li><li>无线局域网很难实现：接收信号强度淹没在本地发射信号强度下 </li></ul></li></ul><p><strong>以太网CSMA/CD的运行机制</strong></p><ol><li>适配器从网络层得到分组, 创建帧</li><li>如果适配器侦听到信道空闲,开始传送帧。如果信道忙, 它会等到信道空闲才传送帧</li><li>如果适配器传送整个帧时，都没有检测到其它传输, 则完成该帧的传送</li><li>如果适配器在发送中检测到其它传送,就放弃传送，并发送一个拥塞信号</li><li>放弃传送后，适配器进入指数回退阶段，即该帧经过n次冲突后，适配器在{0,1,2,…,(2^n)-1}中随机选取一个K值 ，其中n=min(n,10),然后等待K*512比特时间后,回到第2步（<strong>二进制指数回退算法</strong>）</li></ol><p>二进制指数回退算法</p><ul><li>目标：适配器依据当前负载情况重传，重负载时等待时间变长</li><li>第一次冲突： 在{0,1}中选k值；延迟Kx512比特时间传送</li><li>第二次冲突：在{0,1,2,3}中选k值…</li><li>10次以后，在 {0,1,2,3,4,…,1023}中选k值。</li><li>K是等概率选择</li></ul><h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><p>多路访问协议理想特性：</p><ul><li>只有一个节点活动时，吞吐量R b/ s；</li><li>有M个节点活动时，吞吐量R/M b/ s。</li><li>ALOHA和CSMA协议有第一个特性，但没有第二个特性</li></ul><p>典型协议：</p><ul><li><strong>轮询协议</strong></li><li><strong>令牌传递协议</strong></li></ul><p><strong>轮询协议</strong></p><p>主节点“邀请”从节点依次传送</p><p>问题：</p><ul><li>轮询的开销</li><li>延时</li><li>单点故障(主节点)</li></ul><p><strong>令牌传递(token passing)</strong></p><ul><li>控制令牌顺序从一个节点传递到下一个节点。</li><li>令牌：特殊帧</li><li>问题:<ul><li>令牌开销</li><li>延时</li><li>单点失效(token)</li></ul></li></ul><h2 id="4、交换局域网"><a href="#4、交换局域网" class="headerlink" title="4、交换局域网"></a>4、<strong>交换局域网</strong></h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>按照网络覆盖地理范围的大小，计算机网络可分为广域网、局域网和城域网。</p><ul><li><strong>局域网</strong>（Local Area Network ， LAN )：为一个组织所拥有，且地理范围和站点数目均有限，如一个办公室、一幢大楼或几幢大楼之间的地域范围。</li><li><strong>城域网</strong>(Metropolitan Area Network，MAN)：连接着多个LAN，范围扩大到大约1～13英里(1英里=1.6093 km)，构成MAN的每一个LAN可以属于同一组织，也可以属于多个不同的组织。</li><li><strong>广域网</strong>(Wide Area Network，WAN) ：由两个以上的LAN构成，连接可以穿越30英里以上的距离。最广为人知的WAN就是Internet，它由全球成千上万的LAN和WAN组成。</li></ul><p>局域网技术特征：</p><ul><li><p>拓扑结构：星形网、环形网、总线网、树形网和网状网</p></li><li><p>物理媒体（传输介质）:双绞线、同轴电缆、光纤等</p></li><li><p>介质访问控制方法：</p><ul><li>多址访问协议</li><li>随机访问的CSMA/CD</li><li>令牌传递技术的令牌环和FDDI在局域网技术中变得次要或被淘汰</li></ul></li></ul><p>决定了网络的<strong>传输数据类型、响应时间、吞吐量、以及网络应用</strong>等网络特征。</p><p><strong>星型结构</strong></p><p><img src="https://s2.loli.net/2022/06/12/XiIuNs8oA1TGW4H.png" alt="image-20220612174930225"></p><ul><li>辐射状连接</li><li>中央结点集中式通信控制</li><li>优点：结构简单，访问协议简单，单个节点的故障不会影响到整个网络。</li><li>缺点：对中央结点的可靠性要求很高，一有故障，全网瘫痪。</li></ul><p><strong>总线结构</strong></p><p><img src="https://s2.loli.net/2022/06/12/ejOsXRxcWhP8BZ6.png" alt="image-20220612175004731"></p><ul><li>所有的站点都连接在同一根传输线，即“总线”上</li><li>优点：结构简单，易于扩充</li><li>缺点：故障检测比较困难</li></ul><p><strong>环形结构</strong></p><p><img src="https://s2.loli.net/2022/06/12/WPlQ5gfmrbN2Tk8.png" alt="image-20220612175039477"></p><ul><li>站与站点之间首尾相接，形成一个环，数据只能沿单方向传输</li><li>优点：这种结构适合于光纤介质。实时性较强</li><li>缺点：如果处理不当，站点的故障会引起全网故障</li></ul><p><strong>树型结构</strong></p><p><img src="https://s2.loli.net/2022/06/12/BMOP6FZ2i9ERXAt.png" alt="image-20220612175115922"></p><p>它是从星型拓扑演变而来的，形状像一棵倒挂的树<br>特点：与星型拓扑大致相似。它与星型结构相比降低了通信线路成本，增加了网络复杂性</p><p><strong>网状结构</strong></p><p><img src="https://s2.loli.net/2022/06/12/ENkF9cS2JfgX45y.png" alt="image-20220612175146559"></p><p>网状网络的每一个站点都与其它站点一一直接互连<br>优点：连接方法主要是利用冗余的连接，实现站与站之间的高速传输和高容错性能，以提高网络的速度和可靠性<br>优点：关系复杂，建网难，维护难</p><p>计算机与局域网通过网络接口板进行连接，网络接口板又称通信适配器（Adapter）或网络接口卡NIC（Network Interface Card），通常我们称为“网卡”。</p><h3 id="链路层寻址"><a href="#链路层寻址" class="headerlink" title="链路层寻址"></a>链路层寻址</h3><p>链路层地址：MAC(Media Access Control Address)地址。<br>    用于把数据帧从一个节点传送到另一个节点(同一网络中)。</p><p><strong>MAC地址</strong>（LAN地址、物理地址）：</p><ul><li>节点“网卡”本身所带的地址（唯一）。</li><li>MAC地址长度通常为<strong>6字节</strong>(48比特)，共248个。</li><li>6字节地址用16进制表示，每个字节表示为一对16进制数</li><li>网卡的MAC地址是<strong>永久的</strong>（生产时固化在其ROM里）</li></ul><p><strong>MAC地址分配</strong></p><ul><li>由专门机构IEEE管理物理地址空间<ul><li>负责分配六个字节中的前三个字节（高24位，地址块）</li></ul></li><li>MAC 地址是<strong>平面结构</strong><ul><li>带有同一网卡的节点，在任何网络中都有同样的MAC地址。</li></ul></li><li>IP地址具有<strong>层次结构</strong><ul><li>当节点移动到不同网络时，节点的IP地址发生改变。</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/xh5dmt9BSpZ3YFn.png" alt="image-20220612175845582"></p><p><strong>MAC地址识别</strong></p><ul><li>广播信道的局域网中，一个节点发送的帧，在信道上广播传输，其他节点都可能收到该帧。</li><li>大多数情况，一个节点只向某个特定的节点发送。</li><li>由“网卡”负责MAC地址的<strong>封装和识别</strong>。</li><li><strong>发送适配器</strong>：将目的MAC地址封装到帧中，并发送。所有其他适配器都会收到这个帧。</li><li><strong>接收适配器</strong>：检查帧的目的MAC地址是否与自己MAC地址相匹配：<ul><li>匹配：接收该帧，取出数据报，并传递给上层。</li><li>不匹配：丢弃该帧。</li></ul></li><li>广播帧：发送给所有节点的帧，全1地址：FF-FF-FF-FF-FF-FF</li></ul><p>回顾：</p><ul><li>节点的3种不同地址表示<ul><li>应用层的主机名、网络层的IP地址和链路层的MAC地址</li><li>实际在链路上传输时，根据MAC地址，确定相应的节点</li></ul></li><li>地址之间的转换<ul><li>通信时，需要进行地址转换：主机名 -&gt; IP地址 -&gt; MAC地址</li><li>DNS域名系统：将主机名解析到IP地址。DNS为在因特网中任何地方的主机解析主机名。</li><li>ARP地址解析协议：将IP地址解析到MAC地址。ARP只为在<strong>同一个LAN</strong>上的节点解析IP地址。</li></ul></li></ul><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p>Address Resolution Protocol</p><p>ARP表: 局域网上的每个节点(主机、路由器)都有这个表</p><ul><li>为某些局域网节点进行IP/MAC地址映射： &lt; IP address; MAC address; TTL&gt;</li><li>TTL (存活时间): 地址映射将被删除的时间（通常为20分钟）</li></ul><p><strong>两个主机位于同一个局域网</strong></p><ul><li><p>主机A希望发送数据报给主机B</p><ul><li>B的MAC地址不在A的ARP映射表中</li></ul></li><li><p>主机A 广播 ARP查询分组, 其中包含B的IP地址 </p><ul><li>目的MAC地址 = FF-FF-FF-FF-FF-FF</li><li>局域网中所有节点收到ARP查询分组</li></ul></li><li><p>主机B收到ARP查询分组，返回B的MAC地址给主机A</p><ul><li>利用<strong>单播帧</strong>向A发送应答 </li></ul></li><li><p>主机A在它的ARP表中缓存 IP-to-MAC 地址对，直到信息超时</p><ul><li><strong>软状态</strong>：信息超时会被删除，除非有新的更新消息</li></ul></li><li><p>ARP是即插即用的:</p><ul><li>节点创建ARP表不需要网络管理员的干预</li></ul></li></ul><p><strong>发送数据报到子网以外</strong></p><ul><li>集中在寻址上——IP层(数据报)和MAC层(数据帧)</li><li>假设主机A知道主机B的IP地址</li><li>假设主机A知道第一跳路由器R的IP地址(通过DHCP协议)</li><li>假设主机A知道路由器R的MAC地址(通过ARP协议)</li></ul><p>流程：</p><ul><li><p>主机A构建IP数据报，源地址是A的IP地址，目的地址是B的IP地址</p></li><li><p>主机A构建链路层数据帧，其中源MAC地址是A的MAC地址，目的MAC地址是<strong>R(左)接口的MAC地址</strong>，封装A到B的IP数据报。</p></li><li><p>数据帧从主机A发送到路由器R</p></li><li><p>路由器R收到数据帧，抽取出数据报递交到IP层</p></li><li><p>路由器R转发数据报（源和目的IP地址不变！）</p></li><li><p>路由器R将该数据报封装成链路层帧，其中源MAC地址是<strong>R(右)接口的MAC地址</strong>，目的MAC地址是B的MAC地址，封装A到B的IP数据报。</p></li></ul><h3 id="以太网-Ethernrt"><a href="#以太网-Ethernrt" class="headerlink" title="以太网(Ethernrt)"></a>以太网(Ethernrt)</h3><p><strong>以太网是最为著名的有线局域网技术</strong></p><ul><li>是第一个广泛使用的局域网技术；</li><li>简单、便宜；</li><li>版本不断更新，数据速率更高、成本更低。</li></ul><p>物理拓扑结构</p><ul><li><strong>总线</strong>(bus): 一直流行到90年代中期<ul><li>所有结点在同一冲突域(collision domain) (可能彼此冲突) </li></ul></li><li><strong>星形</strong>(star):目前流行<ul><li>中心是交换机</li><li>每个端口运行一个独立的以太网协议(节点相互之间不发生碰撞)</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/12/B13TA8IqXHML5pk.png" alt="image-20220612183056779"></p><p><strong>以太网链路层访问技术</strong></p><p><img src="https://s2.loli.net/2022/06/12/AtHqvfS3n4Q2dbj.png" alt="image-20220612183219068"></p><p><img src="https://s2.loli.net/2022/06/12/6oBPmqJKCLi28wN.png" alt="image-20220612185851009"></p><ul><li><p>发送方：发送适配器将IP数据报封装成以太网帧，并传递到物理层。</p></li><li><p>接收方：接收适配器从物理层收到该帧，取出IP数据报，并传递给网络层</p></li><li><p><strong>前同步码</strong>：8字节</p><ul><li><p>前7字节是“10101010”，最后一个字节是“10101011”。</p></li><li><p>使接收方和发送方的时钟同步，接收方一旦收到连续的8字节前同步码，可确定有帧传过来。</p></li><li><p><strong>前同步码是“无效信号”，接收方收到后删除，不向上层传。</strong></p></li><li><p>CRC的校验范围不包括前同步码。</p></li></ul></li><li><p><strong>源、目的MAC地址</strong>（各6字节）</p><ul><li>适配器只接收目的地址与其MAC地址匹配或广播地址的帧，并将数据字段的内容传递给网络层。否则，丢弃该帧。</li></ul></li><li><p><strong>类型字段</strong>（2字节）</p><ul><li>以太网可以“多路复用”（支持）多种网络层协议（如IP协议、Novell IPX） 。通过“类型”字段区分。</li><li>发送方填入网络层协议“类型” 编号；</li><li>接收适配器根据“类型”字段，将数据字段传递给相应的网络层协议。</li></ul></li><li><p><strong>数据字段</strong>（46~1500字节）</p><ul><li>携带网络层传来的IP数据报</li><li>以太网的最大传输单元MTU是1500字节：<ul><li>若IP数据报超过1500字节，必须将该数据报分段。</li></ul></li><li>最小长度是46字节：<ul><li>如果IP数据报小于46字节，必须填充为46字节。接收方网络层去除填充内容。</li></ul></li></ul></li><li><p><strong>循环冗余检测CRC</strong>(4字节，帧校验序列FCS)</p><ul><li>检测数据帧中是否出现比特差错（翻转）</li><li>发送主机计算CRC：范围包括目的地址、源地址、类型、数据字段的比特，结果放入帧CRC字段。</li><li>接收主机进行CRC校验：接收主机对收到的帧进行同样计算，并校验结果是否和CRC字段的内容相等。若计算结果不等于CRC字段的值(CRC校验失败)，该帧有差错。</li></ul></li></ul><p><strong>以太网向网络层提供的服务</strong></p><ul><li><strong>无连接服务</strong>：通信时，发送方适配器不需要先和接收方适配器“握手”。</li><li><strong>不可靠的服务</strong>：接收到的帧可能包含比特差错。<ul><li>收到正确帧，不发确认帧；</li><li>收到出错帧，丢弃该帧，不发否定帧。</li><li>发送适配器不会重发出错帧。</li><li>丢弃数据的恢复是通过终端<strong>传输层</strong>的可靠数据传输机制来实现的</li></ul></li><li>以太网的MAC协议：使用<strong>无时隙的CSMA/CD协议</strong>（二进制指数回退）</li></ul><h2 id="5、链路层交换机"><a href="#5、链路层交换机" class="headerlink" title="5、链路层交换机"></a>5、链路层交换机</h2><p><strong>链路层设备</strong></p><ul><li>存储转发数据帧</li><li>检查达到的数据帧的MAC地址，有选择的转发数据帧到一个或多个输出链路转发帧</li><li>当数据帧被转发到一个共享网段时，使用CSMA/CD来访问共享链路</li><li><strong>透明</strong>：主机不关心是否存在交换机</li><li><strong>即插即用和自学习</strong>：交换机不需要手工配置</li></ul><p><strong>交换机</strong>：</p><ul><li>每个主机由单独的链路直接连到交换机端口</li><li>交换机可以<strong>缓存</strong>数据帧</li><li>以太网协议在每个输入链路使用，无碰撞，且可以全双工，每条链路自身是一个<strong>碰撞域</strong></li><li>每个交换机有一个交换机转发表，其中每个条目：(主机的MAC地址，到达主机的端口，时戳)</li><li>通过自学习</li></ul><p><strong>自学习</strong>：</p><ul><li>当收到数据帧时，交换机“学习”发送主机的位置：进入的局域网网段(到达端口)</li><li>在转发表中记录发送主机/位置对</li></ul><p><strong>转发</strong>：</p><p>当交换机收到数据帧:</p><ol><li><p>记录到达链路和发送主机的MAC地址</p></li><li><p>使用数据帧的目的MAC地址，在转发表中检索</p></li><li><p>如果在转发表条目中找到对应的MAC地址</p></li><li><p>执行{</p><p>​    如果 目的MAC地址对应的端口与数据帧的达到端口相同</p><p>​    则 丢弃该数据帧</p><p>​    否则 转发该数据帧到条目指定的端口</p><p>}</p></li><li><p>否则，向除到达端口之外的所有端口转发(flood)</p></li></ol><h3 id="交换机互连"><a href="#交换机互连" class="headerlink" title="交换机互连"></a>交换机互连</h3><p><img src="https://s2.loli.net/2022/06/12/RzuaQihsMfUtSod.png" alt="image-20220612192236853"></p><p>A发送数据帧给G——S1通过<strong>泛洪</strong>和<strong>自学习</strong>知道数据帧先转发到S4和S3</p><h3 id="交换机的交换"><a href="#交换机的交换" class="headerlink" title="交换机的交换"></a>交换机的交换</h3><p>特点：</p><ul><li>识别目的MAC地址，根据交换表进行端口选择</li><li>识别源MAC地址更新交换表</li></ul><p>交换方式：</p><ul><li> 存储转发（缓存整个帧后再转发）</li><li> 快速分组又称直通交换（识别出目的地址直接转发）</li></ul><p>存储转发：</p><p><img src="https://s2.loli.net/2022/06/12/fjQqrPmBiSW5EKT.png" alt="image-20220612192632725"></p><p>具有差错检测功能，转发时延较大，适用于出错率高的链路</p><p>快速转发：</p><p><img src="https://s2.loli.net/2022/06/12/kwtEyHvGT5JzsNR.png" alt="image-20220612192700847"></p><p>快速分组又称直通交换：不具有差错检测功能，转发时延较小，适用于时延要求高，出错率低的链路。</p><p>SFD:帧首定界符，FCS：帧检验序列，DA：目的地址，SA：源地址</p><h3 id="三层交换机"><a href="#三层交换机" class="headerlink" title="三层交换机"></a>三层交换机</h3><p>三层交换技术能够在网络模型中的第三层实现数据包的高速转发。</p><p>简单地说，三层交换技术就是二层交换技术+三层转发技术，三层交换机就是“<strong>二层交换机+基于硬件的路由器</strong>” </p><p>交换机制：一次路由，多次交换</p><p>工作原理</p><ul><li>发送站点A在开始发送时，把自己的IP地址与B站的IP地址比较，判断B站是否与自己在同一子网内。</li><li>若目的站B与发送站A在同一子网内，则进行二层的转发。</li><li>若两个站点不在同一子网内，则发送站A要向“缺省网关”发出ARP请求，请求获得B的MAC地址。</li><li>如果三层交换机知道B的MAC地址，则向A回复B的MAC地址。否则三层交换机根据路由信息向B站广播一个ARP请求，B站得到此ARP请求后向三层交换机回复其MAC地址，三层交换机将B站的MAC地址保存到二层交换引擎的MAC地址表中，并回复给发送站A。</li><li>A直接用B的MAC地址封装数据帧，三层交换机接收到数据后直接进行二层交换。</li></ul><p><strong>交换机vs路由器</strong></p><ul><li>两者都是存储转发设备: <ul><li>路由器：网络层设备(检查网络层头部)</li><li>交换机：链路层设备(检查链路层头部)</li></ul></li><li>两者都有转发表<ul><li>路由器：使用由算法计算转发表，基于IP地址转发</li><li>交换机：通过泛洪、自学习来学习转发表，基于MAC地址转发</li></ul></li></ul><p><img src="https://s2.loli.net/2022/06/14/IRuy4zf5QgWXV6c.png" alt="image-20220614224536273"></p><h3 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h3><p>Virtual Local Area Network</p><p>利用支持VLAN的交换机，可以在一个实际的物理局域网内，定义多个虚拟的局域网</p><p><strong>基于端口的VLAN</strong>: 利用交换机内置的管理软件，将端口分组，使得一个单独的交换机</p><ul><li><strong>流量隔离</strong>：从1-8号端口进/出的帧，只能访问1-8号端口</li><li><strong>动态成员</strong>：端口可以在VLAN之间动态调整</li><li><strong>VLAN间转发</strong>：通过路由完成（就像独立的交换机之间）<ul><li>在实际中，厂商会将路由功能和交换功能都整合在一台设备中</li></ul></li><li>干线端口（ trunk port ）承载定义在多个物理交换机之上的VLAN间的流量<ul><li>某一个VLAN内的流量帧，如果要跨域物理的交换机，需使用802.1q格式（带有VLAN ID 信息）</li><li>802.1q协议的作用：对干线端口之间传输的帧，添加/移除额外的头部字段</li></ul></li></ul><h1 id="六、Socket编程"><a href="#六、Socket编程" class="headerlink" title="六、Socket编程"></a>六、Socket编程</h1><p><img src="https://s2.loli.net/2022/06/12/nwLtmAPxXC3iOJd.png" alt="image-20220612225507977"></p><p><img src="https://s2.loli.net/2022/06/15/STLdwGbaOi2Ejxo.png" alt="image-20220614225624895"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> family<span class="token punctuation">,</span><span class="token keyword">int</span> type<span class="token punctuation">,</span><span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<strong>创建一个新的套接字，返回套接字描述符</strong></li><li>参数：<ul><li>family：指明使用的协议栈，如TCP/IP使用的是 PF_INET（PF，Protocol Family）或者AF_INET    </li><li>type: 指明需要的服务类型, 如：<ul><li>SOCK_DGRAM，数据报服务，UDP协议</li><li>SOCK_STREAM，流服务，TCP协议</li></ul></li><li>protocol：IP报头中的协议字段，一般取0</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>myaddr<span class="token punctuation">,</span><span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<strong>为套接字指明一个本地端点地址</strong><ul><li>TCP/IP协议使用sockaddr_in结构，包含IP地址和端口号</li><li>服务器使用它来指明Well Known端口号，然后等待连接</li></ul></li><li>参数：<ul><li>sockfd，套接字描述符，指明创建连接的套接字</li><li>myaddr，本地地址，IP地址和端口号</li><li>addrlen ，地址长度</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span><span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<ul><li><strong>为套接字指明一个本地端点地址</strong></li><li>用于服务器，指明某个套接字连接是被动的，并准备接收传入连接。</li></ul></li><li>参数：<ul><li>Sockfd:套接字描述符，指明创建连接的套接字</li><li>backlog:该套接字使用的队列长度,指定在请求队列中允许的最大请求数</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">accept</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>cliaddr<span class="token punctuation">,</span><span class="token class-name">socklen_t</span> <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<ul><li>系统从完成队列上摘下socket，<strong>为每个新的连接请求创建一个新的套接字</strong>，服务器只对新的连接使用该套接字，<strong>原来的监听套接字接受其他的连接请求</strong>。</li><li>新的连接上传输数据使用新的套接字，使用完毕，服务器将关闭这个套接字。</li></ul></li><li>参数：<ul><li>Sockfd:套接字描述符，指明正在监听的套接字</li><li>cliaddr:提出连接请求的主机地址</li><li>addrlen:地址长度</li></ul></li></ul><blockquote><p>accept默认会阻塞进程，直到有一个客户连接建立后返回，它返回的是一个新可用的套接字，这个套接字是连接套接字。此时我们需要区分两种套接字，一种套接字正如accept的参数sockfd，它是监听套接字，在调用listen函数之后，一个套接字会从主动连接的套接字变身为一个监听套接字；而accept返回是一个连接套接字，它代表着一个网络已经存在的点点连接。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h></span></span><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>servaddr<span class="token punctuation">,</span><span class="token class-name">socklen_t</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<ul><li><strong>同远程服务器建立主动连接</strong>，成功返回0，失败返回－1</li><li>属于客户端的调用</li></ul></li><li>参数：<ul><li>sockfd，套接字描述符，指明创建连接的套接字</li><li>servaddr，指明远端IP地址和端口号</li><li>addrlen，地址长度</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> data_len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>功能：<ul><li>在TCP连接上发送数据, 成功返回数据长度，出错返回－1。</li></ul></li><li>参数：<ul><li>sockfd，套接字描述符</li><li>data，指向要发送数据的指针</li><li>data_len，数据长度</li><li>flags，一般为0</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sendto</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> data_len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>remaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> remaddr_len）<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>功能：<ul><li>基于UDP发送数据报，返回实发数据长度，出错返回－1。</li></ul></li><li>参数：<ul><li>sockfd，套接字描述符</li><li>data，指向要发送数据的指针</li><li>data_len，数据长度</li><li>flags，一般为0</li><li>remaddr，远端地址：IP地址和端口号</li><li>remaddr_len ，地址长度</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> buf_len<span class="token punctuation">,</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>功能：<ul><li><strong>从TCP接收数据,返回实际接收数据长度</strong>，出错返回－1。</li><li>如果没有数据将阻塞，如果收到的数据大于缓存大小，多余数据将丢弃。</li></ul></li><li>参数：<ul><li>Sockfd:套接字描述符</li><li>Buf:指向内存块的指针</li><li>Buf_len:内存块大小，以字节为单位</li><li>flags:一般为0</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> buf_len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span> <span class="token operator">*</span>from<span class="token punctuation">,</span> <span class="token keyword">int</span> fromlen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>功能：<ul><li>从UDP接收数据，返回实际接收的字节数，失败返回－1</li></ul></li><li>参数：<ul><li>Sockfd:套接字描述符</li><li>buf:指向内存块的指针</li><li>buf_len:内存块大小，以字节为单位</li><li>flags:一般为0</li><li>from:远端的地址，IP地址和端口号</li><li>fromlen:远端地址长度</li></ul></li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token keyword">int</span> <span class="token function">close</span> <span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>功能：<ul><li>关闭socket，实际上是关闭文件描述符</li><li><strong>如果只有一个进程使用，立即终止连接并撤销该套接字，如果多个进程共享该套接字，将引用数减一，如果引用数降到零，则撤销它</strong>。</li></ul></li><li>参数：<ul><li>Sockfd:套接字描述符</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 期末复习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十七）（完）</title>
      <link href="/2021/120353702.html"/>
      <url>/2021/120353702.html</url>
      
        <content type="html"><![CDATA[<h1 id="十七、构建小型网络"><a href="#十七、构建小型网络" class="headerlink" title="十七、构建小型网络"></a>十七、构建小型网络</h1><p>您已经来到了网络简介 v7.0 课程的最后一个模块。您已经掌握了建立自己的网络所需的大部分基础知识。从现在开始怎么做？当然，你要构建一个网络。而且您不仅要构建它，还要验证它是否正常工作，甚至还要解决一些常见的网络问题。</p><p><strong>模块目标</strong>: 对小型网络实施网络设计，加入 1 台路由器、1 台交换机和多部终端设备。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>小型网络中的设备</strong></td><td align="left">明确小型网络中使用的设备。</td></tr><tr><td align="left"><strong>小型网络应用程序和协议</strong></td><td align="left">明确小型网络中使用的协议和应用程序。</td></tr><tr><td align="left"><strong>扩展到大型网络</strong></td><td align="left">说明小型网络如何作为构建大型网络的基础。</td></tr><tr><td align="left"><strong>验证连接</strong></td><td align="left">使用 ping 和 tracert 命令的输出验证连接， 并确定相关网络的性能。</td></tr><tr><td align="left"><strong>主机和 IOS 命令</strong></td><td align="left">使用主机和 IOS 命令获取网络中设备的 相关信息。</td></tr><tr><td align="left"><strong>故障排除方法</strong></td><td align="left">描述常用的网络故障排除方法。</td></tr><tr><td align="left"><strong>故障排除场景</strong></td><td align="left">对网络中的设备进行故障排除。</td></tr></tbody></table><h1 id="1、小型网络中的设备"><a href="#1、小型网络中的设备" class="headerlink" title="1、小型网络中的设备"></a>1、小型网络中的设备</h1><h2 id="1-1、小型网络拓扑"><a href="#1-1、小型网络拓扑" class="headerlink" title="1.1、小型网络拓扑"></a>1.1、小型网络拓扑</h2><p>大多数企业规模都很小，因此，大多数的商业网络也很小就不足为奇了。</p><p>小型网络的设计通常很简单。与较大型网络相比，小型网络中设备的数量和类型都显著减少了。</p><p>例如，请参考图中所示的小型企业网络示例。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.1.png"></p><p>这个小型网络需要一台路由器、一台交换机和一个无线接入点来连接有线和无线用户、IP 电话、打印机和服务器。通常小型网络有一个由 DSL、电缆或以太网连接提供的 WAN 连接。</p><p>大型网络需要一个IT部门来维护设备运行、保护设备安全、排除网络设备的故障以及保护组织的数据。管理小型网络所要求的许多技能与管理较大网络所需技能相同。小型网络由当地的IT技术人员或签约的专业人员管理。</p><h2 id="1-2、小型网络的设备选择"><a href="#1-2、小型网络的设备选择" class="headerlink" title="1.2、小型网络的设备选择"></a>1.2、小型网络的设备选择</h2><p>为了满足用户需求，大型网络和小型网络都要求规划和设计。规划可以确保所有要求、成本因素和部署选项得到适当考虑。</p><p>最初设计的注意事项之一就是用于支持网络的中间设备类型。</p><h3 id="成本"><a href="#成本" class="headerlink" title="成本"></a>成本</h3><p>交换机或路由器的购买成本取决于其性能和功能。这包括可用的端口数量和类型以及背板速率。影响成本的其他因素包括网络管理功能、内嵌的安全技术、可选的高级交换技术。还需要考虑连接网络中每台设备所需的电缆布线费用。影响成本考量的另一个关键因素是网络整合的冗余量。</p><h3 id="端口-接口的速度和类型"><a href="#端口-接口的速度和类型" class="headerlink" title="端口/接口的速度和类型"></a>端口/接口的速度和类型</h3><p>路由器或交换机上端口数量和类型的选择是至关重要的。较新版本的计算机有内置的 1Gbps 网卡。有些服务器甚至可能有 10Gbps 端口。虽然比较昂贵，但是选用能够适应速度增长的第 2 层设备使网络能够进行扩展，而无需更换中心设备。</p><h3 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h3><p>网络设备的物理配置有固定式和模块化两种。固定式配置设备具有固定的端口或接口数量和类型。模块化设备具有扩展槽，可以随着需求的提高而新增模块。交换机上有附加端口，供高速上行链路使用。路由器可用于连接不同类型的网络。必须慎重选择每种介质适用的相应模块和接口。</p><h3 id="操作系统的功能和服务"><a href="#操作系统的功能和服务" class="headerlink" title="操作系统的功能和服务"></a>操作系统的功能和服务</h3><p>网络设备必须具有可以支持组织需求的操作系统，如下：</p><ul><li>第 3 层交换</li><li>网络地址转换 (NAT)</li><li>动态主机配置协议 (DHCP)</li><li>安全性</li><li>服务质量 (QoS)</li><li>网络电话 (VoIP)</li></ul><h2 id="1-3、小型网络的IP编址"><a href="#1-3、小型网络的IP编址" class="headerlink" title="1.3、小型网络的IP编址"></a>1.3、小型网络的IP编址</h2><p>在实施网络时，创建一个 IP编址方案并使用它。互联网络中的所有主机和设备都必须有一个唯一地址。</p><p>将纳入IP编址方案的设备包括以下内容：</p><ul><li>终端用户设备-连接的数量和类型（即有线、无线、远程访问）</li><li>服务器和外部设备（如打印机和安全摄像头）</li><li>路由器、交换机和接入点都属于中间设备。</li></ul><p>建议您根据设备类型规划、记录和维护 IP编址方案。使用计划好的IP编址方案可以更容易地识别设备类型并对排除故障，例如，在使用协议分析器排除网络流量问题时。</p><p>例如，请参考图中中小型组织的拓扑结构。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.2.png"></p><p>该组织需要三个用户局域网(即192.168.1.0/24、192.168.2.0/24和192.168.3.0/24）。该组织已决定为每个192.168.x.0/24局域网实现一致的IP编址方案。计划如下表:</p><table><thead><tr><th align="left"><strong>设备类型</strong></th><th align="left"><strong>可分配的IP地址范围</strong></th><th align="left"><strong>概括为…</strong></th></tr></thead><tbody><tr><td align="left">默认网关（路由器）</td><td align="left">192.168.x.<strong>1</strong> - 192.168.x.<strong>2</strong></td><td align="left">192.168.x.<strong>0/30</strong></td></tr><tr><td align="left">交换机(最多 2 个)</td><td align="left">192.168.x.<strong>5</strong> - 192.168.x.<strong>6</strong></td><td align="left">192.168.x.<strong>4/30</strong></td></tr><tr><td align="left">接入点（最多 6 个）</td><td align="left">192.168.x.<strong>9</strong> - 192.168.x.<strong>14</strong></td><td align="left">192.168.x.<strong>8/29</strong></td></tr><tr><td align="left">服务器 (最多 6 台)</td><td align="left">192.168.x.<strong>17</strong> - 192.168.x.<strong>22</strong></td><td align="left">192.168.x.<strong>16/29</strong></td></tr><tr><td align="left">打印机 (最多 6 台)</td><td align="left">192.168.x.<strong>25</strong> - 192.168.x.<strong>30</strong></td><td align="left">192.168.x.<strong>24/29</strong></td></tr><tr><td align="left">IP 电话 (最多 6 台)</td><td align="left">192.168.x.<strong>33</strong> - 192.168.x.<strong>38</strong></td><td align="left">192.168.x.<strong>32/29</strong></td></tr><tr><td align="left">有线设备（最多62个）</td><td align="left">192.168.x.<strong>65</strong> - 192.168.x.<strong>126</strong></td><td align="left">192.168.x.<strong>64/26</strong></td></tr><tr><td align="left">无线设备 (最多 62 个)</td><td align="left">192.168.x.<strong>193</strong> - 192.168.x.<strong>254</strong></td><td align="left">192.168.x.<strong>192/26</strong></td></tr></tbody></table><p>该图显示了使用预定义 IP编址方案分配 IP地址的192.168.2.0/24 网络设备的示例。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.3.png"></p><p>例如，默认的网关 IP 地址是 192.168.2.1/24，交换机地址是 192.168.2.5/24，服务器地址是 192.168.2.17/24，等等。</p><p>注意，可分配的IP地址范围是有意分配到子网网络边界上的，以简化组类型的汇总。例如，假设另一个IP地址为192.168.2.6 的交换机被添加到网络中。要识别网络策略中的所有交换机，管理员可以指定汇总网络地址 192.168.x.4/30。</p><h2 id="1-4、小型网络中的冗余"><a href="#1-4、小型网络中的冗余" class="headerlink" title="1.4、小型网络中的冗余"></a>1.4、小型网络中的冗余</h2><p>网络设计的另一个重要部分是可靠性。即使是小型企业，也常常非常依赖其网络以进行企业运营。网络故障的代价是非常大的。</p><p>为了保持高可靠度，网络设计中要求冗余。冗余有助于避免单点故障。</p><p>在网络中实现冗余有许多方法。可以通过安装重复设备实现冗余，但也可以通过为关键区域提供重复的网络链路来实现，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.4.png"></p><h2 id="1-5、流量管理"><a href="#1-5、流量管理" class="headerlink" title="1.5、流量管理"></a>1.5、流量管理</h2><p>小型网络中良好网络设计的目标也是为了提高员工工作效率和最大限度地减少网络中断。网络管理员应当考虑网络设计中的各种流量类型及其处理。</p><p>应当对小型网络中的路由器和交换机进行配置，以相对于其他数据流量的适当方式支持实时流量，如语音和视频。事实上，<strong>一个好的网络设计将实现服务质量（QoS），根据优先级对流量进行仔细分类</strong>，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.5.png"></p><p>优先级有四个队列。高优先级队列总是先为空。</p><h1 id="2、小型网络应用程序和协议"><a href="#2、小型网络应用程序和协议" class="headerlink" title="2、小型网络应用程序和协议"></a>2、小型网络应用程序和协议</h1><h2 id="2-1、常见应用程序"><a href="#2-1、常见应用程序" class="headerlink" title="2.1、常见应用程序"></a>2.1、常见应用程序</h2><p>上一个主题讨论了小型网络的组件以及一些设计需要考虑的因素。当您正在建立一个网络时，这些考虑是必要的。建立完成后，您的网络仍然需要某些类型的应用程序和协议才能工作。</p><p>网络只有在网络上存在应用程序时才有用。有两种形式的软件程序或进程可以提供网络访问：网络应用程序和应用层服务。</p><p><strong>网络应用程序</strong></p><p>应用程序是指用于网络通信的软件程序。有些终端用户应用程序是网络感知程序，即这些程序实现应用层协议，并可直接与协议栈的较低层通信。电子邮件客户端和 Web 浏览器就属于这种类型的应用程序。</p><p><strong>应用层服务</strong></p><p>其他程序可能需要通过应用层服务使用网络资源，例如文件传输或网络假脱机打印。虽然这些服务对员工而言是透明的，但它们正是负责与网络交互和准备传输数据的程序。无论数据类型是文本、图形还是视频，只要类型不同，就需要与之对应的不同的网络服务，从而确保 OSI 模型的下层能够正确处理数据。</p><p>每个应用程序或网络服务使用协议，定义要使用的标准和数据格式。如果没有协议，数据网络将不能使用通用的方式来格式化及引导数据。为了便于理解不同网络服务的功能，我们有必要先熟悉管理这些服务的底层协议。</p><p>如图所示，使用任务管理器来查看 Windows PC 上当前运行的应用程序、进程和服务。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.6.png"></p><h2 id="2-2、常见协议"><a href="#2-2、常见协议" class="headerlink" title="2.2、常见协议"></a>2.2、常见协议</h2><p>不管在小型还是大型网络中，技术人员的大部分工作都是与网络协议有关的。在小型网络中，网络协议将支持员工所使用的应用程序和服务。</p><p>网络管理员通常需要访问网络设备和服务器。两种最常见的远程访问解决方案是 Telnet 和安全外壳 (SSH)。SSH 服务是 Telnet 的安全替代方案。连接后，管理员可以像在本地登录一样访问 SSH 服务器设备。</p><p>SSH 用于在 SSH 客户端和其他支持 SSH 的设备之间建立安全的远程访问连接：</p><ul><li><strong>网络设备</strong> -网络设备（如路由器、交换机、接入点等）必须支持 SSH，才能为客户端提供远程访问 SSH 服务器的服务。</li><li><strong>服务器</strong> -服务器（例如 Web 服务器、电子邮件服务器等）必须支持到客户端的远程访问 SSH 服务器的服务。</li></ul><p>网络管理员还必须支持公用网络服务器及其所需的相关网络协议，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.7.png"></p><h3 id="Web设备安全"><a href="#Web设备安全" class="headerlink" title="Web设备安全"></a>Web设备安全</h3><ul><li>Web 客户端和 Web 服务器使用超文本传输协议 (HTTP) 交换 Web 流量。</li><li>超文本传输协议安全 (HTTPS) 用于安全的 Web 通信。</li></ul><h3 id="邮件服务器"><a href="#邮件服务器" class="headerlink" title="邮件服务器"></a>邮件服务器</h3><ul><li>邮件服务器和客户端使用简单邮件传输协议 (SMTP)发送邮件。</li><li>邮件客户端使用邮局协议 (POP3) 和互联网消息访问协议 (IMAP)检索邮件。</li><li>使用 <a href="mailto:user@xyz.xxx">user@xyz.xxx</a> 格式指定收件人。</li></ul><h3 id="FTP服务器"><a href="#FTP服务器" class="headerlink" title="FTP服务器"></a>FTP服务器</h3><ul><li>文件传输协议 (FTP) 服务允许在客户端和 FTP 服务器之间下载和上传文件。</li><li>FTP 安全（FPS）和安全 FTP（SFTP）用于保护 FTP 文件交换。</li></ul><h3 id="DHCP服务器"><a href="#DHCP服务器" class="headerlink" title="DHCP服务器"></a>DHCP服务器</h3><p>客户端使用动态主机配置协议 (DHCP) 从 DHCP 服务器获取 IP 配置（即 IP地址、子网掩码、默认网关等）。</p><h3 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h3><ul><li>域名服务（DNS）将域名解析为 IP 地址（例如，cisco.com = 72.163.4.185）</li><li>DNS 向请求主机提供网站的 IP 地址（即域名）。</li></ul><p><strong>注意</strong>: 服务器可以提供多个网络服务。例如，服务器可以是电子邮件、FTP 和 SSH 服务器。</p><p>这些网络协议将构成网络专家的基本工具集。每种网络协议都会定义：</p><ul><li>通信会话任意一端的流程</li><li>消息类型</li><li>消息语法</li><li>信息性字段的意义</li><li>消息发送方式和预期响应</li><li>与下一层的交互</li></ul><p>许多公司都已制定政策，尽可能使用这些协议的安全版本（即SSH、SFTP和HTTPS）。</p><h2 id="2-3、语音和视频应用程序"><a href="#2-3、语音和视频应用程序" class="headerlink" title="2.3、语音和视频应用程序"></a>2.3、语音和视频应用程序</h2><p>如今，企业越来越多地使用 IP 电话和流媒体与客户和业务合作伙伴沟通。许多组织正在使其员工能够远程工作。如图所示，他们的许多用户仍然需要访问公司软件和文件，以及对语音和视频应用程序的支持。</p><p>网络管理员必须确保在网络中安装合适的设备并且对网络设备进行配置以确保优先传输。</p><h3 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h3><ul><li>网络基础设施必须支持实时应用程序。</li><li>必须对 现有设备和布线进行测试和验证。</li><li>可能需要 更新的网络产品。</li></ul><h3 id="VoIP"><a href="#VoIP" class="headerlink" title="VoIP"></a>VoIP</h3><ul><li>VoIP 设备将模拟电话信号转换为数字 IP 数据包。</li><li>通常，VoIP 比IP电话解决方案要低廉得多，但通信质量不能达到相同的标准。</li><li>小型网络语音和 IP 视频可以使用 Skype 和非企业版的思科 WebEx 解决。</li></ul><h3 id="IP电话"><a href="#IP电话" class="headerlink" title="IP电话"></a>IP电话</h3><ul><li>IP电话使用专用的呼叫控制和信令服务器进行语音到IP的转换。</li><li>许多供应商提供小型企业 IP 电话解决方案，如思科Business Edition 4000 系列产品。</li></ul><h3 id="实时应用"><a href="#实时应用" class="headerlink" title="实时应用"></a>实时应用</h3><ul><li>网络必须支持服务质量 (QoS) 机制，以最大限度地减少实时流应用程序的延迟问题。</li><li>实时传输协议 (RTP) 和实时传输控制协议 (RTCP) 支持这一要求。</li></ul><h1 id="3、扩展为大型网络"><a href="#3、扩展为大型网络" class="headerlink" title="3、扩展为大型网络"></a>3、扩展为大型网络</h1><h2 id="3-1、小型网络的增长"><a href="#3-1、小型网络的增长" class="headerlink" title="3.1、小型网络的增长"></a>3.1、小型网络的增长</h2><p>如果您的网络是为小型企业服务的，那么您可能希望该企业能够增长，您的网络也会随之增长。这称为扩展网络，有一些最佳实践可以做到这一点。</p><p>不断扩展是许多小型企业必经的过程，而其网络也必须相应地扩展。理想情况是网络管理员有足够的时间根据公司发展做出关于网络发展的明智决策。</p><p>要扩展网络，要求有以下几个要素：</p><ul><li><strong>网络文档</strong> - 物理和逻辑拓扑</li><li><strong>设备清单</strong> – 使用或组成网络的设备列表</li><li><strong>预算</strong> – 逐项列出IT预算，包括财年设备采购预算</li><li><strong>流量分析</strong> - 应当记录协议、应用程序和服务以及它们各自的流量要求</li></ul><p>这些要素用于为有关小型网络扩展的决策提供信息。</p><h2 id="3-2、协议分析"><a href="#3-2、协议分析" class="headerlink" title="3.2、协议分析"></a>3.2、协议分析</h2><p>随着网络的增长，确定如何管理网络流量变得非常重要。了解网络上传输的流量类型以及当前的流量流很重要。有几个网络管理工具可用于此目的。但是，也可以使用 Wireshark 等简单的协议分析器。</p><p>例如，在多个关键主机上运行 Wireshark 可以显示流经网络的网络流量类型。下图显示了小型网络上 Windows 主机的 Wireshark 协议分布统计信息。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.8.png"></p><p>屏幕截图显示主机正在使用 IPv6 和 IPv4 协议。IPv4 特定输出还显示主机已使用 DNS、SSL、HTTP、ICMP 和其他协议。</p><p>要确定流量模式，应做好以下几点：</p><ul><li>通过捕获网络使用高峰期的流量准确了解各种不同的流量类型。</li><li>针对不同的网段和设备捕获流量，因为某些流量仅在特定的网段内传输。</li></ul><p>协议分析器收集的信息根据流量的源和目标以及发送的流量类型进行分析。这种分析有助于决定提高流量管理效率的方法，例如减少不必要的流量，或通过移动某台服务器的逻辑位置来改变流量的总体模式。</p><p>有时，只要简单地将服务器或服务移到另一个网段就能提高网络性能并满足不断增长的流量需求。有时则需要大刀阔斧地进行网络的重新设计并投入巨大的人力才可以优化网络的性能。</p><h2 id="3-3、员工网络使用率"><a href="#3-3、员工网络使用率" class="headerlink" title="3.3、员工网络使用率"></a>3.3、员工网络使用率</h2><p>除了要了解流量的变化趋势，网络管理员必须知道网络的使用是如何变化的。许多操作系统都提供内置工具来显示此类信息。例如，Windows 主机提供任务管理器、事件查看器和数据使用情况工具等工具。</p><p>这些工具可用于捕获以下信息的 “快照”：</p><ul><li>操作系统和操作系统版本</li><li>CPU 使用率</li><li>内存利用率</li><li>驱动程序利用率</li><li>非网络应用程序</li><li>网络应用程序</li></ul><p>在一段时间内记录小型网络中的员工快照对于识别不断发展的协议需求和相关的流量流非常有用。这种资源利用率的转变就可能要求网络管理员相应地调整网络资源分配。</p><p>Windows 10 数据使用量工具对于确定哪些应用程序正在使用主机上的网络服务特别有用。数据使用量工具可以使用 <strong>Settings &gt; Network &amp; Internet &gt; Data usage &gt; network interface</strong> （从最近 30 天开始）访问。</p><p>图中的示例显示了使用本地 Wi-Fi 网络连接在远程用户 Windows 10 主机上运行的应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.9.png"></p><h1 id="4、验证连接"><a href="#4、验证连接" class="headerlink" title="4、验证连接"></a>4、验证连接</h1><h2 id="4-1、通过Ping验证连接性"><a href="#4-1、通过Ping验证连接性" class="headerlink" title="4.1、通过Ping验证连接性"></a>4.1、通过Ping验证连接性</h2><p>无论您的网络是新的还是小的，或者您正在扩展现有的网络，您总是希望能够验证您的组件彼此之间以及与互联网的连接是否正确。本主题讨论了一些可用于确保网络连接的实用程序。</p><p><strong>ping</strong>命令是快速测试源和目的 IP 地址之间第 3 层连接的最有效方法。该命令还显示各种往返时间统计信息。</p><p>具体而言，该 <strong>ping</strong> 命令使用 Internet 控制消息协议 (ICMP) 来Echo请求（ICMP 类型 8）和Echo应答（ICMP 类型 0）消息。该 <strong>ping</strong> 命令可用于大多数操作系统，包括 Windows、Linux、macOS 和思科 IOS。</p><p>在 Windows 10 主机上，该 <strong>ping</strong> 命令发送四个连续的 ICMP Echo消息，并期望从目标收到四个连续的 ICMP Echo应答。</p><p>例如，假设 PC A Ping PC B. 如图所示，PC A Windows 主机将四个连续的 ICMP Echo消息发送到 PC B（即 10.1.1.10）。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.10.png"></p><p>目的主机接收并处理 ICMP Echos。如图所示，PC B 通过向 PC A 发送四条 ICMP Echo应答消息进行响应。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.11.png"></p><p>如命令输出中所示，PC A 已收到来自 PC-B 的Echo应答，验证了第 3 层网络连接。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ping 10.1.1.10Pinging 10.1.1.10 with 32 bytes of data:Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;47ms TTL&#x3D;51Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;60ms TTL&#x3D;51Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;53ms TTL&#x3D;51Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;50ms TTL&#x3D;51Ping statistics for 10.1.1.10:    Packets: Sent &#x3D; 4, Received &#x3D; 4, Lost &#x3D; 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum &#x3D; 47ms, Maximum &#x3D; 60ms, Average &#x3D; 52msC:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出验证了 PC A 和 PC B 之间的第 3 层连接。</p><p>思科 IOS <strong>ping</strong> 命令的输出不同于 Windows 主机。例如，IOS ping 会发送五条 ICMP Echo消息，如输出所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# ping 10.1.1.10Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.10, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;2 msR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意 <strong>!!!!!</strong> 输出字符。IOS <strong>ping</strong> 命令为收到的每个 ICMP Echo应答显示一个指示符。下表列出 <strong>ping</strong> 命令可能输出的字符：</p><h3 id="IOS-Ping-指示符"><a href="#IOS-Ping-指示符" class="headerlink" title="IOS Ping 指示符"></a>IOS Ping 指示符</h3><table><thead><tr><th align="left">元素</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>!</strong></td><td align="left">感叹号表示成功收到Echo应答 消息。它验证了源和目标之间的第 3 层连接。</td></tr><tr><td align="left"><strong>.</strong></td><td align="left">句点意味着等待Echo应答消息的时间已过期。这表示路径中某处可能存在连接 问题。</td></tr><tr><td align="left"><strong>U</strong></td><td align="left">大写 <strong>U</strong> 表示沿路径的路由器 回应了 ICMP 类型 3 “目的地 不可达” 的错误消息。可能的原因包括路由器不知道目标网络的方向， 或者在目标网络上 找不到主机。</td></tr></tbody></table><p><strong>注意:</strong> 其他可能的 ping 回复包括 Q、M、? 或 &amp;。但是，这些含义超出了本模块的范围。</p><h2 id="4-2、扩展Ping"><a href="#4-2、扩展Ping" class="headerlink" title="4.2、扩展Ping"></a>4.2、扩展Ping</h2><p>标准 <strong>ping</strong> 使用最接近目标网络的接口的 IP 地址作为<strong>ping</strong>的源地址 。R1 上 <strong>ping 10.1.1.10</strong> 命令的源 IP 地址将是 G0/0/0 接口的地址（即 209.165.200.225），如示例所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.12.png"></p><p>思科IOS 提供<strong>ping</strong>命令的“扩展”模式。此模式允许用户通过调整与命令操作相关的参数来创建特殊类型的 ping。</p><p>在特权 EXEC 模式键入<strong>ping</strong> ，可进入扩展模式，无需目的 IP 地址。然后，您将得到多个提示来自定义扩展 <strong>ping</strong>。</p><p><strong>注意:</strong> Pressing <strong>Enter</strong> 可接受所指出的默认值。</p><p>例如，假设您想要测试从 R1 局域网（即 192.168.10.0/24）到 10.1.1.0 局域网的连接性。这可以从 PC A 进行验证。但是，扩展 <strong>ping</strong> 可以在 R1 上配置以指定不同的源地址。</p><p>如示例所示，R1 上扩展 <strong>ping</strong> 命令的源 IP 地址可以配置为使用 G0/0/1 接口的 IP 地址（即 192.168.10.1）。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.13.png"></p><p>下面在R1上的命令输出配置一个扩展<strong>ping</strong>，并指定源IP地址为G0/0/1接口的IP地址(即192.168.10.1)。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# pingProtocol [ip]:Target IP address: 10.1.1.10Repeat count [5]:Datagram size [100]:Timeout in seconds [2]:Extended commands [n]: yIngress ping [n]:Source address or interface: 192.168.10.1DSCP Value [0]:Type of service [0]:Set DF bit in IP header? [no]:Validate reply data? [no]:Data pattern [0x0000ABCD]:Loose, Strict, Record, Timestamp, Verbose[none]:Sweep range of sizes [n]:Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.1, timeout is 2 seconds:Packet sent with a source address of 192.168.10.1!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;1 msR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>: <strong>ping ipv6</strong>命令用于 IPv6 扩展 ping。</p><h2 id="4-3、通过Traceroute验证连接性"><a href="#4-3、通过Traceroute验证连接性" class="headerlink" title="4.3、通过Traceroute验证连接性"></a>4.3、通过Traceroute验证连接性</h2><p>该 <strong>ping</strong> 命令可用于快速确定是否存在第 3 层连接问题。但是，它不能确定问题位于路径的什么位置。</p><p>Traceroute可以帮助定位网络中的第3层问题区域。追踪可用于返回数据包在网络中传输时沿途经过的跳跃列表。它可以用来识别路径上发现问题的点。</p><p>追踪命令的语法因操作系统而异，如图所示。</p><p><strong>Windows 和思科 IOS 追踪命令</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.14.png"></p><p>以下是 Windows 10 主机上的 <strong>tracert</strong> 命令输出示例。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; tracert 10.1.1.10Tracing route to 10.1.10 over a maximum of 30 hops:  1     2 ms     2 ms     2 ms  192.168.10.1  2     *        *        *     Request timed out.  3     *        *        *     Request timed out.  4     *        *        *     Request timed out.^CC:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong> Use <strong>Ctrl-C</strong> to interrupt a <strong>跟踪器</strong> 在窗口.</p><p>唯一成功的响应来自 R1 上的网关。对下一跳的追踪请求超时，由星号(*)表示，这意味着下一跳的路由器没有响应。超时的请求表明，局域网以外的互联网络中有错误，或者这些路由已经配置为不响应追踪中使用的Echo请求。在这个例子中，R1 和 R2 之间似乎存在问题。</p><p>思科 IOS <strong>traceroute</strong> 命令输出与 Windows <strong>tracert</strong>命令不同。例如，请参考以下拓扑结构。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.15.png"></p><p>以下是来自 R1 的Traceroute命令的示例输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# traceroute 10.1.1.10Type escape sequence to abort.Tracing the route to 10.1.1.10VRF info: (vrf in name&#x2F;id, vrf out name&#x2F;id)1 209.165.200.226 1 msec 0 msec 1 msec2 209.165.200.230 1 msec 0 msec 1 msec3 10.1.1.10 1 msec 0 msecR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在此示例中，追踪验证了它可以成功到达 PC B。</p><p>超时表示存在潜在的问题。例如，如果 10.1.1.10 主机不可用，则该 <strong>traceroute</strong> 命令将显示以下输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# traceroute 10.1.1.10Type escape sequence to abort.Tracing the route to 10.1.1.10VRF info: (vrf in name&#x2F;id, vrf out name&#x2F;id)1 209.165.200.226 1 msec 0 msec 1 msec2 209.165.200.230 1 msec 0 msec 1 msec3 * * *4 * * *5 *<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用 <strong>Ctrl-Shift-6</strong> 来中断思科IOS上的 <strong>traceroute</strong>命令。</p><p><strong>注意</strong>: traceroute (tracert) 的 Windows 实现用于发送 ICMP Echo请求。思科 IOS 和 Linux 使用具有无效端口号的 UDP。最终目的地将返回一个ICMP 端口不可达的消息。</p><h2 id="4-4、扩展-Traceroute"><a href="#4-4、扩展-Traceroute" class="headerlink" title="4.4、扩展 Traceroute"></a>4.4、扩展 Traceroute</h2><p>就像扩展 <strong>ping</strong>命令一样，同样也有一个扩展 <strong>traceroute</strong> 命令。它允许管理员调整与命令操作相关的参数。这有助于在排除路由环路故障以及准确确定下一跳路由器时定位问题，或者可以帮助确定路由器或防火墙在何处丢弃或拒绝了数据包。</p><p>Windows <strong>tracert</strong>命令允许通过命令行中的选项输入多个参数。但是，它不像扩展追踪 IOS 命令那样提供引导。以下输出显示了 Windows <strong>tracert</strong> 命令的可用选项。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; tracert &#x2F;?Usage: tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout]               [-R] [-S srcaddr] [-4] [-6] target_nameOptions:    -d                 Do not resolve addresses to hostnames.    -h maximum_hops    Maximum number of hops to search for target.    -j host-list       Loose source route along host-list (IPv4-only).    -w timeout         Wait timeout milliseconds for each reply.    -R                 Trace round-trip path (IPv6-only).    -S srcaddr         Source address to use (IPv6-only).    -4                 Force using IPv4.    -6                 Force using IPv6.C:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>思科IOS扩展<strong>traceroute</strong>选项允许用户通过调整与命令操作相关的参数来创建特殊类型的 trace。在特权 EXEC 模式键入<strong>traceroute</strong> ，可进入扩展traceroute模式，无需目的 IP 地址。IOS 将会显示一些与各个参数的设置相关的提示，引导您使用命令选项。</p><p><strong>注意</strong>:按<strong>Enter</strong>可接受所指出的默认值。</p><p>例如，假设您要测试从 R1 局域网到 PC B 的连接。虽然这可以从 PC A 进行验证。但是，扩展 <strong>traceroute</strong> 可以在 R1 上配置以指定不同的源地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.16.png"></p><p>如示例所示，R1 上扩展 <strong>traceroute</strong> 命令的源 IP 地址可以配置为使用 R1局域网接口的 IP 地址（即 192.168.10.1）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# tracerouteProtocol [ip]:Target IP address: 10.1.1.10Ingress traceroute [n]:Source address: 192.168.10.1DSCP Value [0]:Numeric display [n]:Timeout in seconds [3]:Probe count [3]:Minimum Time to Live [1]:Maximum Time to Live [30]:Port Number [33434]:Loose, Strict, Record, Timestamp, Verbose[none]:Type escape sequence to abort.Tracing the route to 192.168.10.10VRF info: (vrf in name&#x2F;id, vrf out name&#x2F;id)  1 209.165.200.226 1 msec 1 msec 1 msec  2 209.165.200.230 0 msec 1 msec 0 msec  3  *    10.1.1.10 2 msec 2 msecR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、网络基线"><a href="#4-5、网络基线" class="headerlink" title="4.5、网络基线"></a>4.5、网络基线</h2><p>监控网络和排除网络故障的最有效的工具之一就是建立网络基线。创建一条有效的网络性能基线需要一段较长的时间才能完成。在不同时间以及各种负载下测量网络性能有助于建立更准确的网络整体性能概貌。</p><p>网络命令的输出可为网络基线提供数据。开始基线的方法之一就是将<strong>ping</strong>、<strong>trace</strong>或其他相关命令的执行结果复制并粘贴到文本文件中。然后为这些文本文件加上时间戳并保存到档案中以备将来检索和比较。</p><p>需考虑的项目包括错误消息以及主机之间的响应时间。如果响应时间增加较大，则表示可能有延时问题需要解决。</p><p>例如，以下 <strong>ping</strong> 输出已捕获并粘贴到文本文件中。</p><p><strong>August 19, 2019 at 08:14:43</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ping 10.1.1.10Pinging 10.1.1.10 with 32 bytes of data:Reply from 10.1.1.10: bytes&#x3D;32 time&lt;1ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&lt;1ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&lt;1ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&lt;1ms TTL&#x3D;64Ping statistics for 10.1.1.10:    Packets: Sent &#x3D; 4, Received &#x3D; 4, Lost &#x3D; 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum &#x3D; 0ms, Maximum &#x3D; 0ms, Average &#x3D; 0msC:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意 <strong>ping</strong> 往返时间小于 1 毫秒。</p><p>一个月后，再次进行了ping测试并捕获记录。</p><p>**September 19, 2019 at 10:1,821</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ping 10.1.1.10Pinging 10.1.1.10 with 32 bytes of data:Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;50ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;49ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;46ms TTL&#x3D;64Reply from 10.1.1.10: bytes&#x3D;32 time&#x3D;47ms TTL&#x3D;64Ping statistics for 10.1.1.10:    Packets: Sent &#x3D; 4, Received &#x3D; 4, Lost &#x3D; 0 (0% loss),Approximate round trip times in milli-seconds:    Minimum &#x3D; 46ms, Maximum &#x3D; 50ms, Average &#x3D; 48msC:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>请注意，这次 <strong>ping</strong> 往返时间要长得多，表明存在潜在的问题。</p><p>企业网络应该制备详尽的基线，覆盖内容要远比我们在本课中所述全面得多。可选用专业的软件工具来存储和维护基线信息。在本课程中，我们介绍几个基本技巧并讨论基线的用途。</p><p>通过在互联网上搜索 “基准流程最佳实践”，可以找到思科的基准流程最佳实践。</p><h2 id="4-6、实验-使用-Ping-命令和-Traceroute-命令测试网络延时"><a href="#4-6、实验-使用-Ping-命令和-Traceroute-命令测试网络延时" class="headerlink" title="4.6、实验 - 使用 Ping 命令和 Traceroute 命令测试网络延时"></a>4.6、实验 - 使用 Ping 命令和 Traceroute 命令测试网络延时</h2><p>略</p><h1 id="5、主机和IOS命令"><a href="#5、主机和IOS命令" class="headerlink" title="5、主机和IOS命令"></a>5、主机和IOS命令</h1><h2 id="5-1、Windows主机的-IP-配置"><a href="#5-1、Windows主机的-IP-配置" class="headerlink" title="5.1、Windows主机的 IP 配置"></a>5.1、Windows主机的 IP 配置</h2><p>如果您使用上一主题中的任何工具来验证连接性，并发现网络的某些部分不能正常工作，那么现在是使用一些命令来对设备进行故障排除的时候了。主机和 IOS 命令可以帮助您确定问题是否与设备的 IP编址有关，这是一个常见的网络问题。</p><p>检查主机设备上的 IP 地址是网络中用于验证端到端连接并排除故障的常见做法。在 Windows 10 中，您可以从<strong>Network and Sharing Center</strong>（如图所示）访问 IP 地址详细信息，以快速查看四个重要的设置：地址、掩码、路由器和 DNS。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.17.png"></p><p>但是，网络管理员通常通过会在 Windows 计算机的命令行发出 <strong>ipconfig</strong> 命令来查看 Windows 主机上的 IP编址信息，如示例输出中所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfigWindows IP Configuration(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16      IPv4 Address. . . . . . . . . . . : 192.168.10.10      Subnet Mask . . . . . . . . . . . : 255.255.255.0   Default Gateway . . . . . . . . . : 192.168.10.1(Output omitted)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<strong>ipconfig /all</strong>命令可查看 MAC 地址和有关设备第 3 层编址的许多细节，如示例输出中所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfig &#x2F;allWindows IP Configuration   Host Name . . . . . . . . . . . . : PC-A-00H20   Primary Dns Suffix  . . . . . . . : cisco.com   Node Type . . . . . . . . . . . . : Hybrid   IP Routing Enabled. . . . . . . . : No   WINS Proxy Enabled. . . . . . . . : No   DNS Suffix Search List. . . . . . : cisco.com(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Intel(R) Dual Band Wireless-AC 8265   Physical Address. . . . . . . . . : F8-94-C2-E4-C5-0A   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : Yes   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16(Preferred)    IPv4 Address. . . . . . . . . . . : 192.168.10.10(Preferred)   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Lease Obtained. . . . . . . . . . : August 17, 2019 1:20:17 PM   Lease Expires . . . . . . . . . . : August 18, 2019 1:20:18 PM   Default Gateway . . . . . . . . . : 192.168.10.1   DHCP Server . . . . . . . . . . . : 192.168.10.1   DHCPv6 IAID . . . . . . . . . . . : 100177090   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-21-F3-76-75-54-E1-AD-DE-DA-9A   DNS Servers . . . . . . . . . . . : 192.168.10.1   NetBIOS over Tcpip. . . . . . . . : Enabled<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果将主机配置为 DHCP 客户端，则可以使用 <strong>ipconfig /release</strong> 和 <strong>ipconfig /renew</strong> 命令续订 IP 地址配置，如示例输出中所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfig &#x2F;release(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16   Default Gateway . . . . . . . . . :(Output omitted)C:\Users\PC-A&gt; ipconfig &#x2F;renew(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16   IPv4 Address. . . . . . . . . . . : 192.168.1.124   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Default Gateway . . . . . . . . . : 192.168.1.1(Output omitted)C:\Users\PC-A&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在安装了 Windows 系统的 PC 上，DNS 客户端服务可以预先在内存中存储已解析的域名，从而优化 DNS 域名解析性能。在 Windows 计算机系统中，输入<strong>ipconfig /displaydns</strong>命令可以显示所有 DNS 缓存条目，如示例输出中所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfig &#x2F;displaydnsWindows IP Configuration(Output omitted)    netacad.com    ----------------------------------------    Record Name . . . . . : netacad.com    Record Type . . . . . : 1    Time To Live  . . . . : 602    Data Length . . . . . : 4    Section . . . . . . . : Answer    A (Host) Record . . . : 54.165.95.219(Output omitted)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2、Linux主机的-IP-配置"><a href="#5-2、Linux主机的-IP-配置" class="headerlink" title="5.2、Linux主机的 IP 配置"></a>5.2、Linux主机的 IP 配置</h2><p>在 Linux 计算机上使用 GUI 验证 IP 设置将根据 Linux 发行版和桌面界面而有所不同。下图显示了运行 Gnome 桌面的 Ubuntu 发行版上的 <strong>Connection Information</strong> 对话框。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.18.png"></p><p>在命令行中，网络管理员使用 <strong>ifconfig</strong> 命令显示当前活动接口的状态及其 IP 配置，如输出中所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[analyst@secOps ~]$ ifconfigenp0s3    Link encap:Ethernet  HWaddr 08:00:27:b5:d6:cb            inet addr: 10.0.2.15  Bcast:10.0.2.255  Mask: 255.255.255.0          inet6 addr: fe80::57c6:ed95:b3c9:2951&#x2F;64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:1332239 errors:0 dropped:0 overruns:0 frame:0          TX packets:105910 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:1855455014 (1.8 GB)  TX bytes:13140139 (13.1 MB)lo: flags&#x3D;73  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10        loop  txqueuelen 1000  (Local Loopback)        RX packets 0  bytes 0 (0.0 B)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 0  bytes 0 (0.0 B)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux的<strong>ip address</strong> 命令用于显示地址及其属性。它也可以用于添加或删除 IP 地址。</p><p><strong>注意:</strong> 显示的输出可能会因 Linux 发行版不同和而有所区别。</p><h2 id="5-3、macOS主机的-IP-配置"><a href="#5-3、macOS主机的-IP-配置" class="headerlink" title="5.3、macOS主机的 IP 配置"></a>5.3、macOS主机的 IP 配置</h2><p>在 Mac 主机的 GUI 中，打开 <strong>Network Preferences &gt; Advanced</strong> 以获取 IP编址信息，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.19.png"></p><p>但是，该 <strong>ifconfig</strong> 命令也可用于验证输出中显示的接口 IP 配置。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">MacBook-Air:~ Admin$ ifconfig en0en0: flags&#x3D;8863 mtu 1500        ether c4:b3:01:a0:64:98        inet6 fe80::c0f:1bf4:60b1:3adb%en0 prefixlen 64 secured scopeid 0x5        inet 10.10.10.113 netmask 0xffffff00 broadcast 10.10.10.255        nd6 options&#x3D;201        media: autoselect        status: activeMacBook-Air:~ Admin$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用于验证主机 IP 设置的其他有用的 macOS 命令包括 <strong>networksetup -listallnetworkservices</strong> 和 <strong>networksetup -getinfo &lt;***网络服务***&gt;,</strong> 如下面的输出所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">MacBook-Air:~ Admin$ networksetup -listallnetworkservicesAn asterisk (*) denotes that a network service is disabled.iPhone USBWi-FiBluetooth PANThunderbolt BridgeMacBook-Air:~ Admin$ MacBook-Air:~ Admin$ networksetup -getinfo Wi-FiDHCP ConfigurationIP address: 10.10.10.113Subnet mask: 255.255.255.0Router: 10.10.10.1Client ID:IPv6: AutomaticIPv6 IP address: noneIPv6 Router: noneWi-Fi ID: c4:b3:01:a0:64:98MacBook-Air:~ Admin$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-4、arp-命令"><a href="#5-4、arp-命令" class="headerlink" title="5.4、arp 命令"></a>5.4、arp 命令</h2><p>该 <strong>arp</strong> 命令是从 Windows、Linux 或 Mac 的命令提示符执行的。该命令列出了当前主机 ARP 缓存中的所有设备，所列出的信息包括每台设备的 IPv4 地址、物理地址和编址类型（静态/动态）。</p><p>例如，请参考图中的拓扑结构。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.20.png"></p><p>在Windows PC-A主机上显示了该<strong>arp -a</strong>命令的输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; arp -aInterface: 192.168.93.175 --- 0xc  Internet Address      Physical Address      Type  10.0.0.2              d0-67-e5-b6-56-4b     dynamic  10.0.0.3              78-48-59-e3-b4-01     dynamic  10.0.0.4              00-21-b6-00-16-97     dynamic  10.0.0.254            00-15-99-cd-38-d9     dynamic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该 <strong>arp -a</strong> 命令显示了已知 IP 地址及 MAC 地址绑定。请注意， IP 地址 10.0.0.5 不包含在列表中。这是因为ARP 缓存仅显示最近访问过的设备的信息。</p><p>要确保填充 ARP 缓存，请<strong>ping</strong>一台设备以使该设备对应的条目出现在 ARP 表中。例如，如果 PC-A ping了 10.0.0.5，则 ARP 缓存将包含该 IP 地址的条目。</p><p>当网络管理员要使用更新后的信息重新填充路由器缓存时，可通过使用<strong>netsh interface ip delete arpcache</strong>命令来清空缓存。</p><p><strong>注意</strong>: 您可能需要主机的管理员访问权限才能使用 <strong>netsh interface ip delete arpcache</strong> 命令。</p><h2 id="5-5、常用show-命令回顾"><a href="#5-5、常用show-命令回顾" class="headerlink" title="5.5、常用show 命令回顾"></a>5.5、常用show 命令回顾</h2><p>命令和工具可用于验证主机配置，同样，命令也可用于验证中间设备的接口。Cisco IOS 提供了用于验证路由器接口和交换机接口工作情况的命令。</p><p>思科IOS CLI <strong>show</strong>命令显示有关设备配置和运行的相关信息。网络技术人员使用 <strong>show</strong>命令广泛用于查看配置文件，检查设备接口和进程的状态并且验证设备运行状态。几乎路由器的每个进程或功能的状态都可使用<strong>show</strong>命令显示出来。</p><p>表中列出了常用的 <strong>show</strong> 命令以及应该何时使用它们。</p><table><thead><tr><th align="left">Command</th><th align="left"><strong>Useful for …</strong></th></tr></thead><tbody><tr><td align="left"><strong>show running-config</strong></td><td align="left">验证当前的配置和设置</td></tr><tr><td align="left"><strong>show interfaces</strong></td><td align="left">验证接口状态并显示任何错误消息</td></tr><tr><td align="left"><strong>show ip interface</strong></td><td align="left">验证接口的第 3 层信息</td></tr><tr><td align="left"><strong>show arp</strong></td><td align="left">验证本地以太网局域网上的已知主机列表</td></tr><tr><td align="left"><strong>show ip route</strong></td><td align="left">验证第 3 层路由信息。</td></tr><tr><td align="left"><strong>show protocols</strong></td><td align="left">验证哪些协议是可操作的</td></tr><tr><td align="left"><strong>show version</strong></td><td align="left">验证设备的内存、接口和许可</td></tr></tbody></table><p><strong>注：对每个命令的详情见之前的笔记</strong></p><h2 id="5-6、show-cdp-neighbors-命令"><a href="#5-6、show-cdp-neighbors-命令" class="headerlink" title="5.6、show cdp neighbors 命令"></a>5.6、show cdp neighbors 命令</h2><p>还有几个很有用的 IOS 命令。思科发现协议 (CDP) 是思科专有协议，在数据链路层运行。由于 CDP 在数据链路层运行，即使第 3 层连接还未建立，两台或多台思科网络设备（例如支持不同网络层协议的路由器）也可以互相获取信息。</p><p>思科设备启动时会默认启动 CDP。CDP 会自动发现运行 CDP 的邻近思科设备，无论这些设备运行哪种第 3 层协议或协议簇。CDP 还会与直连的 CDP 邻居交换硬件和软件设备信息。</p><p>CDP 提供每台 CDP 邻居设备的以下信息：</p><ul><li><strong>设备标识符</strong> -交换机、路由器或其他设备的已配置主机名</li><li><strong>地址列表</strong> - 每种支持的协议最多对应一个网络层地址</li><li><strong>端口标识符</strong> -本地和远程端口的名称 － ASCII 字符格式的字符串，例如 FastEthernet 0/0</li><li><strong>功能列表</strong> -例如，特定设备是第 2 层交换机还是第 3 层交换机</li><li><strong>平台</strong> - 设备的硬件平台-例如 Cisco 1841 系列路由器</li></ul><p>请参考拓扑和<strong>show cdp neighbor</strong>命令的输出。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.21.png"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R3# show cdp neighborsCapability Codes: R - Router, T - Trans Bridge, B - Source Route Bridge                  S - Switch, H - Host, I - IGMP, r - Repeater, P - Phone,                  D - Remote, C - CVTA, M - Two-port Mac RelayDevice ID        Local Intrfce     Holdtme    Capability  Platform  Port IDS3               Gig 0&#x2F;0&#x2F;1         122              S I   WS-C2960+ Fas 0&#x2F;5Total cdp entries displayed : 1R3#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出显示了 R3 G0/0/1 接口连接到 S3 的F0/5 接口，这是思科2960+交换机。请注意，R3 尚未收集有关 S4 的信息。这是因为思科发现协议(CDP)只能发现直接连接的思科设备。S4 没有直接连接到 R3，所以没有在输出中列出。</p><p>该 <strong>show cdp neighbors detail</strong> 命令显示相邻设备的 IP 地址，如输出中所示。无论是否能 ping 通邻居，CDP 都会显示邻居的 IP 地址。当两台思科路由器无法通过共享的数据链路进行路由时，此命令非常有用。<strong>show cdp neighbors detail</strong>命令有助于确定某个 CDP 邻居是否存在 IP 配置错误。</p><p>虽然它和 CDP 同样有用，但它也会带来安全风险，因为它可以为威胁行动者提供有用的网络基础设施信息。例如，许多 IOS 版本默认情况下会向所有已启用的端口发送 CDP 通告。但是，最佳实践建议仅在连接到其他基础设施思科设备的接口上启用 CDP。应在面向用户的端口上禁用 CDP 通告。</p><p>由于某些 IOS 版本默认情况下会向外发送 CDP 通告，因此必须知道如何禁用 CDP。要全局禁用 CDP，可以使用全局配置命令<strong>no cdp run</strong>。要在某一接口上禁用 CDP，请使用接口命令<strong>no cdp enable</strong>。</p><h2 id="5-7、show-ip-interface-brief-命令"><a href="#5-7、show-ip-interface-brief-命令" class="headerlink" title="5.7、show ip interface brief 命令"></a>5.7、show ip interface brief 命令</h2><p><strong>show ip interface brief</strong>是最常用的命令之一。它提供的输出比<strong>show ip interface</strong>命令的输出更简略。它提供路由器上所有网络接口的重要信息摘要。</p><p>例如，<strong>show ip interface brief</strong>输出显示路由器的所有接口、分配给每个接口的 IP 地址（如果有）和接口的运行状态。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show ip interface briefInterface              IP-Address      OK? Method Status                ProtocolGigabitEthernet0&#x2F;0&#x2F;0   209.165.200.225 YES manual up                    upGigabitEthernet0&#x2F;0&#x2F;1   192.168.10.1    YES manual up                    upSerial0&#x2F;1&#x2F;0            unassigned      NO  unset  down                  downSerial0&#x2F;1&#x2F;1            unassigned      NO  unset  down                  downGigabitEthernet0       unassigned      YES unset  administratively down downR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证交换机接口</strong></p><p><strong>show ip interface brief</strong>命令也可用于验证交换机接口的状态，如输出所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">S1# show ip interface briefInterface              IP-Address      OK? Method Status                ProtocolVlanl                  192.168.254.250 YES manual up                    upFastEthernet0&#x2F;l        unassigned      YES unset  down                  downFastEthernet0&#x2F;2        unassigned      YES unset  up                    upFastEthernet0&#x2F;3        unassigned      YES unset  up                    up<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>The VLAN1 interface is assigned an IPv4 address of 192.168.254.250, has been enabled, and is operational.</p><p>输出还显示 FastEthernet0/1 接口已关闭。这表示没有设备连接到该接口或与该接口连接的设备中有一个网络接口不能正常运行。</p><p>相反，输出显示 FastEthernet0/2 接口和 FastEthernet0/3 接口都运行正常。这通过 Status（状态）列和 Protocol（协议）列中的 up（工作）来表明。</p><h2 id="5-8、视频-Show-Version-命令"><a href="#5-8、视频-Show-Version-命令" class="headerlink" title="5.8、视频- Show Version 命令"></a>5.8、视频- Show Version 命令</h2><p><strong>show version</strong>命令可用于检验和检修启动过程中使用的一些基本硬件和软件组件。</p><p>视频略</p><h2 id="5-9、Packet-Tracer-解释show命令输出"><a href="#5-9、Packet-Tracer-解释show命令输出" class="headerlink" title="5.9、Packet Tracer-解释show命令输出"></a>5.9、Packet Tracer-解释show命令输出</h2><p>略</p><h1 id="6、故障排除方法"><a href="#6、故障排除方法" class="headerlink" title="6、故障排除方法"></a>6、故障排除方法</h1><h2 id="6-1、故障排除基本方法"><a href="#6-1、故障排除基本方法" class="headerlink" title="6.1、故障排除基本方法"></a>6.1、故障排除基本方法</h2><p>在前两个主题中，您了解了一些可用于帮助识别网络中的问题区域的实用程序和命令。这是故障排除的一个重要部分。有很多方法可以解决网络问题。本主题详细介绍了一个结构化的故障排除过程，该过程可帮助您成为更好的网络管理员。它还提供了一些更多的命令来帮助您解决问题。网络问题可能非常简单，也可能很复杂，而且可能会因硬件、软件和连接问题综合导致。技术人员必须能够分析问题并确定错误的原因才能解决网络问题。此过程称为故障排除。</p><p>常用且有效的故障排除方法以科学方法为基础。</p><p>此表显示故障排除流程的六个主要步骤。</p><table><thead><tr><th align="left">步骤</th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>第 1 步：确定问题</strong></td><td align="left">这是故障排除流程的第一步。虽然此步骤中可以使用工具，但是沟通 往往非常有用。</td></tr><tr><td align="left"><strong>第 2 步：推测潜在原因</strong></td><td align="left">问题确定后，尝试推测一个 潜在的原因。此步骤通常会得出问题的多种潜在 原因。</td></tr><tr><td align="left"><strong>第 3 步：验证推测以确定原因</strong></td><td align="left">推断真正的原因 根据可能的原因，验证自己的理论，推断出 哪个才是导致问题的真正原因。技术人员通常会应用快速程序测试潜在原因，看 其是否能解决问题。流程没有解决这个问题，可能需要进一步研究 这个问题并且判断出准确的原因。</td></tr><tr><td align="left"><strong>第 4 步：制定解决方案并实施方案</strong></td><td align="left">在您已经明确了导致问题的原因之后，设计一个 方案来解决问题并实施解决方案。</td></tr><tr><td align="left"><strong>步骤 5. 检验解决方案并实施预防措施</strong></td><td align="left">在修复了问题之后，要验证完整的功能。如果需要的话，还要实施一些防御措施。</td></tr><tr><td align="left"><strong>第 6 步：记录调查结果、采取措施和结果</strong></td><td align="left">在故障排除流程的最后一步，记录 调查结果、采取措施和结果。这对于未来参考非常重要。</td></tr></tbody></table><p>为了对问题进行评估，请先确定网络中有多少台设备存在问题。如果网络中的一台设备存在问题，则在该设备上开始进行故障排除。如果网络中的所有设备都有问题，请在连接所有其他设备的设备上开始实施故障排除流程。您应该开发出一种合理且一致的方法，通过一次排除一个问题来诊断网络问题。</p><h2 id="6-2、解决还是上报？"><a href="#6-2、解决还是上报？" class="headerlink" title="6.2、解决还是上报？"></a>6.2、解决还是上报？</h2><p>在某些情况下，立即解决该问题是不可能的。如果问题需要经理决策，要求一些特定专业知识，或者实施故障排除的技术人员不具备所需网络访问级别，则应上报此问题。</p><p>例如，在完成故障排查后，技术人员推断应该更换路由器模块。此问题应上报经理批准。经理可能需要再次上报此问题，因为需要财务部门批准后才能购买新的模块。</p><p>公司政策应清楚地说明技术人员应何时以及如何上报问题。</p><h2 id="6-3、debug命令"><a href="#6-3、debug命令" class="headerlink" title="6.3、debug命令"></a>6.3、debug命令</h2><p>OS 进程、协议、机制和事件生成消息以告知它们的状态。在排除故障或验证系统操作时，这些消息可以提供有价值的信息。IOS<strong>debug</strong>命令允许管理员实时显示这些消息，以便进行分析。它是思科IOS 设备中用于监控事件的一个非常重要的工具。</p><p>所有<strong>debug</strong>命令都在特权 EXEC 模式下输入。思科IOS 允许缩小<strong>debug</strong>的输出，以便仅包含相关功能或子功能。这一点很重要，因为调试输出在 CPU 进程中享有高优先级，可能会导致系统不可用。因此，只在排查特定问题时才使用<strong>debug</strong>命令。</p><p>如示例所示，要监控思科路由器中 ICMP 消息的状态，请使用<strong>debug ip icmp</strong>命令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# debug ip icmpICMP packet debugging is onR1#R1# ping 10.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.1, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;2 msR1#*Aug 20 14:18:59.605: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0*Aug 20 14:18:59.606: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0*Aug 20 14:18:59.608: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0*Aug 20 14:18:59.609: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0*Aug 20 14:18:59.611: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0R1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要列出所有调试命令选项的简短说明，请在特权 EXEC 模式下的命令行处使用**debug ?**命令。</p><p>要关闭特定调试功能，请在<strong>debug</strong>命令前添加关键字<strong>no</strong>：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# no debug ip icmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者，您可以在特权 EXEC 模式中输入命令的<strong>undebug</strong>形式：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# undebug ip icmp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要同时关闭所有活动的 debug 命令，请使用<strong>undebug all</strong>命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# undebug all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用某些 <strong>debug</strong> 命令时要小心。某些命令（例如<strong>debug all</strong>和<strong>debug ip packet</strong> ）会生成大量输出，并会使用大量的系统资源。路由器可能会忙于显示<strong>debug</strong>消息，以至于没有足够的处理能力来执行其网络功能，或侦听关闭调试的命令。因此，不建议使用这些命令选项，应尽量避免。</p><h2 id="6-4、terminal-monitor-命令"><a href="#6-4、terminal-monitor-命令" class="headerlink" title="6.4、terminal monitor 命令"></a>6.4、terminal monitor 命令</h2><p>授权访问IOS命令行界面的连接可以通过以下两种方式建立:</p><ul><li><strong>本地</strong> 本地连接（即控制台连接）需要使用反转电缆对路由器或交换机的控制台接口进行物理访问。</li><li><strong>远程</strong> -远程连接需要使用 Telnet 或 SSH 来与配置了IP的设备建立连接。</li></ul><p>某些 IOS 消息会自动显示在控制台连接上，但不会显示在远程连接上。例如，默认情况下，在控制台连接上显示 <strong>debug</strong> 输出。但是， <strong>debug</strong> 输出不会自动显示在远程连接上。这是因为<strong>debug</strong>消息是日志消息，它被禁止显示在vty线路上。</p><p>例如，在以下输出中，用户使用 Telnet 建立了从 R2 到 R2 的远程连接。然后用户发出了 <strong>debug ip icmp</strong> 命令。但是，该命令无法显示 <strong>debug</strong> 输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R2# telnet 209.165.200.225Trying 209.165.200.225 ... Open Authorized access only!User Access VerificationPassword:R1&gt; enablePassword:R1# debug ip icmpICMP packet debugging is onR1# ping 10.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.1, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;2 msR1#! No debug output displayed&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要在终端（虚拟控制台）上显示日志消息，请使用<strong>terminal monitor</strong>特权 EXEC 命令。要停止终端上的日志记录消息，请使用<strong>terminal no monitor</strong>特权 EXEC 命令。</p><p>例如，注意<strong>terminal monitor</strong>命令现在是如何输入的，<strong>ping</strong>命令显示了<strong>debug</strong>输出。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1#  terminal monitorR1# ping 10.1.1.1Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 10.1.1.1, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;2 msR1#*Aug 20 16:03:49.735: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0**Aug 20 16:03:49.737: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0**Aug 20 16:03:49.738: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0**Aug 20 16:03:49.740: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0**Aug 20 16:03:49.741: ICMP: echo reply rcvd, src 10.1.1.1, dst 209.165.200.225,topology BASE, dscp 0 topoid 0R1# no debug ip icmpICMP packet debugging is offR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>: 该 <strong>debug</strong> 命令的目的是在短时间内捕获实时输出（即几秒钟到一分钟左右）。不需要时总是禁用<strong>debug</strong>。</p><h1 id="7、故障排除场景"><a href="#7、故障排除场景" class="headerlink" title="7、故障排除场景"></a>7、故障排除场景</h1><h2 id="7-1、双工操作和不匹配问题"><a href="#7-1、双工操作和不匹配问题" class="headerlink" title="7.1、双工操作和不匹配问题"></a>7.1、双工操作和不匹配问题</h2><p>许多常见的网络问题可以很容易地识别和解决。现在您已经掌握了用于网络故障排除的工具和流程，本主题将回顾作为网络管理员可能遇到的一些常见网络问题。</p><p>在数据通信中，双工是指两台设备之间数据传输的方向。</p><p>有两种双工通信模式：</p><ul><li><strong>半双工</strong> -通信限制为每次在一个方向进行数据交换。</li><li><strong>全双工</strong> -允许同时发送和接收通信。</li></ul><p>该图说明了每种双工方法的工作方式。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.22.png"></p><p>为了达到最佳通信性能，两个互相连接的以太网接口必须在同一双工模式下运行，以避免低效和链路延迟。</p><p>以太网自动协商功能简化了配置，最大限度地减少了问题，最大限度地提高了两个相互连接的以太网链路之间的链路性能。连接的设备首先通告其支持的功能，然后选择两端所支持的最高性能模式。例如，图中的交换机和路由器已成功自动协商全双工模式。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN17.23.png"></p><p>如果两个连接的设备，一个在全双工模式下运行，另一个在半双工模式下运行，就会出现双工不匹配。当数据通过双工不匹配的链路通信时，链路性能就会很差。</p><p>双工不匹配通常是由于接口配置错误导致的，或者在极少数情况下是由自动协商失败引起的。当设备之间仍在通信时，可能很难对双工不匹配的问题进行排查。</p><h2 id="7-2、IOS-设备的-IP-寻址问题"><a href="#7-2、IOS-设备的-IP-寻址问题" class="headerlink" title="7.2、IOS 设备的 IP 寻址问题"></a>7.2、IOS 设备的 IP 寻址问题</h2><p>与 IP 地址相关的问题可能会阻止远程网络设备进行通信。由于 IP 地址是分层的，分配给网络设备的任何 IP 地址都必须符合该网络地址范围。错误分配的 IP 地址会导致很多问题，包括 IP 地址冲突和路由问题。</p><p>IPv4 分配不正确的两个常见原因是手动分配错误或与 DHCP 相关的问题。</p><p>网络管理员通常必须手动将 IP 地址分配到设备，比如服务器和路由器。如果在分配期间出现错误，则很可能引发设备的通信问题。</p><p>在 IOS 设备上，请使用<strong>show ip interface</strong> 或 <strong>show ip interface brief</strong>命令验证哪些 IPv4 地址分配给了网络接口。例如，如图所示发出 <strong>show ip interface</strong> <strong>brief</strong> 命令将验证 R1 上的接口状态。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show ip interface briefInterface              IP-Address      OK? Method Status                ProtocolGigabitEthernet0&#x2F;0&#x2F;0   209.165.200.225 YES manual up                    upGigabitEthernet0&#x2F;0&#x2F;1   192.168.10.1    YES manual up                    upSerial0&#x2F;1&#x2F;0            unassigned      NO  unset  down                  downSerial0&#x2F;1&#x2F;1            unassigned      NO  unset  down                  downGigabitEthernet0       unassigned      YES unset  administratively down downR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-3、终端设备的-IP编址问题"><a href="#7-3、终端设备的-IP编址问题" class="headerlink" title="7.3、终端设备的 IP编址问题"></a>7.3、终端设备的 IP编址问题</h2><p>在基于 Windows 的计算机中，当设备无法与 DHCP 服务器通信时，Windows 将自动分配一个属于 169.254.0.0/16 范围内的地址。此功能称为自动专用IP编址 (APIPA)，旨在促进本地网络内的通信。可以将其想象成 Windows 发声说“我将使用 169.254.0.0/16 范围内的这个地址，因为我无法获得任何其他地址”。</p><p>通常，拥有APIPA地址的计算机无法与网络中的其他设备通信，因为这些设备很可能不属于 169.254.0.0/16 网络。这种情况表示，应对 IPv4 地址自动分配问题进行修复。</p><p><strong>注意</strong>: 如果与 DHCP 服务器的通信失败，其他操作系统（例如 Linux 和 OS X）不会将 IPv4 地址分配给网络接口。</p><p>大多数终端设备配置为依赖于 DHCP 服务器来实现 IPv4 地址的自动分配。如果设备无法与 DHCP 服务器通信，则服务器不会为该特定网络分配 IPv4 地址，而且设备将无法通信。</p><p>如输出所示，要验证 IP 地址是否分配到基于 Windows 的计算机，请使用<strong>ipconfig</strong>命令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfigWindows IP Configuration(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16   IPv4 Address. . . . . . . . . . . : 192.168.10.10   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Default Gateway . . . . . . . . . : 192.168.10.1(Output omitted)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-4、默认网关问题"><a href="#7-4、默认网关问题" class="headerlink" title="7.4、默认网关问题"></a>7.4、默认网关问题</h2><p>终端设备的默认网关是可以将流量转发到其他网络的最近的网络设备。如果设备的默认网关地址不正确或不存在，它将无法与远程网络中的设备通信。由于默认网关是通向远程网络的路径，其地址必须与终端设备属于同一网络。</p><p>默认网关地址可以手动设置，也可以从 DHCP 服务器获取。与 IPv4 寻址问题类似，默认网关问题可能与配置错误（在手动分配的情况下）或 DHCP 问题（如果使用自动分配）有关。</p><p>要解决默认网关配置错误问题，请确保为设备配置正确的默认网关。如果手动设置的默认地址不正确，只需将其替换为合适的地址即可。如果默认网关地址是自动设置的，请确保设备可以与 DHCP 服务器通信。还必须验证路由器接口上的 IPv4 地址和子网掩码是否配置适当，以及该接口是否处于活动状态。</p><p>如显示所示，要验证基于 Windows 的计算机上的默认网关，请使用<strong>ipconfig</strong>命令。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfigWindows IP Configuration(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16   IPv4 Address. . . . . . . . . . . : 192.168.10.10   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Default Gateway . . . . . . . . . : 192.168.10.1(Output omitted)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在路由器上，使用<strong>show ip route</strong>命令列出路由表，并验证称为默认路由的默认网关是否已设置。当数据包的目的地址与路由表中任何其他路由不匹配时，使用此路由。</p><p>例如，输出验证 R1具有指向 IP 地址 209.168.200.226 的默认网关（即最后求助网关）。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show ip route | begin GatewayGateway of last resort is 209.165.200.226 to network 0.0.0.0O*E2  0.0.0.0&#x2F;0 [110&#x2F;1] via 209.165.200.226, 02:19:50, GigabitEthernet0&#x2F;0&#x2F;0      10.0.0.0&#x2F;24 is subnetted, 1 subnetsO        10.1.1.0 [110&#x2F;3] via 209.165.200.226, 02:05:42, GigabitEthernet0&#x2F;0&#x2F;0      192.168.10.0&#x2F;24 is variably subnetted, 2 subnets, 2 masksC        192.168.10.0&#x2F;24 is directly connected, GigabitEthernet0&#x2F;0&#x2F;1L        192.168.10.1&#x2F;32 is directly connected, GigabitEthernet0&#x2F;0&#x2F;1      209.165.200.0&#x2F;24 is variably subnetted, 3 subnets, 2 masksC        209.165.200.224&#x2F;30 is directly connected, GigabitEthernet0&#x2F;0&#x2F;0L        209.165.200.225&#x2F;32 is directly connected, GigabitEthernet0&#x2F;0&#x2F;0O        209.165.200.228&#x2F;30           [110&#x2F;2] via 209.165.200.226, 02:07:19, GigabitEthernet0&#x2F;0&#x2F;0R1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>突出显示的第一行基本上说明了网关通往任何地址（即 0.0.0.0）都应该发送到 IP 地址 209.165.200.226。第二行显示了 R1 如何获悉默认网关。在这种情况下，R1 从另一个启用了OSPF的路由器接收信息。</p><h2 id="7-5、排除-DNS-故障"><a href="#7-5、排除-DNS-故障" class="headerlink" title="7.5、排除 DNS 故障"></a>7.5、排除 DNS 故障</h2><p>域名服务 (DNS) 定义了一种将域名（例如 <a href="http://www.cisco.㯘/">www.cisco.com）与</a>-ob5f/) IP 地址相匹配的自动化服务。DNS 解析对于设备无关紧要，但对最终用户而言非常重要。</p><p>用户通常会错误地将互联网链路的运行与 DNS的可用性相关联。“网络中断”或“互联网中断”等用户投诉通常就是由于 DNS 服务器无法访问所导致的。当数据包路由以及其他网络服务仍正常运行时，DNS 故障经常会导致用户得出错误结论。如果用户在 Web 浏览器中键入一个域名（例如 <a href="http://www.cisco.㯘/">www.cisco.com），而</a>%2C-w63n/) DNS 服务器无法访问，则该域名将无法转换为 IP 地址，网站将不会显示。</p><p>DNS 服务器地址可以手动或自动分配。网络管理员通常负责在服务器和其他设备上手动分配 DNS 服务器地址，而 DHCP 用于将 DNS 服务器地址自动分配到客户端。</p><p>虽然公司和组织通常会管理他们自己的 DNS 服务器，但任何可访问的 DNS 服务器都可以用于解析域名。小型办公室和家庭办公室 (SOHO) 用户通常依赖其 ISP 所维护的 DNS 服务器来进行域名解析。ISP 维护的 DNS 服务器通过 DHCP 分配给 SOHO 客户。另外，Google 维护了一个可供所有人使用的公共 DNS 服务器，它对于测试非常有用。Google 的公共 DNS 服务器的 IPv4 地址为 8.8.8.8，其 IPv6 DNS 地址为 2001:4860:4860::8888。</p><p>思科提供了OpenDNS，它通过过滤网络钓鱼和一些恶意网站来提供安全的 DNS 服务。您可以在首选 DNS 服务器和备用 DNS 服务器字段中将 DNS 地址更改为 208.67.222.222 和 208.67.220.220。家庭和企业可以使用web内容过滤和安全等高级功能。</p><p>如显示所示，使用<strong>ipconfig /all</strong>验证 Windows 计算机正在使用哪个 DNS 服务器。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; ipconfig &#x2F;all(Output omitted)Wireless LAN adapter Wi-Fi:   Connection-specific DNS Suffix  . :   Description . . . . . . . . . . . : Intel(R) Dual Band Wireless-AC 8265   Physical Address. . . . . . . . . : F8-94-C2-E4-C5-0A   DHCP Enabled. . . . . . . . . . . : Yes   Autoconfiguration Enabled . . . . : Yes   Link-local IPv6 Address . . . . . : fe80::a4aa:2dd1:ae2d:a75e%16(Preferred)   IPv4 Address. . . . . . . . . . . : 192.168.10.10(Preferred)   Subnet Mask . . . . . . . . . . . : 255.255.255.0   Lease Obtained. . . . . . . . . . : August 17, 2019 1:20:17 PM   Lease Expires . . . . . . . . . . : August 18, 2019 1:20:18 PM   Default Gateway . . . . . . . . . : 192.168.10.1   DHCP Server . . . . . . . . . . . : 192.168.10.1   DHCPv6 IAID . . . . . . . . . . . : 100177090   DHCPv6 Client DUID. . . . . . . . : 00-01-00-01-21-F3-76-75-54-E1-AD-DE-DA-9A   DNS Servers . . . . . . . . . . . : 208.67.222.222   NetBIOS over Tcpip. . . . . . . . : Enabled(Output omitted)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>nslookup</strong>命令是 PC 的另一个有用的 DNS 故障排除工具。利用 <strong>nslookup</strong>，用户可以手动进行 DNS 查询并分析 DNS 响应。该 <strong>nslookup</strong> 命令显示了对于<a href="http://www.cisco.com/">www.cisco.com</a> 查询的输出。请注意，您也可以简单地输入一个IP地址然后通过 <strong>nslookup</strong> 解析其域名。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users\PC-A&gt; nslookupDefault Server:  Home-NetAddress:  192.168.1.1&gt; cisco.comServer:  Home-NetAddress:  192.168.1.1Non-authoritative answer:Name:    cisco.comAddresses:  2001:420:1101:1::185          72.163.4.185&gt; 8.8.8.8Server:  Home-NetAddress:  192.168.1.1Name:    dns.googleAddress:  8.8.8.8&gt;&gt; 208.67.222.222Server:  Home-NetAddress:  192.168.1.1Name:    resolver1.opendns.comAddress:  208.67.222.222&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-6、Packet-Tracer-排除连接故障"><a href="#7-6、Packet-Tracer-排除连接故障" class="headerlink" title="7.6、Packet Tracer - 排除连接故障"></a>7.6、Packet Tracer - 排除连接故障</h2><p>略</p><h2 id="7-7、实验-排除连接故障"><a href="#7-7、实验-排除连接故障" class="headerlink" title="7.7、实验 - 排除连接故障"></a>7.7、实验 - 排除连接故障</h2><p>略</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十六）</title>
      <link href="/2021/120314164.html"/>
      <url>/2021/120314164.html</url>
      
        <content type="html"><![CDATA[<h1 id="十六、网络安全基础知识"><a href="#十六、网络安全基础知识" class="headerlink" title="十六、网络安全基础知识"></a>十六、网络安全基础知识</h1><p>您可能已经建立了一个网络，或者您正准备那样做。这里有一些东西值得思考。建立一个没有安全保护的网络就像打开了所有到你家的门和窗户，然后去度假。任何人都可以短暂拜访，获得进入，窃取或破坏物品，或者只是制造一片混乱。正如你在新闻中看到的，任何网络都有可能被入侵! 作为网络管理员，让威胁发起者难以访问您的网络是您工作的一部分。本模块将概述网络攻击的类型，以及如何减少威胁发起者成功的机会。</p><p><strong>模块目标</strong>: 配置交换机和路由器的设备强化功能，提升安全性。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>安全威胁和漏洞</strong></td><td align="left">说明基本安全措施对于网络设备的必要性。</td></tr><tr><td align="left"><strong>网络攻击</strong></td><td align="left">明确安全漏洞。</td></tr><tr><td align="left"><strong>网络攻击缓解</strong></td><td align="left">明确常用的威胁缓解措施。</td></tr><tr><td align="left"><strong>设备安全</strong></td><td align="left">配置网络设备的设备强化功能，缓解 安全威胁。</td></tr></tbody></table><h1 id="1、安全威胁和漏洞"><a href="#1、安全威胁和漏洞" class="headerlink" title="1、安全威胁和漏洞"></a>1、安全威胁和漏洞</h1><h2 id="1-1、威胁类型"><a href="#1-1、威胁类型" class="headerlink" title="1.1、威胁类型"></a>1.1、威胁类型</h2><p>有线和无线计算机网络是人们日常活动中不可或缺的一部分。个人和组织都同样依赖其计算机和网络。不速之客的入侵可能导致代价高昂的网络中断和工作成果的丢失。针对网络的攻击有时具有相当的破坏性，可能造成重要信息或资产的损坏或失窃，导致时间上和金钱上的损失。</p><p>入侵者会通过软件漏洞、硬件攻击或通过猜测某人的用户名和密码来获取网络访问。通过修改或利用软件漏洞来获取访问权的入侵者通常被称为威胁发起者。</p><p>一旦威胁发起者取得网络的访问权，就可能给网络带来四种威胁。</p><h3 id="信息盗窃"><a href="#信息盗窃" class="headerlink" title="信息盗窃"></a>信息盗窃</h3><p>指侵入计算机以获取机密信息。信息可以用于各种目的或出售。例子: 盗窃组织的专有信息，例如研究和开发数据。</p><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p>是指闯入计算机破坏或更改数据记录。数据丢失的示例是：一个威胁发起者发送可重新格式化计算机硬盘的病毒。数据操纵示例是：闯入记录系统来更改信息（例如物品价格）。</p><h3 id="身份盗窃"><a href="#身份盗窃" class="headerlink" title="身份盗窃"></a>身份盗窃</h3><p>是一种信息盗窃形式，以冒用他人的身份为目的窃取个人信息。利用此类信息，威胁发起者便可以非法获取文件、申请信用贷款或者进行未经授权的在线购物。身份盗窃案件日渐增多，每年造成的损失达数十亿之多。</p><h3 id="服务中断"><a href="#服务中断" class="headerlink" title="服务中断"></a>服务中断</h3><p>阻止合法用户访问他们有权访问的服务。例如: 对服务器、网络设备或网络通信链路发起的拒绝服务 (DoS) 攻击。</p><h2 id="1-2、漏洞分类"><a href="#1-2、漏洞分类" class="headerlink" title="1.2、漏洞分类"></a>1.2、漏洞分类</h2><p>漏洞是指网络或设备的薄弱程度。路由器、交换机、桌面、服务器、甚至安全设备都存在一定程度的漏洞。一般而言，受到攻击的网络设备都是端点设备，例如服务器和台式计算机。</p><p>有三种主要的漏洞或弱点：技术、配置和安全策略。所有这三种漏洞源都会让网络或设备对各种攻击保持开放状态，包括恶意代码攻击和网络攻击。</p><h3 id="技术漏洞"><a href="#技术漏洞" class="headerlink" title="技术漏洞"></a>技术漏洞</h3><table><thead><tr><th>TCP/IP 协议缺陷</th><th>超文本传输协议 (HTTP)，文件传输协议(FTP)， 和互联网控制消息协议 (ICMP)本质上是 不安全的。简单网络管理协议 (SNMP)和简单邮件传输 协议 (SMTP) 与TCP设计时所基于的固有的 不安全结构有关。</th></tr></thead><tbody><tr><td>操作系统缺陷</td><td>每个操作系统都有必须解决的安全问题。UNIX、Linux、Mac OS、Mac OS X、Windows Server 2012、Windows 7、 Windows 8它们记录在计算机应急响应小组 (CERT) 档案中， 网址为 <a href="http://www.cert.org./">http://www.cert.org。</a></td></tr><tr><td>网络设备缺陷</td><td>各种类型的网络设备，例如路由器，防火墙和 交换机都具有安全弱点，必须识别并加以 保护。他们的弱点包括密码保护，缺乏 身份验证、路由协议和防火墙漏洞。</td></tr></tbody></table><h3 id="配置漏洞"><a href="#配置漏洞" class="headerlink" title="配置漏洞"></a>配置漏洞</h3><table><thead><tr><th align="left">漏洞</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">不安全的用户帐户</td><td align="left">用户帐户信息可能不安全地通过网络传输， 将用户名和密码暴露给威胁发起者。</td></tr><tr><td align="left">系统帐户的密码容易被猜到</td><td align="left">用户密码创建不当造成了这种常见问题。</td></tr><tr><td align="left">互联网服务配置错误</td><td align="left">在Web浏览器中打开JavaScript可以在访问不受信任的站点时 通过由威胁发起者控制的JavaScript进行攻击。 其他潜在的弱点来源包括配置错误的终端 服务、FTP 或 Web 服务器（例如微软互联网信息 服务 IIS) 和 Apache HTTP 服务器。</td></tr><tr><td align="left">产品的默认设置不安全</td><td align="left">许多产品的默认设置容易带来 安全漏洞。</td></tr><tr><td align="left">网络设备配置错误</td><td align="left">设备本身配置错误会带来严重的安全 问题。例如，错误配置的访问列表、路由协议或 SNMP 社区字符串可以造成或开启安全漏洞。</td></tr></tbody></table><h3 id="策略漏洞"><a href="#策略漏洞" class="headerlink" title="策略漏洞"></a>策略漏洞</h3><table><thead><tr><th align="left">漏洞</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">缺乏书面的安全策略</td><td align="left">未以书面形式记录的安全策略无法得到长久有效的 应用和执行。</td></tr><tr><td align="left">政治</td><td align="left">政治斗争和争权夺利可能导致难以长期执行 相同的安全策略。</td></tr><tr><td align="left">缺乏身份验证持续性</td><td align="left">如果密码选择不当、易于破解或甚至是默认密码，会导致 对网络的未经授权的访问。</td></tr><tr><td align="left">没有实行逻辑访问控制</td><td align="left">监控和审计力度不够，导致攻击和未授权使用不断发生， 浪费公司资源。这可能会导致法律诉讼 或针对IT技术人员、IT管理人员、 甚至允许这些不安全条件持续存在的公司领导层的解雇。</td></tr><tr><td align="left">软件和硬件的安装与更改没有遵循策略执行</td><td align="left">未经授权更改网络拓扑或安装 未经批准的应用程序会造成或开启安全漏洞。</td></tr><tr><td align="left">没有设计灾难恢复计划</td><td align="left">缺乏灾难恢复计划可能在发生自然灾害或 企业在遭到威胁发起者攻击时造成恐慌和 混乱。</td></tr></tbody></table><h2 id="1-3、物理安全"><a href="#1-3、物理安全" class="headerlink" title="1.3、物理安全"></a>1.3、物理安全</h2><p>络中一个同样重要的漏洞区域是设备的物理安全性。如果网络资源可以被物理性破坏，攻击发起者便可借此拒绝对网络资源的使用。</p><p>物理威胁分为四类：</p><ul><li><strong>硬件威胁</strong> － 这包括对服务器、路由器、交换机、布线间和工作站的物理破坏</li><li><strong>环境威胁</strong> －这包括极端温度（过热或过冷）或极端湿度（过湿或过干）</li><li><strong>电气威胁</strong> － 这包括电压过高、电源电压不足（电气管制）、不合格电源（噪音），以及断电</li><li><strong>维护威胁</strong> － 这包括关键电气组件处理不佳（静电放电），缺少关键备用组件、布线混乱和标识不明</li></ul><p>必须创建和实现一个良好的物理安全计划来解决这些问题。该图显示了物理安全计划的一个示例。</p><p><strong>制定物理安全规划，限制对设备的破坏</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.1.png"></p><ul><li>保护机房。</li><li>实现物理安全，限制对设备的破坏</li></ul><p><strong>步骤 1.</strong> 将设备锁定，并防止未经授权的人员经门窗、天花板、架空地板、管道和通风孔进行访问。</p><p><strong>步骤 2.</strong> 使用电子日志监控配线间。</p><p><strong>步骤 3.</strong> 使用安全摄像头。</p><h1 id="2、网络攻击"><a href="#2、网络攻击" class="headerlink" title="2、网络攻击"></a>2、网络攻击</h1><h2 id="2-1、恶意软件的类型"><a href="#2-1、恶意软件的类型" class="headerlink" title="2.1、恶意软件的类型"></a>2.1、恶意软件的类型</h2><p>上一主题介绍了网络威胁的类型以及使威胁成为可能的漏洞。本主题将详细介绍威胁发起者如何获得网络的访问权限或限制授权用户的访问权限。</p><p>恶意软件是“有恶意的软件”的简称。是专门用来损坏、破坏、窃取数据、主机或网络或对数据、主机或网络进行“坏的”或者非法操作的代码或软件。恶意软件的类型包括病毒、蠕虫和特洛伊木马</p><p><strong>病毒</strong></p><p>计算机病毒是一种通过将自身副本插入另一个程序并成为其一部分来传播的恶意软件类型。它在计算机之间传播，感染所到之处。病毒从严重程度上来讲包括从导致轻度恼人影响到损坏数据或软件和导致拒绝服务 (DoS) 条件。几乎所有的病毒都是附加到一个可执行文件中，这意味着病毒可能在系统上存在，但在用户运行或打开恶意主机文件或程序前不会处于活跃状态也不会传播。执行主机代码后，也就执行了病毒代码。通常情况下，主机程序在感染了病毒后仍继续运行。但是，一些病毒用其自身副本覆盖其他程序，这就完全破坏了主机程序。当病毒附加的软件或文档通过网络、磁盘、文件共享或被感染的电子邮件附件从一台计算机传输到另一台计算机时，也传播了病毒。</p><p><strong>蠕虫</strong></p><p>计算机蠕虫与病毒相似，它们均可复制自身的功能副本，并造成相同类型的损坏。与病毒相比，病毒需要通过感染的主机文件来传播，而蠕虫属于独立软件，无需借助主机程序或人工帮助即可传播。蠕虫不需要附加在程序中来感染主机并通过系统漏洞进入计算机。蠕虫无需帮助便可利用系统功能在网络中传输。</p><p><strong>特洛伊木马</strong></p><p>特洛伊木马是另一种类型的恶意软件，以希腊人用来潜入特洛伊的木马来命名。它是看起来合法的有害软件。用户通常是被骗加载特洛伊木马并在他们的系统上执行。特洛伊木马激活后，可以在主机上进行任意数量的攻击，从激怒用户（过多的弹窗或改变桌面）到破坏主机（删除文件、窃取数据或激活和传播病毒等其他恶意软件）。众所周知，特洛伊木马为恶意用户访问系统创建后门。</p><p>不同于病毒和蠕虫，特洛伊木马不通过感染其他文件进行复制。它们也不自我复制。特洛伊木马必须通过用户交互传播，如打开电子邮件附件或从互联网下载并运行文件。</p><h2 id="2-2、侦查攻击"><a href="#2-2、侦查攻击" class="headerlink" title="2.2、侦查攻击"></a>2.2、侦查攻击</h2><p>除了恶意代码攻击外，网络还可能遭受各种网络攻击。网络攻击可分为三大类别：</p><ul><li><strong>侦察攻击</strong> – 搜索和映射系统、服务或漏洞</li><li><strong>访问攻击</strong> – 数据、系统或用户访问权限的未授权控制</li><li><strong>拒绝服务</strong> – 网络、系统或服务的禁用或损坏</li></ul><p>对于侦察攻击，外部威胁发起者可以使用互联网工具（如<strong>nslookup</strong>和<strong>whois</strong>实用程序）轻松地确定分配给公司或实体的 IP 地址空间。确定 IP 地址空间后，威胁发起者可以 ping 这些公有 IP 地址以确定哪些地址正在使用。为帮助自动执行此步骤，威胁发起者可能会使用 ping 扫描工具，例如<strong>fping</strong>或<strong>gping</strong>。它系统地向给定范围或子网中的所有网络地址执行 ping 操作。这类似于浏览电话簿的某一部分，拨打其中列出的每个号码，看哪些号码有人接听。</p><p><strong>侦查攻击</strong></p><ol><li>互联网查询</li><li>Ping扫描</li><li>端口扫描</li></ol><h2 id="2-3、访问攻击"><a href="#2-3、访问攻击" class="headerlink" title="2.3、访问攻击"></a>2.3、访问攻击</h2><p>访问攻击利用身份验证服务、FTP 服务和 Web 服务的已知漏洞，获取对 Web 帐户、机密数据库和其他敏感信息的访问。访问攻击使个人能够对他们无权查阅的信息进行未经授权访问。访问攻击可分为四种类型：密码攻击、信任利用、端口重定向和中间人攻击。</p><h3 id="密码攻击"><a href="#密码攻击" class="headerlink" title="密码攻击"></a>密码攻击</h3><p>威胁发起者可以使用多种方法实施密码攻击：</p><ul><li>暴力攻击</li><li>特洛伊木马攻击</li><li>数据包嗅探</li></ul><h3 id="信任利用"><a href="#信任利用" class="headerlink" title="信任利用"></a>信任利用</h3><p>在信任利用攻击中，威胁发起者会使用未经授权的特权来访问系统，可能还会进一步攻陷目标。</p><h3 id="端口重定向"><a href="#端口重定向" class="headerlink" title="端口重定向"></a>端口重定向</h3><p>在端口重定向攻击中，威胁发起者会把攻陷的系统作为攻击其他目标的大本营。图中的示例显示出威胁发起者使用 SSH（端口22）连接受攻击主机 A 的威胁发起者。主机 B 信任主机 A；因此，允许威胁发起者使用 Telnet 访问主机 B。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.2.png"></p><h3 id="中间人"><a href="#中间人" class="headerlink" title="中间人"></a>中间人</h3><p>在中间人攻击中，威胁发起者会置身于两个合法实体之间，以便读取或修改双方之间传输的数据。图中显示了中间人攻击的示例。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.3.png"></p><p><strong>步骤 1</strong>. 受害者请求网页时，该请求将被定向到威胁发起者的计算机。</p><p><strong>步骤 2</strong>. 威胁发起者的计算机接收到请求，从合法网站获取实际页面。</p><p><strong>步骤 3</strong>. 威胁发起者可以更改合法的网页并对数据进行更改。</p><p><strong>步骤 4</strong>. 威胁发起者随后将所请求的网页转发给受害者。</p><h2 id="2-4、拒绝服务攻击"><a href="#2-4、拒绝服务攻击" class="headerlink" title="2.4、拒绝服务攻击"></a>2.4、拒绝服务攻击</h2><p>拒绝服务 (DoS) 攻击是知名度最高的攻击，并且是最难防范的攻击。然而，由于其实施简单、破坏力强大，安全管理员需要特别关注 DoS 攻击。</p><p>DoS 攻击的方式多种多样。不过其目的都是通过消耗系统资源使授权用户无法正常使用服务。为了帮助防止 DoS 攻击，必须使操作系统和应用程序与最新的安全更新保持同步。</p><h3 id="DoS攻击"><a href="#DoS攻击" class="headerlink" title="DoS攻击"></a>DoS攻击</h3><p>DoS 攻击属于重大风险，因为它们可以中断通信，并在时间和财务上造成大量损失。这些攻击执行起来相对简单，即使是缺乏技能的威胁发起者也可以执行。</p><p>例如：发送大量ping命令，让该服务器没办法响应其他人的请求</p><h3 id="DDoS攻击"><a href="#DDoS攻击" class="headerlink" title="DDoS攻击"></a>DDoS攻击</h3><p>分布式 DoS 攻击 (DDoS) 与 DoS 攻击类似，但是它从多个协同攻击源发起攻击。举例来说，威胁发起者建立了一个受感染主机的网络，受感染的主机称为僵尸主机。受感染主机（僵尸）的网络称为僵尸网络。威胁发起者使用命令和控制(CnC)程序来指示僵尸网络进行DDoS攻击。</p><h1 id="3、网络攻击缓解"><a href="#3、网络攻击缓解" class="headerlink" title="3、网络攻击缓解"></a>3、网络攻击缓解</h1><h2 id="3-1、纵深防御方法"><a href="#3-1、纵深防御方法" class="headerlink" title="3.1、纵深防御方法"></a>3.1、纵深防御方法</h2><p>现在您已经了解了更多有关威胁发起者如何入侵网络的信息，您需要了解如何防止这种未经授权的访问。本主题详细介绍了为使您的网络更加安全可以采取的一些措施。</p><p>要缓解网络攻击，必须首先保护设备，包括路由器、交换机、服务器和主机。大多数组织机构使用纵深防御法（也称为分层方法）来确保安全性。这需要网络设备和服务相互配套以协同工作。</p><p>思考图中的网络。已经实施了若干安全设备和服务来保护用户和资产免受 TCP/IP 威胁的侵害。</p><p>通过所有网络设备（包括路由器和交换机）各自图标上显示的密码组合锁判断，这些网络设备也经过了强化。这表示这些设备已受到保护，以防止威胁发起者对其获取访问权和进行篡改。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.4.png"></p><p>这个环境中部署了一些安全设备和服务，来保护组织机构的用户、资产，免遭TCP/IP威胁的侵害。</p><ul><li><strong>VPN</strong> - 为公司站点提供安全 VPN 服务的路由器，并使用安全加密隧道为远程用户提供远程访问支持。</li><li><strong>ASA防火墙</strong> - 用来提供状态化防火墙服务的专用设备。它可确保内部流量可以流出并返回，但外部流量无法发起与内部主机的连接。</li><li><strong>IPS</strong> - 入侵防御系统，负责监测入站和出站流量，查找恶意软件、网络攻击特征等。如果识别到威胁，它会立即阻止此威胁。</li><li><strong>ESA/WSA</strong> - 电子邮件安全设备（ESA）负责过滤垃圾邮件和可疑邮件。网络安全设备会过滤已知和可疑的互联网恶意软件站点。</li><li><strong>AAA服务器</strong> - AAA服务器中包含一个安全数据库，其中记录了谁有权访问和管理网络设备。网络设备使用此数据库对管理用户进行认证。</li></ul><h2 id="3-2、保留备份"><a href="#3-2、保留备份" class="headerlink" title="3.2、保留备份"></a>3.2、保留备份</h2><p>备份设备配置和数据是防止数据丢失的最有效方式之一。数据备份可将计算机上的信息副本存储到可放在安全地方的可移动备份介质中。基础设施设备应该在FTP或类似的文件服务器上备份配置文件和IOS映像。如果计算机或路由器硬件发生故障，可以使用备份副本恢复数据或配置。</p><p>应根据安全策略中的规定定期执行备份。数据备份通常存储在非现场位置，在主要设施发生任何问题时能保护备份介质。Windows 主机提供了备份和还原实用程序。对用户来说，将数据备份到其他驱动器或基于云的存储提供商非常重要。</p><p>该表显示了备份考虑事项及其描述。</p><table><thead><tr><th align="left"><strong>考虑事项</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">频率</td><td align="left">根据安全策略中的标识定期执行 备份。完全备份可能非常耗时，因此需要每月或 或每周执行一次备份，并经常对更改的文件进行部分备份。</td></tr><tr><td align="left">存储容量</td><td align="left">务必对备份进行验证，以确保数据的完整性并验证文件恢复程序。 验证文件恢复程序。</td></tr><tr><td align="left">安全</td><td align="left">应按照安全策略的要求，每天， 每周或每月轮流将备份转移到批准的异地 存储位置。</td></tr><tr><td align="left">验证</td><td align="left">应使用强密码保护备份。恢复数据 需要提供密码。</td></tr></tbody></table><h2 id="3-3、升级、更新和补丁"><a href="#3-3、升级、更新和补丁" class="headerlink" title="3.3、升级、更新和补丁"></a>3.3、升级、更新和补丁</h2><p>保持与最新进展同步会使对网络攻击的防御更加有效。随着新的恶意软件不断涌现，企业必须保持当前的防病毒软件为最新版本。</p><p>缓解蠕虫攻击的最有效方法是从操作系统厂商处下载安全更新，并为所有存在漏洞的系统应用补丁。管理大量系统时，会牵涉到创建用于部署在新系统或升级系统上的标准软件映像（经授权可在客户端系统中使用的操作系统和可信任的应用程序）。但是，安全要求不断变化，而且已部署系统也可能需要安装安全更新补丁。</p><p>管理关键安全补丁的一个解决方案是确保所有终端系统自动下载更新，如图中Windows 10所示。安全补丁会自动下载并安装，无需用户干预。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.5.png"></p><h2 id="3-4、认证、授权和记账"><a href="#3-4、认证、授权和记账" class="headerlink" title="3.4、认证、授权和记账"></a>3.4、认证、授权和记账</h2><p>所有网络设备都应该进行安全配置，只允许经过授权的个人访问。认证、授权和记账（AAA 或“三 A”）网络安全服务提供了设置网络设备访问控制的主要框架。</p><p>AAA 方法用于控制可以访问网络的用户（认证）、用户访问网络时可以执行的操作（授权），以及把他们在那里时所做的事记录下来（记账）。</p><p>AAA 的概念类似于信用卡的使用。信用卡会确定谁可以使用它、消费限额是多少，并记录使用者的消费项目。</p><h2 id="3-5、防火墙"><a href="#3-5、防火墙" class="headerlink" title="3.5、防火墙"></a>3.5、防火墙</h2><p>防火墙是保护用户远离外部威胁的最为有效的安全工具之一。防火墙可通过防止不必要的流量进入内部网络来保护计算机和网络。</p><p>防火墙驻留在两个或多个网络之间，控制其间的流量并帮助阻止未授权的访问。例如，图中上面的拓扑说明防火墙如何使来自内部网络主机的流量离开并返回到内部网络。底部拓扑说明系统如何拒绝外部网络（即 Internet）发起的流量访问内部网络。</p><p><strong>防火墙操作</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.6.png"></p><p>防火墙可以允许外部用户控制对特定服务的访问。例如，外部用户可访问的服务器通常位于称为隔离区 (DMZ) 的特殊网络中，如图所示。DMZ 使网络管理员能够为连接到该网络的主机应用特定策略。</p><p><strong>带有DMZ的防火墙拓扑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN16.7.png"></p><h2 id="3-6、防火墙的类型"><a href="#3-6、防火墙的类型" class="headerlink" title="3.6、防火墙的类型"></a>3.6、防火墙的类型</h2><p>防火墙产品可以打包成各种形式。这些产品使用不同技术来区分应禁止和应允许的网络访问。其包括以下内容：</p><ul><li><strong>数据包过滤</strong> - 根据 IP 或 MAC 地址阻止或允许访问</li><li><strong>应用程序过滤</strong> - 根据端口号阻止或允许访问特定类型的应用程序</li><li><strong>URL 过滤</strong> - 根据特定的 URL 或关键字阻止或允许访问网站</li><li><strong>状态包侦测 (SPI)</strong> - 传入数据包必须是对内部主机所发出请求的合法响应。除非得到特别允许，否则未经请求的数据包会被拦截。状态包侦测还可具有识别和过滤特定类型攻击，例如拒绝服务 (DoS) 的能力。</li></ul><h2 id="3-7、终端安全"><a href="#3-7、终端安全" class="headerlink" title="3.7、终端安全"></a>3.7、终端安全</h2><p>端点，或主机，是充当网络客户端的单个计算机系统或设备。常见终端包括笔记本电脑、台式机、服务器、智能手机和平板电脑。保护端点设备是网络管理员最具挑战性的工作之一，因为它牵涉到人类本性。公司必须制定适当的有明确记录的策略，并且员工必须了解这些规则。需要培训员工正确使用网络。策略通常包括使用<strong>防病毒软件和主机入侵防御</strong>。更全面的终端安全解决方案依赖网络访问控制。</p><h1 id="4、设备安全"><a href="#4、设备安全" class="headerlink" title="4、设备安全"></a>4、设备安全</h1><h2 id="4-1、思科AutoSecure"><a href="#4-1、思科AutoSecure" class="headerlink" title="4.1、思科AutoSecure"></a>4.1、思科AutoSecure</h2><p>在网路中有很多区域需要格外提供安全防护，设备本身就是其中之一。您可能已经有了计算机、智能手机或平板电脑的密码。它是否足够坚固？您是否使用其他工具来增强设备的安全性? 本主题会告诉您怎么做。</p><p>当在设备上安装新的操作系统时，安全设置保留为默认值。在大多数情况下，这种安全级别并不够。对于思科路由器，思科AutoSecure 功能可用于协助保护系统，如示例所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# auto secure                --- AutoSecure Configuration ---*** AutoSecure configuration enhances the security ofthe router but it will not make router absolutely securefrom all security attacks ***<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此外，还有以下适用于大部分操作系统的一些简单步骤：</p><ul><li>立即更换默认用户名和密码。</li><li>限制对系统资源的访问，只有授权用户才可以访问。</li><li>尽可能关闭和卸载任何不必要的服务和应用程序。</li></ul><p>通常，制造商提供的设备已经在仓库中存放了一段时间，并没有安装最新补丁。必须在实施之前更新所有软件并安装所有安全补丁。</p><h2 id="4-2、密码"><a href="#4-2、密码" class="headerlink" title="4.2、密码"></a>4.2、密码</h2><p>为了保护网络设备，使用强密码非常重要。以下是需要遵循的标准原则：</p><ul><li>使用的密码长度至少为 8 个字符，最好是 10 个或更多字符。密码越长越安全。</li><li>使用复杂密码。如果条件允许，密码中混合使用大写和小写字母、数字、符号和空格。</li><li>密码中避免使用重复的常用字词、字母或数字顺序、用户名、亲属或宠物的名字、个人传记信息（例如出生日期、身份证号码、祖先的名字）或其他易于识别的信息。</li><li>故意将口令中的词拼错。例如，Smith = Smyth = 5mYth 或 Security = 5ecur1ty。</li><li>定期更改密码。如果密码不知不觉地遭到破坏，那么威胁发起者使用该密码的机会就会受到限制。</li><li>请勿将密码写出来并放在显眼位置上，比如桌面上或显示屏上。</li></ul><p>表中显示强密码和弱密码的示例。</p><h3 id="Weak-Passwords"><a href="#Weak-Passwords" class="headerlink" title="Weak Passwords"></a>Weak Passwords</h3><table><thead><tr><th align="left">弱密码</th><th align="left">密码薄弱的原因</th></tr></thead><tbody><tr><td align="left">secret</td><td align="left">简单词典密码</td></tr><tr><td align="left">smith</td><td align="left">母亲姓氏</td></tr><tr><td align="left">toyota</td><td align="left">汽车品牌</td></tr><tr><td align="left">bob1967</td><td align="left">用户的姓名和生日</td></tr><tr><td align="left">Blueleaf23</td><td align="left">简单的单词和数字</td></tr></tbody></table><h3 id="Strong-Passwords"><a href="#Strong-Passwords" class="headerlink" title="Strong Passwords"></a>Strong Passwords</h3><table><thead><tr><th align="left">强密码</th><th align="left">它为何强</th></tr></thead><tbody><tr><td align="left">b67n42d39c</td><td align="left">组合使用字母数字字符</td></tr><tr><td align="left">12^h u4@1p7</td><td align="left">组合使用字母数字字符和特殊符号，并包括空格</td></tr></tbody></table><p>思科路由器会忽略密码中的前置空格，但第一个字符之后的空格不会忽略。因此，创建强密码的一种方法就是使用空格键和创建一个由多个词组成的短语。这就是所谓的密码短语。密码短语通常比简单密码更易记忆。而且猜到它所用时间更长，也更难猜到。</p><h2 id="4-3、其他密码安全性"><a href="#4-3、其他密码安全性" class="headerlink" title="4.3、其他密码安全性"></a>4.3、其他密码安全性</h2><p>强密码只有在保持其机密性才是有用的。在思科路由器和交换机上可以采取以下几个步骤来帮助确保密码的机密性：</p><ul><li>加密所有的明文密码</li><li>设置可接受的最小密码长度</li><li>阻止暴力密码猜测攻击</li><li>在指定时间后 禁用非活动的特权 EXEC 模式访问。</li></ul><p>如图中的示例配置所示，<strong>service password-encryption</strong>全局配置命令防止未经授权的个人在配置文件中查看明文形式的密码。哪个命令可加密所有的明文密码？请注意在示例中，密码 “cisco” 已加密为 “03095A0F034F”。</p><p>为了确保配置的所有密码至少为指定的最小长度，请在全局配置模式下使用 <strong>security passwords min-length</strong>命令。在图中，任何新配置的密码都必须至少有8个字符。</p><p>威胁发起者可以使用密码破解软件对网络设备进行暴力攻击。这种攻击不断尝试猜测有效的密码，直到其中一个成功为止。使用 <strong>login block-for *#* attempts *#* within *#*</strong> 全局配置命令来阻止此类攻击。如图中示例，<strong>login block-for 120 attempts 3 within 60</strong>命令是在 60 秒内有 3 次登录尝试失败时阻止vty登录尝试 120 秒。</p><p>网络管理员可能会分心，意外地在终端上打开一个特权执行模式会话。这可能使内部威胁发起者能够更改或删除设备配置。</p><p>默认情况下，思科路由器将在 10 分钟不活动后注销 EXEC 会话。但是，您可以使用 <strong>exec-timeout</strong> <em>分 秒</em> 线路配置命令减少此设置。此命令可应用于在线控制台、辅助线路和 vty 线路。在图中，我们告诉思科设备在用户闲置 5 分 30 秒后自动断开 vty 线上的非活动用户。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1(config)# service password-encryption R1(config)# security passwords min-length 8 R1(config)# login block-for 120 attempts 3 within 60R1(config)# line vty 0 4 R1(config-line)# password cisco R1(config-line)# exec-timeout 5 30 R1(config-line)# transport input ssh R1(config-line)# end R1# R1# show running-config | section line vtyline vty 0 4 password 7 094F471A1A0A exec-timeout 5 30 login transport input sshR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4、启用SSH"><a href="#4-4、启用SSH" class="headerlink" title="4.4、启用SSH"></a>4.4、启用SSH</h2><p>Telnet简化了远程设备访问，但并不安全。Telnet 数据包中包含的数据以未加密形式传输。因此，强烈建议在设备上启用安全外壳 (SSH) 以进行安全远程访问。</p><p>可以通过下列六个步骤来配置思科设备以支持 SSH。</p><p><strong>步骤 1.</strong> <strong>配置唯一的主机名</strong>。设备必须有一个唯一的主机名，而不是默认主机名。</p><p><strong>步骤 2. 配置 IP 域名</strong>. 使用全局配置命令<strong>ip-domain name</strong>配置网络的 IP 域名。</p><p><strong>步骤 3. 生成密钥来加密 SSH 流量</strong>. SSH 加密源和目的地之间的流量。但是，要这样做，必须使用全局配置命令 <strong>crypto key generate rsa general-keys modulus</strong> <em>位数</em> 生成唯一的身份验证密钥。该模数<em>位数</em>确定密钥大小并且可配置为 360 位至 2048 位。位值越大，密钥越安全。然而，较大的位值也需要较长的时间来加密和解密信息。最小建议系数长度为 1024 位。</p><p><strong>步骤 4.</strong> <strong>验证或创建一个本地数据库条目</strong>。使用<strong>username</strong>全局配置命令来创建本地数据库用户名条目。在示例中，使用了参数<strong>secret</strong>，因此密码将使用MD5加密。</p><p><strong>步骤 5.</strong> <strong>向本地数据库认证身份</strong>。使用 <strong>login local</strong> 线路配置命令对本地数据库的vty线路进行身份验证。</p><p><strong>步骤 6. 启用 vty inbound SSH 会话</strong>. 默认情况下，在vty线路上不允许输入会话。您可以使用**transport input [ssh | telnet]**命令指定多个输入协议，包括 Telnet 和 SSH。</p><p>如示例所示，路由器R1配置在span.com域中。此信息与<strong>crypto key generate rsa general-keys modulus</strong>命令中指定的位值一起使用，用于创建加密密钥。</p><p>接下来，为名为 Bob 的用户创建本地数据库条目。最后，将vty线路配置为根据本地数据库进行身份验证，并且只接受传入的SSH会话。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# configure terminalRouter(config)# hostname R1R1(config)# ip domain name span.comR1(config)# crypto key generate rsa general-keys modulus 1024The name for the keys will be: Rl.span.com % The key modulus size is 1024 bits% Generating 1024 bit RSA keys, keys will be non-exportable...[OK]Dec 13 16:19:12.079: %SSH-5-ENABLED: SSH 1.99 has been enabledR1(config)#R1(config)# username Bob secret ciscoR1(config)# line vty 0 4R1(config-line)# login localR1(config-line)# transport input sshR1(config-line)# exitR1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、禁止未使用的服务"><a href="#4-5、禁止未使用的服务" class="headerlink" title="4.5、禁止未使用的服务"></a>4.5、禁止未使用的服务</h2><p>思科路由器和交换机启动时会有一列活动服务，这些活动在您的网络中可能需要或不需要。禁用任何未使用的服务以保留系统资源，如CPU周期和RAM，并防止威胁发起者利用这些服务。默认打开的服务类型将根据IOS版本而有所不同。例如，IOS-XE 通常只打开 HTTPS 和 DHCP 端口。您可以使用 <strong>show ip ports all</strong> 命令来验证这一点，如示例所示。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# show ip ports allProto Local Address               Foreign Address             State       PID&#x2F;Program NameTCB       Local Address               Foreign Address             (state)tcp   :::443                     :::*                        LISTEN      309&#x2F;[IOS]HTTP COREtcp   *:443                      *:*                         LISTEN      309&#x2F;[IOS]HTTP COREudp   *:67                        0.0.0.0:0                               387&#x2F;[IOS]DHCPD ReceiveRouter#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>IOS-XE 之前的 IOS 版本使用 <strong>show control-plane host open-ports</strong> 命令。我们提到此命令，因为您可能会在旧设备上看到它。输出是相似的。但是，请注意，这个较旧的路由器有不安全的 HTTP 服务器和 Telnet 正在运行。这两种服务都应该被禁用。如示例所示，使用 <strong>no ip http server</strong> 全局配置命令禁用 HTTP。通过在行配置命令<strong>transport input ssh</strong>中指定仅 SSH 来禁用 Telnet 。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Router# show control-plane host open-ports Active internet connections (servers and established)Prot        Local Address      Foreign Address                  Service    State tcp                 *:23                  *:0                   Telnet   LISTEN tcp                 *:80                  *:0                HTTP CORE   LISTEN udp                 *:67                  *:0            DHCPD Receive   LISTENRouter# configure terminalRouter(config)# no ip http serverRouter(config)# line vty 0 15Router(config-line)# transport input ssh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-6、Packet-Tracer-配置安全密码和SSH"><a href="#4-6、Packet-Tracer-配置安全密码和SSH" class="headerlink" title="4.6、Packet Tracer-配置安全密码和SSH"></a>4.6、Packet Tracer-配置安全密码和SSH</h2><p>略</p><h2 id="4-7、实验-使用SSH配置网络设备"><a href="#4-7、实验-使用SSH配置网络设备" class="headerlink" title="4.7、实验-使用SSH配置网络设备"></a>4.7、实验-使用SSH配置网络设备</h2><p>略</p><h1 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h1><p>1、要在路由器上实施 SSH，需要执行以下步骤：</p><ul><li><p>配置唯一的主机名。 </p></li><li><p>配置网络域名。 </p></li><li><p>配置用户账户以使用 AAA 或本地数据库进行认证。 </p></li><li><p>生成 RSA 密钥。 </p></li><li><p>启用 VTY SSH 会话。</p></li></ul><p>2、SSH 通过虚拟接口提供安全的远程登录。SSH 提供了比 Telnet 更强的密码身份验证。SSH 还会在会话期间加密数据。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web安全 安全架构 思科 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十五）</title>
      <link href="/2021/120332589.html"/>
      <url>/2021/120332589.html</url>
      
        <content type="html"><![CDATA[<h1 id="十五、应用层"><a href="#十五、应用层" class="headerlink" title="十五、应用层"></a>十五、应用层</h1><p>如您所知，传输层实际上是数据从一个主机移动到另一个主机的地方。但在此之前，必须确定很多细节，以便正确地进行数据传输。这就是为什么在OSI 和 TCP/IP 模型中都有一个应用层。举个例子，在互联网上出现流媒体视频之前，我们不得不以各种各样的方式观看家庭电影。想象一下，您拍摄了一些您孩子的足球比赛。您住在另一个城市的父母只有一台录像带播放机。您必须把您的视频从相机复制到正确类型的录像带发送给他们。您的哥哥有一个 DVD 播放机，所以您将您的视频转成 DVD 发送给他。这就是应用层的全部内容，确保您的数据是接收设备可以使用的格式。就让我们一探究竟吧!</p><p><strong>模块目标</strong>: 说明应用层为最终用户应用程序提供支持的方式。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>应用层、表示层和会话层</strong></td><td align="left">解释应用层、表示层和会话层的功能如何协同工作， 以向最终用户应用提供网络 服务。</td></tr><tr><td align="left"><strong>点对点</strong></td><td align="left">说明最终用户应用程序如何在点对点网络中运作。</td></tr><tr><td align="left"><strong>Web 和电子邮件协议</strong></td><td align="left">说明 Web 和电子邮件协议的工作方式。</td></tr><tr><td align="left"><strong>IP 编址服务</strong></td><td align="left">说明 DNS 和 DHCP 的工作方式。</td></tr><tr><td align="left"><strong>文件共享服务</strong></td><td align="left">说明文件传输协议的工作方式。</td></tr></tbody></table><h1 id="1、应用层、表示层、会话层"><a href="#1、应用层、表示层、会话层" class="headerlink" title="1、应用层、表示层、会话层"></a>1、应用层、表示层、会话层</h1><h2 id="1-1、应用层"><a href="#1-1、应用层" class="headerlink" title="1.1、应用层"></a>1.1、应用层</h2><p>在OSI和TCP/IP 模型中的应用层最接近最终用户。如图所示，该层为用于通信的应用程序和用于消息传输的底层网络提供接口。应用层协议用于在源主机和目的主机上运行的程序之间进行数据交换。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.1.png"></p><p>基于TCP/IP模型，OSI 模型上面三层（应用层、表示层和会话层）定义了 TCP/IP 应用层的功能。</p><p>目前已有很多种应用层协议，而且人们还在不断开发新的协议。某些最广为人知的应用层协议包括超文本传输协议(HTTP)、文件传输协议 (FTP)，简单文件传输协议 (TFTP)，互联网邮件访问协议 (IMAP) 和域名系统 (DNS) 协议。</p><h2 id="1-2、表示层和会话层"><a href="#1-2、表示层和会话层" class="headerlink" title="1.2、表示层和会话层"></a>1.2、表示层和会话层</h2><p><strong>表示层</strong></p><p>表示层具有三个主要功能：</p><ul><li><strong>将来自源设备的数据格式化或表示成兼容形式，以便目的设备接收。</strong></li><li><strong>采用可被目的设备解压缩的方式对数据进行压缩。</strong></li><li><strong>加密要传输的数据并在收到数据时解密数据。</strong></li></ul><p>如图所示，表示层为应用层格式化数据并制定文件格式标准。常见的视频标准包括Matroska视频(MKV)、活动图像专家组 (MPEG)和QuickTime视频(MOV)。常见图形图像格式为图形交换格式 (GIF)、联合图像专家组 (JPG) 和便携式网络图像 (PNG) 格式。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.2.png"></p><p><strong>会话层</strong></p><p>顾名思义，会话层的功能就是创建并维护源应用程序和目的应用程序之间的对话。会话层用于处理信息交换，发起对话并使其处于活动状态，并在对话中断或长时间处于空闲状态时重启会话。</p><h2 id="1-3、TCP-IP应用层协议"><a href="#1-3、TCP-IP应用层协议" class="headerlink" title="1.3、TCP/IP应用层协议"></a>1.3、TCP/IP应用层协议</h2><p>TCP/IP 应用层协议指定了许多常见互联网通信功能必需的格式和控制信息。在通信会话过程中，源设备和目的设备均使用应用层协议。为确保通信畅通，源主机和目的主机上所实现的应用层协议必须一致。</p><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><p><strong>DNS - 域名系统（或服务）</strong></p><ul><li>TCP,UDP客户端 53</li><li>将域名（例如 cisco.com）转换为 IP 地址。</li></ul><h3 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h3><p><strong>BOOTP - 引导程序协议</strong></p><ul><li>UDP 客户端 68，服务器 67</li><li>允许无盘工作站探查其 IP 地址、网络中 BOOTP 服务器的 IP 地址以及要加载到内存中以引导机器的文件</li><li>BOOTP 正在被 DHCP 所取代</li></ul><p><strong>DHCP-动态主机配置协议</strong></p><ul><li>UDP 客户端 68，服务器 67</li><li>动态分配IP地址可以重复使用不再需要的地址</li></ul><h3 id="电子邮箱"><a href="#电子邮箱" class="headerlink" title="电子邮箱"></a>电子邮箱</h3><p><strong>SMTP - 简单邮件传输协议</strong></p><ul><li>TCP 25</li><li>允许客户端向邮件服务器发送电子邮件</li><li>允许服务器向其他服务器发送电子邮件</li></ul><p><strong>POP3 - 邮局协议</strong></p><ul><li>TCP 110</li><li>允许客户端从邮件服务器检索电子邮件 将电子邮件* 下载到客户端的本地邮件应用程序</li></ul><p><strong>IMAP - 互联网消息访问协议</strong></p><ul><li>TCP 143</li><li>允许客户端访问存储在邮件服务器中的电子邮件</li><li>在服务器上维护电子邮件</li></ul><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p><strong>FTP - 文件传输协议</strong></p><ul><li>TCP 20至21</li><li>设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件</li><li>FTP是一种可靠、面向连接且进行确认的文件传输协议。</li></ul><p><strong>TFTP - 简单文件传输协议</strong></p><ul><li>UDP 客户端 69</li><li>一个简单的，无连接的文件传输协议，使用尽最大努力、不被答复的文件交付</li><li>它使用的开销比FTP少</li></ul><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p><strong>HTTP-超文本传输协议</strong></p><ul><li>TCP 80,8080</li><li>有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集</li></ul><p><strong>HTTPS - 安全 HTTP</strong></p><ul><li>TCP，UDP 443</li><li>浏览器使用加密技术保护 HTTP 通信</li><li>验证您的浏览器连接的网站</li></ul><h1 id="2、对等体到对等体"><a href="#2、对等体到对等体" class="headerlink" title="2、对等体到对等体"></a>2、对等体到对等体</h1><h2 id="2-1、客户端-服务端模式"><a href="#2-1、客户端-服务端模式" class="headerlink" title="2.1、客户端-服务端模式"></a>2.1、客户端-服务端模式</h2><p>在前面的主题中，您了解了在源和目的主机上实现的TCP/IP应用层协议必须是兼容的。在本主题中，您将了解应用层中的客户端/服务器模式和使用的流程。对等网络也是如此。在客户端-服务器模型中，请求信息的设备称为客户端，而响应请求的设备称为服务器。 客户端是一个硬件/软件的组合，人们使用它来直接访问存储在服务器上的资源。</p><p>客户端进程和服务器进程都处于应用层。客户端首先向服务器发送数据请求，服务器通过发送一个或多个数据流来响应客户端。应用层协议规定了客户端和服务器之间请求和响应的格式。除了实际数据传输外，数据交换过程还要求用户身份验证以及要传输的数据文件的标识。</p><p>客户端-服务器网络的一个示例是使用 ISP 的电子邮件服务发送、接收和存储电子邮件。家用计算机的电子邮件客户端向 ISP 的电子邮件服务器请求所有未读邮件。随后服务器向客户端发送被请求的邮件以示响应。从客户端到服务器的数据传输称为上传；而从服务器到客户端的数据传输则称为下载。</p><p>如图所示，文件从服务器下载到客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.3.png"></p><h2 id="2-2、对等网络"><a href="#2-2、对等网络" class="headerlink" title="2.2、对等网络"></a>2.2、对等网络</h2><p>在对等 (P2P) 网络模式中，可以从对等设备访问数据，而无需使用专用服务器。</p><p>P2P 网络模型包含两个部分：P2P 网络和 P2P 应用程序。这两个部分具有相似的特征，但实际工作过程却大不相同。</p><p>在 P2P 网络中，两台或多台计算机通过网络互连，它们共享资源(如打印机和文件)时可以不借助专用服务器。每台接入的终端设备（称为“对等体”）既可以作为服务器，也可以作为客户端。在某项事务中，作为服务器的计算机也可以同时成为其他服务器的客户端。于是，计算机的角色根据请求的不同在客户端和服务器之间切换。</p><p>除共享文件外，这样一个网络还允许用户启用网络游戏，或者共享互联网连接。</p><p>在对等交换中，两台设备在通信过程中处于平等地位。对等体1拥有与对等体2共享的文件，并且可以访问直接连接到对等体2的共享打印机来打印文件。对等体2正在与对等体1共享直接连接的打印机，同时访问对等体1上的共享文件，如图所示。</p><p>该图描绘了对等模型。两台计算机通过交换机连接并直接相互通信。此外，打印机由其中一台计算机共享，并且可以被图中的任何一台计算机访问。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.4.png"></p><h2 id="2-3、Peer-to-Peer-Applications"><a href="#2-3、Peer-to-Peer-Applications" class="headerlink" title="2.3、Peer-to-Peer Applications"></a>2.3、Peer-to-Peer Applications</h2><p>如图所示，对等 (P2P) 应用程序允许设备在同一通信中同时充当客户端和服务器。在该模型中，每台客户端都是服务器，而每台服务器也同时是客户端。P2P 应用程序要求每台终端设备提供用户界面并运行后台服务。</p><p>某些 P2P 应用程序中采用混合系统，即共享的资源是分散的，但指向资源位置的索引存储在集中目录中。在混合系统中，每台对等设备通过访问索引服务器获取存储在另一台对等设备中的资源位置。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.5.png"></p><p>两个客户端同时发起和接收消息。</p><h2 id="2-4、常见对等应用程序"><a href="#2-4、常见对等应用程序" class="headerlink" title="2.4、常见对等应用程序"></a>2.4、常见对等应用程序</h2><p>使用 P2P 应用程序时，网络中运行该应用程序的每台计算机都可以充当在网络中运行该应用程序的其他计算机的客户端或服务器。常见 P2P 网络包括:</p><ul><li>BitTorrent</li><li>Direct Connect</li><li>eDonkey</li><li>Freenet</li></ul><p>某些 P2P 应用程序基于 Gnutella 协议，允许每个用户与他人共享整个文件。如图所示，通过与 Gnutella 协议兼容的客户端软件，用户可以在互联网上连接 Gnutella 服务，然后定位并访问由其他 Gnutella 对等设备共享的资源。许多Gnutella客户机应用程序可用,包括μTorrent,BitComet, DC++, Deluge, 和emule。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.6.png"></p><p>P2P 应用程序通过 Gnutella 可以搜索对等体上的共享资源。</p><p>许多 P2P 应用程序允许用户同时相互分享许多文件片段。客户端使用一个torrent文件查找其他拥有其所需片段的用户，以便可以稍后直接连接到他们。此文件还包含有关跟踪计算机的信息，跟踪哪些用户拥有某些文件的特定片段。客户端同时需要多个用户的文件片段。这被称为集群且该技术称为 BitTorrent。BitTorrent 有其自己的客户端。但有许多其他的 BitTorrent 客户端，包括uTorrent、Deluge 和 qBittorrent。</p><p><strong>注意:</strong> 用户间可以分享任何类型的文件。这些文件中的许多是有版权的，这意味着只有创建者有使用和分发它们的权利。未得到版权持有者许可下载或分发有版权的文件是违法的。侵害版权会导致刑事起诉或民事诉讼。</p><h1 id="3、Web和电子邮件协议"><a href="#3、Web和电子邮件协议" class="headerlink" title="3、Web和电子邮件协议"></a>3、Web和电子邮件协议</h1><h2 id="3-1、超文本传输协议和超文本标记语言"><a href="#3-1、超文本传输协议和超文本标记语言" class="headerlink" title="3.1、超文本传输协议和超文本标记语言"></a>3.1、超文本传输协议和超文本标记语言</h2><p>有些应用层特定的协议是为web浏览和电子邮件等常见用途设计的。第一个主题概述了这些协议。本主题将进一步详细介绍。</p><p>当在 Web 浏览器中输入一个 Web 地址或统一资源定位符 (URL) 时，Web 浏览器将与Web 服务建立连接。Web 服务正在使用 HTTP 协议的服务器上运行。一提到 Web 地址，大多数人往往想到 URL 以及统一资源标识符 (URI)。</p><p>为了更好地理解 Web 浏览器和 Web 客户端的交互原理，我们可以研究一下浏览器是如何打开网页的。在本例中，请使用 <code>http://www.cisco.com/index.html</code> URL。</p><h3 id="第1步"><a href="#第1步" class="headerlink" title="第1步"></a>第1步</h3><p>浏览器对 URL 地址的三个组成部分进行分析：</p><ul><li>http（协议或方案）</li><li><a href="http://www.cisco.com(服务器名称)/">www.cisco.com（服务器名称）</a></li><li>index.html（所请求的特定文件名）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.7.png"></p><h3 id="第2步"><a href="#第2步" class="headerlink" title="第2步"></a>第2步</h3><p>然后，浏览器将通过域名服务器将 <a href="http://www.cisco.com/">www.cisco.com</a> 转换成数字表示的 IP 地址，用它连接到该服务器。客户端通过向服务器发送GET请求向服务器发起一个HTTP请求并请求index.html文件。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.8.png"></p><h3 id="第3步"><a href="#第3步" class="headerlink" title="第3步"></a>第3步</h3><p>作为对请求的响应，服务器将此web页面的HTML代码发送到浏览器。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.9.png"></p><h3 id="第4步"><a href="#第4步" class="headerlink" title="第4步"></a>第4步</h3><p>浏览器解译 HTML 代码并为浏览器窗口格式化页面。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.10.png"></p><h2 id="3-2、HTTP和HTTPS"><a href="#3-2、HTTP和HTTPS" class="headerlink" title="3.2、HTTP和HTTPS"></a>3.2、HTTP和HTTPS</h2><p>HTTP 是一种请求/响应协议。当客户端，尤其是 Web 浏览器，发送请求到 Web 服务器时，HTTP 将指定用于该通信的消息类型。常用的三种消息类型包括 GET（见图）、POST 和 PUT。</p><ul><li><strong>GET</strong> - 客户端请求数据。客户端（Web 浏览器）向 Web 服务器发送 GET 消息以请求 HTML 页面。</li><li><strong>POST</strong> - 上传数据文件到 Web 服务器，例如表单数据。</li><li><strong>PUT</strong> - 用于向 Web 服务器上传资源或内容，例如图像。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.11.png"></p><p>尽管 HTTP 灵活性相当高，但它不是一个安全协议。由于请求消息以明文形式向服务器发送信息，它非常容易被拦截和解读。服务器的响应（尤其是 HTML 页面）也不加密。</p><p>为了在互联网中进行安全通信，人们使用 HTTP 安全（HTTPS）协议。HTTPS 借助身份验证和加密来保护数据，使数据得以安全地在客户端与服务器之间传输。HTTPS 使用的客户端请求服务器响应过程与 HTTP 相同，但在数据流通过网络传输以前会使用安全套接字层 (SSL) 加密。</p><h2 id="3-3、电子邮件协议"><a href="#3-3、电子邮件协议" class="headerlink" title="3.3、电子邮件协议"></a>3.3、电子邮件协议</h2><p>电子邮件托管是 ISP 提供的主要服务之一。如果要在计算机或其他终端设备上运行电子邮件，仍然需要多种应用程序和服务，如图所示。邮件是通过网络发送、存储和检索电子消息的存储转发方法。邮件消息存储在邮件服务器的数据库中。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.12.png"></p><p>邮件客户端通过与邮件服务器通信来收发邮件。邮件服务器之间也会互相通信，以便将邮件从一个域发到另一个域中。也就是说，发送邮件时，邮件客户端并不会直接与另外一个邮件客户端通信。而是双方客户端均依靠邮件服务器来传输邮件。</p><p>电子邮件支持三种单独的协议以实现操作：**简单邮件传输协议 (SMTP)、邮局协议 (POP) 和 Internet 邮件访问协议 (IMAP)**。发送邮件的应用层进程会使用 SMTP。客户端会使用以下两种应用层协议之一来检索邮件：POP 或 IMAP。</p><h2 id="3-4、SMTP、POP和IMAP"><a href="#3-4、SMTP、POP和IMAP" class="headerlink" title="3.4、SMTP、POP和IMAP"></a>3.4、SMTP、POP和IMAP</h2><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p><strong>简单邮件传输协议</strong></p><p>SMTP 邮件格式要求邮件具有报头和正文。虽然邮件正文没有长度限制，但邮件报头必须具有格式正确的收件人邮件地址和发件人地址。</p><p>当客户端发送邮件时，客户端 SMTP 进程会连接公认端口 25 上的服务器 SMTP 进程。连接建立后，客户端将尝试通过此连接发送邮件到服务器。服务器收到邮件后，如果收件人在本地，它会将邮件保存在本地账户中，或者将邮件转发给另一台邮件服务器以便传输。</p><p>发出邮件时，目的邮件服务器可能并不在线，或者正忙。因此，SMTP 将邮件转到后台处理，稍后再发送。服务器会定期检查邮件队列，然后尝试再次发送。经过预定义的过期时间后，如果仍然无法发送邮件，则会将其作为无法投递的邮件退回给发件人。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.13.png"></p><h3 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h3><p><strong>邮局协议</strong></p><p>应用程序使用 POP 从邮件服务器中检索邮件。根据 POP 的规定，邮件将从服务器下载到客户端，然后从服务器上删除。这是 POP 的默认操作。</p><p>服务器通过在 TCP 端口 110 上被动侦听客户端连接请求来启动 POP 服务。当客户端要使用此服务时，它会发送一个请求来建立与服务器的 TCP 连接，如图所示。一旦建立连接，POP 服务器即会发送问候语。然后客户端和 POP 服务器会交换命令和响应，直到连接关闭或中止。</p><p>根据 POP，由于电子邮件会下载到客户端并从服务器删除，因此电子邮件不会集中保存在某一特定的位置。因为 POP 不存储邮件，因此不建议用于需要集中备份解决方案的小型企业。</p><p>POP3 是最常用的版本。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.14.png"></p><h3 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h3><p> <strong>Internet 邮件访问协议</strong></p><p>IMAP 是另外一种用于检索电子邮件消息的协议。与 POP 不同的是，当用户连接使用 IMAP 的服务器时，邮件的副本会下载到客户端应用程序，如图所示。同时原始邮件会一直保留在服务器上，直到用户将它们手动删除。用户在自己的邮件客户端软件中查看邮件副本。</p><p>用户可以在服务器上创建文件层次结构来组织和保存邮件。该文件结构会照搬到邮件客户端。当用户决定删除邮件时，服务器会同步该操作，从服务器上删除对应的邮件。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.15.png"></p><h1 id="4、IP编址服务"><a href="#4、IP编址服务" class="headerlink" title="4、IP编址服务"></a>4、IP编址服务</h1><h2 id="4-1、域名服务"><a href="#4-1、域名服务" class="headerlink" title="4.1、域名服务"></a>4.1、域名服务</h2><p>还有其他应用层特定的协议，它们被设计可以更容易地获取网络设备的地址。这些服务是必不可少的，因为记住 IP 地址而不是 URL 或手动配置中大型网络中的所有设备将非常耗时。本模块的第一个主题为您介绍了这些协议。本主题将详细介绍 IP 编址服务、DNS 和 DHCP。</p><p>在数据网络中，使用数字 IP 地址标记设备以便通过网络发送和接收数据。人们创建了可以将数字地址转换为简单易记名称的域名系统。</p><p>在互联网上，更便于人们记忆的是 <a href="http://www.cisco.com/">http://www.cisco.com</a> 这样的完全限定域名，而不是该服务器的实际数字 IP 地址 198.133.219.25。如果思科决定更改 <a href="http://www.cisco.com/">www.cisco.com</a> 的数字地址，那么更改对用户是透明的，因为域名将保持不变。公司只需要将新地址与现有域名链接起来即可保证连通性。</p><p>DNS 协议定义了一套自动化服务，该服务将资源名称与所需的数字网络地址匹配。协议涵盖了查询格式、响应格式及数据格式。DNS 协议通信采用单一格式，即消息格式。该格式用于所有类型的客户端查询和服务器响应、报错消息、以及服务器间的资源记录信息的传输。</p><h3 id="第1步-1"><a href="#第1步-1" class="headerlink" title="第1步"></a>第1步</h3><p>用户在浏览器应用程序地址字段中输入 FQDN。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.16.png"></p><h3 id="第2步-1"><a href="#第2步-1" class="headerlink" title="第2步"></a>第2步</h3><p>一个DNS 查询发送到客户端计算机的指定 DNS 服务器。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.17.png"></p><h3 id="第3步-1"><a href="#第3步-1" class="headerlink" title="第3步"></a>第3步</h3><p>DNS 服务器将 FQDN 与其 IP 地址匹配。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.18.png"></p><h3 id="第4步-1"><a href="#第4步-1" class="headerlink" title="第4步"></a>第4步</h3><p>DNS 查询响应将FQDN 的 IP 地址发送回客户端。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.19.png"></p><h3 id="第5步"><a href="#第5步" class="headerlink" title="第5步"></a>第5步</h3><p>客户端计算机使用IP地址向服务器发出请求。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.20.png"></p><h2 id="4-2、DNS消息格式"><a href="#4-2、DNS消息格式" class="headerlink" title="4.2、DNS消息格式"></a>4.2、DNS消息格式</h2><p>DNS 服务器中存储不同类型的资源记录，用来解析域名。这些记录中包含域名、地址以及记录的类型。这些记录有以下类型：</p><ul><li><strong>A</strong> - 终端设备 IPv4 地址</li><li><strong>NS</strong> - 授权域名服务器</li><li><strong>AAAA</strong> - 终端设备 IPv6 地址（读作“四 A”）</li><li><strong>MX</strong> - 邮件交换记录</li></ul><p>在客户端进行查询时，服务器 DNS 进程首先会查看自己的记录以解析名称。如果服务器不能通过自身存储的记录解析域名，它将联系其他服务器对该域名进行解析。在检索到匹配信息并将其返回到原始请求服务器后，服务器临时存储数字地址，以供再次请求同一域名时使用。</p><p>Windows PC 上的 DNS 客户端服务还可存储以前在内存中解析的域名。<strong>ipconfig /displaydns</strong>命令显示所有 DNS 缓存条目。</p><p>如表中所示，DNS在服务器间使用相同的消息格式，包含所有类型的客户端查询的问题、回答、授权和更多信息以及服务器响应、错误消息和服务器间的资源记录信息的传输。</p><table><thead><tr><th align="left"><strong>DNS 消息部分</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">问题</td><td align="left">向域名服务器提出的问题</td></tr><tr><td align="left">回答</td><td align="left">回答该问题的资源记录</td></tr><tr><td align="left">权限 (Authority)</td><td align="left">指向权限的资源记录</td></tr><tr><td align="left">更多</td><td align="left">包含其他信息的资源记录</td></tr></tbody></table><h2 id="4-3、DNS层级"><a href="#4-3、DNS层级" class="headerlink" title="4.3、DNS层级"></a>4.3、DNS层级</h2><p>DNS 协议采用分层系统创建数据库以提供名称解析，如图所示。DNS 使用域名来划分层次。</p><p>域名结构被划分为多个更小的受管域。每台 DNS 服务器维护着特定的数据库文件，而且只负责管理 DNS 结构中那一小部分的“域名-IP”映射。当 DNS 服务器收到的域名转换请求不属于其所负责的 DNS 区域时，该 DNS 服务器可将请求转发到与该请求对应的区域中的 DNS 服务器进行转换。DNS 具有可扩展性，这是因为主机名解析分散于多台服务器上完成。</p><p>不同的顶级域有不同的含义，分别代表着组织类型或起源国家/地区。请参见以下顶级域示例：</p><ul><li><strong>.com</strong> - 商业或行业</li><li><strong>.org</strong> - 非营利组织</li><li><strong>.au</strong> - 澳大利亚</li><li><strong>.co</strong> - 哥伦比亚</li><li><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.21.png"></li></ul><h2 id="4-4、nslookup命令"><a href="#4-4、nslookup命令" class="headerlink" title="4.4、nslookup命令"></a>4.4、nslookup命令</h2><p>我们通常在配置网络设备时提供一个或者多个 DNS 服务器地址，DNS 客户端可以使用该地址进行域名解析。ISP往往会为 DNS 服务器提供地址。当用户应用程序请求通过域名连入远程设备时，DNS 客户端将向某一域名服务器请求查询，获得域名解析后的数字地址。</p><p>用户还可以使用操作系统中名为 Nslookup 的实用程序手动查询域名服务器，来解析给定的主机名。该实用程序也可以用于<strong>检修域名解析故障，以及验证域名服务器的当前状态。</strong></p><p>在图中，发出<strong>nslookup</strong>命令后，即显示为主机配置的默认 DNS 服务器。可以在<strong>nslookup</strong>提示符下输入主机名或域名。Nslookup 实用程序还有很多选项，可以用于大量测试以及 DNS 进程验证。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\Users&gt; nslookupDefault Server:  dns-sj.cisco.comAddress:  171.70.168.183&gt; www.cisco.comServer:  dns-sj.cisco.comAddress:  171.70.168.183Name:    origin-www.cisco.comAddresses:  2001:420:1101:1::a          173.37.145.84Aliases:  www.cisco.com&gt; cisco.netacad.netServer:  dns-sj.cisco.comAddress:  171.70.168.183Name:    cisco.netacad.netAddress:  72.163.6.223&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-5、语法检查器-nslookup命令"><a href="#4-5、语法检查器-nslookup命令" class="headerlink" title="4.5、语法检查器-nslookup命令"></a>4.5、语法检查器-nslookup命令</h2><p>略</p><h2 id="4-6、动态主机配置协议"><a href="#4-6、动态主机配置协议" class="headerlink" title="4.6、动态主机配置协议"></a>4.6、动态主机配置协议</h2><p>IPv4 服务的动态主机配置协议 (DHCP) 会自动分配 IPv4 地址、子网掩码、网关以及其他 IPv4 网络参数。这称为动态编址。动态编址的替代选项是静态编址。在使用静态编址时，网络管理员在主机上手动输入 IP 地址信息。</p><p>主机连入网络时，将联系 DHCP 服务器并请求地址。DHCP 服务器从已配置地址范围（也称为“地址池”）中选择一条地址，并将其分配（租赁）给主机。</p><p>在较大型的网络中，或者用户经常变更的网络中，地址分配优先选用 DHCP。新用户可能在到达时需要连接；其他用户可能有新计算机必须要连接。与为每个连接使用静态编址的做法相比，采用 DHCP 自动分配 IPv4 地址的方法更有效。</p><p>DHCP可以在一段可配置的时间内分配IP地址，这段时间称为<strong>租期</strong>。租期是一个重要的 DHCP 设置，当租期过期或 DHCP 服务器收到 DHCPRELLAME 消息时，地址将返回到 DHCP 池以便重复使用。因此，用户可以自由的移动位置，并通过DHCP随时重新连接网络。</p><p>如图所示,很多类型的设备都可以成为 DHCP 服务器。在大多数中型到大型网络中，DHCP 服务器通常都是基于 PC 的本地专用服务器。在家庭网络中，DHCP 服务器通常位于本地路由器，将家庭网络连接到 ISP。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.22.png"></p><p>很多网络都同时采用 DHCP 和静态编址。DHCP 用于一般用途主机，例如用户终端设备。静态编址用于网络设备，例如网关路由器、交换机、服务器和打印机。</p><p>IPv6 的 DHCP（DHCPv6）为 IPv6 客户端提供类似服务。一个重要的不同是，<strong>DHCPv6 不会提供默认网关地址。这只能从路由器的 Router Advertisement（路由器通告）消息中动态获得。</strong></p><h2 id="4-7、DHCP工作原理"><a href="#4-7、DHCP工作原理" class="headerlink" title="4.7、DHCP工作原理"></a>4.7、DHCP工作原理</h2><p>如图所示，配置了 DHCP 的 IPv4 设备在启动或连接到网络时，客户端将广播一条 DHCP 发现 (DHCPDISCOVER) 消息以确定网络上是否有可用 DHCP 服务器。DHCP 服务器回复 DHCP 服务 (DHCPOFFER) 消息，为客户端提供租赁服务。该服务消息包含为其分配的 IPv4 地址和子网掩码、DNS 服务器的 IPv4 地址和默认网关的 IPv4 地址。租赁服务还包括租用期限。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.23.png"></p><p>如果本地网络中有超过一台 DHCP 服务器，客户端可能会收到多条 DHCPOFFER 消息。此时，客户端必须在这些服务器中进行选择，并且将包含服务器标识信息及客户端所接受的租赁服务的 DHCP 请求 (DHCPREQUEST) 消息发送出去。客户端还可选择向服务器请求分配以前分配过的地址。</p><p>如果客户端请求的 IPv4 地址（或者服务器提供的 IPv4 地址）仍然可用，服务器将返回 DHCP 确认 (DHCPACK) 消息，向客户端确认地址租赁。如果请求的地址不再有效，则所选服务器将回复一条 DHCP 否定确认 (DHCPNAK) 消息。一旦返回 DHCP NAK 消息，应重新启动选择进程，并重新发送新的 DHCP 发现消息。客户端租赁到地址后，应在租期结束前发送 DHCPREQUEST 消息进行续期。</p><p>DHCP 服务器确保每个 IP 地址都是唯一的（一个 IP 地址不能同时分配到不同的网络设备上）。因此，大多数ISP往往使用 DHCP 为其客户分配地址。</p><p>DHCPv6 有一组与DHCPv4 类似的消息。DHCPv6 消息包括 SOLICIT、ADVERTISE、INFORMATION REQUEST 和 REPLY。</p><h2 id="4-8、实验-观察DNS解析"><a href="#4-8、实验-观察DNS解析" class="headerlink" title="4.8、实验-观察DNS解析"></a>4.8、实验-观察DNS解析</h2><p>略</p><h2 id="4-9、测验"><a href="#4-9、测验" class="headerlink" title="4.9、测验"></a>4.9、测验</h2><p>1、当DNS服务器接收不到在其区域内域名的域名解析请求时，服务将该请求转发给另一个DNS服务器</p><p>2、nslookup命令将显示已配置的默认DNS服务器</p><h1 id="5、文件共享服务"><a href="#5、文件共享服务" class="headerlink" title="5、文件共享服务"></a>5、文件共享服务</h1><h2 id="5-1、文件传输协议"><a href="#5-1、文件传输协议" class="headerlink" title="5.1、文件传输协议"></a>5.1、文件传输协议</h2><p>正如您在前面的主题中了解到的，在客户端/服务器模式中，如果两个设备都使用文件传输协议(FTP)，客户端可以将数据上传到服务器，并从服务器下载数据。与 HTTP、电子邮件和编址协议一样，FTP 是常用的应用层协议。本主题将更详细地讨论 FTP。</p><p>FTP 用于客户端和服务器之间的数据传输。FTP 客户端是一种在计算机上运行的应用，用于从 FTP 服务器中收发数据。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.24.png"></p><p>取决于通过控制连接发送的命令，可以从服务器下载数据，也可以从客户端上传数据。</p><p>FTP需要客户端和服务器之间的<strong>两个连接</strong></p><p>客户端使用 TCP 端口 <strong>21</strong> 与服务器建立第一个连接用于控制流量。流量由客户端命令和服务器应答组成。</p><p>客户端使用 TCP 端口 <strong>20</strong> 与服务器建立第二个连接用于实际数据传输。每当有数据需要传输时都会建立此连接。</p><p>数据传输可以在任何一个方向进行。客户端可以从服务器下载（取）数据，也可以向服务器上传（放）数据。</p><h2 id="5-2、服务器消息块"><a href="#5-2、服务器消息块" class="headerlink" title="5.2、服务器消息块"></a>5.2、服务器消息块</h2><p>服务器消息块 (SMB) 是一种客户端/服务器文件共享协议，用于规范共享网络资源（如目录、文件、打印机以及串行端口）结构。这是一种请求-响应协议。所有的 SMB 消息都采用一种常用格式。该格式采用固定大小的文件头，后跟可变大小的参数以及数据组件。</p><p>以下是 SMB 消息的三个功能：</p><ul><li>启动、身份验证以及终止会话</li><li>控制文件和打印机的访问</li><li>允许应用程序向任何设备收发消息</li></ul><p>Microsoft 网络配置中主要采用 SMB 形式实现文件共享和打印服务。随着 Windows 2000 软件系列的推出，Microsoft 更改了基础结构以使用 SMB。而在以前的 Microsoft 产品中，SMB 服务需要使用非 TCP/IP 协议来执行域名解析。从 Windows 2000 开始，之后的所有 Microsoft 产品都使用 DNS 命名，使 TCP/IP 协议能够直接支持 SMB 资源共享，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.25.png"></p><p>SMB 是一种客户端/服务器，请求-响应协议。服务器可将其资源共享给网络中的客户端使用。</p><p>Windows PC 之间的 SMB 文件交换过程如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN15.26.png"></p><p>使用 SMB 协议可以通过 Windows 资源管理器将一台 PC 中的文件复制到另一台 PC。</p><p>与 FTP 协议支持的文件共享不同，SMB 协议中的客户端要与服务器建立长期连接。一旦建立连接，客户端用户就可以访问服务器上的资源，就如同资源位于客户端主机上一样。</p><p>在 LINUX 和 UNIX 操作系统中，通过 SAMBA（SMB 的一个版本）可以实现与 Microsoft 网络的资源共享。在 Apple Macintosh 操作系统中，通过 SMB 协议也可以实现资源共享。</p><h1 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h1><p>1、DHCP 协议用于请求、发布和管理 IP 编址信息。CSMA/CD 是用于有线以太网的访问方法。ICMP 用于测试连接。SNMP 用于网络管理，而 FTP 用于文件传输。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十四）</title>
      <link href="/2021/120348627.html"/>
      <url>/2021/120348627.html</url>
      
        <content type="html"><![CDATA[<h1 id="十四、传输层"><a href="#十四、传输层" class="headerlink" title="十四、传输层"></a>十四、传输层</h1><p>欢迎来学习传输层！</p><p>顾名思义,传输层是将数据从一个主机传输到另一个主机的地方。这是您的网络真正开始动起来的地方! 传输层使用两个协议: TCP和UDP。可以把TCP看作是在邮件中收到一封挂号信。您必须先签收,然后邮递员才会给您。这会稍微减慢这个过程,但是发送者可以确定地知道您收到了这封信,以及您收到这封信的时间。UDP更像是一个普通的,盖了邮戳的信。它到达了您的邮箱（如果它到了的话）,它可能是给您的,但它实际上也可能是给其他不住在那里的人的。而且,它还可能根本就没有到达您的邮箱。发件人无法确定您已收到了信。尽管如此,有时还是需要像盖了邮戳的信件一样的UDP协议。本主题深入探讨 TCP和 UDP 在传输层中的工作方式。</p><p><strong>模块目标</strong>: 比较各种传输层协议支持端到端通信的方式。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据传输</strong></td><td align="left">说明传输层在端对端通信中 管理数据传输的目的。</td></tr><tr><td align="left"><strong>TCP 概述</strong></td><td align="left">说明 TCP 的特征</td></tr><tr><td align="left"><strong>UDP 概述</strong></td><td align="left">说明UDP 的特征。</td></tr><tr><td align="left"><strong>端口号</strong></td><td align="left">说明 TCP 和 UDP 如何使用端口号。</td></tr><tr><td align="left"><strong>TCP 通信过程</strong></td><td align="left">说明 TCP 会话的建立和终止过程如何 有助于实现可靠通信。</td></tr><tr><td align="left"><strong>可靠性和流控制</strong></td><td align="left">说明如何通过发送和确认 TCP 协议数据单元来 保证数据传输。</td></tr><tr><td align="left"><strong>UDP 通信</strong></td><td align="left">比较各种传输层协议支持 端到端通信的方式。</td></tr></tbody></table><h1 id="1、数据传输"><a href="#1、数据传输" class="headerlink" title="1、数据传输"></a>1、数据传输</h1><h2 id="1-1、传输层的应用"><a href="#1-1、传输层的应用" class="headerlink" title="1.1、传输层的应用"></a>1.1、传输层的应用</h2><p>应用层程序生成必须在源主机和目的主机之间交换的数据。传输层负责在不同主机上运行的应用程序之间进行的逻辑通信。这可能包括在两个主机之间建立临时会话以及应用程序信息的可靠传输等服务。</p><p>如图所示，传输层将应用层与负责网络传输的下层连接起来。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.1.png"></p><p>传输层并不了解目标主机类型、数据必须经过的介质类型、数据使用的路径，链路拥塞情况或网络大小。</p><p>传输层包括两个协议：</p><ul><li>传输控制协议 (TCP)</li><li>用户数据报协议 (UDP)</li></ul><h2 id="1-2、传输层的职责"><a href="#1-2、传输层的职责" class="headerlink" title="1.2、传输层的职责"></a>1.2、传输层的职责</h2><h3 id="跟踪各个会话"><a href="#跟踪各个会话" class="headerlink" title="跟踪各个会话"></a>跟踪各个会话</h3><p>在传输层中，源应用和目的应用之间传输的每个数据集称为会话并分别进行跟踪。传输层负责维护并跟踪这些会话。</p><p>如图所示，每台主机上都可以有多个应用同时在网络上通信。</p><p>大多数网络对单个数据包能承载的数据量都有限制。因此，必须将数据分成可管理的部分。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.2.png"></p><h3 id="数据分段和数据段重组"><a href="#数据分段和数据段重组" class="headerlink" title="数据分段和数据段重组"></a>数据分段和数据段重组</h3><p>传输层负责将应用程序数据划分为适当大小的块。根据所使用的传输层协议，传输层块称为数据段或数据报。该图说明了使用不同块进行每个会话的传输层。</p><p>传输层将数据划分为更易于管理和传输的更小的块（即，数据段或数据报）。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.3.png"></p><h3 id="添加报头信息"><a href="#添加报头信息" class="headerlink" title="添加报头信息"></a>添加报头信息</h3><p>传输层协议还将包含二进制数据的报头信息添加到每个数据块中，这些数据被组织成几个字段。不同的传输层协议通过这些字段值在管理数据通信过程中执行各自的功能。</p><p>例如，接收主机使用报头信息将数据块重新组装为接收应用程序层程序的完整数据流。</p><p>传输层可以确保在设备上运行多个应用时，所有应用都能接收正确的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.4.png"></p><h3 id="标识应用"><a href="#标识应用" class="headerlink" title="标识应用"></a>标识应用</h3><p>传输层必须能够划分和管理具有不同传输要求的多个通信。为了将数据流传递到适当的应用程序，传输层使用称为端口号的标识符来标识目标应用。如图所示，在每台主机中，每个需要访问网络的软件进程都将被分配一个唯一的端口号。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.5.png"></p><h3 id="会话多路复用"><a href="#会话多路复用" class="headerlink" title="会话多路复用"></a>会话多路复用</h3><p>将某些类型的数据（即视频流）作为完整的通信流在网络中发送，会使用所有可用带宽。这将阻止其他通信会话同时发生。而且也难以对损坏的数据开展错误恢复和重新传输的工作。</p><p>如图所示，传输层使用数据段和多路复用，使不同的通信会话在同一网络上交错。</p><p>可对数据段中的数据执行错误检查，以确定数据段在传输过程中是否发生了更改。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.6.png"></p><h2 id="1-3、传输层协议"><a href="#1-3、传输层协议" class="headerlink" title="1.3、传输层协议"></a>1.3、传输层协议</h2><p>IP 只涉及数据包的结构、地址分配和路由。IP 不指定数据包的传送或传输方式。</p><p>传输层协议指定如何在主机之间传输消息，并负责管理会话的可靠性要求。传输层包括 TCP 和 UDP 协议。</p><p>不同的应用有不同的传输可靠性要求。因此，TCP/IP 提供了两个传输层协议，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.7.png"></p><h2 id="1-4、传输控制协议（TCP）"><a href="#1-4、传输控制协议（TCP）" class="headerlink" title="1.4、传输控制协议（TCP）"></a>1.4、传输控制协议（TCP）</h2><p>IP 只涉及从原始发送方到最终目的地的数据包的结构、编址和路由。IP不负责保证传递或确定发送方和接收方之间是否需要建立连接。</p><p>TCP 被认为是可靠且功能齐全的传输层协议，用于确保所有数据到达目的设备。TCP包含确保应用数据传递的字段。这些字段需要发送和接收的主机进行额外处理。</p><p><strong>注意</strong>：TCP将数据分为若干个数据段。</p><p>TCP 传输类似于从源到目的地跟踪发送的数据包。如果快递订单分多个数据包，客户可以在线查看发货顺序。</p><p>TCP 使用以下基本操作提供可靠性和流量控制：</p><ul><li>编号并跟踪从特定应用程序发送到特定主机的数据段。</li><li>确认收到数据</li><li>在一定时间段后重新传输未确认的数据</li><li>有顺序的数据可能以错误的顺序到达 以接收方可以接受的有效速率* 发送数据</li></ul><p>为了维护会话的状态并跟踪信息，TCP必须首先在发送方和接收方之间建立连接。这就是为什么TCP被称为是一种面向连接的协议。</p><h2 id="1-5、用户数据报协议（UDP）"><a href="#1-5、用户数据报协议（UDP）" class="headerlink" title="1.5、用户数据报协议（UDP）"></a>1.5、用户数据报协议（UDP）</h2><p>UDP是一种比TCP更简单的传输层协议。它不提供可靠性和流量控制，这意味着它需要更少的报头字段。由于发送方和接收方UDP进程不需要管理可靠性和流量控制，这意味着 UDP 数据报的处理速度比 TCP 数据段快。UDP 仅提供在相应应用之间传输数据报的基本功能，需要很少的开销和数据检查。</p><p><strong>注意</strong>：UDP 将数据划分为数据报，也称为数据段。</p><p>UDP是一种<strong>无连接协议</strong>。由于 UDP 不提供可靠性或流量控制，因此不需要建立连接。由于 UDP 不跟踪客户端和服务器之间发送或接收的信息，因此UDP 也称为<strong>无状态协议</strong>。</p><p>UDP 也称为<strong>最大努力交付协议</strong>，因为在目的地接收到数据后没有确认消息。UDP 中没有通知发送方是否成功传输的传输层流程。</p><p>UDP 类似于邮寄未挂号的常规信件。发件人不知道收件人是否能够接收信件。邮局也不负责跟踪信件或在信件未到达最终目的地时通知发件人。</p><h2 id="1-6、正确的应用程序使用正确的传输层协议"><a href="#1-6、正确的应用程序使用正确的传输层协议" class="headerlink" title="1.6、正确的应用程序使用正确的传输层协议"></a>1.6、正确的应用程序使用正确的传输层协议</h2><p>一些应用可以容忍在网络传输过程中丢失部分数据，但是不接受传输中出现延迟。由于需要的网络开销较少，对于这些应用，UDP 是更好的选择。UDP 是 IP 语音 (VoIP) 之类应用的首选。确认和重新发送会拖慢传输速度，并使语音会话不可接受。</p><p>UDP 也被“请求-回复”应用程序使用，其中数据最少，并且可以快速完成重新传输。例如，域名服务 (DNS) 为此类事务使用 UDP。客户端从DNS服务器请求已知域名的IPv4和IPv6地址。如果客户端在预定的时间内没有收到响应，它将再次发送请求。</p><p>例如，如果视频数据流中的一段或者两段数据未到达目的地，就会造成数据流的短暂中断。这可能表现为图像失真或声音失真，用户也许不会察觉。如果目的设备必须负责处理丢失的数据，则流可能在等待重新发送的过程中被推迟，从而导致图像或声音的质量大大降低。在这种情况下，最好利用接收到的分段呈现最佳媒体，并放弃可靠性。</p><p>对于其他应用程序，重要的是所有数据都应到达并且可以按适当的顺序对其进行处理。对于这些类型的应用程序，使用TCP 作为传输协议。例如，数据库、Web 浏览器和邮件客户端等应用，要求发送的所有数据都必须以原始形式到达目的地。任何数据的丢失都可能导致通信失败，要么不能完成通信，要么通信的信息不可读。例如，通过网页访问银行信息时，确保所有信息都正确发送和接收是非常重要的。</p><p>应用开发人员必须根据应用的需求，选择适合的传输层协议类型。视频可以通过 TCP 或 UDP 发送。存储音频和视频流的应用使用 TCP。应用程序使用 TCP 执行缓冲、带宽探测和拥塞控制，以便更好地控制用户体验。</p><p>实时视频和语音通常使用UDP，但也可能使用TCP，或同时使用UDP和TCP。视频会议应用程序默认情况下可能使用UDP，但由于许多防火墙阻止UDP，应用程序也可以通过TCP发送。</p><p>存储音频和视频流的应用使用 TCP。例如，如果您的网络突然不能支持观看一个点播电影所需的带宽，则应用使播放暂停。在暂停期间，您可能会看到一个“缓冲……”消息，这时，TCP 正在重建流。当所有的片段都井然有序且恢复最低限度的带宽时，您的 TCP 会话重新开始，电影恢复播放。</p><p>该图总结了UDP和TCP之间的差异。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.8.png"></p><h1 id="2、TCP概述"><a href="#2、TCP概述" class="headerlink" title="2、TCP概述"></a>2、TCP概述</h1><h2 id="2-1、TCP功能"><a href="#2-1、TCP功能" class="headerlink" title="2.1、TCP功能"></a>2.1、TCP功能</h2><p>在上一主题中，您了解了TCP和UDP是两个传输层协议。本主题提供了更多关于TCP的详细信息，以及何时使用它而不是UDP是明智的。</p><p>要了解 TCP 和 UDP 的差异，就必须了解每种协议如何实现特定的可靠性功能，以及每个协议如何跟踪会话。</p><p>除了支持数据分段和重组的基本功能之外，TCP 还提供以下服务：</p><ul><li><strong>建立会话</strong> -TCP是一种面向连接的协议，在转发任何流量之前，在源设备和目的设备之间协商并建立永久连接（或会话）。通过建立会话，设备可以协商特定时间能够转发的流量，而且两个设备之间的通信数据可得到严格管理。</li><li><strong>确保可靠的传递</strong> -由于多种原因，数据段在网络传输过程中可能会损坏或者完全丢失。TCP确保从源设备发送的每个数据段都能够到达目的地。</li><li><strong>提供相同顺序的传递</strong> -由于网络可能提供了多条路由，每条路由又有不同的传输速率，所以可能导致数据抵达的顺序错乱。通过对数据段编号和排序，TCP 确保按正确的顺序重组这些数据段。</li><li><strong>支持流量控制</strong> -网络主机的资源有限（即，内存或处理能力）。当 TCP 发现这些资源超负荷运转时，它可以请求源应用程序降低数据流速。为此，TCP 会调整源设备传输的数据量。流量控制可避免当接收主机的资源不堪重负时，数据的重新传输。</li></ul><p>有关 TCP 的更多信息，请在互联网上搜索 RFC 793。</p><h2 id="2-2、TCP报头"><a href="#2-2、TCP报头" class="headerlink" title="2.2、TCP报头"></a>2.2、TCP报头</h2><p>TCP是有状态的协议，意味着它跟踪通信会话的状态。为了跟踪会话的状态，TCP 记录已发送的信息和已确认的信息。状态会话开始于会话建立时，结束于会话终止时。</p><p>在封装应用层数据时，TCP 数据段会增加 20 个字节（即 160 位）的开销。该图显示的是 TCP 报头中的字段。</p><p><strong>TCP报头由一个20字节报头中的10个字段组成</strong></p><p>该图显示的是 TCP 报头中的字段。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.9.png"></p><h2 id="2-3、TCP报头字段"><a href="#2-3、TCP报头字段" class="headerlink" title="2.3、TCP报头字段"></a>2.3、TCP报头字段</h2><p>该表标识并描述了 TCP 报头中的十个字段。</p><table><thead><tr><th align="left"><strong>TCP 报头字段</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>源端口</strong></td><td align="left">一个16位字段, 用于通过端口号标识源应用程序。</td></tr><tr><td align="left"><strong>目的端口</strong></td><td align="left">一个16位字段, 用于通过端口号标识目的应用 程序。</td></tr><tr><td align="left"><strong>序列号</strong></td><td align="left">一个32位字段, 用于数据重组。</td></tr><tr><td align="left"><strong>确认号</strong></td><td align="left">一个32位的字段, 用于指示已接收到数据, 并且期望从源 接收下一个字节。</td></tr><tr><td align="left"><strong>报头长度</strong></td><td align="left">一个4位字段, 称为“数据偏移”, 表示 TCP数据段报头的长度。</td></tr><tr><td align="left"><strong>保留</strong></td><td align="left">一个6位字段, 保留供将来使用。</td></tr><tr><td align="left"><strong>控制位</strong></td><td align="left">一个6位字段, 包括位代码或标志, 指示 TCP段的目的和功能。</td></tr><tr><td align="left"><strong>窗口大小</strong></td><td align="left">一个16位字段, 用于指示一次可以接受的 字节数。</td></tr><tr><td align="left"><strong>校验和</strong></td><td align="left">一个16位字段, 用于数据段报头和数据的错误检查。</td></tr><tr><td align="left"><strong>紧急</strong></td><td align="left">一个 16 位字段, 用于指示包含的数据是否紧急。</td></tr></tbody></table><h2 id="2-4、使用TCP的应用程序"><a href="#2-4、使用TCP的应用程序" class="headerlink" title="2.4、使用TCP的应用程序"></a>2.4、使用TCP的应用程序</h2><p>TCP 很好地说明了 TCP/IP 协议簇的不同层如何拥有特定角色。TCP 处理与将数据流划分为数据段、提供可靠性、控制数据流量和数据段重新排序相关的所有任务。TCP 使应用程序不用再管理这些任务。如图所示的应用程序只需要将数据流发送到传输层和使用 TCP 提供的服务。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.10.png"></p><h1 id="3、UDP概述"><a href="#3、UDP概述" class="headerlink" title="3、UDP概述"></a>3、UDP概述</h1><h2 id="3-1、UDP功能"><a href="#3-1、UDP功能" class="headerlink" title="3.1、UDP功能"></a>3.1、UDP功能</h2><p>本主题将介绍UDP、它的作用以及何时使用UDP代替TCP是一个好主意。UDP 是一种尽最大努力传输协议。UDP 是一种轻型传输协议，提供与 TCP 相同的数据分段和重组功能，但是没有 TCP 所提供的可靠性和流量控制。</p><p>UDP 协议非常简单，它通常被描述为与 TCP 比较所不提供的功能。</p><p>UDP的特点包括以下几种：</p><ul><li>数据按照接收顺序重构。</li><li>丢失的任何数据段都不会重新发送。</li><li>不会建立会话。</li><li>不会告知发送者资源可用性。</li></ul><p>有关 UDP 的更多信息，请在互联网上搜索 RFC。</p><h2 id="3-2、UDP报头"><a href="#3-2、UDP报头" class="headerlink" title="3.2、UDP报头"></a>3.2、UDP报头</h2><p>UDP 是无状态协议，这意味着客户端和服务器都不会跟踪通信会话的状态。如果使用 UDP 作为传输协议时要求可靠性，必须由应用来处理可靠性。</p><p>通过网络传输实时视频和语音的一个最重要的要求是数据持续高速传输。实时视频和语音应用能够容忍具有极小或没有明显影响的一些数据丢失，非常适合于 UDP。</p><p>UDP 中的通信块称为数据报或数据段。这些数据报通过传输层协议尽力传送。</p><p>UDP报头比TCP报头简单得多，因为它只有四个字段，需要8个字节(即64位)。该图显示的是 UDP 报头中的字段。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.11.png"></p><h2 id="3-3、UDP报头字段"><a href="#3-3、UDP报头字段" class="headerlink" title="3.3、UDP报头字段"></a>3.3、UDP报头字段</h2><p>该表标识并描述了 UDP 报头中的四个字段。</p><table><thead><tr><th align="left"><strong>UDP 报头字段</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>源端口</strong></td><td align="left">一个16位字段,用于通过端口号标识源应用程序。</td></tr><tr><td align="left"><strong>目的端口</strong></td><td align="left">一个16位字段,用于通过端口号标识目的应用 程序。</td></tr><tr><td align="left"><strong>长度</strong></td><td align="left">一个16位字段,指示UDP数据报报头的长度。</td></tr><tr><td align="left"><strong>校验和</strong></td><td align="left">一个16位字段,用于数据报报头和数据的错误检查。</td></tr></tbody></table><h2 id="3-4、使用UDP的应用程序"><a href="#3-4、使用UDP的应用程序" class="headerlink" title="3.4、使用UDP的应用程序"></a>3.4、使用UDP的应用程序</h2><p>最适合采用 UDP 协议的三种应用程序包括：</p><ul><li><strong>实时视频和多媒体应用程序</strong> - 这些应用可以容忍部分数据丢失但要求延迟极小或没有延迟的应用程序。示例包括 VoIP 和实时流传输视频。</li><li><strong>简单请求和应答应用程序</strong> - 处理简单事务的应用程序，其中主机发送请求，但不一定收到应答。示例包括 DNS 和 DHCP。</li><li><strong>处理可靠性的应用程序</strong> - 不要求进行流量控制、错误检测、确认和错误恢复，或这些功能由应用程序来执行的单向通信。示例包括 SNMP 和 TFTP。</li></ul><p>该图标识了需要 UDP 的应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.12.png"></p><p>虽然 DNS 和 SNMP 默认使用 UDP，但它们都可以使用 TCP。如果 DNS 请求或 DNS 响应大于 512 字节，DNS 会使用 TCP，例如 DNS 响应包含许多域名解析时。同样，在某些情况下，网络管理员可以配置 SNMP 使用 TCP。</p><h1 id="4、端口号"><a href="#4、端口号" class="headerlink" title="4、端口号"></a>4、端口号</h1><h2 id="4-1、多个单独的通信"><a href="#4-1、多个单独的通信" class="headerlink" title="4.1、多个单独的通信"></a>4.1、多个单独的通信</h2><p>如您所知，在某些情况下TCP是适合该作业的协议，在其他情况下则应使用UDP。无论传输何种类型的数据，TCP和UDP都使用端口号。</p><p>TCP 和 UDP 传输层协议使用端口号来管理多个同时的对话。如图所示，TCP和UDP报头字段标识源和目的应用程序端口号。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.13.png"></p><p>源端口号与本地主机上的原始应用程序相关联，而目的端口号与远程主机上的目的应用程序相关联。</p><p>例如，假设一台主机正在向 Web 服务器发起网页请求。当主机发起网页请求时，主机会动态生成源端口号，以惟一地标识会话。由主机生成的每个请求将使用不同的动态创建的源端口号。这就使多个会话能够同时发生。</p><p>在请求中，目的端口号是标识目的Web服务器正在被请求的服务类型的端口号。例如，当客户端在目的端口中指定端口 80 时，接收该消息的服务器就知道请求的是 Web 服务。</p><p>服务器可同时提供多个服务，例如在端口 80 上提供 Web 服务，并同时在端口 21 上提供建立文件传输协议 (FTP) 连接的服务。</p><h2 id="4-2、套接字对"><a href="#4-2、套接字对" class="headerlink" title="4.2、套接字对"></a>4.2、套接字对</h2><p>源端口和目的端口都被置入分段内，然后分段封装于 IP 数据包内。IP 数据包中含有源 IP 地址和目的 IP 地址。源 IP 地址和源端口号的组合或者目的 IP 地址和目的端口号的组合，称为套接字。</p><p>在图中的示例中，PC 同时从目标服务器请求 FTP 和 Web 服务。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.14.png"></p><p>在该示例中，PC生成的FTP请求包括第2层MAC地址和第3层IP地址。请求还标识了源端口号 1305（即，由主机动态生成）和标识了FTP服务的目的端口21。主机还使用相同的第 2 层和第 3 层地址从服务器请求了一个网页。但是，它使用的是源端口号 1099（即，由主机动态生成）和标识了Web服务的目的端口80。</p><p>套接字用于标识客户端所请求的服务器和服务。客户端套接字可能如下所示，其中 1099 代表源端口号：192.168.1.5:1099</p><p>Web 服务器上的套接字则可能是192.168.1.7:80</p><p>这两个套接字组合在一起形成一个套接字对：192.168.1.5:1099，192.168.1.7:80</p><p>有了套接字，一台客户端上运行的多个进程便可彼此区分，它们与同一服务器进程建立的多个连接也可以彼此区分。</p><p>对于请求数据的应用而言，该源端口号就像是一个返回地址。传输层将跟踪此端口和发出该请求的应用，当返回响应时，传输层可以将其转发到正确的应用。</p><h2 id="4-3、端口号组"><a href="#4-3、端口号组" class="headerlink" title="4.3、端口号组"></a>4.3、端口号组</h2><p>互联网编号指派机构 (IANA) 是负责分配各种编址标准（包括端口号）的标准组织。用于标识源端口号和目的端口号的16位二进制提供了从0到65535的端口范围。</p><p>IANA 已将号码范围划分为以下三个端口组。</p><table><thead><tr><th align="left"><strong>端口组</strong></th><th align="left"><strong>号码范围</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>公认端口</strong></td><td align="left"><strong>0到1023</strong></td><td align="left">这些端口号保留用于常见或流行的服务和应用程序, 例如 Web浏览器, 电子邮件客户端和远程访问 客户端。为常用的服务器应用程序定义的公认端口使 客户端能够轻松识别所需的关联服务。</td></tr><tr><td align="left"><strong>注册端口</strong></td><td align="left"><strong>1024到49151</strong></td><td align="left">IANA将这些端口号分配给请求实体, 以用于特定的进程或应用程序。这些进程主要是用户选择安装的单个 应用程序, 而不是使用公认端口号的 常见应用程序。例如, 思科已为其RADIUS服务器身份验证进程 注册了端口1812。</td></tr><tr><td align="left"><strong>私有</strong> 和(或) <strong>动态端口</strong></td><td align="left"><strong>49152 到 65535</strong></td><td align="left">这些端口也称为 <em>临时端口</em>。客户端的操作系统通常在 发起与服务的连接时动态分配端口号。之后即可在通信过程中使用动态端口识别客户端 应用程序。</td></tr></tbody></table><p><strong>注意</strong>: 一些客户端操作系统在分配源端口时可能使用注册端口号而不是动态端口号。</p><p>该表显示了一些常用的公认端口号及其相关应用程序。</p><p><strong>Well-Known Port Numbers</strong></p><table><thead><tr><th align="left"><strong>端口号</strong></th><th align="left"><strong>协议</strong></th><th align="left"><strong>应用层</strong></th></tr></thead><tbody><tr><td align="left"><strong>20</strong></td><td align="left">TCP</td><td align="left">文件传输协议 (FTP) - 数据</td></tr><tr><td align="left"><strong>21</strong></td><td align="left">TCP</td><td align="left">文件传输协议 (FTP) - 控制</td></tr><tr><td align="left"><strong>22</strong></td><td align="left">TCP</td><td align="left">安全 Shell (SSH)</td></tr><tr><td align="left"><strong>23</strong></td><td align="left">TCP</td><td align="left">Telnet</td></tr><tr><td align="left"><strong>25</strong></td><td align="left">TCP</td><td align="left">简单邮件传输协议 (SMTP)</td></tr><tr><td align="left"><strong>53</strong></td><td align="left">UDP、TCP</td><td align="left">域名服务 (DNS)</td></tr><tr><td align="left"><strong>67</strong></td><td align="left">UDP</td><td align="left">动态主机配置协议 (DHCP)- 服务器</td></tr><tr><td align="left"><strong>68</strong></td><td align="left">UDP</td><td align="left">动态主机配置协议-客户端</td></tr><tr><td align="left"><strong>69</strong></td><td align="left">UDP</td><td align="left">简单文件传输协议 (TFTP)</td></tr><tr><td align="left"><strong>80</strong></td><td align="left">TCP</td><td align="left">超文本传输协议 (HTTP)</td></tr><tr><td align="left"><strong>110</strong></td><td align="left">TCP</td><td align="left">邮局协议第 3 版 (POP3)</td></tr><tr><td align="left"><strong>143</strong></td><td align="left">TCP</td><td align="left">互联网消息访问协议 (IMAP)</td></tr><tr><td align="left"><strong>161</strong></td><td align="left">UDP</td><td align="left">简单网络管理协议 (SNMP)</td></tr><tr><td align="left"><strong>443</strong></td><td align="left">TCP</td><td align="left">安全超文本传输协议 (HTTPS)</td></tr></tbody></table><p>一些应用程序可能既使用 TCP，又使用 UDP。例如，当客户端向 DNS 服务器发送请求时，DNS 使用 UDP。但是，两台 DNS 服务器之间的通信始终使用 TCP。</p><p>在IANA网站上搜索端口注册表，来查看端口号及相关应用的完整列表。</p><h2 id="4-4、netstat-命令"><a href="#4-4、netstat-命令" class="headerlink" title="4.4、netstat 命令"></a>4.4、netstat 命令</h2><p>不明的 TCP 连接可能造成重大的安全威胁。因为此类连接表示某程序或某人正连接到本地主机。有些时候，需要了解联网主机中启用并运行了哪些活动 TCP 连接。Netstat 是一种重要的网络实用程序，可用来检验此类连接。如下所示，输入命令 <strong>netstat</strong>可列出正在使用的协议、本地地址和端口号、外部地址和端口号以及连接的状态。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\&gt; netstatActive Connections  Proto  Local Address          Foreign Address            State  TCP    192.168.1.124:3126     192.168.0.2:netbios-ssn    ESTABLISHED  TCP    192.168.1.124:3158     207.138.126.152:http       ESTABLISHED  TCP    192.168.1.124:3159     207.138.126.169:http       ESTABLISHED  TCP    192.168.1.124:3160     207.138.126.169:http       ESTABLISHED  TCP    192.168.1.124:3161     sc.msn.com:http            ESTABLISHED  TCP    192.168.1.124:3166     www.cisco.com:http         ESTABLISHED(output omitted)C:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，<strong>netstat</strong>命令会试图将 IP 地址解析为域名，将端口号解析为公认应用程序。使用**-n**选项能够以数字形式显示 IP 地址和端口号。</p><h1 id="5、TCP通信过程"><a href="#5、TCP通信过程" class="headerlink" title="5、TCP通信过程"></a>5、TCP通信过程</h1><h2 id="5-1、TCP服务器进程"><a href="#5-1、TCP服务器进程" class="headerlink" title="5.1、TCP服务器进程"></a>5.1、TCP服务器进程</h2><p>您已经了解了 TCP 的基础知识。了解端口号的作用将帮助您掌握TCP通信过程的细节。在本主题中，您还将了解TCP三次握手和会话终止的过程。</p><p>在服务器上运行的每个应用程序进程都配置为使用一个端口号。端口号由系统管理员自动分配或手动配置。</p><p>在同一传输层服务中，单个服务器上不能同时存在具有相同端口号的两个不同服务。例如，主机同时运行 Web 服务器应用程序和文件传输应用程序时，不能为两个应用程序配置相同的端口（如 TCP 端口 80）。</p><p>分配有特定端口的活动服务器应用程序被认为是开放的，也就是说，传输层将接受并处理分配到该端口的数据段。所有发送到正确套接字地址的传入客户端请求都将被接受，数据将被传送到服务器应用。在同一服务器上可以同时开启很多端口，每个端口对应一个动态服务器应用。</p><h3 id="发送TCP请求的客户端"><a href="#发送TCP请求的客户端" class="headerlink" title="发送TCP请求的客户端"></a>发送TCP请求的客户端</h3><p>客户端 1 正在请求 Web 服务，客户端 2 正在使用公认端口（即 Web 服务 = 端口 80，电子邮件服务 = 端口 25）请求电子邮件服务。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.15.png"></p><h3 id="请求的目的端口"><a href="#请求的目的端口" class="headerlink" title="请求的目的端口"></a>请求的目的端口</h3><p>请求动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.16.png"></p><h3 id="请求的源端口"><a href="#请求的源端口" class="headerlink" title="请求的源端口"></a>请求的源端口</h3><p>当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.17.png"></p><h3 id="响应的目的端口"><a href="#响应的目的端口" class="headerlink" title="响应的目的端口"></a>响应的目的端口</h3><p>注意，服务器对web请求的响应现在具有目的端口49152，而电子邮件的响应现在具有目的端口51152。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.18.png"></p><h3 id="响应的源端口"><a href="#响应的源端口" class="headerlink" title="响应的源端口"></a>响应的源端口</h3><p>服务器响应中的源端口是发起请求中的原始目的端口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.19.png"></p><h2 id="5-2、TCP连接的建立"><a href="#5-2、TCP连接的建立" class="headerlink" title="5.2、TCP连接的建立"></a>5.2、TCP连接的建立</h2><p>在一些文化中，两个人见面时常常通过握手来问好。双方都把握手的行为理解为友好问候的信号。网络中的连接是类似的。在 TCP 连接中，主机客户端使用三次握手过程与服务器建立连接。</p><h3 id="第一步SYN"><a href="#第一步SYN" class="headerlink" title="第一步SYN"></a>第一步SYN</h3><p>源客户端请求与服务器进行客户端-服务器通信会话。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.20.png"></p><h3 id="第二步ACK和SYN"><a href="#第二步ACK和SYN" class="headerlink" title="第二步ACK和SYN"></a>第二步ACK和SYN</h3><p>服务器确认客户端-服务器通信会话，并请求服务器-客户端通信会话。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.21.png"></p><h3 id="第三步ACK"><a href="#第三步ACK" class="headerlink" title="第三步ACK"></a>第三步ACK</h3><p>源客户端确认服务器-客户端通信会话。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.22.png"></p><p>三次握手验证目标主机是否可用来通信。在示例中，主机 A验证了主机 B可用。</p><h2 id="5-3、会话终止"><a href="#5-3、会话终止" class="headerlink" title="5.3、会话终止"></a>5.3、会话终止</h2><p>若要关闭连接，分段报头必须设置完成 (FIN) 控制标志。为终止每个单向 TCP 会话，需采用包含 FIN 分段和确认 (ACK) 分段的二次握手。因此，若要终止 TCP 支持的整个会话过程，需要实施四次交换，以终止两个双向会话。客户端或服务器都可以发起终止。</p><p>在本示例中，为了更容易理解，采用了客户端和服务器这两个术语进行说明。实际上，终止的过程可以由任意两台具有开放会话的主机发起。</p><h3 id="第1步FIN"><a href="#第1步FIN" class="headerlink" title="第1步FIN"></a>第1步FIN</h3><p>当客户端的数据流中没有其他要发送的数据时，它将发送带 FIN 标志设置的分段。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.23.png"></p><h3 id="第2步ACK"><a href="#第2步ACK" class="headerlink" title="第2步ACK"></a>第2步ACK</h3><p>服务器发送 ACK 信息，确认收到从客户端发出的请求终止会话的 FIN 信息。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.24.png"></p><h3 id="第3步FIN"><a href="#第3步FIN" class="headerlink" title="第3步FIN"></a>第3步FIN</h3><p>服务器向客户端发送FIN消息，终止从服务端到客户端的对话</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.25.png"></p><h3 id="第4步ACK"><a href="#第4步ACK" class="headerlink" title="第4步ACK"></a>第4步ACK</h3><p>客户端发送 ACK 响应信息，确认收到从服务器发出的 FIN 信息。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.26.png"></p><p>当所有数据段得到确认后，会话关闭。</p><h2 id="5-4、TCP三次握手分析"><a href="#5-4、TCP三次握手分析" class="headerlink" title="5.4、TCP三次握手分析"></a>5.4、TCP三次握手分析</h2><p>主机维护状态，跟踪会话过程中的每个分段，并使用 TCP 报头信息交换已接收数据的相关信息。TCP 是全双工协议，每个连接都代表两个单向通信会话。若要建立连接，主机应执行三次握手。如图所示，TCP 报头中的控制位指出了连接的进度和状态。</p><p>这些是三次握手的功能：</p><ul><li>确认目的设备存在于网络上。</li><li>确认目的设备有活动的服务，并且正在源客户端要使用的目的端口号上接受请求。</li><li>通知目的设备源客户端想要在该端口号上建立通信会话。</li></ul><p>通信完成后，将关闭会话并终止连接。连接和会话机制保障了 TCP 的可靠性功能。</p><p><strong>控制位字段</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.27.png"></p><p>TCP 分段报头的控制位字段中的六位被称为标志。标志是设置为开启或关闭的位。</p><p>六个控制位标志如下：</p><ul><li><strong>URG</strong> - 紧急指针字段（重要）</li><li><strong>ACK</strong> -用于建立连接和会话终止的确认标志</li><li><strong>PSH</strong> - 推送功能</li><li><strong>RST</strong> 在出现错误或超时时重置连接</li><li><strong>SYN</strong> -同步建立连接中使用的序列号</li><li><strong>FIN</strong> -没有更多来自发送方的数据，并用于会话终止</li></ul><p>搜索互联网以了解 PSH 和 URG 标志的详细信息。</p><h2 id="5-5、视频-TCP三次握手"><a href="#5-5、视频-TCP三次握手" class="headerlink" title="5.5、视频-TCP三次握手"></a>5.5、视频-TCP三次握手</h2><p>略</p><h1 id="6、可靠性和流控制"><a href="#6、可靠性和流控制" class="headerlink" title="6、可靠性和流控制"></a>6、可靠性和流控制</h1><h2 id="6-1、TCP可靠性-保证及按序传递"><a href="#6-1、TCP可靠性-保证及按序传递" class="headerlink" title="6.1、TCP可靠性-保证及按序传递"></a>6.1、TCP可靠性-保证及按序传递</h2><p>对某些应用程序来说，TCP更好，原因是，与 UDP 不同，它重新发送丢弃的数据包以及对数据包进行编号，以便在传递前指示其正确的顺序。TCP 还可以帮助维护数据包的流量，以避免设备过载。本主题详细介绍 TCP 的这些功能。</p><p>有时可能TCP数据段没有到达目的地。有时，TCP段可能会无序到达。因此，为了让接收方理解原始消息，必须接收所有数据，并重组这些数据段，使其恢复原有顺序。每个数据包中的数据段报头中都含有序列号，便于进行数据重组。序列号代表 TCP 分段的第一个数据字节在完整数据中的位置。</p><p>在会话建立过程中，将设置初始序列号 (ISN)。此 ISN 表示传输到接收应用的字节起始值。在会话过程中，每传送一定字节的数据，序列号就随之增加。通过这样的数据字节跟踪，可以唯一标识并确认每个分段，还可以标识丢失的分段。</p><p>ISN 并不是从 1 开始，而是随机的数字。这样做的目的是防止某些类型的恶意攻击。为简单起见，本章的示例中我们将使用 1 作为 ISN。</p><p>如图所示，数据段的序列号用于指示如何重组和重新排序收到的数据段。</p><p><strong>在目的设备上对TCP数据段进行重新排序</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.28.png"></p><p>接收方的 TCP 进程将数据段中的数据存入缓存区，然后数据段按照正确的序列顺序进行排列，重组后发送到应用层。对于序列号混乱的分段，将被保留以备后期处理。等缺失的分段到达后，再来按顺序处理这些分段。</p><h2 id="6-2、视频-TCP可靠性-序列号和确认"><a href="#6-2、视频-TCP可靠性-序列号和确认" class="headerlink" title="6.2、视频-TCP可靠性-序列号和确认"></a>6.2、视频-TCP可靠性-序列号和确认</h2><p>TCP 的其中一项功能是确保每个数据段都能到达目的地。在目的主机上的 TCP 服务确认该源应用收到的数据。</p><p>视频略</p><h2 id="6-3、TCP可靠性-数据丢失和重传"><a href="#6-3、TCP可靠性-数据丢失和重传" class="headerlink" title="6.3、TCP可靠性-数据丢失和重传"></a>6.3、TCP可靠性-数据丢失和重传</h2><p>无论网络设计得有多好，数据丢失还是时有发生。TCP 提供了管理数据段丢失的方法。其中一个方法就是重新传输未确认的数据。</p><p>序列 (SEQ) 号和确认 (ACK) 号一起使用，以确认接收传输段中包含的数据字节。SEQ 编号标识正在传输的数据段中的第一个字节。TCP 使用发送回源代码的 ACK 编号来指示接收方希望接收的下一个字节。这称为<strong>期望确认</strong>。</p><p>在进行后续增强之前，TCP只能确认预期的下一个字节。例如，在图中，为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B将应答并确认指定下一个预期的数据段是段3。主机A不知道其他数据段是否到达。因此，主机A将重新发送段3到段10。如果所有重新发送的数据段都成功到达，则段 5 到 段10 将是重复的。这会导致延迟、拥塞和效率低下。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.29.png"></p><p>今天的主机操作系统通常采用一种称为选择性确认 (SAK) 的可选 TCP 功能，在三次握手期间协商。如果两个主机都支持SACK，则接收方可以明确地确认接收了哪些数据段(字节)，包括任何不连续的段。因此，发送主机只需要重新传输丢失的数据。例如，在下图中，还是为简单起见，主机A使用数据段号向主机B发送段1到10。如果除段3和段4之外的所有数据段都已到达，主机B可以确认它已经接收了段1和段2 (ACK 3)，并有选择地确认段5到10 (SACK 5-10)。主机A只需要重新发送段3和段4。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.30.png"></p><p><strong>注意</strong>：TCP通常会为每个其他数据包发送ACK，但是超出本主题范围的其他因素可能会改变这种行为。</p><p>TCP使用计时器来知道在重新发送一个数据段之前需要等待多长时间。</p><h2 id="6-4、视频-TCP可靠性-数据丢失和重传"><a href="#6-4、视频-TCP可靠性-数据丢失和重传" class="headerlink" title="6.4、视频-TCP可靠性-数据丢失和重传"></a>6.4、视频-TCP可靠性-数据丢失和重传</h2><p>略</p><h2 id="6-5、TCP流量控制-窗口大小和确认"><a href="#6-5、TCP流量控制-窗口大小和确认" class="headerlink" title="6.5、TCP流量控制-窗口大小和确认"></a>6.5、TCP流量控制-窗口大小和确认</h2><p>TCP 还提供了流量控制机制。流量控制即目的主机能够可靠地接收并处理的数据量。流量控制可以调整给定会话中源和目的地之间的数据流速，有助于保持 TCP 传输的可靠性。为此，TCP 报头包括一个称为“窗口大小”的 16 位字段。</p><p>图中显示了一个窗口大小和确认的示例。</p><p><strong>TCP窗口大小示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.31.png"></p><p>窗口大小用于确定在获得确认前可以发送的字节数。确认号是指下一个预期字节的编号。</p><p>窗口大小是 TCP 会话的目的设备一次可以接受和处理的字节数。在本例中，PC B 用于 TCP 会话的初始窗口大小为 10000 字节。从第 1 个字节开始，字节数为 1，PC A 在不收到确认的前提下可以发送的最后一个字节为 10,000。这被称为PC A的发送窗口。每个 TCP 分段均包含窗口大小，那样目的设备可以根据缓冲区的可用性随时修改窗口大小。</p><p>初始窗口大小在三次握手期间建立 TCP 会话时确定。源设备必须根据目的设备的窗口大小限制发送到目的设备的字节数。只有源设备收到字节数已接收的确认之后，才能继续发送更多会话数据。通常情况下，目的设备不会等待其窗口大小的所有字节接收后才以确认应答。接收和处理字节时，目的设备就会发送确认，以告知源设备它可以继续发送更多字节。</p><p>例如，通常情况下，PC B 不会等待所有 10,000 字节都接收后才发送确认。这就意味着 PC A 可以在收到 PC B 的确认时调整其发送窗口。如图所示，当 PC A 收到确认号为 2,921 的确认消息时，它即是下一个预期的字节的编号。PC A 发送窗口将增加 2920 字节。这会将发送窗口从 10000 字节更改为 12920。现在只要 PC A 发送不超出其新的发送窗口 12920 的字节数，它就能够向 PC B 另外发送 10000 字节。</p><p>目的设备在处理接收的字节时发送确认并不断调整源设备的发送窗口大小被称为滑动窗口。在上一个示例中，PC A 的发送窗口会增加或滑动了 2921 个字节，从 10000 增到 12920。</p><p>如果目的设备缓冲区空间的可用性减小，它可以缩减窗口大小，通知源设备减少发送的字节数，而不需要接收确认。</p><p><strong>注意</strong>：设备如今使用滑动窗口协议。接收方通常在每收到两个数据段之后发送确认。在确认之前收到的数据段的数量可能有所不同。滑动窗口的优势在于，只要接收方确认之前的数据段，就可以让发送方持续传输数据段。滑动窗口的详细信息不在本课程的讨论范围之内。</p><h2 id="6-6、TCP流量控制-最大段大小（MSS）"><a href="#6-6、TCP流量控制-最大段大小（MSS）" class="headerlink" title="6.6、TCP流量控制-最大段大小（MSS）"></a>6.6、TCP流量控制-最大段大小（MSS）</h2><p>如图所示，在每个TCP数据段内，源主机正在传输 1460 字节的数据。这通常是目的设备可接收的最大段大小 (MSS)。MSS 是 TCP 报头中选项字段的一部分，用于指定设备可以在单个 TCP数据段中接收的最大数据量（以字节为单位）。MSS 大小不包括 TCP 报头。MSS 通常包括在三次握手过程中。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.32.png"></p><p>使用 IPv4 时，常见的 MSS 为 1460 字节。主机会从以太网最大传输单位 (MTU) 中减去 IP 和 TCP 报头，从而确定其 MSS 字段的值。在以太网接口上，默认 MTU 为 1500 个字节。减去 20 个字节的 IPv4 报头和 20 个字节的 TCP 报头，默认 MSS 大小为 1460 个字节，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.33.png"></p><h2 id="6-7、TCP流量控制-避免堵塞"><a href="#6-7、TCP流量控制-避免堵塞" class="headerlink" title="6.7、TCP流量控制-避免堵塞"></a>6.7、TCP流量控制-避免堵塞</h2><p>网络中出现拥塞会使过载的路由器丢弃数据包。当包含 TCP 数据段的数据包未到达其目的地时，它们就成为未确认的数据包。通过确定 TCP 数据段发送但未确认的速率，源设备可以假设一定程度的网络拥塞。</p><p>出现网络拥塞时，从源设备丢失的 TCP 数据段就会重传。如果不适当控制重传，TCP 数据段的额外重传会使拥塞的情况更糟。网络中不仅有 TCP 数据段的新数据包，而且还有重传丢失的 TCP 数据段的反馈效果，这都增加了拥塞。为避免和控制拥塞，TCP 使用了多个拥塞处理机制、计时器和算法。</p><p>如果源设备确定 TCP 数据段没有被确认或没有被及时确认，它会在收到确认之前减少发送的字节数。如图所示，PC A 感知到存在拥塞，因此，在收到PC B的确认之前减少了它发送的字节数。</p><p><strong>TCP拥塞控制</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.34.png"></p><p>确认号是下一个预期字节的编号，而不是数据段的编号。简化使用的数据段号用作说明。</p><p>注意是源设备在减少其发送的未确认的字节数，而不是由目的设备来确定窗口大小。</p><p><strong>注意：</strong>实际拥塞处理机制、计时器和算法的解释不属于本课程的范围。</p><h1 id="7、UDP通信"><a href="#7、UDP通信" class="headerlink" title="7、UDP通信"></a>7、UDP通信</h1><h2 id="7-1、UDP低开销与可靠性"><a href="#7-1、UDP低开销与可靠性" class="headerlink" title="7.1、UDP低开销与可靠性"></a>7.1、UDP低开销与可靠性</h2><p>如前所述，UDP非常适合需要快速通信的场合，比如VoIP。本主题详细解释为什么 UDP 非常适合某些类型的传输。如图所示，UDP 不建立连接。因为 UDP 的数据报头较小而且没有网络管理流量，因此可以提供低开销数据传输。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.35.png"></p><h2 id="7-2、UDP数据报重组"><a href="#7-2、UDP数据报重组" class="headerlink" title="7.2、UDP数据报重组"></a>7.2、UDP数据报重组</h2><p>与 TCP分段类似，当将多个 UDP 数据报发送到目的主机时，它们通常采用不同的路径，到达顺序也可能跟发送时的顺序不同。与 TCP 不同，UDP 不跟踪序列号。如图所示，UDP 不会按传输顺序重新排列数据报。</p><p>因此，UDP 仅仅是将接收到的数据按照先来后到的顺序转发到应用程序。如果数据顺序对应用程序很重要，应用程序必须确定正确的顺序并决定如何处理数据。</p><p><strong>UDP：无连接和不可靠</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.36.png"></p><h2 id="7-3、UDP服务器进程与请求"><a href="#7-3、UDP服务器进程与请求" class="headerlink" title="7.3、UDP服务器进程与请求"></a>7.3、UDP服务器进程与请求</h2><p>如图所示，与基于 TCP 的应用程序相同的是，基于 UDP 的服务器应用程序也被分配了公认端口号或注册端口号。当上述应用或进程在服务器上运行时，它们就会接受与所分配端口号相匹配的数据。当 UDP 收到用于某个端口的数据报时，它就会按照应用的端口号将数据发送到相应的应用。</p><p><strong>UDP服务器侦听请求</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.37.png"></p><p><strong>注意:</strong> 图中所示的远程认证拨号用户服务 (RADIUS) 服务器通过提供认证、授权和审计服务，来管理用户访问。RADIUS 的操作不属于本课程的范围。</p><h2 id="7-4、UDP客户端进程"><a href="#7-4、UDP客户端进程" class="headerlink" title="7.4、UDP客户端进程"></a>7.4、UDP客户端进程</h2><p>与 TCP 一样，客户端应用向服务器进程请求数据，便会发起客户端-服务器通信。UDP 客户端进程则是从可用端口号中动态挑选一个端口号，用来作为会话的源端口。而目的端口通常都是分配到服务器进程的公认端口号或注册端口号。</p><p>客户端选定了源端口和目的端口后，通信事务中的所有数据报头都采用相同的端口对。对于从服务器到达客户端的数据来说，数据报头所含的源端口号和目的端口号作了互换。</p><h3 id="发送UDP请求的客户端"><a href="#发送UDP请求的客户端" class="headerlink" title="发送UDP请求的客户端"></a>发送UDP请求的客户端</h3><p>客户端1使用公认端口53发送DNS请求，而客户端2使用注册端口1812请求RADIUS身份验证服务。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.38.png"></p><h3 id="UDP请求的目的端口"><a href="#UDP请求的目的端口" class="headerlink" title="UDP请求的目的端口"></a>UDP请求的目的端口</h3><p>客户端的请求会动态生成源端口号。在这种情况下，客户端 1 使用源端口 49152，客户端 2 使用源端口 51152。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.39.png"></p><h3 id="UDP请求源端口"><a href="#UDP请求源端口" class="headerlink" title="UDP请求源端口"></a>UDP请求源端口</h3><p>当服务器响应客户端请求时，它会反转发起请求的目的端口和源端口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.40.png"></p><h3 id="UDP响应目的端口"><a href="#UDP响应目的端口" class="headerlink" title="UDP响应目的端口"></a>UDP响应目的端口</h3><p>在服务器中，对DNS请求的响应目的端口现在是49152，而RADIUS身份验证的响应目的端口现在是51152。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.41.png"></p><h3 id="UDP响应源端口"><a href="#UDP响应源端口" class="headerlink" title="UDP响应源端口"></a>UDP响应源端口</h3><p>服务器响应中的源端口是发起请求中的原始目的端口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN14.42.png"></p><h1 id="8、单元检测"><a href="#8、单元检测" class="headerlink" title="8、单元检测"></a>8、单元检测</h1><p>1、在TCP通信中使用源端口号的目的是<strong>跟踪设备之间的多个会话</strong></p><p>2、传输层协议的职责：</p><p><strong>跟踪各个会话，数据分段和数据段重组，标识应用</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 tcp/ip udp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十二）</title>
      <link href="/2021/120157163.html"/>
      <url>/2021/120157163.html</url>
      
        <content type="html"><![CDATA[<h1 id="十二、IPv6编址"><a href="#十二、IPv6编址" class="headerlink" title="十二、IPv6编址"></a>十二、IPv6编址</h1><p><strong>模块目标</strong>: 实施 IPv6 编址方案。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>IPv4 的问题</strong></td><td align="left">说明 IPv6 编址的必要性。</td></tr><tr><td align="left"><strong>IPv6 地址表示方法</strong></td><td align="left">说明 IPv6 地址的表示方式。</td></tr><tr><td align="left"><strong>IPv6 地址类型</strong></td><td align="left">比较不同类型的 IPv6 网络地址。</td></tr><tr><td align="left"><strong>GUA 和 LLA 静态配置</strong></td><td align="left">说明如何配置静态全局单播和链路本地 IPv6 网络地址。</td></tr><tr><td align="left"><strong>IPv6 GUA的动态编址</strong></td><td align="left">说明如何动态配置全局单播地址。</td></tr><tr><td align="left"><strong>IPv6 LLA的动态编址</strong></td><td align="left">动态配置链路本地地址。</td></tr><tr><td align="left"><strong>IPv6 组播地址</strong></td><td align="left">识别 IPv6 地址</td></tr><tr><td align="left"><strong>IPv6 网络的子网划分</strong></td><td align="left">实施子网划分 IPv6编址方案</td></tr></tbody></table><h1 id="1、IPv4的问题"><a href="#1、IPv4的问题" class="headerlink" title="1、IPv4的问题"></a>1、IPv4的问题</h1><h2 id="1-1、IPv6的必要性"><a href="#1-1、IPv6的必要性" class="headerlink" title="1.1、IPv6的必要性"></a>1.1、IPv6的必要性</h2><p>您已经知道IPv4的地址用完了。这就是为什么您需要了解 IPv6 的原因。</p><p>IPv6 旨在接替 IPv4。IPv6 拥有更大的 128 位地址空间，提供 340 涧（即，340后面有36个0）个不确定地址。不过，IPv6 不只是具有更大的地址空间。</p><p>当 IEFT 开始开发 IPv4 的接替版本时，还借此机会修复了 IPv4 的限制，并开发了增强功能。一个示例是 Internet 控制消息协议第 6 版 (ICMPv6)，它包括 IPv4 的 ICMP (ICMPv4) 中没有的地址解析和地址自动配置功能。</p><p>IPv4 地址空间耗尽一直是迁移到 IPv6 的动因。随着非洲、亚洲和世界其他地区越来越多地使用互联网，IPv4 地址已经无法满足这一增长需求。</p><p>理论上，IPv4 最多有 43 亿个地址。私有地址与网络地址转换 (NAT) 对于放缓 IPv4 地址空间的耗尽起了不可或缺的作用。然而，NAT对于许多应用程序来说是有问题的，它会造成延迟，并且有严重阻碍对等体对对等体通信的限制。</p><p>随着移动设备数量的不断增加，移动供应商一直在引领着向IPv6的过渡。美国最大的两家移动运营商报告称，他们超过90%的流量都在IPv6之上。</p><p>大多数顶级ISP和内容提供商，如YouTube、Facebook和NetFlix，也已经完成了过渡。许多公司，如微软、Facebook和LinkedIn，都在向内部只允许使用ipv6过渡。2018年，宽带ISP Comcast报告部署超过65%，英国天空广播报告超过86%。</p><p><strong>物联网</strong></p><p>当今的互联网与过去几十年相比大有不同。当今的互联网不仅仅是邮件、网页和计算机之间的文件传输。互联网正在不断向物联网 (IoT) 发展。能够访问互联网的设备将不仅仅只有计算机、平板电脑和智能手机。未来安装有传感器并支持互联网访问的设备将包括汽车、生物化学设备和家用电器以及自然生态系统等一切事物。</p><p>考虑到互联网用户的不断增加、有限的 IPv4 地址空间、NAT 问题和物联网等问题，是时候开始向 IPv6 过渡了。</p><h2 id="1-2、IPv4和IPv6并存"><a href="#1-2、IPv4和IPv6并存" class="headerlink" title="1.2、IPv4和IPv6并存"></a>1.2、IPv4和IPv6并存</h2><p>过渡到 IPv6 不是一朝一夕可以完成的。在不久的将来，IPv4和IPv6都将共存，并且过渡将需要几年的时间。IETF 已经创建了各种协议和工具来协助网络管理员将网络迁移到 IPv6。迁移技术可分为三类：</p><h3 id="双堆栈"><a href="#双堆栈" class="headerlink" title="双堆栈"></a>双堆栈</h3><p>双堆栈允许 IPv4 和 IPv6 在同一网段上共存。双堆栈设备同时运行 IPv4 和 IPv6 协议栈。称为原生 IPv6，这意味着客户网络与他们的ISP建立了IPv6连接，并能够通过IPv6访问互联网上的内容。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.1.png"></p><h3 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h3><p>隧道是一种通过 IPv4 网络传输 IPv6 数据包的方法。IPv6 数据包与其他类型数据类似，也封装在 IPv4 数据包中。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.2.png"></p><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>网络地址转换 64 (NAT64) 允许支持 IPv6 的设备与支持 IPv4 的设备使用类似于 IPv4 中 NAT 的转换技术进行通信。IPv6 数据包被转换为 IPv4 数据包，IPv4 数据包被转换为 IPv6 数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.3.jpg"></p><p><strong>注意:</strong> 隧道和转换用于过渡到原生IPv6，仅应在需要时使用。目标是从源到目的地进行本地 IPv6 通信。</p><h1 id="2、IPv6地址表示方法"><a href="#2、IPv6地址表示方法" class="headerlink" title="2、IPv6地址表示方法"></a>2、IPv6地址表示方法</h1><h2 id="2-1、IPv6编址格式"><a href="#2-1、IPv6编址格式" class="headerlink" title="2.1、IPv6编址格式"></a>2.1、IPv6编址格式</h2><p>学习网络中的IPv6的第一步是理解IPv6地址的编写和格式化方式。IPv6 地址比 IPv4 地址多得多，这就是为什么我们不太可能用完它们。</p><p>IPv6 地址长度为 128 位，写作十六进制值字符串。如图所示，每 4 位以一个十六进制数字表示，共 32 个十六进制值。IPv6 地址不区分大小写，可用大写或小写书写。</p><p><strong>16位数据段或十六进制数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.4.jpg"></p><p><strong>首选格式</strong></p><p>前面的图也显示了，书写 IPv6 地址的首选格式为 x：x：x：x：x：x：x：x，每个“x”均包括四个十六进制值。术语“八位组”是指 IPv4 地址的八位。在 IPv6 中，十六位位组是指代 16 位二进制或四位十六进制数的非官方术语。每个“x”是一个16 位二进制数或四位十六进制数字组成的十六进制数。</p><p>首选格式表示使用所有 32 个十六进制数字书写 IPv6 地址。这并不意味着它是表示 IPv6 地址的理想方法。在本模块中，您将了解到有两条规则可帮助减少表示一个 IPv6 地址所需数字的数目</p><h2 id="2-2、规则1-省略前导0"><a href="#2-2、规则1-省略前导0" class="headerlink" title="2.2、规则1-省略前导0"></a>2.2、规则1-省略前导0</h2><p>第一条有助于缩短 IPv6 地址记法的规则是省略十六进制数中的所有前导 0（零）。以下是省略前导零的四个方法示例：</p><ul><li>01ab 可表示为 1ab</li><li>09f0 可表示为 9f0</li><li>0a00 可表示为 a00</li><li>00ab 可表示为 ab</li></ul><p>此规则仅适用于前导 0，不适用于后缀 0，否则会造成地址不明确。例如，十六进制的“abc”可能是“0abc”，也可能是“abc0”，但这些表示的值不相同。</p><table><thead><tr><th align="left">类型</th><th align="left">格式</th></tr></thead><tbody><tr><td align="left">首选</td><td align="left"><code>2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000 : 0200</code></td></tr><tr><td align="left">无前导 0</td><td align="left"><code>2001 :  db8 :    0 : 1111 :    0 :    0 :    0 :  200</code></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">首选</td><td align="left"><code>2001 : 0db8 : 0000 : 00a3 : ab00 : 0ab0 : 00ab : 1234</code></td></tr><tr><td align="left">无前导 0</td><td align="left"><code>2001 :  db8 :    0 :   a3 : ab00 :  ab0 :   ab : 1234</code></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">首选</td><td align="left"><code>2001 : 0db8 : 000a : 0001 : c012 : 90ff : fe90 : 0001</code></td></tr><tr><td align="left">无前导 0</td><td align="left"><code>2001 :  db8 :    a :    1 : c012 : 90ff : fe90 :    1</code></td></tr></tbody></table><h2 id="2-3、规则2-双冒号"><a href="#2-3、规则2-双冒号" class="headerlink" title="2.3、规则2-双冒号"></a>2.3、规则2-双冒号</h2><p>第二条有助于缩短 IPv6 地址记法的规则是使用双冒号 (::) 替换任何由一个或多个全由 0 组成的16 位十六进制数组成的连续字符串。例如，2001:db8:cafe:1:0:0:0:1（前导0省略）可以表示为2001:db8:cafe:1::1。双冒号 (::) 用于代替三个全 0十六进制数 (0:0:0)。</p><p><strong>双冒号 (::) 仅可在每个地址中使用一次，否则可能会得出一个以上的地址。</strong>当与忽略前导 0 的方法一起使用时，IPv6 地址记法可以大幅缩短。这通常称为压缩格式。</p><p>如果一个地址有多个连续的全为0的十六进制数字符串，最佳实践是在最长的字符串上使用双冒号(::)。如果字符串相等，则第一个字符串应使用双冒号 (::)。</p><table><thead><tr><th align="left">类型</th><th align="left">格式</th></tr></thead><tbody><tr><td align="left">Preferred</td><td align="left"><code>2001 : 0db8 : 0000 : 1111 : 0000 : 0000 : 0000 : 0200</code></td></tr><tr><td align="left">压缩/空间</td><td align="left"><code>2001 :  db8 :    0 : 1111 :                    :  200</code></td></tr><tr><td align="left">压缩</td><td align="left"><code>2001:db8:0:1111::200</code></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">首选</td><td align="left"><code>2001 : 0db8 : 0000 : 0000 : ab00 : 0000 : 0000 : 0000</code></td></tr><tr><td align="left">压缩/空间</td><td align="left"><code>2001 :  db8 :    0 :    0 : ab00 :: </code></td></tr><tr><td align="left">压缩</td><td align="left"><code>2001:db8:0:0:ab00::</code></td></tr><tr><td align="left"></td><td align="left"></td></tr><tr><td align="left">首选</td><td align="left"><code>2001 : 0db8 : aaaa : 0001 : 0000 : 0000 : 0000 : 0000</code></td></tr><tr><td align="left">压缩/空间</td><td align="left"><code>2001 :  db8 : aaaa :    1 ::</code></td></tr></tbody></table><h1 id="3、IPv6地址类型"><a href="#3、IPv6地址类型" class="headerlink" title="3、IPv6地址类型"></a>3、IPv6地址类型</h1><h2 id="3-1、单播、组播、任播"><a href="#3-1、单播、组播、任播" class="headerlink" title="3.1、单播、组播、任播"></a>3.1、单播、组播、任播</h2><p>与 IPv4 一样，有不同类型的 IPv6 地址。事实上，IPv6 地址有三大类：</p><ul><li><strong>单播</strong> - IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。</li><li><strong>组播</strong> - IPv6 组播地址用于将单个 IPv6 数据包发送到多个目的地。</li><li><strong>任播</strong> -IPv6 任播地址是可分配到多个设备的 IPv6 任播地址。发送至任播地址的数据包会被路由到最近的拥有该地址的设备。任播地址不在本课程的讨论范围之内。</li></ul><p>与 IPv4 不同，IPv6 没有广播地址。但是，IPv6 具有 IPv6 全节点组播地址，这在本质上与广播地址的效果相同。</p><h2 id="3-2、IPv6前缀长度"><a href="#3-2、IPv6前缀长度" class="headerlink" title="3.2、IPv6前缀长度"></a>3.2、IPv6前缀长度</h2><p>IPv4 地址的前缀或网络部分可以由点分十进制子网掩码或前缀长度（斜线记法）标识。例如， IPv4 地址 192.168.1.10（点分十进制子网掩码为 255.255.255.0）等值于 192.168.1.10/24。</p><p>在 IPv4 中，/24 称为前缀。在 IPv6 中，它被称为前缀长度。IPv6 不使用点分十进制子网掩码记法。与IPv4一样，前缀长度以斜线记法表示，用于表示 IPv6 地址的网络部分。</p><p>前缀长度范围为 0 至 128。推荐的局域网和大多数其他网络类型 IPv6 前缀长度为 /64，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.5.png"></p><p>地址前缀或网络部分的长度为 64 位，为该地址的接口 ID（主机部分）另外保留 64 位。</p><p>强烈建议对大多数网络使用 64 位接口 ID。这是因为无状态地址自动配置(SLAAC)使用64位作为接口ID。它还使子网划分更易于创建和管理。</p><h2 id="3-3、IPv6单播地址的类型"><a href="#3-3、IPv6单播地址的类型" class="headerlink" title="3.3、IPv6单播地址的类型"></a>3.3、IPv6单播地址的类型</h2><p>IPv6 单播地址用于唯一标识支持 IPv6 的设备上的接口。发送到单播地址的数据包由分配有该地址的接口接收。与 IPv4 类似，源 IPv6 地址必须是单播地址。目的 IPv6 地址可以是单播地址也可以是组播地址。该图显示了IPv6 单播地址的不同类型。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.6.png"></p><p>与IPv4设备只有一个地址不同，IPv6地址通常有两个单播地址:</p><ul><li><strong>全局单播地址(GUA)</strong> - 这类似于公有 IPv4 地址。这些地址具有全局唯一性，是互联网可路由的地址。GUA可静态配置或动态分配</li><li><strong>链路本地地址 (LLA)</strong> -这对于每个支持ipv6的设备都是必需的。LLA用于与同一链路中的其他设备通信。在 IPv6 中，术语链路是指子网。LLA仅限于单个链路。它们的唯一性仅在该链路上得到保证，因为它们在该链路之外不具有可路由性。换句话说，路由器不会转发具有本地链路源地址或目的地址的数据包。</li></ul><h2 id="3-4、关于唯一本地地址的注意事项"><a href="#3-4、关于唯一本地地址的注意事项" class="headerlink" title="3.4、关于唯一本地地址的注意事项"></a>3.4、关于唯一本地地址的注意事项</h2><p>唯一本地地址（范围 fc00:: /7 到 fdff:: /7）尚未普遍实现。因此，本模块仅涵盖 GUA 和 LLA 配置。然而，唯一本地地址最终可能被用于地址不应该从外部访问的设备，例如内部服务器和打印机。</p><p>IPv6 唯一本地地址与 IPv4 的 RFC 1918 私有地址具有相似之处，但是也有着重大差异。</p><ul><li>唯一本地地址用于一个站点内或数量有限的站点之间的本地编址。</li><li>唯一本地地址可用于从来不需要访问其他网络的设备。</li><li>唯一本地地址不会全局路由或转换为全局 IPv6 地址。</li></ul><p><strong>注意</strong>: 许多站点也使用 RFC 1918 地址的私有性质来尝试去保护或隐藏其网络，使其免遭潜在的安全风险。但是，这绝不是这些技术的既定用途，IETF 始终推荐各站点在面向互联网的路由器上采取妥善的安全预防措施。</p><h2 id="3-5、IPv6-GUA"><a href="#3-5、IPv6-GUA" class="headerlink" title="3.5、IPv6 GUA"></a>3.5、IPv6 GUA</h2><p>IPv6 全局单播地址 (GUA) 具有全局唯一性，可在 IPv6互联网上路由。这些地址相当于公有 IPv4 地址。互联网名称与数字地址分配机构 (ICANN)，即 IANA 的运营商，将 IPv6 地址块分配给五家 RIR。目前分配的仅是前三位为 001 或 2000::/3 的全局单播地址（GUA），如图所示。</p><p>该图显示了第一个十六进制数的值范围，其中当前可用的GUAs的第一个十六进制数字以2或3开头。这只是可用 IPv6 地址空间的 1/8，对于其他类型单播和组播地址而言只是很小的一部分。</p><p><strong>注意</strong>: 2001:db8::/32已经留作备档之用，包括示例用途。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.7.png"></p><p>下图显示了 GUA 的结构和范围。</p><p>带有 /48 全局路由前缀和 /64 前缀的### IPv6 地址</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.8.png"></p><p>GUA 有三个部分：</p><ul><li>全局路由前缀</li><li>子网 ID</li><li>接口 ID</li></ul><h2 id="3-6、IPv6-GUA结构"><a href="#3-6、IPv6-GUA结构" class="headerlink" title="3.6、IPv6 GUA结构"></a>3.6、IPv6 GUA结构</h2><p><strong>全局路由前缀</strong></p><p>全局路由前缀为提供商（如 ISP）分配给客户或站点的地址的前缀或网络部分。例如，ISP 通常会为其客户分配 /48 全局路由前缀。全局路由前缀通常会因 ISP 的策略而异。</p><p>前面的图显示了使用/48全局路由前缀的GUA。/48 前缀是分配的常见全局路由前缀，本课程中的多数示例均使用该前缀。</p><p>例如，IPv6 地址2001:db8:acad::/48 的全局路由前缀，该前缀表示ISP知道该前缀（网络）的方式是前48位（3个十六进制数）（2001:db8:acad）。/48 前缀长度后面的双冒号 (::) 表示地址的剩余部分全部为 0。全局路由前缀的大小决定子网 ID 的大小。</p><p><strong>子网ID</strong></p><p>子网ID字段是全局路由前缀和接口ID之间的区域。与IPv4不同，在IPv4中您必须从主机部分借用位来创建子网，IPv6在设计时考虑到了子网。组织使用子网 ID 确定其站点的子网。子网 ID 越大，可用子网越多。</p><p><strong>注意</strong>: 许多组织正在接收 /32 全局路由前缀。使用推荐的 /64 前缀来创建 64 位接口 ID，会留下一个 32 位子网 ID。这意味着具有 /32 全局路由前缀和 32 位子网 ID 的组织将拥有 43 亿个子网，每个子网都有 1800亿亿（18后面跟18个0）个子网。这是与公有 IPv4 地址数量一样多的子网！</p><p>在前面的图中，IPv6地址有一个/48全局路由前缀，这在许多企业网络中很常见。这使得检查地址的不同部分变得特别容易。使用典型的/64前缀长度，前四个十六进制数是地址的网络部分，其中第四个十六进制数表示子网 ID。剩下的四个十六进制数用于接口 ID。</p><p><strong>接口ID</strong></p><p>IPv6 接口 ID 相当于 IPv4 地址的主机部分。使用术语“接口 ID”是因为单个主机可能有多个接口，而每个接口又有一个或多个 IPv6 地址。该图显示了 IPv6 GUA 的结构示例。强烈建议在大多数情况下使用 /64 子网，这会创建64位接口ID。64 位接口 ID 允许每个子网有1800亿亿个设备或主机。</p><p>/64 子网或前缀（全局路由前缀 + 子网 ID）为接口 ID 留下 64 位。建议允许启用 SLAAC 的设备创建自己的 64 位接口 ID。它还使得 IPv6 编址计划的开发变得简单而有效。</p><p><strong>注意</strong>: 与 IPv4 不同，在 IPv6 中，全 0 和全 1 主机地址可以分配给设备。可以使用全1地址，因为广播地址不在IPv6中使用。全 0 地址也可使用，但它留作子网路由器任播地址，应仅分配给路由器。</p><h2 id="3-7、IPv6-LLA"><a href="#3-7、IPv6-LLA" class="headerlink" title="3.7、IPv6 LLA"></a>3.7、IPv6 LLA</h2><p>IPv6 链路本地地址(LLA)允许设备与同一链路上支持 IPv6 的其他设备通信，并且只能在该链路（子网）上通信。具有源或目的LLA的数据包不能在数据包的源链路之外进行路由。</p><p>GUA 不是一项要求。但是，每个启用 IPv6 的网络接口都必须有 LLA。</p><p>如果没有手动为接口配置LLA，设备会在不与 DHCP 服务器通信的情况下自动创建自己的地址。支持 IPv6 的主机会创建 IPv6 LLA，即使没有为该设备分配 IPv6 全局单播地址。这允许支持 IPv6 的设备与同一子网中的其他支持 IPv6 的设备通信。这包括与默认网关（路由器）的通信。</p><p>IPv6 LLAs在fe80::/10范围内。/10 表示前 10 位是 1111 1110 10xx xxxx。第一个十六进制数的范围是 1111 1110 10<strong>00 0000</strong> (fe80) 到 1111 1110 10<strong>11 1111</strong> (febf)。</p><p>该图显示使用IPv6 LLA进行通信的示例。PC 能够使用LLA直接与打印机进行通信。</p><p><strong>IPv6 链路本地通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.9.png"></p><p>下图显示了IPv6 LLA的一些用途。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.10.png"></p><ol><li>路由器使用邻居路由器的LLA发送路由更新。</li><li>主机使用本地路由器的 LLA 作为默认网关。</li></ol><p><strong>注意</strong>: 通常情况下，用作链路上其他设备的默认网关的是路由器的LLA而不是GUA。</p><p>设备可以通过两种方式获取 LLA：</p><ul><li><strong>静态</strong> -这意味着设备已手动配置。</li><li><strong>动态</strong> -这意味着设备通过使用随机生成的值或使用扩展唯一标识符 (EUI) 方法创建自己的接口 ID，该方法使用客户端 MAC 地址和其他位。</li></ul><h2 id="3-8、测验"><a href="#3-8、测验" class="headerlink" title="3.8、测验"></a>3.8、测验</h2><p><strong>LLA</strong>类型的IPv6地址以fe80开头</p><h1 id="4、GUA和LLA静态配置"><a href="#4、GUA和LLA静态配置" class="headerlink" title="4、GUA和LLA静态配置"></a>4、GUA和LLA静态配置</h1><h2 id="4-1、路由器上的静态GUA配置"><a href="#4-1、路由器上的静态GUA配置" class="headerlink" title="4.1、路由器上的静态GUA配置"></a>4.1、路由器上的静态GUA配置</h2><p>如您在上一主题中了解到的，IPv6 GUA与公有 IPv4 地址数量相同。它们具有全局唯一性，可在 IPv6互联网上路由。IPv6 LLA 允许两个启用 IPV6 的设备在同一链路（子网）上相互通信。在路由器上静态配置IPv6 GUA和LLA很容易，可以帮助您创建IPv6网络。本主题教您如何做到这一点！</p><p>在 思科 IOS 中，大多数 IPv6 的配置和验证命令与 IPv4 的相似。在多数情况下，唯一区别是命令中使用<strong>ipv6</strong> 取代<strong>ip</strong> 。</p><p>例如，在接口上配置 IPv4 地址的思科IOS 命令是 <strong>ip address</strong> <em>ip 地址 子网掩码</em>，相比之下，在接口上配置 IPv6 GUA 的命令是 <strong>ipv6 address</strong> <em>ipv6 地址/前缀长度</em>。</p><p>注意 <em>ipv6-address</em> 和 <em>prefix-length</em>之间没有空格。</p><p>配置示例使用图中的拓扑和下列 IPv6 子网：</p><ul><li>2001:db8:acad:1:/64</li><li>2001:db8:acad:2:/64</li><li>2001:db8:acad:3:/64</li></ul><p><strong>示例拓扑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.11.png"></p><p>示例列出在 R1 的 G0/0/0、G0/0/1 和 Serial 0/1/0 接口上配置 IPv6 GUA所需的命令。</p><p>路由器R1上的IPv6 GUA配置</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1(config)# interface gigabitethernet 0&#x2F;0&#x2F;0R1(config-if)# ipv6 address 2001:db8:acad:1::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface gigabitethernet 0&#x2F;0&#x2F;1R1(config-if)# ipv6 address 2001:db8:acad:2::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface serial 0&#x2F;1&#x2F;0R1(config-if)# ipv6 address 2001:db8:acad:3::1&#x2F;64R1(config-if)# no shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-2、Windows-主机上的静态GUA配置"><a href="#4-2、Windows-主机上的静态GUA配置" class="headerlink" title="4.2、Windows 主机上的静态GUA配置"></a>4.2、Windows 主机上的静态GUA配置</h2><p>在主机上手动配置 IPv6 地址与配置 IPv4 地址相似。</p><p>如图中所示，为 PC1 配置的默认网关地址为2001:DB8:ACAD:1::1。该地址是同一网络中 R1 千兆以太网接口的GUA。或者，也可以配置默认网关地址以与千兆以太网接口的LLA相匹配。使用路由器的LLA作为默认网关地址被认为是最佳实践。任一配置都可以。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.12.png"></p><p>与使用 IPv4 一样，在客户端配置静态地址并不能扩展至更大的环境。因此，多数 IPv6 网络的管理员会启用 IPv6 地址的动态分配。</p><p>设备可以通过两种方法自动获取 IPv6 GUA：</p><ul><li>无状态地址自动配置 (SLAAC)</li><li>有状态 DHCPv6</li></ul><p>下一个主题将介绍SLAAC和DHCPv6。</p><p><strong>注意</strong>: 使用 DHCPv6 或 SLAAC 时，路由器的LLA将自动指定为默认网关地址。</p><h2 id="4-3、链路本地单播地址的静态配置"><a href="#4-3、链路本地单播地址的静态配置" class="headerlink" title="4.3、链路本地单播地址的静态配置"></a>4.3、链路本地单播地址的静态配置</h2><p>手动配置LLA可以让您创建的地址便于识别和记忆。一般来说，只需要在路由器上创建可识别的LLA。这样做很有用，因为路由器LLA将被用作默认网关地址并包含在路由通告消息中。</p><p>LLA 可以使用 <strong>ipv6 address</strong> <em>ipv6-链路本地地址</em> <strong>link-local</strong> 命令手动配置。当地址以 fe80 到 febf 范围的十六进制数开头时，<strong>link-local</strong>参数必须符合该地址。</p><p>该图显示了一个示例拓扑，每个接口上都有LLA。</p><p><strong>带有LLA的拓扑示例</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.13.png"></p><p>该示例显示了路由器 R1 上 LLA 的配置。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1(config)# interface gigabitethernet 0&#x2F;0&#x2F;0R1(config-if)# ipv6 address fe80::1:1 link-localR1(config-if)# exitR1(config)# interface gigabitethernet 0&#x2F;0&#x2F;1R1(config-if)# ipv6 address fe80::2:1 link-localR1(config-if)# exitR1(config)# interface serial 0&#x2F;1&#x2F;0R1(config-if)# ipv6 address fe80::3:1 link-localR1(config-if)# exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态配置的LLA用于使它们更易于识别为属于路由器R1。在示例中，路由器 R1 的所有接口都配置了以 <strong>fe80::1:<strong><em>n</em> 开头的 LLA 以及唯一的最右侧数字 “n”。“</strong>1</strong>” 表示路由器 R1。</p><p>遵循与路由器 R1 相同的语法，如果拓扑包含路由器 R2，那么它的三个接口将配置LLA为 fe80::2:1、fe80::2:2和fe80::2:3。</p><p><strong>注意</strong>: 只要每个链路上的LLA是唯一的，就可以在每个链路上配置完全相同的LLA。这是因为LLA仅在该链路上具有唯一性。但是，常见的实践是在路由器的每个接口上创建一个不同的 LLA，以便轻松识别路由器和特定接口。</p><h2 id="4-4、语法检查器-GUA和LLA的静态配置"><a href="#4-4、语法检查器-GUA和LLA的静态配置" class="headerlink" title="4.4、语法检查器-GUA和LLA的静态配置"></a>4.4、语法检查器-GUA和LLA的静态配置</h2><p>略</p><h1 id="5、IPv6-GUA的动态编址"><a href="#5、IPv6-GUA的动态编址" class="headerlink" title="5、IPv6 GUA的动态编址"></a>5、IPv6 GUA的动态编址</h1><h2 id="5-1、RS-and-RA-消息"><a href="#5-1、RS-and-RA-消息" class="headerlink" title="5.1、RS and RA 消息"></a>5.1、RS and RA 消息</h2><p>如果您不想静态地配置IPv6 GUAs，也不必担心。大多数设备会动态获取其 IPv6 GUA。本主题说明如何使用路由器通告（RA）和路由器请求（RS）消息来完成此过程。本主题比较技术性，但是当您理解了路由器通告可以使用的三种方法之间的区别，以及创建接口ID的EUI-64进程与随机生成的进程的区别，您将在您的IPv6专业知识上有一个巨大的飞跃!</p><p>对于 GUA，设备通过 Internet 控制消息协议版本 6 (ICMPv6) 消息动态获取地址。IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，该消息是对RA消息的请求。这两条消息都显示在图中。</p><p><strong>ICMPv6 RS  和 RA 消息</strong></p><p>如果您不想静态地配置IPv6 GUAs，也不必担心。大多数设备会动态获取其 IPv6 GUA。本主题说明如何使用路由器通告（RA）和路由器请求（RS）消息来完成此过程。本主题比较技术性，但是当您理解了路由器通告可以使用的三种方法之间的区别，以及创建接口ID的EUI-64进程与随机生成的进程的区别，您将在您的IPv6专业知识上有一个巨大的飞跃!</p><p>对于 GUA，设备通过 Internet 控制消息协议版本 6 (ICMPv6) 消息动态获取地址。IPv6 路由器每 200 秒定期将 ICMPv6 RA 消息发送到网络上所有支持 IPv6 的设备。在响应发送 ICMPv6 路由器请求 (RS) 消息的主机时，也会发送 RA 消息，该消息是对RA消息的请求。这两条消息都显示在图中。</p><p><strong>ICMPv6 RS和RA消息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.14.png"></p><ol><li>RS 消息由请求寻址信息的主机发送到所有 IPv6 路由器。</li><li>RA 消息被发送到所有 IPv6 节点。如果使用方法 1（仅 SLAAC），RA 将包括网络前缀、前缀长度和默认网关信息。</li></ol><p>RA消息位于IPv6路由器以太网接口上。必须为路由器启用 IPv6 路由，这在默认情况下是不启用的。若要将路由器启用为 IPv6 路由器，必须使用 <strong>ipv6 unicast-routing</strong> 全局配置命令。</p><p>ICMPv6 RA 消息提示设备获取 IPv6 GUA的方式。最终决定取决于设备的操作系统。ICMPv6 RA 消息包括以下：</p><ul><li><strong>网络前缀和前缀长度</strong> – 这会告知设备其所属的网络。</li><li><strong>默认网关</strong> – IPv6 LLA，RA 消息的源 IPv6 地址。</li><li><strong>DNS 地址和域名</strong> – 这些是DNS 服务器的地址和域名。</li></ul><p>RA 消息有三种方法：</p><ul><li><strong>方法 1: SLAAC</strong> -“我拥有您需要的一切，包括前缀、前缀长度和默认网关地址。”</li><li><strong>方法 2:SLAAC 和 无状态DHCPv6服务器</strong> -“这是我的信息，但您需要从 无状态DHCPv6 服务器获得其他信息，例如 DNS 地址。”</li><li><strong>方法 3:有状态的 DHCPv6（无SLAAC）</strong> -“我可以给您默认网关的地址。您需要向有状态的 DHCPv6 服务器询问您的所有其他信息。”</li></ul><h2 id="5-2、方法1：SLAAC"><a href="#5-2、方法1：SLAAC" class="headerlink" title="5.2、方法1：SLAAC"></a>5.2、方法1：SLAAC</h2><p>SLAAC是一种允许设备在没有DHCPv6服务的情况下创建自己的GUA的方法。使用 SLAAC，设备根据本地路由器的 ICMPv6 路由器通告 (RA) 消息获取必要信息。</p><p>默认情况下，RA 消息会提示接收设备使用 RA 消息中的信息创建其自己的 IPv6 GUA及其他必要信息。DHCPv6 服务器的服务不是必需项。</p><p>SLAAC 是无状态的，也就是说没有中央服务器（例如有状态DHCPv6 服务器）来分配GUA和维持设备及其地址的清单。借助 SLAAC，客户端设备使用 RA 消息中的信息创建其自己的GUA。如图中所示，地址的两部分生成如下：</p><ul><li><strong>前缀</strong> -这是在 RA 消息中通告的。</li><li><strong>接口 ID</strong> -使用 EUI-64 流程或通过生成一个随机 64 位数字产生，取决于设备的操作系统。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.16.png"></p><ol><li>路由器发送了一个带有本地链路前缀的RA消息。</li><li>PC使用SLAAC从RA消息获取前缀并创建自己的接口ID。</li></ol><h2 id="5-3、方法2：SLAAC和无状态DHCPv6"><a href="#5-3、方法2：SLAAC和无状态DHCPv6" class="headerlink" title="5.3、方法2：SLAAC和无状态DHCPv6"></a>5.3、方法2：SLAAC和无状态DHCPv6</h2><p>路由器的接口可配置为使用 SLAAC 和无状态 DHCPv6 或仅使用有状态 DHCPv6 发送路由器通告。</p><p>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p><ul><li>SLAAC创建自己的IPv6 GUA</li><li>路由器LLA，是RA源IPv6地址，作为默认网关地址</li><li>使用无状态 DHCPv6 服务器获取其他信息，例如 DNS 服务器地址和域名。</li></ul><p><strong>注意</strong>: 使用无状态 DHCPv6 服务器分配 DNS 服务器地址和域名。<strong>它不分配 GUA。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.17.png"></p><ol><li>PC向所有IPv6路由器发送了一条RS消息，“我需要编址信息”。</li><li>路由器通过方法2 (SLAAC和DHCPv6)向所有IPv6节点发送了一条RA消息。“这是您的前缀、前缀长度和默认网关信息。但 DNS 信息需要从 DHCPv6 服务器获取。”</li><li>PC向所有DHCPv6服务器发送了一条DHCPv6请求消息。“我使用 SLAAC 创建了我的 IPv6 地址并获取了我的默认网关地址，但我需要来自无状态 DHCPv6 服务器的其他信息。 “</li></ol><h2 id="5-4、方法3：有状态的DHCPv6"><a href="#5-4、方法3：有状态的DHCPv6" class="headerlink" title="5.4、方法3：有状态的DHCPv6"></a>5.4、方法3：有状态的DHCPv6</h2><p>路由器接口可以配置为仅使用有状态的DHCPv6发送RA。</p><p>有状态 DHCPv6 与 IPv4 的 DHCP 相似。设备可以从有状态 DHCPv6 服务器自动接收编址信息，包括GUA、前缀长度和 DNS 服务器地址。</p><p>如图所示，使用此方法，RA 消息建议设备使用以下内容：</p><ul><li>路由器LLA，是RA源IPv6地址，作为默认网关地址。</li><li>使用有状态 DHCPv6 服务器获取GUA、DNS 服务器地址、域名和其他必要信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.18.png"></p><ol><li>PC向所有IPv6路由器发送了一条RS消息，“我需要编址信息”。</li><li>路由器使用方法3（有状态的 DHCPv6）向所有 IPv6节点发送 RA 消息，指明”我是您的默认网关，但您需要向有状态的 DHCPv6 服务器询问 IPv6地址和其他编址信息”。</li><li>PC向所有DHCPv6服务器发送一条DHCPv6请求消息，“我从RA消息收到了我的默认网关地址，但是我需要一个IPv6地址和来自有状态的DHCPv6服务器的所有其他编址信息”。</li></ol><p>使用有状态 DHCPv6 服务器分配并维持哪台设备接收哪个 IPv6 地址的清单。IPv4 的 DHCP 是有状态的。</p><p><strong>注意:</strong> 默认网关地址仅可从 RA 消息中动态获取。无状态或有状态 DHCPv6 服务器均不提供默认网关地址。</p><h2 id="5-5、EUI-64流程和随机生成"><a href="#5-5、EUI-64流程和随机生成" class="headerlink" title="5.5、EUI-64流程和随机生成"></a>5.5、EUI-64流程和随机生成</h2><p>当 RA 消息为 SLAAC 或 SLAAC 和无状态 DHCPv6 时，客户端必须生成自己的接口 ID。客户端从 RA 消息中获知地址的前缀部分，但必须创建自己的接口 ID。如图所示，接口 ID 可使用 EUI-64 流程或随机生成的 64 位数字创建。</p><p><strong>动态创建接口ID</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.19.png"></p><ol><li>路由器发送 RA 信息</li><li>PC在RA消息中使用前缀，并使用EUI-64或一个随机64位数字来生成接口ID</li></ol><h2 id="5-6、EUI-64流程"><a href="#5-6、EUI-64流程" class="headerlink" title="5.6、EUI-64流程"></a>5.6、EUI-64流程</h2><p>IEEE 定义了扩展唯一标识符 (EUI) 或修改的 EUI-64 流程。该流程使用客户端的 48 位以太网 MAC 地址，并在该 48 位 MAC 地址的中间插入另外 16 位来创建 64 位接口 ID。</p><p>以太网 MAC 地址一般使用十六进制表示，由两部分组成：</p><ul><li><strong>组织唯一标识符 (OUI)</strong> - OUI 为 IEEE 分配的 24 位（6 个十六进制数字）厂商代码。</li><li><strong>设备标识符</strong> - 设备标识符是通用 OUI 内的唯一 24 位（6 个十六进制数字）值。</li></ul><p>EUI-64 接口 ID 以二进制表示，共分三个部分：</p><ul><li>客户端 MAC 地址的 24 位 OUI，但是第 7 位（通用/本地 (U/L) 位）颠倒。这意味着，如果第 7 位是 0，则它会变为 1，反之亦然。</li><li>插入的 16 位值 fffe（十六进制）。</li><li>客户端 MAC 地址的 24 位设备标识符。</li></ul><p>该图是 EUI-64 流程图，它使用 R1 千兆以太网 MAC 地址，即 fc99:4775:cee0。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.20.png"></p><p><strong>步骤 1:</strong> 划分 OUI 和设备标识符之间的 MAC 地址。</p><p><strong>步骤 2:</strong> 插入十六进制值 fffe（二进制形式为 1111 1111 1111 1110）。</p><p><strong>步骤 3:</strong> 将 OUI 的前 2 个十六进制值转换为二进制值，并颠倒 U/L 位（第 7 位）。在该示例中，第 7 位的 0 变为 1。</p><p>结果即是 EUI-64 生成的接口 ID：fe99:47ff:fe75:cee0。</p><p><strong>注意</strong>: U/L 位的用途和该位值的翻转原因会在 RFC 5342 中讨论。</p><p><strong>ipconfig</strong> 命令的示例输出显示了使用 SLAAC 和 EUI-64 流程动态创建的 IPv6 GUA。识别地址可能是使用EUI-64创建的一个简单方法是位于接口ID中间的<strong>fffe</strong>。</p><p>EUI-64 优势在于可以使用以太网 MAC 地址确定接口 ID。这也允许网络管理员使用唯一 MAC 地址轻松跟踪终端设备的 IPv6 地址。然而，这引起了许多用户的隐私担忧，他们担心自己的数据包可能会被追踪到实际的物理计算机。出于这些顾虑，可以转而使用随机生成的接口 ID。</p><p>EUI-64生成的接口ID</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . :IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:fc99:47ff:fe75:cee0Link-local IPv6 Address . . . . . : fe80::fc99:47ff:fe75:cee0Default Gateway . . . . . . . . . : fe80::1C:\ &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-7、随机生成的接口ID"><a href="#5-7、随机生成的接口ID" class="headerlink" title="5.7、随机生成的接口ID"></a>5.7、随机生成的接口ID</h2><p>根据操作系统，设备可以使用随机生成的接口 ID，而不使用 MAC 地址和 EUI-64 流程。从 Windows Vista 开始，Windows 使用随机生成的接口 ID，而不是 EUI-64 创建的接口 ID。Windows XP 和之前的 Windows 操作系统均使用 EUI-64。</p><p>如图所示，接口 ID 创建后（无论是使用 EUI-64 流程还是通过随机生成），它都可以在 RA 消息中结合 IPv6 前缀来创建GUA。</p><p><strong>随机生成的64位接口ID</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:50a5:8a35:a5bb:66e1   Link-local IPv6 Address . . . . . : fe80::50a5:8a35:a5bb:66e1   Default Gateway . . . . . . . . . : fe80::1C:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>: 为确保任何 IPv6 单播地址的唯一性，客户端可以使用重复地址检测 (DAD) 流程。这与 ARP 请求其地址的流程相似。如该请求没有响应，则地址是唯一的。</p><h1 id="6、IPv6-LLA的动态编址"><a href="#6、IPv6-LLA的动态编址" class="headerlink" title="6、IPv6 LLA的动态编址"></a>6、IPv6 LLA的动态编址</h1><h2 id="6-1、动态LLA"><a href="#6-1、动态LLA" class="headerlink" title="6.1、动态LLA"></a>6.1、动态LLA</h2><p>所有 IPv6 设备都必须有 IPv6 LLA。与 IPv6 GUA一样，您也可以动态创建 LLA。无论您如何创建LLA(和GUA)，重要的是要验证所有IPv6地址配置。本主题介绍动态生成的 LLA和 IPv6 配置验证。</p><p>该图显示了如何使用fe80::/10 前缀和通过 EUI-64 流程或随机生成的 64 位数字创建的接口 ID 动态创建LLA。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.21.png"></p><h2 id="6-2、Windows上的动态LLA"><a href="#6-2、Windows上的动态LLA" class="headerlink" title="6.2、Windows上的动态LLA"></a>6.2、Windows上的动态LLA</h2><p>操作系统，如Windows，通常会对SLAAC创建的GUA和动态分配的LLA使用相同的方法。请参阅之前显示的以下示例中突出显示的区域。</p><p><strong>EUI-64生成的接口ID</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:Connection-specific DNS Suffix . :IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:fc99:47ff:fe75:cee0Link-local IPv6 Address . . . . . : fe80::fc99:47ff:fe75:cee0Default Gateway . . . . . . . . . : fe80::1C:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>随机生成的64位接口ID</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">C:\&gt; ipconfigWindows IP ConfigurationEthernet adapter Local Area Connection:   Connection-specific DNS Suffix  . :   IPv6 Address. . . . . . . . . . . : 2001:db8:acad:1:50a5:8a35:a5bb:66e1   Link-local IPv6 Address . . . . . : fe80::50a5:8a35:a5bb:66e1   Default Gateway . . . . . . . . . : fe80::1C:\&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-3、思科路由器上的动态LLA"><a href="#6-3、思科路由器上的动态LLA" class="headerlink" title="6.3、思科路由器上的动态LLA"></a>6.3、思科路由器上的动态LLA</h2><p>当为接口分配GUA时，思科路由器会自动创建 IPv6 LLA。默认情况下，思科 IOS 路由器使用 EUI-64 为 IPv6 接口上的所有LLA生成接口 ID。对于串行接口，路由器会使用以太网接口的 MAC 地址。回想一下，LLA在该链路或网络上必须具有唯一性。但是，使用动态分配的LLA的缺点在于其接口 ID 较长，因此很难识别并记住分配的地址。示例显示了路由器 R1 千兆以太网0/0/0 接口的 MAC 地址。该地址用于在同一接口上动态创建LLA，也用于串行0/1/0接口。</p><p>为了更容易在路由器上识别和记忆这些地址，通常要在路由器上静态配置 IPv6 LLA。</p><p>在路由器 R1 上使用 EUI-64 的### IPv6 LLA</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show interface gigabitEthernet 0&#x2F;0&#x2F;0GigabitEthernet0&#x2F;0&#x2F;0 is up, line protocol is up  Hardware is ISR4221-2x1GE, address is 7079.b392.3640 (bia 7079.b392.3640)(Output omitted)R1# show ipv6 interface briefGigabitEthernet0&#x2F;0&#x2F;0   [up&#x2F;up]    FE80::7279:B3FF:FE92:3640    2001:DB8:ACAD:1::1GigabitEthernet0&#x2F;0&#x2F;1   [up&#x2F;up]    FE80::7279:B3FF:FE92:3641    2001:DB8:ACAD:2::1Serial0&#x2F;1&#x2F;0            [up&#x2F;up]    FE80::7279:B3FF:FE92:3640    2001:DB8:ACAD:3::1Serial0&#x2F;1&#x2F;1            [down&#x2F;down]    unassignedR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-4、验证IPv6地址配置"><a href="#6-4、验证IPv6地址配置" class="headerlink" title="6.4、验证IPv6地址配置"></a>6.4、验证IPv6地址配置</h2><p>图中显示了示例拓扑。</p><h3 id="show-ipv6-interface-brief"><a href="#show-ipv6-interface-brief" class="headerlink" title="show ipv6 interface brief"></a>show ipv6 interface brief</h3><p><strong>show ipv6 interface brief</strong> 命令会显示以太网接口的 MAC 地址。EUI-64 使用此 MAC 地址生成LLA的接口 ID。此外，<strong>show ipv6 interface brief</strong> 命令用于显示各个接口的缩略输出。与接口位于同一行的 [up/up] 输出指示第 1 层/第 2 层接口状态。这与等效的 IPv4 命令的状态和协议列相同。</p><p>注意，每个接口有两个 IPv6 地址。每个接口的第二个地址是已配置的 GUA。第一个地址以 fe80 开头，是接口的链路本地单播地址。回想一下，分配 GUA 后，LLA 会自动添加到接口。</p><p>另请注意，R1 的 Serial 0/0/0 本地链路地址与其 GigabitEthernet 0/0 接口相同。串行接口没有以太网 MAC 地址，因此思科 IOS 使用第一个可用的以太网接口的 MAC 地址。这样可行，因为本地链路接口仅在该链路上具有唯一性。</p><p><strong>show ipv6 interface brief 命令在路由器 R1</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show ipv6 interface briefGigabitEthernet0&#x2F;0&#x2F;0 [up&#x2F;up]FE80::1:12001:DB8:ACAD:1::1GigabitEthernet0&#x2F;0&#x2F;1 [up&#x2F;up]FE80::1:22001:DB8:ACAD:2::1Serial0&#x2F;1&#x2F;0 [up&#x2F;up]FE80::1:32001:DB8:ACAD:3::1Serial0&#x2F;1&#x2F;1 [down&#x2F;down]unassignedR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="show-ipv6-route"><a href="#show-ipv6-route" class="headerlink" title="show ipv6 route"></a>show ipv6 route</h3><p>如示例所示，<strong>show ipv6 route</strong> 命令可用于检验 IPv6 网络和特定 IPv6 接口地址已添加到 IPv6 路由表中。该 <strong>show ipv6 route</strong> 命令将仅显示 IPv6 网络，而不显示 IPv4 网络。</p><p>在路由表中，路由旁边的 <strong>C</strong> 表示这是一个直连网络。当路由器接口配置了 GUA 并处于 “up/up” 状态时，IPv6 前缀和前缀长度会作为直连路由添加至 IPv6 路由表。</p><p><strong>注意</strong>:<strong>L</strong> 表示本地路由，即为接口分配的特定 IPv6 地址。这不是一个 LLA。由于 LLA 不是可路由地址，因此它们不包括在路由表中。</p><p>接口上配置的 IPv6 GUA也作为本地路由添加到路由表中。本地路由具有 /128 前缀。路由表使用本地路由来有效处理目的地址为路由器接口地址的数据包。</p><p><strong>show ipv6 route 命令在路由器 R1</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# show ipv6 routeIPv6 Routing Table - default - 7 entriesCodes: C - Connected, L - Local, S - Static, U - Per-user Static routeC 2001:DB8:ACAD:1::&#x2F;64 [0&#x2F;0]via GigabitEthernet0&#x2F;0&#x2F;0, directly connectedL 2001:DB8:ACAD:1::1&#x2F;128 [0&#x2F;0]via GigabitEthernet0&#x2F;0&#x2F;0, receiveC 2001:DB8:ACAD:2::&#x2F;64 [0&#x2F;0]via GigabitEthernet0&#x2F;0&#x2F;1, directly connectedL 2001:DB8:ACAD:2::1&#x2F;128 [0&#x2F;0]via GigabitEthernet0&#x2F;0&#x2F;1, receiveC 2001:DB8:ACAD:3::&#x2F;64 [0&#x2F;0]via Serial0&#x2F;1&#x2F;0, directly connectedL 2001:DB8:ACAD:3::1&#x2F;128 [0&#x2F;0]via Serial0&#x2F;1&#x2F;0, receiveL FF00::&#x2F;8 [0&#x2F;0]via Null0, receiveR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h3><p>IPv6 的 <strong>ping</strong> 命令和 IPv4 中这条命令的用法相同，只不过使用的是 IPv6 地址。如示例中所示，命令的作用是验证 R1 和 PC1 之间的第 3 层连通性。从路由器对 LLA 实施 ping 命令时，思科 IOS 会提示用户确认出接口。由于目的 LLA 可以在一个或多个链路或网络上使用，路由器需要知道要将 ping 发送到哪个接口。</p><p><strong>ping 命令在路由器 R1</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1# ping 2001:db8:acad:1::10Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 2001:DB8:ACAD:1::10, timeout is 2 seconds:!!!!!Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;1&#x2F;1 msR1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-5、语法检查器-验证IPv6地址配置"><a href="#6-5、语法检查器-验证IPv6地址配置" class="headerlink" title="6.5、语法检查器-验证IPv6地址配置"></a>6.5、语法检查器-验证IPv6地址配置</h2><p>使用 <strong>show</strong> 命令在路由器R1接口上验证IPv6地址配置。</p><p>略</p><h1 id="7、IPv6组播地址"><a href="#7、IPv6组播地址" class="headerlink" title="7、IPv6组播地址"></a>7、IPv6组播地址</h1><h2 id="7-1、分配的IPv6组播地址"><a href="#7-1、分配的IPv6组播地址" class="headerlink" title="7.1、分配的IPv6组播地址"></a>7.1、分配的IPv6组播地址</h2><p>在本模块的前面，您了解到IPv6地址有三大类：单播、任播和组播。本主题将详细介绍组播地址。</p><p>IPv6 组播地址类似于 IPv4 组播地址。回想一下，组播地址用于发送单个数据包到一个或多个目标（组播组）。IPv6 组播地址的前缀为ff00::/8。</p><p><strong>注意</strong>: 组播地址仅可用作目的地址，不能用作源地址。</p><p>IPv6 组播地址分为两种类型：</p><ul><li>知名组播地址</li><li>请求节点组播地址</li></ul><h2 id="7-2、知名IPv6组播地址"><a href="#7-2、知名IPv6组播地址" class="headerlink" title="7.2、知名IPv6组播地址"></a>7.2、知名IPv6组播地址</h2><p>已分配的知名IPv6 组播地址。分配的组播地址是为预先定义的设备组保留的组播地址。分配的组播地址是用于到达运行通用协议或服务的设备组的单个地址。分配的组播地址用在特定的协议环境，例如 DHCPv6。</p><p>这些是两种常见的 IPv6 分配组播组：</p><ul><li><strong>ff02:全节点组播组</strong> -这是一个包含所有支持 IPv6 的设备的组播组。发送到该组的数据包由该链路或网络上的所有 IPv6 接口接收和处理。这与 IPv4 中的广播地址具有相同的效果。图中显示使用全节点组播地址进行通信的示例。IPv6 路由器将ICMPv6 RA 消息发送给全节点组播组。</li><li><strong>ff02:全路由器组播组</strong> - 这是所有IPv6路由器加入的组播组。当在IPv6路由器全局模式下启用ipv6 unicast-routing命令后，该路由器即成为该组的成员。发送到该组的数据包由该链路或网络上的所有 IPv6 路由器接收和处理。</li></ul><p><strong>IPv6全节点组播：RA消息</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.24.png"></p><p>支持 IPv6 的设备将 ICMPv6 RS 消息发送到全路由器组播地址。RS 消息向 IPv6 路由器发出 RA 消息请求来协助设备的地址配置。IPv6路由器使用RA 消息作出响应，正如所示。</p><h2 id="7-3、请求节点IPv6组播地址"><a href="#7-3、请求节点IPv6组播地址" class="headerlink" title="7.3、请求节点IPv6组播地址"></a>7.3、请求节点IPv6组播地址</h2><p>请求节点组播地址类似于全节点组播地址。请求节点组播地址的优势在于它被映射到特殊的以太网组播地址。这使得以太网网卡可以通过检查目的 MAC 地址过滤该帧，而不是将它发送给 IPv6 流程来判断该设备是否是 IPv6 数据包的既定目标。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.25.png"></p><h1 id="8、IPv6网络的子网"><a href="#8、IPv6网络的子网" class="headerlink" title="8、IPv6网络的子网"></a>8、IPv6网络的子网</h1><h2 id="8-1、使用子网ID划分子网"><a href="#8-1、使用子网ID划分子网" class="headerlink" title="8.1、使用子网ID划分子网"></a>8.1、使用子网ID划分子网</h2><p>本模块的介绍提到了 IPv6 网络的子网划分。它还表示，您可能会发现它比 IPv4 网络的子网划分更容易一些。您马上就会知道了!</p><p>回想一下，使用IPv4时，我们必须从主机部分借用位来创建子网。这是因为对IPv4来说，子网划分是事后才想到的。但是，IPv6 的设计考虑到了子网划分。IPv6 GUA中的一个单独的子网ID字段用于创建子网。如图所示，子网ID字段是全局路由前缀和接口ID之间的区域。</p><p><strong>带有16位子网ID的GUA</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.26.png"></p><p>128 位地址的好处在是，它可以为每个网络支持足够多的子网并为每个子网支持足够多的主机。地址保留不是问题。例如，如果全局路由前缀是a /48，并且使用一个典型的64位接口ID，这将创建一个16位子网ID:</p><ul><li><strong>16 位子网 ID</strong> -创建多达 65,536 个子网。</li><li><strong>64 位子网 ID</strong> -每个子网支持多达 1800亿亿个主机 IPv6 地址（即 18,000,000,000,000,000,000）。</li></ul><p><strong>注意</strong>: 也可以将子网划分为 64 位接口 ID（或主机部分），但是很少这么要求。</p><p>IPv6 子网划分也比 IPv4 容易实施，因为不需要转换为二进制。要确定下一个可用子网，只需要将十六进制数相加。</p><h2 id="8-2、IPv6子网划分示例"><a href="#8-2、IPv6子网划分示例" class="headerlink" title="8.2、IPv6子网划分示例"></a>8.2、IPv6子网划分示例</h2><p>例如，假设一个组织分配了 2001:db8:acad::/48 全局路由前缀，并采用 16 位子网 ID。这将允许组织创建65,536个 /64 子网，如图所示。注意，所有子网的全局路由前缀是相同的。只为每个子网递增子网 ID 的十六位字节数（以十六进制形式）。</p><p><strong>使用16位子网ID划分子网</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.27.png"></p><h2 id="8-3、IPv6子网分配"><a href="#8-3、IPv6子网分配" class="headerlink" title="8.3、IPv6子网分配"></a>8.3、IPv6子网分配</h2><p>由于有 65,536 个子网可供选择，网络管理员的任务就变为设计一个逻辑方案来分配网络地址。</p><p>如图所示，示例拓扑需要五个子网，每个局域网一个，以及R1和R2之间的串行链路一个。与IPv4的示例不同，IPv6的串行链路子网将具有与局域网相同的前缀长度。虽然这可能会“浪费”地址，但是使用 IPv6 时地址保留并不是问题。</p><p><strong>示例拓扑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.28.png"></p><p>如下图所示，在本示例中 5 个 IPv6 子网的分配将使用 0001 到 0005 的子网 ID 字段。每个 /64 子网提供的地址都远多于所需要的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN12.29.png"></p><h2 id="8-4、配置了IPv6子网的路由器"><a href="#8-4、配置了IPv6子网的路由器" class="headerlink" title="8.4、配置了IPv6子网的路由器"></a>8.4、配置了IPv6子网的路由器</h2><p>与配置 IPv4 类似，示例显示了每个路由器接口都已经配置到不同的 IPv6 子网中。</p><p><strong>路由器R1上的IPv6地址配置</strong></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">R1(config)# interface gigabitethernet 0&#x2F;0&#x2F;0R1(config-if)# ipv6 address 2001:db8:acad:1::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface gigabitethernet 0&#x2F;0&#x2F;1R1(config-if)# ipv6 address 2001:db8:acad:2::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)# interface serial 0&#x2F;1&#x2F;0R1(config-if)# ipv6 address 2001:db8:acad:3::1&#x2F;64R1(config-if)# no shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9、单元检测"><a href="#9、单元检测" class="headerlink" title="9、单元检测"></a>9、单元检测</h1><p>1、当在接口上启用IPv6时，自动分配给接口的地址类型是<strong>链路本地</strong></p><p>2、IPv6网络前缀<strong>FE80::/10</strong>只用于本地链接而不能被路由</p><p>3、成功 ping 通::1 IPv6 地址表示<strong>IP已正确安装在主机上</strong></p><p>4、在启用 IPv6 的接口上，至少需要<strong>本地链路</strong>地址</p><p>5、IPv6全局单播地址的三个部分是：</p><ul><li><strong>用于标识本地企业站点内部网络的子网ID</strong></li><li><strong>用于标识网络上本地主机的接口ID</strong></li><li><strong>一种全局路由前缀，用于标识由ISP提供的地址的网络部分</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十三）</title>
      <link href="/2021/120154066.html"/>
      <url>/2021/120154066.html</url>
      
        <content type="html"><![CDATA[<h1 id="十三、ICMP"><a href="#十三、ICMP" class="headerlink" title="十三、ICMP"></a>十三、ICMP</h1><p>欢迎来学习ICMP！</p><p>假设您有一套复杂的火车组模型。您的轨道和火车全部连接好并通了电，正准备出发。您按下了开关。火车在轨道的中途停了下来。您马上就知道问题很可能出在火车停下的地方，所以您先去那里看看。用网络将其可视化并不容易。幸运的是，有一些工具可以帮助您定位网络中的问题区域，并且它们可以与 IPv4 和 IPv6 网络一起工作！您会很高兴知道，本模块有几个Packet Tracer活动来帮助您练习使用这些工具，所以让我们开始测试吧！</p><p><strong>模块目标</strong>: 使用各种工具测试网络连接。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>ICMP 消息</strong></td><td align="left">说明如何使用 ICMP 测试网络连接。</td></tr><tr><td align="left"><strong>Ping 和 Traceroute 测试</strong></td><td align="left">说明如何使用 Ping 和 Traceroute 实用程序测试网络连接。</td></tr></tbody></table><h1 id="1、ICMP消息"><a href="#1、ICMP消息" class="headerlink" title="1、ICMP消息"></a>1、ICMP消息</h1><h2 id="1-1、ICMPv4-and-ICMPv6消息"><a href="#1-1、ICMPv4-and-ICMPv6消息" class="headerlink" title="1.1、ICMPv4 and ICMPv6消息"></a>1.1、ICMPv4 and ICMPv6消息</h2><p>在本主题中，您会了解不同类型的 Internet 控制消息协议 (ICMP) ，以及用于发送它们的工具。</p><p>虽然 IP 只是“尽最大努力”的协议，但在与另一个IP设备通信时，TCP/IP套件确实提供了错误消息和参考消息。这些消息使用 ICMP 服务发送。其用途是就特定情况下处理 IP 数据包的相关问题提供反馈，而并非是使 IP 可靠。ICMP 消息并非必需的，而且在网络内通常出于安全原因而被禁止。</p><p>ICMP 可同时用于 IPv4 和 IPv6。ICMPv4 是 IPv4 的消息协议。ICMPv6 为 IPv6 提供相同的服务，此外，还包括其他功能。在本课程中，涉及 ICMPv4 和 ICMPv6 时均会使用术语 ICMP。</p><p>ICMP 消息的类型及其发送原因非常多。ICMPv4 和 ICMPv6 通用的 ICMP 消息包括：</p><ul><li>主机联通性</li><li>目的地或服务不可达</li><li>超时</li></ul><h2 id="1-2、主机可接通性"><a href="#1-2、主机可接通性" class="headerlink" title="1.2、主机可接通性"></a>1.2、主机可接通性</h2><p>ICMP Echo消息可用于测试 IP 网络上主机的可达性。本地主机向一台主机发送 ICMP Echo请求。如果主机可用，目的主机会回应以Echo应答。</p><h2 id="1-3、目的地或服务不可达"><a href="#1-3、目的地或服务不可达" class="headerlink" title="1.3、目的地或服务不可达"></a>1.3、目的地或服务不可达</h2><p>当主机或网关收到无法传送的数据包时，它会使用 ICMP 目的地不可达消息通知源主机，目的地或服务无法到达。消息包括指示数据包为何无法传送的代码。</p><p>ICMPv4 的目的地不可达代码示例有：</p><ul><li>0 - 网络不可达。</li><li>1 - 主机不可达。</li><li>2 - 协议不可达。</li><li>3 - 端口不可达。</li></ul><p>ICMPv6 的目的地不可达代码示例有：</p><ul><li>0-没有通往目标的路由。</li><li>1-管理上禁止与目的地通信（例如防火墙）</li><li>2-超出源地址的范围</li><li>3-地址无法访问</li><li>4-端口不可达。</li></ul><p><strong>注意</strong>: ICMPv6 的目的地不可达消息代码与此类似，但稍有不同。</p><h2 id="1-4、超时"><a href="#1-4、超时" class="headerlink" title="1.4、超时"></a>1.4、超时</h2><p>路由器使用 ICMPv4 超时消息表明，因为数据包的生存时间 (TTL) 字段递减到 0 而不能转发该数据包。如果路由器接收数据包并且将 IPv4 数据包的 TTL 字段的值递减为零，则它会丢弃数据包并向源主机发送超时消息。</p><p>如果路由器因数据包过期而无法转发 IPv6 数据包，ICMPv6 也会发送超时消息。ICMPv6使用IPv6跳数限制字段来确定数据包是否已过期，而不是IPv4 TTL字段。</p><p><strong>注意</strong>: <strong>traceroute</strong>工具使用超时消息。</p><h2 id="1-5、ICMPv6消息"><a href="#1-5、ICMPv6消息" class="headerlink" title="1.5、ICMPv6消息"></a>1.5、ICMPv6消息</h2><p>在 ICMPv6 中发现的信息和错误消息非常类似于 ICMPv4 的控制和错误消息。但是，ICMPv6 拥有 ICMPv4 中所没有的新特性和功能提升。ICMPv6 消息封装在 IPv6 中。</p><p>ICMPv6 在邻居发现协议（ND 或 NDP）中包括四个新协议。</p><p>IPv6 路由器和 IPv6 设备之间的消息传递，包括动态地址分配如下所示：</p><ul><li>路由器请求 (RS) 消息</li><li>路由器通告 (RA) 消息</li></ul><p>IPv6 设备之间的消息传递，包括重复的地址检测和地址解析如下所示：</p><ul><li>邻居请求 (NS) 消息</li><li>邻居通告 (NA) 消息</li></ul><p><strong>注意</strong>: ICMPv6 ND 还包括重定向消息，与 ICMPv4 中使用的重定向消息功能相似。</p><h3 id="RA消息"><a href="#RA消息" class="headerlink" title="RA消息"></a>RA消息</h3><p>启用IPv6的路由器每200秒发送RA消息，向启用IPv6的主机提供编址信息。RA 消息中可以包含主机的编址信息，例如前缀、前缀长度、DNS 地址和域名。使用 SLAAC 的主机会将其默认网关设置为发送 RA 的路由器的本地链路地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.1.png"></p><p>R1 发送一条 RA 消息说，“嗨，所有 IPv6设备大家好。我是 R1，您可以使用 SLAAC 创建 IPv6 全局单播地址。前缀是2001:db8:acad:1::/64。顺便说一下，使用我的链接本地地址fe80::1作为你的默认网关。”</p><h3 id="RS消息"><a href="#RS消息" class="headerlink" title="RS消息"></a>RS消息</h3><p>启用IPv6 的路由器还会发送 RA 消息以响应 RS 消息。在图中，PC1 发送 RS 消息以确定如何动态接收其 IPv6 地址信息。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.5.png"></p><p>R1 用 RA 消息回复 RS。</p><ol><li>PC1 发送一条 RS 消息说，“嗨，我刚刚启动。网络上是否有 IPv6 路由器？我需要知道如何动态获取我的 IPv6 地址信息。”</li><li>R1 用 RA 消息回复。“嗨，所有IPv6 设备大家好。我是 R1，您可以使用 SLAAC 创建 IPv6 全局单播地址。前缀是2001:db8:acad:1::/64. 顺便说一下，使用我的链接本地地址fe80::1作为你的默认网关。”</li></ol><h3 id="NS消息"><a href="#NS消息" class="headerlink" title="NS消息"></a>NS消息</h3><p>当设备分配有全局IPv6单播或本地链路单播地址时，则建议对地址执行 重复检测（DAD） 来确保IPv6地址的唯一性。如图所示，要检查地址的唯一性，设备将发送 NS 信息，其中使用自身 IPv6 地址作为目标 IPv6 地址。</p><p>如果网络中的其他设备具有该地址，则会使用 NA 消息进行响应。此 NA 消息通知发送方设备地址已在使用。如果回应的 NA 消息未在固定的一段时间返回，则单播地址是唯一的，可以使用。</p><p><strong>注意</strong>: DAD 不是必需的，但是 RFC 4861 建议对单播地址执行 DAD。</p><p>PC1向自己新配置的IPv6地址发送一个NS邻居请求消息，以确保网络上没有其他主机具有相同的IPv6地址，这是一个DAD，重复地址检测。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.6.png"></p><p>PC1 发送一条 NS 消息来检查地址的唯一性，“谁有 IPv6 地址 2001:db8:acad:1::10，请给我你的 MAC 地址？ “</p><h3 id="NA消息"><a href="#NA消息" class="headerlink" title="NA消息"></a>NA消息</h3><p>当 LAN 上的设备知道目的 IPv6 单播地址，但不知道其以太网 MAC 地址时，会使用地址解析。要确定目的 MAC 地址，设备会将 NS 消息发送到请求节点地址。该消息包括已知（目标）IPv6 地址。具有目标 IPv6 地址的设备会使用包含其以太网 MAC 地址的 NA 消息进行回应。</p><p>在图中，R1向2001:db8:acad:1::10发送一条NS消息，询问它的MAC地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.7.png"></p><ol><li>R1发送一个地址解析NS消息。“谁有IPv6地址2001:db8:acad:1::10，请给我你的MAC地址?”</li><li>PC1 回复了 NA 消息。“我是2001:db8:acad:1::10，我的 MAC 地址是 00:aa:bb:cc:dd:ee。 “</li></ol><h1 id="2、Ping和Traceroute测试"><a href="#2、Ping和Traceroute测试" class="headerlink" title="2、Ping和Traceroute测试"></a>2、Ping和Traceroute测试</h1><h2 id="2-1、Ping-测试连接性"><a href="#2-1、Ping-测试连接性" class="headerlink" title="2.1、Ping-测试连接性"></a>2.1、Ping-测试连接性</h2><p>在上一主题中，介绍了 <strong>ping</strong> 和跟踪路由 (<strong>tracert</strong>) 工具。在本主题中，您将了解每个工具的使用情况以及如何使用它们。Ping 是一种测试程序，它使用 ICMP Echo请求和Echo应答消息来测试主机之间的连接。</p><p>为了测试与网络上的另一台主机的连接，可使用 <strong>ping</strong> 命令将回应请求发送给该主机地址。若指定地址处的主机收到回应请求，便会使用Echo应答进行响应。每收到一个Echo应答，<strong>ping</strong>都会提供发出请求与收到应答的时间反馈。这可以作为网络性能的度量。</p><p>Ping 对响应规定了超时值。如果在超时前没有收到应答，ping 会提供一条消息，表示未收到响应。这可能表示存在问题，但是，还可能表示在网络上启用了阻止 ping 消息的安全功能。如果在发送ICMP Echo请求之前需要执行地址解析(ARP或ND)，那么第一次ping通常会超时。</p><p>所有请求发送完毕后，<strong>ping</strong>实用程序会提供摘要，包括成功率和到达目的地的平均往返时间。</p><p>使用<strong>ping</strong>进行的连通性测试的类型包括:</p><ul><li>Ping 本地环回</li><li>向默认网关发出 ping 命令</li><li>Ping 远程主机</li></ul><h2 id="2-2、对回环执行ping命令"><a href="#2-2、对回环执行ping命令" class="headerlink" title="2.2、对回环执行ping命令"></a>2.2、对回环执行ping命令</h2><p>Ping可用于测试本地主机上IPv4或IPv6的内部配置。要执行此测试，对于 IPv4，我们<strong>ping</strong>本地环回地址 127.0.0.1，对于 IPv6，则是 ::1。</p><p>从 127.0.0.1 接收的 IPv4 响应或从 ::1 接收的 IPv6 响应，表示主机上的 IP 安装正确。此响应来自网络层。但是，此响应并不代表地址、掩码或网关配置正确。它也不能说明有关网络协议栈下层的任何状态。它只测试 IP 网络层的 IP 连接。如果收到错误消息，则表示该主机上的 TCP/IP 无法正常运行。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.2.png"></p><ul><li>对本地主机执行 Ping 操作可确认本地主机上已采用 TCP/IP 并且工作正常。</li><li>对 127.0.0.1 执行 ping 操作导致设备对自身执行 ping 操作。</li></ul><h2 id="2-3、向默认网关发出ping命令"><a href="#2-3、向默认网关发出ping命令" class="headerlink" title="2.3、向默认网关发出ping命令"></a>2.3、向默认网关发出ping命令</h2><p>您也可以使用<strong>ping</strong> 测试主机在本地网络中通信的能力。这通常是通过 ping 主机网关 IP 地址完成的。成功 <strong>ping</strong>通网关表示主机和充当网关的路由器接口在本地网络中均运行正常。</p><p>对于此测试，最常用的是网关地址，因为路由器在一般情况下始终都能正常运行。如果网关地址不响应，可以将<strong>ping</strong>发送到本地网络上已知能够正常运行的另一台主机的 IP 地址。</p><p>如果网关或另一台主机做出响应，则说明本地主机可以通过本地网络成功通信。如果网关不响应但其另一台主机响应，可能说明充当网关的路由器接口存在问题。</p><p>一种可能性是在主机上配置了错误的网关地址。另一种可能原因是路由器接口完全正常，但对其采取了阻止其处理或响应 ping 请求的安全限制。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN13.3.png"></p><p>主机会 ping 其默认网关，发送 ICMP Echo请求。默认网关会发送Echo应答，确认连接。</p><h2 id="2-4、Ping远程主机"><a href="#2-4、Ping远程主机" class="headerlink" title="2.4、Ping远程主机"></a>2.4、Ping远程主机</h2><p>Ping 也可用于测试本地主机跨互联网通信的能力。如图所示，本地主机可以 ping 远程网络中运行正常的 IPv4 主机。路由器使用其 IP 路由表转发数据包。</p><p>如果 ping 成功，则说明网际网络大部分运行正常。在互联网络上成功 <strong>ping</strong>通即确认本地网络上的通信正常，充当网关的路由器运行正常，且可能位于本地网络和远程主机网络之间路径上的所有其他路由器运行正常。</p><p>此外，还可以验证远程主机的功能。如果远程主机无法在其本地网络外通信，则它不会响应。</p><p><strong>注意</strong>:许多网络管理员限制或禁止 ICMP 消息进入企业网络；因此，没有收到<strong>ping</strong>响应可能是由于安全限制。</p><h2 id="2-5、Traceroute-测试路径"><a href="#2-5、Traceroute-测试路径" class="headerlink" title="2.5、Traceroute-测试路径"></a>2.5、Traceroute-测试路径</h2><p>Ping 用于测试两台主机之间的连接，但是不提供关于主机之间设备的详细信息。Traceroute <strong>tracert</strong>实用程序可以生成通信路径上成功到达的设备列表。此列表可以提供重要的验证和故障排除信息。如果数据到达目的地，则 Trace 就会列出主机之间的路径中每台路由器上的接口。如果数据在沿途的某一跳上失败，则回应 Trace 的最后一个路由器的地址可以提供指示，说明发现问题或有安全限制的地方。</p><p><strong>往返时间</strong></p><p>Traceroute 可提供沿路径每一跳的往返时间并指示是否有某一跳未响应。往返时间是数据包到达远程主机以及从该主机返回响应所花费的时间。星号 (*) 用于表示丢失的或无应答的数据包。</p><p>此信息可用于在路径中定位有问题的路由器，或表示路由器配置为不应答。如果显示器显示特定的某一跳响应时间长或数据丢失，这表示该路由器的资源或其连接可能压力过大。</p><p><strong>IPv4 TTL 和 IPv6 跳数限制</strong></p><p>Traceroute 使用第 3 层报头中的 IPv4 TTL 字段功能和 IPv6 跳数限制字段功能以及 ICMP 超时消息。</p><p>从 Traceroute 发送的第一个消息序列的 TTL 字段值为 1。这会导致此 TTL 使 IPv4 数据包在第一台路由器处超时。该路由器使用 ICMPv4 超时消息作为响应。现在，Traceroute 知道了第一跳的地址。</p><p>随后，Traceroute 逐渐增加每个消息系列的 TTL 字段值（2、3、4…）。这可为 Trace 提供数据包在该路径沿途再次超时所经过的每一跳的地址。TTL 字段的值将不断增加，直至到达目的主机或增至预定义的最大值。</p><p>到达最终目的主机后，该主机将不再以 ICMP 超时消息做出应答，而会以 ICMP 端口无法到达消息或 ICMP Echo应答消息做出应答。</p><h2 id="2-6、Packet-Tracer-验证IPv4和IPv6编址"><a href="#2-6、Packet-Tracer-验证IPv4和IPv6编址" class="headerlink" title="2.6、Packet Tracer - 验证IPv4和IPv6编址"></a>2.6、Packet Tracer - 验证IPv4和IPv6编址</h2><p>略</p><h2 id="2-7、Packet-Tracer-使用Ping-和Traceroute-测试网络连接"><a href="#2-7、Packet-Tracer-使用Ping-和Traceroute-测试网络连接" class="headerlink" title="2.7、Packet Tracer - 使用Ping 和Traceroute 测试网络连接"></a>2.7、Packet Tracer - 使用Ping 和Traceroute 测试网络连接</h2><p>略</p><h2 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h2><p>1、IPv4 和 IPv6 使用<strong>ICMP</strong>协议来提供错误消息</p><p>2、在路由器上输入ping 命令时，最常见的指示符如下所示：</p><ul><li><strong>!</strong> - 表示收到一个 ICMP Echo 应答消息</li><li><strong>.</strong> - 表示超时，正在等待 ICMP Echo应答消息</li><li><strong>U</strong> - 表示收到了一个 ICMP 无法到达的消息</li></ul><p>3、<strong>ping</strong> 命令提供有关向远程主机发送Echo请求和收到Echo应答之间时间的反馈。这可以作为网络性能的度量。一个成功的<strong>ping</strong>操作还可以表明是否可以通过网络到达目的主机。</p><p>4、<strong>ping 127.0.0.1</strong> 命令用于验证 TCP/IP 堆栈是否正常工作。这条命令可以验证从网络层到物理层再返回网络层的协议栈是否工作正常，而不会向网络介质发送任何信号。也就是说，这个测试不会超出PC本身的范畴。例如，它不检测电缆是否连接到 PC。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十一）</title>
      <link href="/2021/112320273.html"/>
      <url>/2021/112320273.html</url>
      
        <content type="html"><![CDATA[<p>十一、IPv4编址</p><p>目前，仍有大量使用IPv4编址的网络，即这些组织正在向IPv6过渡。因此，对于网络管理员来说，了解有关IPv4编址的所有信息仍然非常重要。本模块详细介绍了IPv4编址的基本方面。它包括了如何将网络划分为子网，以及如何创建一个变长子网掩码 (VLSM) 作为整体IPv4编址方案的一部分。</p><p><strong>模块目标</strong>: 计算 IPv4 子网划分方案，有效执行网络分段。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>IPv4 地址结构</strong></td><td align="left">描述 IPv4 地址的结构,包括网络 部分、主机部分和子网掩码。</td></tr><tr><td align="left"><strong>IPv4 单播、广播和组播</strong></td><td align="left">比较单播、广播和组播 IPv4 地址的 特征和用途。</td></tr><tr><td align="left"><strong>IPv4 地址的分类</strong></td><td align="left">说明公有、私有和保留 IPv4 地址。</td></tr><tr><td align="left"><strong>⁪网络分段</strong></td><td align="left">说明如何通过在网络中划分子网来优化 通信。</td></tr><tr><td align="left"><strong>IPv4 网络的子网</strong></td><td align="left">说明如何计算 IPv4 子网的 /24 前缀长度。</td></tr><tr><td align="left"><strong>/16 和 /8 前缀的子网</strong></td><td align="left">说明如何计算 IPv4 子网的 /16 和 /8 前缀长度。</td></tr><tr><td align="left"><strong>按照要求划分子网</strong></td><td align="left">说明如何根据一组给定的子网划分要求,实施IPv4 编址方案。</td></tr><tr><td align="left"><strong>变长子网掩码</strong></td><td align="left">说明如何使用变长子网掩码 (VLSM) 创建 灵活的编址方案。</td></tr><tr><td align="left"><strong>结构化设计</strong></td><td align="left">实施 VLSM 编址方案。</td></tr></tbody></table><h1 id="1、IPv4地址结构"><a href="#1、IPv4地址结构" class="headerlink" title="1、IPv4地址结构"></a>1、IPv4地址结构</h1><h2 id="1-1、网络部分和主机部分"><a href="#1-1、网络部分和主机部分" class="headerlink" title="1.1、网络部分和主机部分"></a>1.1、网络部分和主机部分</h2><p>IPv4 地址为32位分层地址，由网络部分和主机部分两个部分组成。在确定网络部分和主机部分时，必须先查看 32 位数据流，如图所示。</p><p><strong>IPv4地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.1.png"></p><p><strong>对于同一网络中的所有设备，地址的网络部分中的位必须完全相同。地址的主机部分中的位必须唯一，</strong>这方便识别网络中的特定主机。如果两台主机在 32 位数据流中的指定网络部分有相同的位模式，则这两台主机位于同一网络。</p><p>但是，主机如何知道 32 位数据流中的哪一部分用于标识网络，哪一部分用于标识主机呢？这就是子网掩码的作用。</p><h2 id="1-2、子网掩码"><a href="#1-2、子网掩码" class="headerlink" title="1.2、子网掩码"></a>1.2、子网掩码</h2><p>如图所示，为主机分配 IPv4 地址需要以下内容：</p><ul><li><strong>IPv4 地址</strong> - 这是主机的唯一 IPv4 地址。</li><li><strong>子网掩码</strong> - 用于标识 IPv4 地址的网络部分/主机部分。</li></ul><p><strong>Windows计算机上的IPv4配置</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.2.png"></p><p><strong>注意:</strong> 访问远程网络需要一个默认网关IPv4地址，将域名转换为IPv4地址需要DNS服务器的IPv4地址。</p><p>IPv4子网掩码用于将地址的网络部分与IPv4地址的主机部分区分开来。当把 IPv4 地址分配给一台设备时，该设备使用子网掩码来确定设备的网络地址。网络地址代表同一网络中的所有设备的地址。</p><p>下图以点分十进制和二进制格式显示了32位子网掩码。</p><p><strong>子网掩码</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.3.png"></p><p>请注意子网掩码是一个1位连续序列，后面跟有一个0位连续序列组成的序列。</p><p>为了确定 IPv4 地址的网络部分和主机部分，要将子网掩码与 IPv4 地址进行从左到右逐位比较（如图所示）。</p><p><strong>将IPv4地址与其子网掩码关联</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.4.png"></p><p>注意，子网掩码实际上不包含 IPv4 地址的网络部分或主机部分，它仅通知计算机在哪里查找IPv4地址的网络部分和主机部分。</p><p>用于确定网络部分和主机部分的实际流程叫做 AND 运算。</p><h2 id="1-3、前缀长度"><a href="#1-3、前缀长度" class="headerlink" title="1.3、前缀长度"></a>1.3、前缀长度</h2><p>使用点分十进制子网掩码地址表示网络地址和主机地址会变得很麻烦。幸运的是，还有另一种识别子网掩码的方法，称为前缀长度。</p><p>前缀长度是子网掩码中设置为 1 的位数。使用“斜线记法”写入，即“/”紧跟设置为 1 的位数。借此计算子网掩码中的位数，并在前面加斜线表示。</p><p>请参阅下表示例：第一列中列出了主机地址使用的各种子网掩码。第二列显示转换的 32 位二进制地址。最后一列显示最终的前缀长度。</p><p><strong>Comparing the Subnet Mask and Prefix Length</strong></p><table><thead><tr><th align="left"><strong>子网掩码</strong></th><th align="left"><strong>32 位地址</strong></th><th align="left"><strong>前缀长度</strong></th></tr></thead><tbody><tr><td align="left">255.0.0.0</td><td align="left"><code>11111111.00000000.00000000.00000000</code></td><td align="left">/8</td></tr><tr><td align="left">255.255.0.0</td><td align="left"><code>11111111.11111111.00000000.00000000</code></td><td align="left">/16</td></tr><tr><td align="left">255.255.255.0</td><td align="left"><code>11111111.11111111.11111111.00000000</code></td><td align="left">/24</td></tr><tr><td align="left">255.255.255.128</td><td align="left"><code>11111111.11111111.11111111.10000000</code></td><td align="left">/25</td></tr><tr><td align="left">255.255.255.192</td><td align="left"><code>11111111.11111111.11111111.11000000</code></td><td align="left">/26</td></tr><tr><td align="left">255.255.255.224</td><td align="left"><code>11111111.11111111.11111111.11100000</code></td><td align="left">/27</td></tr><tr><td align="left">255.255.255.240</td><td align="left"><code>11111111.11111111.11111111.11110000</code></td><td align="left">/28</td></tr><tr><td align="left">255.255.255.248</td><td align="left"><code>11111111.11111111.11111111.11111000</code></td><td align="left">/29</td></tr><tr><td align="left">255.255.255.252</td><td align="left"><code>11111111.11111111.11111111.11111100</code></td><td align="left">/30</td></tr></tbody></table><p><strong>注意</strong>: 网络地址也称为前缀或网络前缀。因此，前缀长度是子网掩码中设置为 1 的位数。</p><p>当使用前缀长度表示 IPv4 地址时，IPv4 地址后面写入不带空格的前缀长度。例如，192.168.10.10 255.255.255.0可以写成192.168.10.10/24。后面将讨论各种类型前缀长度的使用。目前，重点是 /24（例如 255.255.255.0）前缀。</p><h2 id="1-4、确定网络：逻辑与（AND）"><a href="#1-4、确定网络：逻辑与（AND）" class="headerlink" title="1.4、确定网络：逻辑与（AND）"></a>1.4、确定网络：逻辑与（AND）</h2><p>逻辑与(AND)是布尔或数字逻辑中使用的三种布尔运算之一。另外两种是或(OR)和非(NOT)。使用“与”运算来确定网络地址。</p><p>逻辑与运算比较两个位，所得结果如下所示。注意只有 1 AND 1 等于 1。任何其他组合都会产生 0。</p><ul><li>1 AND 1 = 1</li><li>0 AND 1 = 0</li><li>1 AND 0 = 0</li><li>0 AND 0 = 0</li></ul><p><strong>注意</strong>: 在数字逻辑中，1 表示真，0 表示假。使用AND运算时，两个输入值都必须为 True (1)，结果才能为 True (1)。</p><p>要确定 IPv4 主机的网络地址，应将 IPv4 地址与子网掩码逐位进行逻辑 AND 运算。地址和子网掩码之间的 AND 运算得到的结果就是网络地址。</p><p>要举例说明 AND 是如何用于发现网络地址的，假设主机的 IPv4 地址为 192.168.10.10，子网掩码为 255.255.255.0，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.5.png"></p><ul><li><strong>IPv4 主机地址 (192.168.10.10)</strong> -主机的 IPv4 地址，采用点分十进制和二进制格式。</li><li><strong>子网掩码 (255.255.255.0)</strong> -主机的子网掩码，采用点分十进制和二进制格式。</li><li><strong>网络地址 (192.168.10.0)</strong> -IPv4地址和子网掩码之间的逻辑AND运算产生一个点分十进制和二进制格式的IPv4网络地址。</li></ul><p>以第一个位序列为例，请注意AND运算是在主机地址的1位和子网掩码的1位上执行的。这将产生网络地址的 1 位。1 AND 1 = 1。</p><p>IPv4 主机地址和子网掩码之间的AND运算过程，产生主机的 IPv4 网络地址。在此示例中，主机地址 192.168.10.10 与子网掩码 255.255.255.0 (/24) 之间的 AND运算会产生 IPv4 网络地址为192.168.10.0/24。这是一个重要的 IPv4运算，因为它会告诉主机其所属的网络。</p><h2 id="1-5、视频-网络地址、主机地址和广播地址"><a href="#1-5、视频-网络地址、主机地址和广播地址" class="headerlink" title="1.5、视频-网络地址、主机地址和广播地址"></a>1.5、视频-网络地址、主机地址和广播地址</h2><p>略</p><h2 id="1-6、网络地址、主机地址和广播地址"><a href="#1-6、网络地址、主机地址和广播地址" class="headerlink" title="1.6、网络地址、主机地址和广播地址"></a>1.6、网络地址、主机地址和广播地址</h2><p>在每个网络中有三种类型的 IP 地址：</p><ul><li>网络地址</li><li>主机地址</li><li>广播地址</li></ul><p>使用图中的拓扑，将检查这三种类型的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.6.png"></p><p><strong>网络地址</strong></p><p>网络地址是表示特定网络的地址。如果设备满足以下三个条件，则属于此网络：</p><ul><li>它具有与网络地址相同的子网掩码。</li><li>它具有与网络地址相同的网络位，如子网掩码所示。</li><li>它与具有相同网络地址的其他主机位于同一广播域中。</li></ul><p>主机通过在其 IPv4 地址与其子网掩码之间执行一个AND运算来确定其网络地址。</p><p>如表中所示，由子网掩码确定的网络地址在主机部分中包含所有 0 位。在此示例中，网络地址是 192.168.10.0/24。无法将网络地址分配给设备</p><p><strong>Network, Host, and Broadcast Addresses</strong></p><table><thead><tr><th align="left"></th><th align="center"><strong>网络部分</strong></th><th align="center"><strong>主机部分</strong></th><th align="center"><strong>主机位数</strong></th></tr></thead><tbody><tr><td align="left">子网掩码<strong>为255.255.255.<strong>0或</strong>/24</strong></td><td align="center"><code>255      255      25511111111 11111111 11111111</code></td><td align="center"><code>000000000</code></td><td align="center"></td></tr><tr><td align="left">网络地址<strong>为 192.168.10.<strong>0或</strong>/24</strong></td><td align="center"><code>192      168       1011000000 10100000 00001010</code></td><td align="center"><code>000000000</code></td><td align="center">全都是0</td></tr><tr><td align="left">第一个地址<strong>192.168.10</strong>.1或**/24**</td><td align="center"><code>192      168       1011000000 10100000 00001010</code></td><td align="center"><code>100000001</code></td><td align="center">除最后一位为1以外其他位全是0位</td></tr><tr><td align="left">最后一个地址 <strong>192.168.10</strong>.254或**/24**</td><td align="center"><code>192      168       1011000000 10100000 00001010</code></td><td align="center"><code>25411111110</code></td><td align="center">除最后一位为0以外其他位全是1位</td></tr><tr><td align="left">广播地址 <strong>192.168.10</strong>.255或**/24**</td><td align="center"><code>192      168       1011000000 10100000 00001010</code></td><td align="center"><code>25511111111</code></td><td align="center">全都是1</td></tr></tbody></table><p><strong>主机地址</strong></p><p>主机地址是可以分配给设备的地址，如主机，笔记本电脑，智能手机，网络摄像头，打印机，路由器等。地址的主机部分是由子网掩码中 0 位表示的位。除了全0位（这将是网络地址）或全1位（这将是广播地址）之外，主机地址在主机部分可以有任何位的组合。</p><p>同一网络中的所有设备，必须具有相同的子网掩码和相同的网络位。只有主机位会有所不同，且必须是唯一的。</p><p>请注意表中，有第一个和最后一个主机地址：</p><ul><li><strong>第一个主机地址</strong> -网络中的第一个主机，除最后一位（最右边）为1位外包含所有0位。在这个例子中，它的地址是192.168.10.1/24。</li><li><strong>最后一个主机地址</strong> -网络中的最后一个主机，除最后一位（最右边）为0位外包含所有1位。在这个例子中，它的地址是192.168.10.254/24。</li></ul><p>从192.168.10.1/24到192.168.10.254/24之间（包含）的任何地址都可以分配给网络上的设备。</p><p><strong>广播地址</strong></p><p>广播地址是在需要访问IPv4网络上的所有设备时使用的地址。如表中所示，由子网掩码确定的网络广播地址在主机部分中包含所有 1 位。在此示例中，网络地址是 192.168.10.255/24。无法将广播地址分配给设备。</p><h1 id="2、IPv4单播、广播和组播"><a href="#2、IPv4单播、广播和组播" class="headerlink" title="2、IPv4单播、广播和组播"></a>2、IPv4单播、广播和组播</h1><h2 id="2-1、单播"><a href="#2-1、单播" class="headerlink" title="2.1、单播"></a>2.1、单播</h2><p>在上一个主题中，您了解了 IPv4 地址的结构；每个地址都有一个网络部分和一个主机部分。从源设备发送数据包有不同的方法，这些不同的传输影响目的IPv4地址。</p><p>单播传输是指在一对一通信中，一个设备向另一个设备发送消息。</p><p>单播数据包具有一个目的 IP 地址，该地址是一个单播地址，该地址指向一个单独的接收者。源 IP 地址只能是单播地址，因为数据包只能来自单个源。这与目的IP地址是单播、广播还是组播无关。</p><p><strong>注意</strong>: 在本课程中，除非另行说明，否则设备之间的所有通信均指单播通信。</p><p>IPv4 单播主机地址的地址范围是 1.1.1.1到 223.255.255.255。不过，此范围中的很多地址被留作特殊用途。这些特殊用途的地址将在本模块后续部分讨论。</p><h2 id="2-2、广播"><a href="#2-2、广播" class="headerlink" title="2.2、广播"></a>2.2、广播</h2><p>广播播传输是指设备在一对多通信中，向网络上的所有设备发送消息。</p><p>广播数据包以主机部分全部为 1 的地址或32个1位作为目的 IP地址。</p><p><strong>注意: IPv4使用广播数据包但是，IPv6没有广播数据包。</strong></p><p>广播数据包必须由同一广播域中的所有设备处理。广播域标识同一网段上的所有主机。可以对广播进行定向或限制。定向广播是将数据包发送给特定网络中的所有主机。例如，位于 172.16.4.0/24 网络的主机向 172.16.4.255 发送数据包。受限广播将被发送至 255.255.255.255。默认情况下，路由器不转发广播。</p><p>广播数据包使用网络上的资源，使网络上的所有接收主机都处理该数据包。因此，广播通信应加以限制，以免对网络或设备的性能造成负面影响。因为路由器可分隔广播域，所以细分网络可以通过消除过多的广播通信来提高网络性能。</p><p><strong>IP直接广播</strong></p><p>除了 255.255.255.255 的广播地址外，每个网络还有一个广播 IPv4 地址。这个地址称为定向广播，它使用网络范围内的最大地址，即所有主机位全部为 1 的地址。例如，网络192.168.1.0/24的定向广播地址是192.168.1.255。此地址允许与该网络中的所有主机进行通信。要向网络中的所有主机发送数据，主机只需以该网络广播地址为目标地址发送一个数据包即可。</p><p>未直接连接到目标网络的设备转发 IP 定向广播，其方式与转发去往网络上主机的单播 IP 数据包相同。当定向广播数据包到达直接连接到目标网络的路由器时，该数据包在目标网络上进行广播。</p><p><strong>注意</strong>: 由于安全问题和恶意用户的滥用，从思科 IOS 版本 12.0 开始通过全局配置命令 <strong>no ip directed-broadcasts</strong>，定向广播在默认情况下是关闭的。</p><h2 id="2-3、组播"><a href="#2-3、组播" class="headerlink" title="2.3、组播"></a>2.3、组播</h2><p>主机通过组播传输可以向所属组播组中的选定主机组发送一个数据包，从而减少了流量。</p><p>组播数据包是一个目的IP地址为组播地址的数据包。IPv4 将 224.0.0.0 到 239.255.255.255 的地址保留为组播范围。</p><p>接收特定组播数据包的主机称为组播客户端。<strong>组播客户端使用客户端程序请求的服务来加入组播组。</strong></p><p><strong>每个组播组由一个 IPv4 组播目的地址代表。</strong>当 IPv4 主机加入组播组后，该主机既要处理目的地址为此组播地址的数据包，也要处理发往其唯一单播地址的数据包。</p><p><strong>路由协议（如 OSPF）使用组播传输。</strong>例如，启用 OSPF 的路由器使用保留的 OSPF 组播地址 224.0.0.5 相互通信。只有启用 OSPF 的设备才会以 224.0.0.5 作为目的 IPv4 地址处理这些数据包。所有其他设备将忽略这些数据包。</p><h2 id="2-4、Activity-Unicast-Broadcast-or-Multicast"><a href="#2-4、Activity-Unicast-Broadcast-or-Multicast" class="headerlink" title="2.4、Activity - Unicast,Broadcast,or Multicast"></a>2.4、Activity - Unicast,Broadcast,or Multicast</h2><p>略</p><h1 id="3、IPv4地址的分类"><a href="#3、IPv4地址的分类" class="headerlink" title="3、IPv4地址的分类"></a>3、IPv4地址的分类</h1><h2 id="3-1、公有和私有的IPv4地址"><a href="#3-1、公有和私有的IPv4地址" class="headerlink" title="3.1、公有和私有的IPv4地址"></a>3.1、公有和私有的IPv4地址</h2><p>正如有不同的方式传输 IPv4 数据包一样，也有不同类型的 IPv4 地址。一些 IPv4 地址不能用于外联到互联网，而其他地址则专门用于路由到互联网。一些用于验证连接，另一些则是自分配的。作为网络管理员，您最终将非常熟悉 IPv4 地址的类型，但现在，您至少应该知道它们是什么以及何时使用它们。</p><p>公有 IPv4 地址是能在 ISP（互联网运营商）路由器之间全局路由的地址。但是，并非所有可用的 IPv4 地址都可用于互联网。大多数组织使用称为私有地址的地址块向内部主机分配 IPv4 地址。</p><p>20 世纪 90 年代中期，随着万维网(WWW)的引入，由于 IPv4 地址空间耗尽，引入了私有 IPv4 地址。私有 IPv4 地址并不是唯一的，可以在任何网络内部使用它。</p><p><strong>注意</strong>: IPv4 地址耗尽的长期解决方案是 IPv6。</p><h3 id="The-Private-Address-Blocks"><a href="#The-Private-Address-Blocks" class="headerlink" title="The Private Address Blocks"></a>The Private Address Blocks</h3><table><thead><tr><th align="left"><strong>网络地址和前缀</strong></th><th align="left"><strong>RFC 1918 私有地址范围</strong></th></tr></thead><tbody><tr><td align="left">10.0.0.0/8</td><td align="left">10.0.0.0 - 10.255.255.255</td></tr><tr><td align="left">172.16.0.0/12</td><td align="left">172.16.0.0 - 172.31.255.255</td></tr><tr><td align="left">192.168.0.0/16</td><td align="left">192.168.0.0 - 192.168.255.255</td></tr></tbody></table><p><strong>注意</strong>: 私有地址在 RFC 1918 中定义，有时也称为 RFC 1918 地址空间。</p><h2 id="3-2、路由到互联网"><a href="#3-2、路由到互联网" class="headerlink" title="3.2、路由到互联网"></a>3.2、路由到互联网</h2><p>大多数内部网络（从大型企业到家庭网络）都使用私有 IPv4 地址来编址所有内部设备（Intranet），包括主机和路由器。但是，私有地址不可全局路由。</p><p>在图中，客户网络 1、2 和 3 正在其内部网络之外发送数据包。这些数据包有一个源IPv4地址，它是一个私有地址，还有一个目的IPv4地址，它是公有地址(全局可路由)。在将数据包转发给ISP之前，必须过滤(丢弃)带有私有地址的数据包或将其转换为公有地址。</p><h3 id="私有-IPv4-地址和网络地址转换-NAT"><a href="#私有-IPv4-地址和网络地址转换-NAT" class="headerlink" title="私有 IPv4 地址和网络地址转换 (NAT)"></a>私有 IPv4 地址和网络地址转换 (NAT)</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.35.png"></p><p>在 ISP 可以转发此数据包之前，它必须使用网络地址转换 (NAT) 将源 IPv4 地址（即私有地址）转换为公有 IPv4 地址。NAT用于转换私有和公有 IPv4 地址。这通常是在将内部网络连接到 ISP 网络的路由器上完成。在路由到互联网之前，组织内部网中的私有 IPv4 地址将被转换为公有 IPv4 地址。</p><p><strong>注意</strong>: 虽然具有私有 IPv4 地址的设备无法通过互联网从另一个设备直接访问，但 IETF 并不认为私有 IPv4 地址或 NAT 是有效的安全措施。</p><p>拥有可用于互联网的资源的组织（如 Web 服务器）也将拥有具有公有 IPv4 地址的设备。如图所示，该网络的这一部分被称为DMZ（非军事区）。图中的路由器不仅执行路由，还执行 NAT 并充当安全防火墙。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.7.png"></p><p><strong>注意:</strong> 私有 IPv4 地址通常用于教育目的，而不是使用最有可能属于组织的公有 IPv4 地址。</p><h2 id="3-3、练习-通过或阻止IPv4地址"><a href="#3-3、练习-通过或阻止IPv4地址" class="headerlink" title="3.3、练习-通过或阻止IPv4地址"></a>3.3、练习-通过或阻止IPv4地址</h2><p>即3.1的表格</p><h2 id="3-4、专用IPv4地址"><a href="#3-4、专用IPv4地址" class="headerlink" title="3.4、专用IPv4地址"></a>3.4、专用IPv4地址</h2><p>一些地址，比如网络地址和广播地址不能分配给主机。还有些特殊地址可以分配给主机，但这些主机在网络内的交互方式却受到限制。</p><p><strong>环回地址</strong></p><p>环回地址（127.0.0.0 /8 或 127.0.0.1 到 127.255.255.254）通常仅被标识为127.0.0.1，主机使用这些特殊地址将流量指向其自身。注意 127.0.0.1 环回地址对<strong>ping</strong>命令的应答。也要注意该块中的任何地址是如何环回到本地主机的，如图的第二个<strong>ping</strong>所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.8.png"></p><p><strong>本地链路地址</strong></p><p>本地链路地址（169.254.0.0 /16 或 169.254.0.1 至 169.254.255.254）通常称为自动私有 IP 编址 (APIPA) 地址或自分配地址。 当没有可用的DHCP服务器时，Windows DHCP客户端使用它们进行自我配置。本地链路地址可以用于点对点连接，但通常不用于此目的。</p><h2 id="3-5、传统有类编址"><a href="#3-5、传统有类编址" class="headerlink" title="3.5、传统有类编址"></a>3.5、传统有类编址</h2><p>1981 年，使用在RFC 790 中 Assigned Numbers 部分定义的有类编址对 IPv4 地址进行了分配。根据三个类别（A 类、B 类或 C 类）之一为客户分配网络地址。RFC 将单播范围分为具体的类别：</p><ul><li><strong>A 类 (0.0.0.0/8 - 127.0.0.0/8)</strong> -用于支持拥有 1600 万以上主机地址的规模非常大的网络。A类的第一个八位组使用固定的 /8 前缀表示网络地址，其他的三个八位组表示主机地址(每个网络支持1600 万以上主机地址)。</li><li><strong>B 类 (128.0.0.0 /16 – 191.255.0.0 /16)</strong> - 用于支持拥有大约 65,000 个主机地址的大中型网络。B类的两个高位八位组使用固定的 /16 前缀表示网络地址，其他的两个八位组表示主机地址(每个网络支持65,000个以上主机地址)。</li><li><strong>C 类 (192.0.0.0 /24 – 223.255.255.0 /24)</strong> - 用于支持最多拥有 254 台主机的小型网络。C类的前三个八位组使用固定的 /24 前缀表示网络地址，其余的八位组表示主机地址（每个网络中只有254个主机地址）。</li></ul><p><strong>注意</strong>: 还有包含 224.0.0.0 到 239.0.0.0 的 D 类组播块以及包含 240.0.0.0 – 255.0.0.0 的 E 类实验地址块。</p><p>当时，由于使用互联网的计算机数量有限，有类编址是分配地址的有效手段。如图所示，A 类和 B 类网络具有非常多的主机地址，而C类只有很少的主机地址。A 类网络占 IPv4 网络的 50%。这导致大多数可用的 IPv4 地址未被使用。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.9.png"></p><p>二十世纪90年代中期，随着万维网 (WWW) 的引入，有类编址被弃用，以便更有效地分配有限的 IPv4 地址空间。有类地址分配被替换为今天使用的无类编址。无类编址会忽略A、B、C类的规则。公有 IPv4 网络地址（网络地址和子网掩码）是根据合理的地址数量分配的。</p><h2 id="3-6、IP地址的分配"><a href="#3-6、IP地址的分配" class="headerlink" title="3.6、IP地址的分配"></a>3.6、IP地址的分配</h2><p>公有 IPv4 地址是能通过互联网全局路由的地址。公有 IPv4 地址必须是唯一的。</p><p>IPv4 和 IPv6 地址是通过互联网编号指派机构 (IANA) 管理的。IANA 管理并向地区性互联网注册机构 (RIR) 分配 IP 地址块。图中显示了五个RIR。</p><p>RIR 的职责是向 ISP 分配 IP 地址，而 ISP 将向组织和更小的 ISP 提供 IPv4 地址块。根据 RIR 的政策规定，组织也可直接从 RIR 获取地址。</p><p><strong>Regional Internet Registries</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.10.png"></p><ul><li><strong>AfriNIC</strong> (非洲网络信息中心) - 非洲地区</li><li><strong>APNIC</strong> (亚太网络信息中心) - 亚太地区</li><li><strong>ARIN</strong> (美洲互联网号码注册管理机构) - 北美地区</li><li><strong>LACNIC</strong> (拉丁美洲及加勒比互联网地址注册管理机构) - 拉丁美洲和部分加勒比海岛屿</li><li><strong>RIPE NCC</strong> (欧洲 IP 地址注册中心) - 欧洲、中东和中亚</li></ul><h2 id="3-7、Activity-Public-or-Private-IPv4-Address"><a href="#3-7、Activity-Public-or-Private-IPv4-Address" class="headerlink" title="3.7、Activity - Public or Private IPv4 Address"></a>3.7、Activity - Public or Private IPv4 Address</h2><p>见3.1的表格</p><h1 id="4、网络分段"><a href="#4、网络分段" class="headerlink" title="4、网络分段"></a>4、网络分段</h1><h2 id="4-1、广播域和分段"><a href="#4-1、广播域和分段" class="headerlink" title="4.1、广播域和分段"></a>4.1、广播域和分段</h2><p>您是否收到过群发给您公司或学校每个人的电子邮件？这就是一个广播电子邮件。它包含了您们每个人都需要知道的信息。但是，通常广播并不是与邮件列表中的每个人都相关。有时候，只有一部分人需要阅读这些信息。</p><p>在以太网局域网中，设备使用广播和地址解析协议 (ARP) 来定位其他设备。地址解析协议 (ARP)将第 2 层广播发送到本地网络上的已知 IPv4 地址，以发现相关 MAC 地址。以太网局域网上的设备还可以使用服务定位其他设备。主机通常需要使用动态主机配置协议 (DHCP) 来获取 IPv4 地址配置，这会发送本地网络上的广播来定位 DHCP 服务器。</p><p>交换机会将广播传播到所有接口，接收它的接口除外。例如，如果图中的交换机接收到广播，则它会将其转发到网络上连接的其他交换机和其他用户。</p><p><strong>路由器分段广播域</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.11.png"></p><p>路由器不传播广播。路由器在收到广播时，它不会将其转发到其他接口。例如，当 R1 在其 Gigabit Ethernet 0/0 接口收到广播时，它不会将其转发到另一个接口。</p><p>因此，每个路由器接口都连接了一个广播域，而广播只能在特定广播域内传播。</p><h2 id="4-2、大型广播域存在的问题"><a href="#4-2、大型广播域存在的问题" class="headerlink" title="4.2、大型广播域存在的问题"></a>4.2、大型广播域存在的问题</h2><p>大型广播域是连接很多主机的网络。大型广播域的一个问题是这些主机会生成太多广播，这会导致网络操作速度缓慢，因为它会导致大量的流量，而设备操作变慢是因为设备必须接受和处理每个广播数据包。</p><p>解决方案是使用称为“子网划分”的过程缩减网络的规模以创建更小的广播域。这些较小的网络空间通常称为“子网”。</p><p>在图中，网络地址为 172.16.0.0 /16 的 LAN 1 中的 400 个用户被划分到两个子网中，每个子网包含 200 个用户，网络地址分别为 172.16.0.0 /24 和 172.16.1.0 /24。广播仅在更小的网络域内传播。因此，LAN 1 中的广播不会传播到 LAN 2。</p><p><strong>在网络之间通信</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.12.png"></p><p>注意，从一个单一的/16网络到两个/24网络前缀长度是如何变化的。这是基本的子网划分：使用主机位可以创建其他子网。</p><p><strong>注意</strong>: 术语“子网”和“网络”经常互换使用。大多数网络是一些较大地址块的子网。</p><h2 id="4-3、划分网络的原因"><a href="#4-3、划分网络的原因" class="headerlink" title="4.3、划分网络的原因"></a>4.3、划分网络的原因</h2><p>子网划分可以降低整体网络流量并改善网络性能。它也能让管理员实施安全策略，例如哪些子网允许或不允许进行通信。另一个原因是，它减少了由于错误配置、硬件/软件问题或恶意意图而受到异常广播流量影响的设备数量。</p><p>使用子网有多种方法，可帮助管理网络设备。</p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.13.png"></p><h3 id="组域功能"><a href="#组域功能" class="headerlink" title="组域功能"></a>组域功能</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.14.png"></p><h3 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.15.png"></p><p>网络管理员可以使用对网络有意义的任何其他划分来创建子网。注意，在每个图中，子网使用较长的前缀来标识网络。</p><p>理解如何对网络划分子网是所有网络管理员必须掌握的基本技能。已经创建了各种方法来帮助理解这一过程。虽然开始时会让您有点晕头转向，但是请把注意力集中于细节和实践操作，那样就会更容易理解子网划分。</p><h2 id="4-4、测验"><a href="#4-4、测验" class="headerlink" title="4.4、测验"></a>4.4、测验</h2><p>注：默认情况下，<strong>路由器</strong>不会转发IPv4广播数据包</p><h1 id="5、IPv4网络的子网"><a href="#5、IPv4网络的子网" class="headerlink" title="5、IPv4网络的子网"></a>5、IPv4网络的子网</h1><h2 id="5-1、在二进制八位组边界上划分子网"><a href="#5-1、在二进制八位组边界上划分子网" class="headerlink" title="5.1、在二进制八位组边界上划分子网"></a>5.1、在二进制八位组边界上划分子网</h2><p>在上一个主题中，您了解了对网络进行划分的几个很好的理由。您还了解到，划分一个网络称为子网划分。子网划分是管理 IPv4 网络时的一项关键技能。一开始可能会有点困难，但是通过练习会变得容易得多。</p><p>创建 IPv4 子网时会将一个或多个主机位作为网络位。具体做法是延长子网掩码，从地址的主机部分借用若干位来增加网络位。借用的主机位越多，可以定义的子网也就越多。为了增加子网数量而借用的位越多，每个子网的主机数量就越少。</p><p>网络在二进制八位数边界 /8、/16 和 /24 处最容易进行子网划分。该表标识了这些前缀长度。注意，使用较长的前缀会减少每个子网能包含的主机数。</p><p><strong>Subnet Masks on Octet Boundaries</strong></p><table><thead><tr><th><strong>前缀长度</strong></th><th align="left"><strong>子网掩码</strong></th><th align="left"><strong>在二进制中的子网掩码（n = 网络，h = 主机）</strong></th><th align="left"><strong># 主机</strong></th></tr></thead><tbody><tr><td><strong>/8</strong></td><td align="left"><strong>255</strong>. 0.0.0</td><td align="left"><code>**nnnnnnnn**.hhhhhhhh.hhhhhhhh.hhhhhhhh **11111111**.00000000.00000000.00000000</code></td><td align="left">16,777,214</td></tr><tr><td><strong>/16</strong></td><td align="left"><strong>255.255</strong>.0.0</td><td align="left"><code>**nnnnnnnn.nnnnnnnn**.hhhhhhhh.hhhhhhhh **11111111.11111111**.00000000.00000000</code></td><td align="left">65,534</td></tr><tr><td><strong>/24</strong></td><td align="left"><strong>255.255.255</strong>.0</td><td align="left"><code>**nnnnnnnn.nnnnnnnn**.nnnnnnnn.hhhhhhhh **11111111.11111111.11111111**.00000000</code></td><td align="left">254</td></tr></tbody></table><p>为了理解如何在二进制八位组边界上进行子网划分，请考虑以下示例。假设企业选择了私有地址 10.0.0.0/8 作为其内部网络地址。该网络地址可以在一个广播域中连接 16,777,214 个主机。显然，在一个子网上拥有超过 1600 万台主机并不理想。</p><p>企业可以进一步在二进制八位组边界 /16 处对 10.0.0.0/8 地址进行子网划分，如表所示。这能让企业定义多达 256 个子网（例如，10.0.0.0/16 – 10.255.0.0/16），每个子网可以连接 65,534 个主机。注意，前两个二进制八位组标识地址的网络部分，而后两个二进制八位组用于标识主机 IP 地址。</p><p><strong>Subnetting Network 10.0.0.0/8 using a /16</strong></p><table><thead><tr><th align="left"><strong>子网地址 (256 个可能的子网)</strong></th><th align="left"><strong>主机范围 （每个子网可能有 65,534 个主机）</strong></th><th align="left"><strong>广播</strong></th></tr></thead><tbody><tr><td align="left"><strong>10.0</strong>.0.0**/16**</td><td align="left"><strong>10.0</strong>.0.1 - <strong>10.0</strong>.255.254</td><td align="left"><strong>10.0</strong>.255.255</td></tr><tr><td align="left"><strong>10.1.<strong>0.0</strong>/16</strong></td><td align="left"><strong>10.1</strong>.0.1 - <strong>10.1</strong>.255.254</td><td align="left"><strong>10.1</strong>.255.255</td></tr><tr><td align="left"><strong>10.2</strong>.0.0**/16**</td><td align="left"><strong>10.2</strong>.0.1 - <strong>10.2</strong>.255.254</td><td align="left"><strong>10.2</strong>.255.255</td></tr><tr><td align="left"><strong>10.3</strong>. 0.0**/16**</td><td align="left"><strong>10.3</strong>.0.1 - <strong>10.3</strong>.255.254</td><td align="left"><strong>10.3</strong>.255.255</td></tr><tr><td align="left"><strong>10.4</strong>.0.0**/16**</td><td align="left"><strong>10.4</strong>.0.1 - <strong>10.4</strong>.255.254</td><td align="left"><strong>10.4</strong>.255.255</td></tr><tr><td align="left"><strong>10.5</strong>.0.0**/16**</td><td align="left"><strong>10.5</strong>.0.1 - <strong>10.5</strong>.255.254</td><td align="left"><strong>10.5</strong>.255.255</td></tr><tr><td align="left"><strong>10.6</strong>.0.0**/16**</td><td align="left"><strong>10.6</strong>.0.1 - <strong>10.6</strong>.255.254</td><td align="left"><strong>10.6</strong>.255.255</td></tr><tr><td align="left"><strong>10.7</strong>.0.0**/16**</td><td align="left"><strong>10.7</strong>.0.1 - <strong>10.7</strong>.255.254</td><td align="left"><strong>10.7</strong>.255.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.255</strong>.0.0**/16**</td><td align="left"><strong>10.255</strong>.0.1 - <strong>10.255</strong>.255.254</td><td align="left"><strong>10.255</strong>.255.255</td></tr></tbody></table><p>另外，企业也可以选择在 /24 二进制八位组边界处对 10.0.0.0/8 网络进行子网划分，如表所示。这将让企业能定义 65,536 个子网，每个子网能连接 254 个主机。/24 边界在子网划分中使用非常广泛，因为它在这个二进制八位数边界处可以容纳足够多的主机，并且子网划分也很方便。</p><p><strong>Subnetting Network 10.0.0.0/8 using a /24 Prefix</strong></p><table><thead><tr><th align="left"><strong>子网地址 (65,536 个可能的子网)</strong></th><th align="left"><strong>主机范围 （每个子网可能有 254 个主机）</strong></th><th align="left"><strong>广播</strong></th></tr></thead><tbody><tr><td align="left"><strong>10.0.0</strong>.0**/24**</td><td align="left"><strong>10.0.0</strong>.1 - <strong>10.0.0</strong>.254</td><td align="left"><strong>10.0.0</strong>.255</td></tr><tr><td align="left"><strong>10.0.1</strong>.0**/24**</td><td align="left"><strong>10.0.1</strong>.1 - <strong>10.0.1</strong>.254</td><td align="left"><strong>10.0.1</strong>.255</td></tr><tr><td align="left"><strong>10.0.2</strong>.0**/24**</td><td align="left"><strong>10.0.2</strong>.1 - <strong>10.0.2</strong>.254</td><td align="left"><strong>10.0.2</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.0.255</strong>.0**/24**</td><td align="left"><strong>10.0.255</strong>.1 - <strong>10.0.255</strong>.254</td><td align="left"><strong>10.0.255</strong>.255</td></tr><tr><td align="left"><strong>10.1.0</strong>.0**/24**</td><td align="left"><strong>10.1.0</strong>.1 - <strong>10.1.0</strong>.254</td><td align="left"><strong>10.1.0</strong>.255</td></tr><tr><td align="left"><strong>10.1.1</strong>.0**/24**</td><td align="left"><strong>10.1.1</strong>.1 - <strong>10.1.1</strong>.254</td><td align="left"><strong>10.1.1</strong>.255</td></tr><tr><td align="left"><strong>10.1.2</strong>.0**/24**</td><td align="left"><strong>10.1.2</strong>.1 - <strong>10.1.2</strong>.254</td><td align="left"><strong>10.1.2</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.100.0</strong>.0**/24**</td><td align="left"><strong>10.100.0</strong>.1 - <strong>10.100.0</strong>.254</td><td align="left"><strong>10.100.0</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.255.255</strong>.0**/24**</td><td align="left"><strong>10.255.255</strong>.1 - <strong>10.2255.255</strong>.254</td><td align="left"><strong>10.255.255</strong>.255</td></tr></tbody></table><h2 id="5-2、在二进制八位组边界内划分子网"><a href="#5-2、在二进制八位组边界内划分子网" class="headerlink" title="5.2、在二进制八位组边界内划分子网"></a>5.2、在二进制八位组边界内划分子网</h2><p>到目前为止所展示的示例都是从常见的 /8、/16 和 /24 网络前缀借用了主机位。然而，子网可以从任何主机位借用位来创建其他掩码。</p><p>例如，/24 网络地址通常通过从第 4 个二进制八位数借用位来使用更长的前缀进行子网划分。这可以让管理员在将网络地址分配到更少数量的终端设备时具有很好的灵活性。</p><p>参考下表可以看到6种对/24网络划分子网的方式。</p><h3 id="Subnet-a-24-Network"><a href="#Subnet-a-24-Network" class="headerlink" title="Subnet a /24 Network"></a>Subnet a /24 Network</h3><table><thead><tr><th align="left"><strong>前缀长度</strong></th><th align="left"><strong>子网掩码</strong></th><th align="left"><strong>在二进制中的子网掩码 （n = 网络，h = 主机）</strong></th><th align="left"><strong># 子网</strong></th><th align="left"><strong># 主机</strong></th></tr></thead><tbody><tr><td align="left">/25</td><td align="left">255.255.255.128</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**n**hhhhhhh11111111.11111111.11111111.**1**0000000</code></td><td align="left"><strong>2</strong></td><td align="left">126</td></tr><tr><td align="left">/26</td><td align="left">255.255.255.192</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nn**hhhhhh11111111.11111111.11111111.**11**000000</code></td><td align="left"><strong>4</strong></td><td align="left">62</td></tr><tr><td align="left">/27</td><td align="left">255.255.255.224</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnn**hhhhh11111111.11111111.11111111.**111**00000</code></td><td align="left"><strong>8</strong></td><td align="left">30</td></tr><tr><td align="left">/28</td><td align="left">255.255.255.240</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnn**hhhh11111111.11111111.11111111.**1111**0000</code></td><td align="left"><strong>16</strong></td><td align="left">14</td></tr><tr><td align="left">/29</td><td align="left">255.255.255.248</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnnn**hhh11111111.11111111.11111111.**11111**000</code></td><td align="left"><strong>32</strong></td><td align="left">6</td></tr><tr><td align="left">/30</td><td align="left">255.255.255.252</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnnnn**hh11111111.11111111.11111111.**111111**00</code></td><td align="left"><strong>64</strong></td><td align="left">2</td></tr></tbody></table><p>对在第 4 个二进制八位组中借用的每个位，可用的子网数会加倍，同时每个子网的主机地址数会减少。</p><ul><li><strong>/25 行</strong> - 从第 4 个二进制八位组借用 1 位可以创建每个能容纳 126 个主机的 2 个子网。</li><li><strong>/26 行</strong> - 借用 2 位可以创建每个能容纳 62 个主机的 4 个子网。</li><li><strong>/27 行</strong> - 借用 3 位可以创建每个能容纳 30 个主机的 8 个子网。</li><li><strong>/28 行</strong> - 借用 4 位可以创建每个能容纳 14 个主机的 16 个子网。</li><li><strong>/29 行</strong> - 借用 5 位可以创建每个能容纳 6 个主机的 32 个子网。</li><li><strong>/30 行</strong> - 借用 6 位可以创建每个能容纳 2 个主机的 64 个子网。</li></ul><h2 id="5-3、视频-子网掩码"><a href="#5-3、视频-子网掩码" class="headerlink" title="5.3、视频-子网掩码"></a>5.3、视频-子网掩码</h2><p>略</p><h3 id="5-4、视频-使用幻数划分子网"><a href="#5-4、视频-使用幻数划分子网" class="headerlink" title="5.4、视频-使用幻数划分子网"></a>5.4、视频-使用幻数划分子网</h3><p>略</p><h2 id="5-5、Packet-Tracer-对-IPv4-网络划分子网"><a href="#5-5、Packet-Tracer-对-IPv4-网络划分子网" class="headerlink" title="5.5、Packet Tracer-对 IPv4 网络划分子网"></a>5.5、Packet Tracer-对 IPv4 网络划分子网</h2><p>略</p><h1 id="6、使用-16和-8前缀划分子网"><a href="#6、使用-16和-8前缀划分子网" class="headerlink" title="6、使用/16和/8前缀划分子网"></a>6、使用/16和/8前缀划分子网</h1><h2 id="6-1、使用-16前缀创建子网"><a href="#6-1、使用-16前缀创建子网" class="headerlink" title="6.1、使用/16前缀创建子网"></a>6.1、使用/16前缀创建子网</h2><p>有些子网比其他子网更容易。本主题介绍如何创建具有相同数量主机的子网。</p><p>在要求较多子网的情况下，需要 IPv4 网络有更多主机位可以借用。例如，网络地址 172.16.0.0 具有默认掩码 255.255.0.0 或 /16。该地址的网络部分有 16 位，主机部分也有 16 位。主机部分的这 16 位可借用来创建子网。表突出显示了对 /16 前缀进行子网划分的所有可能的场景。</p><p><strong>Subnet a /16 Network</strong></p><table><thead><tr><th align="left"><strong>前缀长度</strong></th><th align="left"><strong>子网掩码</strong></th><th align="left"><strong>网络地址 （n = 网络，h = 主机）</strong></th><th align="left"><strong># 子网</strong></th><th align="left"><strong># 主机</strong></th></tr></thead><tbody><tr><td align="left">/17</td><td align="left">255.255.128.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**n**hhhhhhh.hhhhhhhh 11111111.11111111.**1**0000000.00000000</code></td><td align="left"><strong>2</strong></td><td align="left">32766</td></tr><tr><td align="left">/18</td><td align="left">255.255.192.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nn**hhhhhh.hhhhhhhh 11111111.11111111.**11**000000.00000000</code></td><td align="left"><strong>4</strong></td><td align="left">16382</td></tr><tr><td align="left">/19</td><td align="left">255.255.224.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnn**hhhhh.hhhhhhhh 11111111.11111111.**111**00000.00000000</code></td><td align="left"><strong>8</strong></td><td align="left">8190</td></tr><tr><td align="left">/20</td><td align="left">255.255.240.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnn**hhhh.hhhhhhhh 11111111.11111111.**1111**0000.00000000</code></td><td align="left"><strong>16</strong></td><td align="left">4094</td></tr><tr><td align="left">/21</td><td align="left">255.255.248.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnn**hhh.hhhhhhhh 11111111.11111111.**11111**000.00000000</code></td><td align="left"><strong>32</strong></td><td align="left">2046</td></tr><tr><td align="left">/22</td><td align="left">255.255.252.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnn**hh.hhhhhhhh 11111111.11111111.**111111**00.00000000</code></td><td align="left"><strong>64</strong></td><td align="left">1022</td></tr><tr><td align="left">/23</td><td align="left">255.255.254.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnn**h.hhhhhhhh 11111111.11111111.**1111111**0.00000000</code></td><td align="left"><strong>128</strong></td><td align="left">510</td></tr><tr><td align="left">/24</td><td align="left">255.255.255.0</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn**.hhhhhhhh 11111111.11111111.**11111111**.00000000</code></td><td align="left"><strong>256</strong></td><td align="left">254</td></tr><tr><td align="left">/25</td><td align="left">255.255.255.128</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.n**hhhhhhh 11111111.11111111.**11111111.1**0000000</code></td><td align="left"><strong>512</strong></td><td align="left">126</td></tr><tr><td align="left">/26</td><td align="left">255.255.255.192</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.nn**hhhhhh 11111111.11111111.**11111111.11**000000</code></td><td align="left"><strong>1024</strong></td><td align="left">62</td></tr><tr><td align="left">/27</td><td align="left">255.255.255.224</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.nnn**hhhhh 11111111.11111111.**11111111.111**00000</code></td><td align="left"><strong>2048</strong></td><td align="left">30</td></tr><tr><td align="left">/28</td><td align="left">255.255.255.240</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.nnnn**hhhh 11111111.11111111.**11111111.1111**0000</code></td><td align="left"><strong>4096</strong></td><td align="left">14</td></tr><tr><td align="left">/29</td><td align="left">255.255.255.248</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.nnnnn**hhh 11111111.11111111.**11111111.11111**000</code></td><td align="left"><strong>8192</strong></td><td align="left">6</td></tr><tr><td align="left">/30</td><td align="left">255.255.255.252</td><td align="left"><code>nnnnnnnn.nnnnnnnn.**nnnnnnnn.nnnnnn**hh 11111111.11111111.**11111111.111111**00</code></td><td align="left"><strong>16384</strong></td><td align="left">2</td></tr></tbody></table><p>虽然您不需要记住这个表，但仍然需要很好地了解表中每个值的生成方式。不要让表的大小吓着了您。变大的原因是因为它有 8 个能借用的额外位，因此子网和主机的数量只能是变大。</p><h2 id="6-2、使用-16前缀创建100个子网"><a href="#6-2、使用-16前缀创建100个子网" class="headerlink" title="6.2、使用/16前缀创建100个子网"></a>6.2、使用/16前缀创建100个子网</h2><p>假设一家大型企业需要至少 100 个子网，并且已选择私有地址 172.16.0.0/16 作为其内部网络地址。</p><p>当从 /16 地址借用位时，从借用第三个二进制八位组开始，并遵循从左向右的顺序。一次借用一个位直至所需的位数能创建 100 个子网。</p><p>该图显示了当从第三个二进制八位组和第四个二进制八位组借用位时能创建的子网数。注意，现在可以借用的主机位多达 14 个。</p><p><strong>创建的子网数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.16.png"></p><p>要满足企业100个子网的要求，需要借用 7 位（即 27= 128 个子网）</p><p><strong>172.16.0.0/23</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.17.png"></p><p>回想一下，子网掩码必须作出更改以反映借用的位。在本示例中，当借用 7 个位时，掩码将扩展 7 个位到第三个二进制八位数。该掩码以十进制表示为 255.255.254.0，或者 /23 前缀，因为，第三个二进制八位组以二进制表示为 11111110，第四个二进制八位组以二进制表示为 00000000。</p><p>图中显示了生成的子网范围从 172.16.0.0 /23 到 172.16.254.0 /23。</p><p><strong>产生/23子网</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.18.png"></p><p>在为子网借用 7 个位之后，第三个二进制八位组中剩余 1 个主机位，第四个二进制八位组中剩余 8 个主机位，所以总共有 9 个位没有借用。2的9次幂会产生 512 个主机地址。第一个地址是为网络地址保留的，最后一个地址是为广播地址保留的，因此减去这两个地址 (2^9-2) 等于每个 /23 子网有 510 个可用的主机地址。</p><p>如图所示，第一个子网的第一个主机地址是 172.16.0.1，最后一个主机地址是 172.16.1.254。</p><p><strong>172.16.0.0/23子网的地址范围</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.19.png"></p><h2 id="6-3、使用-8前缀创建1000个子网"><a href="#6-3、使用-8前缀创建1000个子网" class="headerlink" title="6.3、使用/8前缀创建1000个子网"></a>6.3、使用/8前缀创建1000个子网</h2><p>与6.2同理，略</p><h2 id="6-4、视频-跨多个二进制八位组进行子网划分"><a href="#6-4、视频-跨多个二进制八位组进行子网划分" class="headerlink" title="6.4、视频-跨多个二进制八位组进行子网划分"></a>6.4、视频-跨多个二进制八位组进行子网划分</h2><p>略</p><h1 id="7、按照要求划分子网"><a href="#7、按照要求划分子网" class="headerlink" title="7、按照要求划分子网"></a>7、按照要求划分子网</h1><h2 id="7-1、对私有和公有IPv4地址空间进行子网划分"><a href="#7-1、对私有和公有IPv4地址空间进行子网划分" class="headerlink" title="7.1、对私有和公有IPv4地址空间进行子网划分"></a>7.1、对私有和公有IPv4地址空间进行子网划分</h2><p>虽然可以快速地将网络划分为子网，但是您的组织的网络可能同时使用公有和私有IPv4地址。这会影响您的网络划分子网的方式。</p><p>该图显示了典型的企业网络：</p><ul><li><strong>内部网-</strong> 这是公司网络的内部部分，只能在组织内部访问。内部网中的设备使用私有 IPv4 地址。</li><li><strong>DMZ-</strong> 这是公司网络的一部分，其中包含可供互联网使用的资源，如 Web 服务器。DMZ 中的设备使用公有 IPv4 地址。</li></ul><p><strong>公有和私有IPv4地址空间</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.20.png"></p><p>内部网和 DMZ 都有自己的子网划分要求和挑战。</p><p>内部网使用私有 IPv4 编址空间。这允许组织使用任何私有 IPv4 网络地址，包括带有 24 个主机位和超过 1600 万台主机的 10.0.0/8 前缀。使用有 24 个主机位的网络地址可使子网划分更容易、更灵活。这包括使用 /16 或 /24 在八位组边界上进行子网划分。</p><p>例如，私有 IPv4 网络地址 10.0.0.0/8 可以使用 /16 掩码进行子网划分。如表中所示，这将产生 256 个子网，每个子网有 65,534 个主机。如果一个组织需要的子网少于200个，允许一定的增长，这将给每个子网提供了足够多的主机地址。</p><p><strong>Subnetting Network 10.0.0.0/8 using a /16</strong></p><table><thead><tr><th align="left"><strong>子网地址 (256 个可能的子网)</strong></th><th align="left"><strong>主机范围 （每个子网可能有 65,534 个主机）</strong></th><th align="left"><strong>广播</strong></th></tr></thead><tbody><tr><td align="left"><strong>10.0</strong>.0.0**/16**</td><td align="left"><strong>10.0</strong>.0.1 - <strong>10.0</strong>.255.254</td><td align="left"><strong>10.0</strong>.255.255</td></tr><tr><td align="left"><strong>10.1</strong>.0.0**/16**</td><td align="left"><strong>10.1</strong>.0.1 - <strong>10.1</strong>.255.254</td><td align="left"><strong>10.1</strong>.255.255</td></tr><tr><td align="left"><strong>10.2</strong>.0.0/16</td><td align="left"><strong>10.2</strong>.0.1 - <strong>10.2</strong>.255.254</td><td align="left"><strong>10.2</strong>.255.255</td></tr><tr><td align="left"><strong>10.3</strong>.0.0**/16**</td><td align="left"><strong>10.3</strong>.0.1 - <strong>10.3</strong>.255.254</td><td align="left"><strong>10.3</strong>.255.255</td></tr><tr><td align="left"><strong>10.4</strong>.0.0**/16**</td><td align="left"><strong>10.4</strong>.0.1 - <strong>10.4</strong>.255.254</td><td align="left"><strong>10.4</strong>.255.255</td></tr><tr><td align="left"><strong>10.5</strong>.0.0**/16**</td><td align="left"><strong>10.5</strong>.0.1 - <strong>10.5</strong>.255.254</td><td align="left"><strong>10.5</strong>.255.255</td></tr><tr><td align="left"><strong>10.6</strong>.0.0**/16**</td><td align="left"><strong>10.6</strong>0.1- **10.6.**255.254</td><td align="left"><strong>10.6</strong>.255.255</td></tr><tr><td align="left"><strong>10.7</strong>.0.0**/16**</td><td align="left"><strong>10.7</strong>.0.1 - <strong>10.7</strong>.255.254</td><td align="left"><strong>10.7</strong>.255.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.255</strong>.0.0**/16**</td><td align="left"><strong>10.255</strong>.0.1 - <strong>10.255</strong>.255.254</td><td align="left"><strong>10.255</strong>.255.255</td></tr></tbody></table><p>使用 10.0.0.0/8 私有 IPv4 网络地址的另一种选择是使用 /24 掩码进行子网划分。如表中所示，这将产生 65,536 个子网，每个子网有 254 个主机。如果一个组织需要超过256个子网，那么使用/24进行子网划分，每个子网有254个主机可以使用。</p><p><strong>Subnetting Network 10.0.0.0/8 using a /24</strong></p><table><thead><tr><th align="left"><strong>子网地址 (65,536 个可能的子网)</strong></th><th align="left"><strong>主机范围 （每个子网可能有 254 个主机）</strong></th><th align="left"><strong>广播</strong></th></tr></thead><tbody><tr><td align="left"><strong>10.0.0</strong>.0**/24**</td><td align="left"><strong>10.0.0</strong>.1 - <strong>10.0.0</strong>.254</td><td align="left"><strong>10.0.0</strong>.255</td></tr><tr><td align="left"><strong>10.0.1</strong>.0**/24**</td><td align="left"><strong>10.0.1</strong>.1 - <strong>10.0.1</strong>.254</td><td align="left"><strong>10.0.1</strong>.255</td></tr><tr><td align="left"><strong>10.0.2</strong>.0**/24**</td><td align="left"><strong>10.0.2</strong>.1 - <strong>10.0.2</strong>.254</td><td align="left"><strong>10.0.2</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.0.255</strong>.0**/24**</td><td align="left"><strong>10.0.255</strong>.1 - <strong>10.0.255</strong>.254</td><td align="left"><strong>10.0.255</strong>.255</td></tr><tr><td align="left"><strong>10.1.0</strong>.0**/24**</td><td align="left"><strong>10.1.0</strong>.1 - <strong>10.1.0</strong>.254</td><td align="left"><strong>10.1.0</strong>.255</td></tr><tr><td align="left"><strong>10.1.1</strong>.0**/24**</td><td align="left"><strong>10.1.1</strong>.1 - <strong>10.1.1</strong>.254</td><td align="left"><strong>10.1.1</strong>.255</td></tr><tr><td align="left"><strong>10.1.2</strong>.0**/24**</td><td align="left"><strong>10.1.2</strong>.1 - <strong>10.1.2</strong>.254</td><td align="left"><strong>10.1.2</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.100.0</strong>.0**/24**</td><td align="left"><strong>10.100.0</strong>.1 - <strong>10.100.0</strong>.254</td><td align="left"><strong>10.100.0</strong>.255</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr><tr><td align="left"><strong>10.255.255</strong>.0**/24**</td><td align="left"><strong>10.255.255</strong>.1 - <strong>10.2255.255</strong>.254</td><td align="left"><strong>10.255.255</strong>.255</td></tr></tbody></table><p>10.0.0.0/8还可以使用任何其他前缀长度的数字进行子网划分，如/12、/18、/20等。这将为网络管理员提供多种选择。使用10.0.0.0/8私有IPv4网络地址使子网规划和实现变得简单。</p><p><strong>那关于DMZ呢？</strong></p><p>因为这些设备需要从互联网公开访问，所以DMZ中的设备需要公有IPv4地址。从20世纪90年代中期开始，公有IPv4地址空间的耗尽成为了一个问题。自 2011 年以来，IANA 和五个 RIR 中的四个用尽了 IPv4 地址空间。虽然组织正在向IPv6过渡，但是剩余的IPv4地址空间仍然非常有限。这意味着组织必须最大限度地提高其自身有限数量的公有 IPv4 地址。这要求**网络管理员将其公有地址空间划分到具有不同子网掩码的子网中，以便最大限度地减少每个子网的未使用主机地址数量。这称为可变长子网掩码 (VLSM)**。</p><h2 id="7-2、最小化未使用的主机-IPv4-地址并最大化子网"><a href="#7-2、最小化未使用的主机-IPv4-地址并最大化子网" class="headerlink" title="7.2、最小化未使用的主机 IPv4 地址并最大化子网"></a>7.2、最小化未使用的主机 IPv4 地址并最大化子网</h2><p>要尽量减少未使用的主机 IPv4 地址数量并最大化可用子网数量，在规划子网时需要考虑两个因素：每个网络所需的主机地址数量和所需的单个子网数量。</p><p>该表显示了对 /24 网络进行子网划分的具体情况。注意，子网数量与主机数量成反比。借用越多的位来创建子网，可用的主机位越少。如果需要更多主机地址，就需要更多主机位，那么子网数就会更少。</p><p>最大子网中所需的主机地址数量将决定主机部分必须保留多少个位。回想一下，有 2 个地址不能使用，因此可用地址的数量可以这样计算：2^n-2。</p><p><strong>Subnetting a /24 Network</strong></p><table><thead><tr><th align="left"><strong>前缀长度</strong></th><th align="left"><strong>子网掩码</strong></th><th align="left"><strong>在二进制中的子网掩码 （n = 网络，h = 主机）</strong></th><th align="left"><strong># 子网</strong></th><th align="left"><strong># 每个子网的主机数</strong></th></tr></thead><tbody><tr><td align="left">/25</td><td align="left">255.255.255.128</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**n**hhhhhhh11111111.11111111.11111111.**1**0000000</code></td><td align="left"><strong>2</strong></td><td align="left">126</td></tr><tr><td align="left">/26</td><td align="left">255.255.255.192</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nn**hhhhhh11111111.11111111.11111111.**11**000000</code></td><td align="left"><strong>4</strong></td><td align="left">62</td></tr><tr><td align="left">/27</td><td align="left">255.255.255.224</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnn**hhhhh11111111.11111111.11111111.**111**00000</code></td><td align="left"><strong>8</strong></td><td align="left">30</td></tr><tr><td align="left">/28</td><td align="left">255.255.255.240</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnn**hhhh11111111.11111111.11111111.**1111**0000</code></td><td align="left"><strong>16</strong></td><td align="left">14</td></tr><tr><td align="left">/29</td><td align="left">255.255.255.248</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnnn**hhh11111111.11111111.11111111.**11111**000</code></td><td align="left"><strong>32</strong></td><td align="left">6</td></tr><tr><td align="left">/30</td><td align="left">255.255.255.252</td><td align="left"><code>nnnnnnnn.nnnnnnnn.nnnnnnnn.**nnnnnn**hh11111111.11111111.11111111.**111111**00</code></td><td align="left"><strong>64</strong></td><td align="left">2</td></tr></tbody></table><p><strong>网络管理员必须设计网络编址方案，以满足每个网络的最大主机数量和子网数量需求。编址方案应允许每个子网的主机地址数量和子网的总数量的增长。</strong></p><h2 id="7-3、示例：高效的IPv4子网划分"><a href="#7-3、示例：高效的IPv4子网划分" class="headerlink" title="7.3、示例：高效的IPv4子网划分"></a>7.3、示例：高效的IPv4子网划分</h2><p>在本示例中，公司总部的ISP为其分配了一个公共网络地址172.16.0.0/22(10个主机位)。如图所示，这将提供 1022 个主机地址。</p><p><strong>注意</strong>: 172.16.0.0/22 是 IPv4 私有地址空间的一部分。我们使用的是此地址，而不是实际的公有 IPv4 地址。</p><p><strong>网络地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.21.png"></p><p>公司总部有一个 DMZ 和四个分支机构，每个分支机构都需要自己的公有 IPv4 地址空间。企业总部需要充分利用有限的IPv4地址空间。</p><p>图中显示的拓扑包括五个站点：一个公司办公室和四个分支站点。每个站点都需要互联网连接，因此需要五个互联网连接。这意味着组织需要来自公司 172.16.0.0/22 公共地址的 10 个子网。最大子网需要 40 个地址。</p><p><strong>具有五个站点的企业拓扑</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.22.png"></p><p>172.16.0.0/22 网络地址有 10 个主机位，如图所示。由于最大子网需要 40 台主机，为 40 台主机提供编址至少需要 6 个主机位。这根据以下公式确定：26 -2 = 62 主机。</p><p><strong>子网方案</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.23.png"></p><p>使用公式确定子网数，结果为 16 个子网：2的四次方= 16。由于示例中网际网络要求 10 个子网，这一数量可以满足其要求而且允许增加一定数量的子网。</p><p>因此，前 4 个主机位可用于分配子网。这意味着第三个八位组的两个位和第四个八位组的两个位将被借用。当从172.16.0.0/22网络借用 4 个位时，新的前缀长度为 /26，子网掩码为 255.255.255.192。</p><p>如图所示，子网可以分配给每个位置和路由器到路由器的连接。</p><p><strong>为每个站点和ISP分配子网</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.24.png"></p><h2 id="7-4、练习-确定借用位数"><a href="#7-4、练习-确定借用位数" class="headerlink" title="7.4、练习 - 确定借用位数"></a>7.4、练习 - 确定借用位数</h2><p>略</p><h2 id="7-5、Packet-Tracer-子网划分场景"><a href="#7-5、Packet-Tracer-子网划分场景" class="headerlink" title="7.5、Packet Tracer - 子网划分场景"></a>7.5、Packet Tracer - 子网划分场景</h2><p>略</p><h1 id="8、VLSM-Variable-Length-Subnet-Mask"><a href="#8、VLSM-Variable-Length-Subnet-Mask" class="headerlink" title="8、VLSM(Variable Length Subnet Mask)"></a>8、VLSM(Variable Length Subnet Mask)</h1><h2 id="8-1、视频-VLSM基础"><a href="#8-1、视频-VLSM基础" class="headerlink" title="8.1、视频-VLSM基础"></a>8.1、视频-VLSM基础</h2><p>正如在上一主题中提到的，公有地址和私有地址会影响您将网络划分子网的方式。还有其他一些问题影响着子网划分方案。一个标准的/16子网划分方案创建的每个子网都拥有相同数量的主机。并不是您创建的每个子网都需要这么多主机，这会导致许多IPv4地址未被使用。也许您需要一个包含更多主机的子网。这就是开发可变长子网掩码 (VLSM) 的原因。</p><h2 id="8-2、视频-VLSM示例"><a href="#8-2、视频-VLSM示例" class="headerlink" title="8.2、视频-VLSM示例"></a>8.2、视频-VLSM示例</h2><p>略</p><h2 id="8-3、IP地址保留"><a href="#8-3、IP地址保留" class="headerlink" title="8.3、IP地址保留"></a>8.3、IP地址保留</h2><p>由于公有IPv4地址空间的耗尽，所以在对IPv4网络进行子网划分时，充分利用可用的主机地址是主要关注的问题。</p><p><strong>注意</strong>: 更大的IPv6地址允许比IPv4更容易的地址规划和分配。保留IPv6地址不是问题。这是向IPv6 过渡的驱动力之一。</p><p>使用传统子网划分，为每个子网分配相同数量的地址。如果所有子网对主机数量的要求相同，或者保留IPv4地址空间不是问题，那么这些固定大小的地址块效率就会很高。通常，对于公有 IPv4 地址，情况并非如此。</p><p>例如，图中显示的拓扑要求七个子网，其中四个子网分别用于四个 LAN，而另外三个分别用于路由器之间的三个连接。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.25.png"></p><p>对指定地址 192.168.20.0/24 进行传统子网划分，从最后一个二进制八位组的主机部分可以借用 3 个位，以满足其七个子网的要求。如图所示，借用 3 个位可以创建 8 个子网，剩余 5 个主机位，每个子网有 30 个可用主机。该方案创建了所需子网，并且满足其最大 LAN 对主机的要求。</p><p><strong>基本子网方案</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.26.png"></p><p>如图所示，这七个子网可以分配给局域网和广域网网络。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.27.png"></p><p>虽然该传统子网划分满足最大 LAN 的需要，并将地址空间划分为足够的子网，但它产生了大量未使用地址，造成地址浪费。</p><p>例如，这三个 WAN 链路的每个子网中仅仅需要两个地址。由于每个子网有 30 个可用地址，这些子网中每个子网有 28 个未使用地址。如图所示，这将产生 84 个未使用地址 (28x3)。</p><p><strong>在WAN子网中未使用的地址</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.28.png"></p><p>此外，这样做还减少了可用子网的总数，从而限制了未来的发展。这种低效的地址使用率正是传统子网划分的缺点。对示例场景采用传统子网划分方案，效率并不是非常高，而且比较浪费。</p><p>变长子网掩码(VLSM)是为了避免浪费地址而开发的，它使我们能够对子网进行子网划分。</p><h2 id="8-4、VLSM"><a href="#8-4、VLSM" class="headerlink" title="8.4、VLSM"></a>8.4、VLSM</h2><p>在前面主题的所有子网示例中，所有子网都使用相同的子网掩码。这意味着每个子网有相同数量的可用主机地址。如图左边所示，传统子网划分可以创建大小相等的子网。传统方案中每个子网都使用相同的子网掩码。如图右边所示，VLSM 使网络空间能够分为大小不等的部分。使用 VLSM，子网掩码将根据特定子网所借用的位数而变化，从而成为 VLSM 的“变量”部分。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.29.png"></p><p>VLSM 就是指对子网划分子网。图中显示了以前使用的相同拓扑。同样，我们会使用192.168.20.0/24网络，将其划分为七个子网，其中四个子网用于四个局域网，三个子网用于路由器之间的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.30.png"></p><p>该图显示了网络192.168.20.0/24如何划分成8个大小相等的子网，每个子网有30个可用的主机地址。其中四个子网用于局域网，三个子网可用于路由器之间的连接。</p><p><strong>基本子网划分方案</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.31.png"></p><p>但是，路由器之间的连接每个子网仅需要两个主机地址（每个路由器接口一个主机地址）。目前，所有子网中的每个子网都有 30 个可用的主机地址。为了避免每个子网浪费28个地址，可以使用 VLSM 为 路由器之间的连接创建较小子网。</p><p>为了为路由器之间的链路创建较小子网，将其中一个子网细分。在本示例中，对最后一个子网 192.168.20.224/27 进一步划分子网。该图显示了通过使用子网掩码 255.255.255.252 或 /30 进一步对最后一个子网进行子网划分。</p><p><strong>VLSM子网划分方案</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.32.png"></p><p>为什么是/30 回想一下，当所需主机地址的数量已知时，可以使用公式 2^n-2（其中 n 等于剩余主机位的数量）。要提供两个可用地址，必须在主机部分保留 2 个主机位。</p><p>因为划分子网的 192.168.20.224/27 地址空间有 5 个主机位，所以可以借用 3 个位，在主机部分保留 2 个位，如图 2 所示。此时的计算与传统子网划分使用的计算完全相同。借用了位，并确定了子网范围。该图显示了如何将四个 /27 子网分配给局域网，将三个 /30 子网分配给路由器之间的链路。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.33.png"></p><p>这种 VLSM 子网划分方案将每个子网的地址数目减少到适合需要较少子网的网络的大小。对路由器之间的链路的子网 7 划分子网，使子网 4、5 和 6 能够用于未来网络，而且路由器之间的链路中能够有 5 个额外的子网可用。</p><p><strong>注意</strong>: 当使用 VLSM 时，请始终从满足最大子网的主机要求开始。继续子网划分直至满足最小子网的主机要求。</p><h2 id="8-5、VLSM-拓扑地址分配"><a href="#8-5、VLSM-拓扑地址分配" class="headerlink" title="8.5、VLSM 拓扑地址分配"></a>8.5、VLSM 拓扑地址分配</h2><p>使用 VLSM 子网，可以为 LAN 和路由器之间网段提供地址，而不产生不必要浪费。</p><p>下图显示了分配给每个路由器接口的网络地址分配和 IPv4 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN11.34.png"></p><p>使用常用编址方案，将每个子网的第一个主机 IPv4 地址分配给路由器的 LAN 接口。每个子网中的主机都将拥有该子网主机地址范围内的一个主机 IPv4 地址和一个合适的掩码。主机将与路由器 LAN 接口相连的地址作为默认网关地址。</p><p>该表显示了每个网络的网络地址和主机地址范围。显示了四个局域网的默认网关地址。</p><table><thead><tr><th align="left"></th><th align="left"><strong>网络地址</strong></th><th align="left"><strong>主机地址范围</strong></th><th align="left"><strong>默认网关地址</strong></th></tr></thead><tbody><tr><td align="left"><strong>大楼 A</strong></td><td align="left">192.168.20.0/27</td><td align="left">192.168.20.1/27 至 192.168.20.30/27</td><td align="left">192.168.20.1/27</td></tr><tr><td align="left"><strong>大楼 B</strong></td><td align="left">192.168.20.32/27</td><td align="left">192.168.20.33/27 至 192.168.20.62/27</td><td align="left">192.168.20.33/27</td></tr><tr><td align="left"><strong>大楼 C</strong></td><td align="left">192.168.20.64/27</td><td align="left">192.168.20.65/27 至 192.168.20.94/27</td><td align="left">192.168.20.65/27</td></tr><tr><td align="left"><strong>大楼 D</strong></td><td align="left">192.168.20.96/27</td><td align="left">192.168.20.97/27 至 192.168.20.126/27</td><td align="left">192.168.20.97/27</td></tr><tr><td align="left"><strong>R1至R2</strong></td><td align="left">192.168.20.224/30</td><td align="left">192.168.20.225/30 至 192.168.20.226/30</td><td align="left"></td></tr><tr><td align="left"><strong>R2至R3</strong></td><td align="left">192.168.20.228/30</td><td align="left">192.168.20.229/30 至 192.168.20.230/30</td><td align="left"></td></tr><tr><td align="left"><strong>R3至R4</strong></td><td align="left">192.168.20.232/30</td><td align="left">192.168.20.233/30 至 192.168.20.234/30</td><td align="left"></td></tr></tbody></table><h2 id="8-6、练习-VLSM实践"><a href="#8-6、练习-VLSM实践" class="headerlink" title="8.6、练习-VLSM实践"></a>8.6、练习-VLSM实践</h2><p>略</p><h1 id="9、结构化设计"><a href="#9、结构化设计" class="headerlink" title="9、结构化设计"></a>9、结构化设计</h1><h2 id="9-1、IPv4网络地址规划"><a href="#9-1、IPv4网络地址规划" class="headerlink" title="9.1、IPv4网络地址规划"></a>9.1、IPv4网络地址规划</h2><p>在开始子网划分之前，您应该为整个网络开发一个 IPv4 编址方案。您要了解您需要多少子网、特定子网需要多少主机、哪些设备是子网的一部分、网络的哪些部分使用私有地址、哪些使用公有地址以及许多其他决定因素。一个良好的编址方案允许增长。一个良好的编址方案也是一个良好的网络管理员的标志。</p><p>IPv4网络子网的规划要求同时分析组织的网络使用需求和子网的构建方法。进行网络需求调研是子网规划的起点。这意味着查看整个网络，包括内部网和DMZ，并确定如何划分每个区域。地址计划包括确定哪里需要地址保留(通常在DMZ中)，哪里有更大的灵活性(通常在内部网中)。</p><p>如果需要地址保留，计划应确定需要多少个子网以及每个子网有多少个主机。如前所述，这通常是DMZ中的公有IPv4地址空间所需要的。这很可能包括使用 VLSM。</p><p>在企业内部网中，地址保留通常不是问题，这主要是由于使用私有IPv4编址，包括10.0.0.0/8，有超过1600万个主机IPv4地址。</p><p>对于大多数组织，私有 IPv4 地址允许提供足够多的内部（内部网）地址。对于许多较大的组织和ISP来说，即使是私有的IPv4地址空间也不足以满足它们的内部需求。这也是组织向 IPv6 过渡的另一个原因。</p><p>对于使用私有 IPv4 地址的内部网和使用公有 IPv4 地址的 DMZ，地址规划和分配非常重要。</p><p>在需要时，地址计划包括根据大小确定每个子网的需要。每个子网将有多少台主机地址计划还需要包括如何分配主机地址，哪些主机要求静态 IPv4 地址和哪些主机可以使用 DHCP 获取其编址信息的需求。这也将有助于防止地址重复，同时允许出于性能和安全原因对地址进行监测和管理。</p><p>了解您的IPv4地址需求将确定您实施的主机地址的范围，并帮助确保有足够的地址满足您的网络需求。</p><h2 id="9-2、设备地址分配"><a href="#9-2、设备地址分配" class="headerlink" title="9.2、设备地址分配"></a>9.2、设备地址分配</h2><p>在一个网络中，有不同类型的设备需要分配地址：</p><ul><li><strong>终端用户客户端</strong> – 大部分网络使用动态主机配置协议 (DHCP)动态地将IPv4地址分配给客户端设备。这能减少网络支持人员的负担，并显著减少输入错误。使用 DHCP 时，地址仅租用一段时间，并且可以在租约到期时重新使用。这是支持临时用户和无线设备的网络的一个重要特性。更改子网划分方案意味着 DHCP 服务器需要进行重新配置，并且客户端必须续订其 IPv4 地址。IPv6 客户端可以使用 DHCPv6 或 SLAAC 获取地址信息。</li><li><strong>服务器和外部设备</strong> - 这些应具有可预测的静态 IP 地址。对这些设备使用统一的编号系统。</li><li><strong>可从互联网访问的服务器</strong> -需要在互联网上公开可用的服务器必须具有公有 IPv4 地址，通常使用 NAT 访问。在一些组织中，必须使远程用户可以使用内部服务器(不可公开使用)。在大多数情况下，这些服务器在内部分配了私有地址，用户需要创建一个虚拟专用网络 (VPN) 连接来访问服务器。这与用户从内部网中的主机访问服务器具有相同的效果。</li><li><strong>中间设备</strong> – 这些设备出于网络管理、监视和安全目的分配了地址。因为我们必须知道如何与中间设备通信，所以它们应当具有可以预测的静态地址。</li><li><strong>网关</strong> - 路由器和防火墙设备给每个接口分配一个 IP 地址，用作该网络中主机的网关。路由器接口一般使用网络中的最小地址或最大地址。</li></ul><p>在制定 IP 编址方案时，通常建议您使用一种固定模式为各类设备分配地址。这样有益于管理员添加和删除设备、根据 IP 过滤流量和简化文档。</p><h2 id="9-3、Packet-Tracer-VLSM-设计与实施实践"><a href="#9-3、Packet-Tracer-VLSM-设计与实施实践" class="headerlink" title="9.3、Packet Tracer-VLSM 设计与实施实践"></a>9.3、Packet Tracer-VLSM 设计与实施实践</h2><p>略</p><h1 id="10、单元检测"><a href="#10、单元检测" class="headerlink" title="10、单元检测"></a>10、单元检测</h1><p>注：</p><p>1、子网掩码与IP地址结合用于<strong>确定主机所属的子网</strong></p><p>2、如果一台网络设备具有掩码 /26，则对于该网络上的主机，有<strong>62</strong>个IP地址可用</p><p>3、IP 地址 172.17.4.250/24 代表<strong>主机地址</strong></p><p>4、子网掩码 255.255.255.0 具有 8 个主机位</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（十）</title>
      <link href="/2021/111934010.html"/>
      <url>/2021/111934010.html</url>
      
        <content type="html"><![CDATA[<h1 id="十、路由器基本配置"><a href="#十、路由器基本配置" class="headerlink" title="十、路由器基本配置"></a>十、路由器基本配置</h1><p>路由器创建并使用路由表将数据包从本地网络转发到其他网络。但路由器在配置完成之前无法创建路由表或转发任何数据包。如果您打算成为一名网络管理员，您一定要知道如何做到这一点。</p><p><strong>模块目标</strong>: 在路由器和终端设备上实施初始设置。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>配置初始路由器设置</strong></td><td align="left">配置思科 IOS 路由器的初始设置。</td></tr><tr><td align="left"><strong>配置接口</strong></td><td align="left">在思科 IOS 路由器上配置两个活动的接口。</td></tr><tr><td align="left"><strong>配置默认网关</strong></td><td align="left">配置设备，使其使用默认网关。</td></tr></tbody></table><h1 id="1、配置初始路由器设置"><a href="#1、配置初始路由器设置" class="headerlink" title="1、配置初始路由器设置"></a>1、配置初始路由器设置</h1><h2 id="1-1、基本路由器配置步骤"><a href="#1-1、基本路由器配置步骤" class="headerlink" title="1.1、基本路由器配置步骤"></a>1.1、基本路由器配置步骤</h2><p>在路由器上配置初始设置时，应完成以下任务。自定义项用[]表示</p><ol><li>配置设备名称。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# hostname [hostname]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>保护特权模式。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# enable secret [password]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>保护用户模式</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# line console 0Router(config-line)# password [password]Router(config-line)# login<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="4"><li>保护远程 Telnet / SSH 访问</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config-line)# line vty 0 4Router(config-line)# password [password]Router(config-line)# loginRouter(config-line)# transport input &#123;ssh | telnet&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>保护配置文件中的所有密码。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config-line)# exitRouter(config)# service password-encryption<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="6"><li>提供法律通知。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# banner motd [delimiter message delimiter]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>保存配置。</li></ol><pre class="line-numbers language-none"><code class="language-none">Router(config)# endRouter# copy running-config startup-config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-2、路由器基本配置示例"><a href="#1-2、路由器基本配置示例" class="headerlink" title="1.2、路由器基本配置示例"></a>1.2、路由器基本配置示例</h2><p>在此示例中，拓扑图中的路由器 R1 将使用初始设置进行配置。</p><p>要配置 R1 的设备名称，请使用以下命令。</p><pre class="line-numbers language-none"><code class="language-none">Router&gt; enable Router# configure terminal Enter configuration commands, one per line.End with CNTL&#x2F;Z.Router(config)# hostname R1 R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong> 注意路由器提示符现在如何显示路由器主机名。</p><p>所有路由器访问都应得到保护。特权 EXEC 模式为用户提供对设备及其配置的完全访问权限。因此，它是要去保护的最重要的模式。</p><p>以下命令保护特权 EXEC 模式和用户 EXEC 模式，启用 Telnet 和 SSH 远程访问，并加密所有明文（即用户 EXEC 和 VTY 线路）密码。</p><pre class="line-numbers language-none"><code class="language-none">R1(config)# enable secret class R1(config)#R1(config)# line console 0 R1(config-line)# password cisco R1(config-line)# login R1(config-line)# exit R1(config)#R1(config)# line vty 0 4 R1(config-line)# password cisco R1(config-line)# login R1(config-line)# transport input ssh telnet R1(config-line)# exit R1(config)#R1(config)# service password-encryption R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>法律通知警告用户只能由允许用户访问该设备。法律通知配置如下。</p><pre class="line-numbers language-none"><code class="language-none">R1(config)# banner motd #Enter TEXT message. End with a new line and the #*********************************************** WARNING: Unauthorized access is prohibited!***********************************************#R1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果前面的命令已配置，路由器意外断电，则所有已配置的命令都将丢失。因此，在实施变更时保存配置非常重要。以下命令将配置保存到 NVRAM。</p><pre class="line-numbers language-none"><code class="language-none">R1# copy running-config startup-configDestination filename [startup-config]? Building configuration...[OK]R1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3、语法检查器-配置初始路由器设置"><a href="#1-3、语法检查器-配置初始路由器设置" class="headerlink" title="1.3、语法检查器-配置初始路由器设置"></a>1.3、语法检查器-配置初始路由器设置</h2><p>略</p><h1 id="2、配置接口"><a href="#2、配置接口" class="headerlink" title="2、配置接口"></a>2、配置接口</h1><h2 id="2-1、配置路由器接口"><a href="#2-1、配置路由器接口" class="headerlink" title="2.1、配置路由器接口"></a>2.1、配置路由器接口</h2><p>此时，您的路由器已经有了基本配置。下一步将配置它们的接口。这是因为在配置接口之前，终端设备无法访问路由器。思科路由器上有许多不同类型的接口。例如，思科 ISR 4321 路由器配备了两个千兆以太网接口：</p><ul><li><strong>GigabitEthernet 0/0/0 (G0/0/0)</strong></li><li><strong>GigabitEthernet 0/0/1 (G0/0/1)</strong></li></ul><p>配置路由器接口的任务与交换机上管理 SVI 非常相似。具体来说，它包括发出以下命令：</p><pre class="line-numbers language-none"><code class="language-none">Router(config)# interface type-and-numberRouter(config-if)# description description-textRouter(config-if)# ip address ipv4-address subnet-maskRouter(config-if)# ipv6 address ipv6-address&#x2F;prefix-lengthRouter(config-if)# no shutdown<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong> 当路由器接口启用时，应显示确认已启用链接的信息。</p><p>虽然不需要 <strong>description</strong> 命令来启用接口，但使用它是一个很好的习惯。通过提供有关所连接的网络类型的信息，可以帮助解决生产网络上的故障。例如，如果接口连接到ISP或服务供应商，则使用<strong>description</strong>命令输入“第三方连接和联系信息”将会有帮助。</p><p><strong>注意</strong>: 说明文字最长不能超过 240 个字符。</p><p>使用<strong>no shutdown</strong> 命令可激活接口，类似于在接口上启动电源。接口还必须连接到另一台设备（交换机或路由器），才能使物理层处于活动状态。</p><p><strong>注意</strong>: 在没有以太网交换机的路由器间连接，必须配置和启用两个互连接口。</p><h2 id="2-2、配置路由器接口示例"><a href="#2-2、配置路由器接口示例" class="headerlink" title="2.2、配置路由器接口示例"></a>2.2、配置路由器接口示例</h2><p>在此示例中，将启用拓扑图中的 R1 直连接口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN10.1.png"></p><p>要在 R1 上配置接口，请使用以下命令。</p><pre class="line-numbers language-none"><code class="language-none">R1&gt; enableR1# configure terminalEnter configuration commands, one per line.End with CNTL&#x2F;Z.R1(config)# interface gigabitethernet 0&#x2F;0&#x2F;0R1(config-if)# description Link to LANR1(config-if)# ip address 192.168.10.1 255.255.255.0R1(config-if)# ipv6 address 2001:db8:acad:10::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)#*Aug  1 01:43:53.435: %LINK-3-UPDOWN: Interface GigabitEthernet0&#x2F;0&#x2F;0, changed state to down*Aug  1 01:43:56.447: %LINK-3-UPDOWN: Interface GigabitEthernet0&#x2F;0&#x2F;0, changed state to up*Aug  1 01:43:57.447: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0&#x2F;0&#x2F;0, changed state to upR1(config)#R1(config)#R1(config)# interface gigabitEthernet 0&#x2F;0&#x2F;1R1(config-if)# description Link to R2R1(config-if)# ip address 209.165.200.225 255.255.255.252R1(config-if)# ipv6 address 2001:db8:feed:224::1&#x2F;64R1(config-if)# no shutdownR1(config-if)# exitR1(config)#*Aug  1 01:46:29.170: %LINK-3-UPDOWN: Interface GigabitEthernet0&#x2F;0&#x2F;1, changed state to down*Aug  1 01:46:32.171: %LINK-3-UPDOWN: Interface GigabitEthernet0&#x2F;0&#x2F;1, changed state to up*Aug  1 01:46:33.171: %LINEPROTO-5-UPDOWN: Line protocol on Interface GigabitEthernet0&#x2F;0&#x2F;1, changed state to upR1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong> 注意那些通知我们G0/0/0 和 G0/0/1已启用了的信息。</p><h2 id="2-3、检验接口配置"><a href="#2-3、检验接口配置" class="headerlink" title="2.3、检验接口配置"></a>2.3、检验接口配置</h2><p>有多条命令可用于检验接口配置。其中最有用的是 <strong>show ip interface brief</strong> 和 <strong>show ipv6 interface brief</strong> 命令，如示例所示。</p><pre class="line-numbers language-none"><code class="language-none">R1#  show ip interface briefInterface IP-Address OK? Method Status Protocol GigabitEthernet0&#x2F;0&#x2F;0 192.168.10.1 YES manual up up GigabitEthernet0&#x2F;0&#x2F;1 209.165.200.225 YES manual up up Vlan1 unassigned YES unset administratively down down R1#  show ipv6 interface briefGigabitEthernet0&#x2F;0&#x2F;0 [up&#x2F;up]FE80::201:C9FF:FE89:45012001:DB8:ACAD:10::1GigabitEthernet0&#x2F;0&#x2F;1 [up&#x2F;up]FE80::201:C9FF:FE89:45022001:DB8:FEED:224::1Vlan1 [administratively down&#x2F;down]unassigned R1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4、配置验证命令"><a href="#2-4、配置验证命令" class="headerlink" title="2.4、配置验证命令"></a>2.4、配置验证命令</h2><p>此表总结了用于验证接口配置的更常用 <strong>show</strong> 命令。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>show ip interface brief</code>       <code>show ipv6 interface brief</code></td><td align="left">所有接口的输出显示,它们的IP地址和 当前的状态已配置和连接的接口的 状态和协议均会显示“up”; 显示任何其他内容都可能表示配置或 布线出现了问题。</td></tr><tr><td align="left"><code>show ip route</code>                           <code>show ipv6 route</code></td><td align="left">显示存储在 RAM 中的 IP 路由表的内容。</td></tr><tr><td align="left"><code>show interfaces</code></td><td align="left">显示设备上所有接口的统计信息。然而,这个命令将只显示 IPv4 编址信息。</td></tr><tr><td align="left"><code>show ip interface</code></td><td align="left">显示路由器上所有接口的 IPv4 统计信息。</td></tr><tr><td align="left"><code>show ipv6 interface</code></td><td align="left">显示路由器上所有接口的 IPv6 统计信息。</td></tr></tbody></table><h1 id="3、配置默认网关"><a href="#3、配置默认网关" class="headerlink" title="3、配置默认网关"></a>3、配置默认网关</h1><h2 id="3-1、主机的默认网关"><a href="#3-1、主机的默认网关" class="headerlink" title="3.1、主机的默认网关"></a>3.1、主机的默认网关</h2><p>如果您的本地网络只有一个路由器，它就将是网关路由器，并且必须使用此信息配置网络上的所有主机和交换机。如果您的本地网络有多个路由器，则必须选择其中一个作为默认网关路由器。本主题介绍如何在主机和交换机上配置默认网关。</p><p>对于通过网络通信的终端设备，必须配置正确的 IP 地址信息，包括默认网关地址。当主机要将数据包发送到另一个网络设备时，才会使用默认网关。默认网关地址通常是连接主机本地网络的路由器接口地址。主机设备的 IP 地址和路由器接口地址必须位于同一网络。</p><p>例如，假设 IPv4 网络拓扑由一个路由器连接两个不同的 LAN 组成。G0/0/0 连接到网络 192.168.10.0，G0/0/1 连接到网络 192.168.11.0。每台主机设备均配置有相应的默认网关地址。</p><p>在此示例中，如果 PC1 向 PC2 发送数据包，则不使用默认网关。相反，PC1 将 PC2 的 IP 地址指定给数据包，然后通过交换机将该数据包直接转发给 PC2。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN10.3.png"></p><p>如果 PC1 向 PC3 发送数据包，该怎么办？PC1 将 PC3 的 IPv4 地址指定给数据包，但会将数据包转发到其默认网关，即 R1 的 G0/0/0 接口。路由器接受数据包，访问其路由表，以确定G0/0/1是基于目标地址的适当出口接口。然后 R1 将数据包转发出相应的接口以达到 PC3。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN10.4.png"></p><p>IPv6 网络上也会发生相同的过程，尽管拓扑中未显示此过程。设备将使用本地路由器的 IPv6 地址作为其默认网关。</p><h2 id="3-2、交换机的默认网关"><a href="#3-2、交换机的默认网关" class="headerlink" title="3.2、交换机的默认网关"></a>3.2、交换机的默认网关</h2><p>连接客户端计算机的交换机通常是第 2 层设备。因此，第 2 层交换机不需要使用 IP 地址就能正常工作。但是，可以在交换机上配置 IP 配置，以便管理员能够远程访问交换机。</p><p>要通过本地 IP 网络连接和管理交换机，必须配置交换机虚拟接口 (SVI)。SVI 配置了本地局域网上的 IPv4 地址和子网掩码。要从远端网络管理交换机，必须给交换机配置一个默认网关。</p><p>在会通过本地网络之外的方式通信的所有设备上，一般都会配置默认网关地址。</p><p>要为交换机配置默认网关，请使用<strong>ip default-gateway</strong> ip-address 全局配置命令。配置的 IP 地址是连接到交换机的本地路由器接口的 IP 地址。</p><p>图中显示了管理员正在建立到另一个网络上的交换机 S1 的远程连接。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN10.5.png"></p><p>在此示例中，管理员主机将使用其默认网关将数据包发送到 R1 的 G0/0/1 接口。R1 会将数据包从其 G0/0/0 接口转发到 S1。由于数据包源 IPv4 地址来自另一个网络，因此 S1 需要默认网关才能将数据包转发到 R1 的 G0/0/0 接口。因此，S1必须配置默认网关才能够应答并建立与管理主机的 SSH 连接。</p><p><strong>注意:</strong> 来自与交换机相连的主机计算机的数据包必须在主机计算机操作系统上配置默认网关地址。</p><p>也可以使用 SVI 上的 IPv6 地址配置工作组交换机。但是，交换机不需要手动配置默认网关的 IPv6 地址。交换机将自动接收来自路由器的 ICMPv6 路由器公告消息的默认网关。</p><h2 id="3-4、Packet-Tracer-将路由器连接到LAN"><a href="#3-4、Packet-Tracer-将路由器连接到LAN" class="headerlink" title="3.4、Packet Tracer -将路由器连接到LAN"></a>3.4、Packet Tracer -将路由器连接到LAN</h2><p>略</p><h2 id="3-5、Packet-Tracer-排除默认网关故障"><a href="#3-5、Packet-Tracer-排除默认网关故障" class="headerlink" title="3.5、Packet Tracer - 排除默认网关故障"></a>3.5、Packet Tracer - 排除默认网关故障</h2><p>对于用来进行多个网络间通信的设备，必须为其配置 IP 地址、子网掩码和默认网关。在主机想向另一网络中的设备发送数据包时，需要使用默认网关。默认网关地址通常是与主机连接的本地网络中的路由器接口地址。在本练习中，您将完成网络的文档编制。然后您将通过测试端到端连接和故障排除问题来验证网络文档。您将使用的故障排除方法包括以下步骤：</p><ol><li>验证网络文档，并使用测试来查明问题。</li><li>为查明的问题确定一个适当的解决方案。</li><li>实施解决方案。</li><li>进行测试以验证问题是否已解决。</li><li>记录解决方案。</li></ol><h1 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h1><p>注：login命令应在<strong>线路配置模式</strong>来执行此任务</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（九）</title>
      <link href="/2021/1119365.html"/>
      <url>/2021/1119365.html</url>
      
        <content type="html"><![CDATA[<h1 id="九、地址解析"><a href="#九、地址解析" class="headerlink" title="九、地址解析"></a>九、地址解析</h1><p>主机和路由器都创建路由表，以确保它们可以跨网络发送和接收数据。那么这些信息是如何在路由表中被创建的呢? 作为网络管理员，您可以手动输入这些 MAC 和 IP 地址。但这将花费大量时间，而且犯一些错误的可能性很大。您是否认为一定有某种方式，由主机和路由器可以自动完成? 当然，您是对的！即使它是自动的，您仍然必须要了解它是如何工作的，因为您可能会需要排除一些故障，或更糟的是，您的网络可能会受到威胁发起者的攻击。</p><p><strong>模块目标</strong>: 介绍ARP和ND如何在网络上实现通信。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>MAC 和 IP</strong></td><td align="left">比较 MAC 地址和 IP 地址的不同作用。</td></tr><tr><td align="left"><strong>⁪ARP</strong></td><td align="left">阐述 ARP 的用途。</td></tr><tr><td align="left"><strong>邻居发现</strong></td><td align="left">描述 IPv6 邻居发现的工作方式。</td></tr></tbody></table><h1 id="1、MAC和IP"><a href="#1、MAC和IP" class="headerlink" title="1、MAC和IP"></a>1、MAC和IP</h1><h2 id="1-1、同一网络中的目的地"><a href="#1-1、同一网络中的目的地" class="headerlink" title="1.1、同一网络中的目的地"></a>1.1、同一网络中的目的地</h2><p>有时，主机必须发送消息，但它只知道目的设备的 IP 地址。主机需要知道该设备的MAC地址，但是如何才能发现它呢? 这就是地址解析变得至关重要的地方。</p><p>以太网 LAN 上的设备都配有两个主要地址：</p><ul><li><strong>物理地址（MAC 地址）</strong> – 用于同一网络上的以太网网卡之间的通信。</li><li><strong>逻辑地址（IP地址）</strong> – 用于将数据包从源设备发送到目的设备。目的IP地址可能与源地址在同一个IP网络上，也可能在远程网络上。</li></ul><p>第二层物理地址(即以太网MAC地址)用于将数据链路层帧从同一网络中一个网卡发送到另一个网卡， IP 数据包就封装在帧中。如果目的IP地址在同一网络上，则目的MAC地址将是目的设备的MAC地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.1.png"></p><p>在本示例中，PC1想要向PC2发送一个数据包。该图显示了从PC1发送的数据包中包含：第2层目的和源MAC地址以及第3层IPv4地址。</p><p>第2层以太网帧包含以下内容：</p><ul><li><strong>目的MAC地址</strong> – 这是简化的 PC2 MAC地址，55-55-55。</li><li><strong>源MAC地址</strong> – 这是 PC1上以太网网卡的简化MAC地址，aa-aa-aa。</li></ul><p>第 3 层 IP 数据包包含以下内容：</p><ul><li><strong>源 IPv4 地址</strong> – 这是 PC1 的 IPv4 地址，192.168.10.10。</li><li><strong>目的 IPv4 地址</strong> – 这是 PC2的 IPv4 地址, 192.168.10.11。</li></ul><h2 id="1-2、远程网络中的目的地"><a href="#1-2、远程网络中的目的地" class="headerlink" title="1.2、远程网络中的目的地"></a>1.2、远程网络中的目的地</h2><p>当目的 IP 地址(IPv4或IPv6)处于远程网络中时，则目的 MAC 地址为主机的默认网关的地址(即路由器接口)。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.2.jpg"></p><p>在本示例中，PC1想要向PC2发送一个数据包。PC2 位于远程网络上。因为目的IPv4地址与PC1不在同一个本地网络上，所以目的MAC地址是路由器上的本地默认网关地址。</p><p>路由器通过检查目的 IPv4 地址来确定转发 IPv4 数据包的最佳路径。路由器收到以太网帧后，将解封第 2 层信息。它可借助目的 IPv4 地址确定下一跳设备，然后将 IPv4 数据包封装在发送接口的新数据链路帧中。</p><p>在我们的示例中, R1现在用新的第2层地址信息封装数据包，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.3.jpg"></p><p>新的目的MAC地址将是R2 G0/0/1接口的地址，新的源MAC地址将是R1 G0/0/1接口的地址。</p><p>沿着路径中的每个链路，IP数据包都被封装在一个帧中。这个帧由该链路的数据链路层技术指定，如以太网。如果下一跳设备为最终目的地，则目的 MAC 地址将是该设备的以太网网卡的 MAC 地址，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.10.png"></p><p>数据流中 IP 数据包的 IP 地址如何与通往目的地路径中每条链路上的 MAC 地址相关联？对于IPv4数据包，这可以通过<strong>地址解析协议</strong> (ARP) 过程来完成。对于IPv6数据包，这个过程是ICMPv6<strong>邻居发现</strong>(ND)。</p><h1 id="2、ARP"><a href="#2、ARP" class="headerlink" title="2、ARP"></a>2、ARP</h1><h2 id="2-1、ARP概述"><a href="#2-1、ARP概述" class="headerlink" title="2.1、ARP概述"></a>2.1、ARP概述</h2><p>如果您的网络使用IPv4通信协议，则需要使用地址解析协议(ARP)将IPv4地址映射到MAC地址。本主题介绍ARP是如何工作的。</p><p>以太网网络上的每个IP设备都有一个唯一的以太网MAC地址。当设备发送以太网第2层帧时，将包含以下两个地址：</p><ul><li><strong>目的 MAC 地址</strong> - 目的设备位于同一本地网络上，则为其以太网MAC地址。如果目的主机位于另一个网络上，则帧中的目的地址将是默认网关（即路由器）的地址。</li><li><strong>源 MAC 地址</strong> - 源主机以太网网卡的MAC地址。</li></ul><p>该图说明了将帧发送到 IPv4 网络上同一段中的另一个主机时出现的问题。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.4.png"></p><p>要向同一本地IPv4网络上的另一个主机发送数据包，主机必须知道目的设备的IPv4地址和MAC地址。设备目的IPv4地址可以是已知的，也可以通过设备名称解析。然而，MAC地址必须被发现。</p><p><strong>设备使用地址解析协议(ARP)来确定一个已知 IPv4 地址的本地设备的目的MAC地址。</strong></p><p>ARP 提供两个基本功能：</p><ul><li>将 IPv4 地址解析为 MAC 地址</li><li>维护IPv4到MAC地址映射表</li></ul><h2 id="2-2、ARP功能"><a href="#2-2、ARP功能" class="headerlink" title="2.2、ARP功能"></a>2.2、ARP功能</h2><p>当数据包发送到要封装入以太网帧的数据链路层时，设备将参照其内存中的表来查找映射至 IPv4 地址的 MAC 地址。此表临时存储在RAM内存中，称为 ARP 表或 ARP 缓存。</p><p>发送设备会在自己的 ARP 表中搜索目的 IPv4 地址和相应的 MAC 地址。</p><ul><li>如果数据包的目的 IPv4 地址与源 IPv4 地址处于同一个网络，则设备会在 ARP 表中搜索目的 IPv4 地址。</li><li>如果目的 IPv4 地址与源 IPv4 地址不在同一个网络中，则设备会在 ARP 表中搜索默认网关的 IPv4 地址。</li></ul><p>这两种情况都是搜索设备的 IPv4 地址和与其相对应的 MAC 地址。</p><p>ARP 表中的每一条（或每行）将一个 IPv4 地址与一个 MAC 地址绑定。我们把两个值之间的关系称为映射。这意味着您可以在表中查找 IPv4 地址并发现相应的 MAC 地址。ARP 表暂时保存（缓存）LAN 上设备的映射。</p><p>如果设备找到 IPv4 地址，其相应的 MAC 地址将作为帧中的目的 MAC 地址。如果找不到该条目，设备会发送一个 ARP 请求。</p><h2 id="2-3、视频-ARP请求"><a href="#2-3、视频-ARP请求" class="headerlink" title="2.3、视频-ARP请求"></a>2.3、视频-ARP请求</h2><p>当设备需要确定与 IPv4 地址关联的 MAC 地址，而它的 ARP 表中没有该 IPv4 地址条目时，会发送一个 ARP 请求。</p><p>ARP 消息直接封装到以太网帧中。没有 IPv4 报头。ARP 请求使用以下帧头信息封装在以太网帧中：</p><ul><li><strong>目的 MAC 地址</strong> – 这是一种要求 LAN 上的所有以太网网卡接受并处理 ARP 请求的广播地址FF-FF-FF-FF-FF-FF。</li><li><strong>源 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li><li><strong>类型</strong> - ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</li></ul><p>因为 ARP 请求属于广播，交换机会将其泛洪到除接收端口外的其他所有端口。局域网上的所有以太网网卡都会处理广播，并且必须将ARP请求发送到其操作系统进行处理。每台设备必须处理 ARP 请求，以检查目的 IPv4 地址是否与其自己的地址相匹配。路由器不会将广播转发到其他接口。</p><p>LAN 上只有一台设备的 IPv4 地址与 ARP 请求中的目的 IPv4 地址相匹配。所有其他设备将不应答。</p><h2 id="2-4、视频-ARP操作-ARP应答"><a href="#2-4、视频-ARP操作-ARP应答" class="headerlink" title="2.4、视频-ARP操作 -ARP应答"></a>2.4、视频-ARP操作 -ARP应答</h2><p>只有具有与ARP请求相应的目的IPv4地址的设备才会以ARP应答做出响应。ARP 应答使用以下帧头信息封装在以太网帧中：</p><ul><li><strong>目的 MAC 地址</strong> – 这是ARP请求发送方的MAC地址。</li><li><strong>源 MAC 地址</strong> – 这是ARP应答发送方的MAC地址。</li><li><strong>类型</strong> – ARP 消息的类型字段为 0x806。该类型字段会通知接收网卡需要将帧的数据部分传递给 ARP 进程处理。</li></ul><p>只有原始发送 ARP 请求的设备会收到单播 ARP 应答。收到该 ARP 应答后，设备会将 IPv4 地址及相应的 MAC 地址添加到自身的 ARP 表中。该 IPv4 地址的数据包现在便可使用其相应的 MAC 地址封装在帧中。</p><p>如果没有设备响应 ARP 请求，就无法创建帧，那么这个数据包会被丢弃。</p><p>ARP 表中的条目具有时间戳。如果设备在时间戳到期前没有从特定设备收到帧，此设备的条目将会从 ARP 表中删除。</p><p>此外，也可以在 ARP 表中输入静态映射条目，但这种情况很少见。静态 ARP 表条目没有到期时间，必须手动删除。</p><p><strong>注意</strong>: IPv6 使用与 IPv4 类似的 ARP 流程，称为 ICMPv6 邻居发现(ND)。与 IPv4 的 ARP 请求和 ARP 应答类似，Pv6 使用邻居请求和邻居通告消息。</p><h2 id="2-5、视频-ARP在远程通信中的作用"><a href="#2-5、视频-ARP在远程通信中的作用" class="headerlink" title="2.5、视频-ARP在远程通信中的作用"></a>2.5、视频-ARP在远程通信中的作用</h2><p>当目的 IPv4 地址与源 IPv4 地址位于不同网络时，源设备需要将帧发送到其默认网关。这是本地路由器的接口。每当源设备具有 IPv4 地址在其他网络中的数据包时，它会使用路由器的目的 MAC 地址将该数据包封装在帧中。</p><p>默认网关的 IPv4 地址存储在主机的 IPv4 配置中。当主机创建通往某台目的主机的数据包时，会将目的 IPv4 地址与其自己的 IPv4 地址进行比较，以确定两个 IPv4 地址是否位于相同的第 3 层网络上。如果目的主机不在同一网络上，源主机将从 ARP 表中查找默认网关的 IPv4 地址条目。如果没有该条目，源主机将使用 ARP 流程来确定默认网关的 MAC 地址。</p><h2 id="2-6、从ARP表中删除条目"><a href="#2-6、从ARP表中删除条目" class="headerlink" title="2.6、从ARP表中删除条目"></a>2.6、从ARP表中删除条目</h2><p>对于每台设备，ARP 缓存定时器将会删除在指定时间内未使用的 ARP 条目。时间根据设备的操作系统不同而不同。例如，较新的 Windows 操作系统将 ARP 表条目存储 15 秒到 45 秒之间</p><p>也可以使用命令来手动删除 ARP 表中的部分或全部条目。当条目被删除之后，要想在 ARP 表中输入映射，必须重复一次发送 ARP 请求和接收 ARP 回复的过程。</p><h2 id="2-7、网络设备上的ARP表"><a href="#2-7、网络设备上的ARP表" class="headerlink" title="2.7、网络设备上的ARP表"></a>2.7、网络设备上的ARP表</h2><p>在思科路由器上，<strong>show ip arp</strong>命令用于显示 ARP 表。</p><p>在 Windows 10 PC 上，<strong>arp –a</strong>命令用于显示 ARP 表。</p><h2 id="2-8、ARP问题-ARP广播和ARP欺骗"><a href="#2-8、ARP问题-ARP广播和ARP欺骗" class="headerlink" title="2.8、ARP问题-ARP广播和ARP欺骗"></a>2.8、ARP问题-ARP广播和ARP欺骗</h2><p>作为广播帧，本地网络上的每台设备都会收到并处理 ARP 请求。在一般的商业网络中，这些广播对网络性能的影响可能微不足道。但是，如图所示，如果大量设备都已启动，并且同时开始使用网络服务，网络性能可能会有短时间的下降。在设备发出初始 ARP 广播并获取必要的 MAC 地址之后，网络受到的影响将会降至最小。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.5.png"></p><p>有时，使用 ARP 可能会造成潜在的安全风险。威胁发起者可以使用 ARP 欺骗来执行 ARP 毒化攻击。如图所示，威胁发起者使用这种技术来应答属于另一台设备（例如默认网关）的 IPv4 地址的 ARP 请求。威胁发起者会发送一个带有自己 MAC 地址的 ARP 应答。ARP 应答的接收方会将错误的 MAC 地址添加到其 ARP 表中，并将这些数据包发送给威胁发起者。 企业级的交换机包含称为动态 ARP 检查 (DAI) 的缓解技术。DAI 不在本课程的讨论范围之内。</p><h1 id="3、IPv6邻居发现"><a href="#3、IPv6邻居发现" class="headerlink" title="3、IPv6邻居发现"></a>3、IPv6邻居发现</h1><h2 id="3-1、视频-IPv6邻居发现"><a href="#3-1、视频-IPv6邻居发现" class="headerlink" title="3.1、视频-IPv6邻居发现"></a>3.1、视频-IPv6邻居发现</h2><p>如果您的网络使用IPv6通信协议，则需要使用邻居发现协议(ND)将 IPv6 地址与 MAC 地址进行匹配。本主题介绍ND是如何工作的。</p><h2 id="3-2、IPv6邻居发现消息"><a href="#3-2、IPv6邻居发现消息" class="headerlink" title="3.2、IPv6邻居发现消息"></a>3.2、IPv6邻居发现消息</h2><p>IPv6 邻居发现协议有时被称为 ND 或 NDP。在本课程中，我们称它为 ND。ND使用ICMPv6为IPv6提供地址解析、路由器发现和重定向服务。ICMPv6 ND 使用五种 ICMPv6 消息来执行这些服务：</p><ul><li>邻居请求消息</li><li>邻居通告消息</li><li>路由器请求消息</li><li>路由器通告消息</li><li>重定向消息</li></ul><p>邻居请求和邻居通告消息用于设备到设备的消息传递，例如地址解析（类似于 IPv4 的 ARP）。设备包括主机计算机和路由器。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.6.png"></p><p>路由器请求和路由器通告消息用于设备和路由器之间的消息传递。通常，路由器发现用于动态地址分配和无状态地址自动配置 (SLAAC)。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.7.png"></p><p><strong>注意</strong>: 第五个 ICMPv6 ND 消息是一个重定向消息，用于更好的下一跳选择。这不在本课程的讨论范围之内。</p><p>IPv6 ND 是在 IETF RFC 4861 中定义的。</p><h2 id="3-3、IPv6邻居发现-地址解析"><a href="#3-3、IPv6邻居发现-地址解析" class="headerlink" title="3.3、IPv6邻居发现-地址解析"></a>3.3、IPv6邻居发现-地址解析</h2><p>与IPv4的ARP非常相似，IPv6设备使用IPv6 ND来确定一个已知IPv6地址的设备的MAC地址。</p><p>ICMPv6 邻居请求和邻居通告消息用于MAC地址解析。这类似于ARP用于IPv4的ARP请求和ARP应答。例如，假设 PC1 想要ping PC2的Ipv6地址2001:db8:acad::11。为了确定已知IPv6地址的MAC地址，PC1发送一个ICMPv6邻居请求消息，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.8.png"></p><p>ICMPv6邻居请求消息使用特定的以太网和IPv6<strong>组播</strong>地址发送。这允许接收设备的以太网卡确定邻居请求消息是否属于它自己，而不必将它发送到操作系统进行处理。</p><p>PC2使用包含其MAC地址的ICMPv6邻居通告消息来应答请求。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN9.9.png"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络协议 思科 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（八）</title>
      <link href="/2021/111823859.html"/>
      <url>/2021/111823859.html</url>
      
        <content type="html"><![CDATA[<h1 id="八、网络层"><a href="#八、网络层" class="headerlink" title="八、网络层"></a>八、网络层</h1><p>在 OSI 模型的网络层，我们将向您介绍通信协议和路由协议。假设您想给住在另一个城市，甚至另一个国家的朋友发一封电子邮件。这个人和您不在同一个网络上。一个简单的交换网络无法获得比您自己的网络末端更远的消息。您需要一些帮助，以保持这条消息沿着去往您朋友的终端设备的路径移动。要向不在本地网络上的任何人发送电子邮件（视频或文件等），您必须能够访问路由器。要访问路由器，您必须使用网络层协议。</p><p><strong>模块目标</strong>: 说明路由器如何使用网络层协议和服务来实现端到端连接。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>网络层的特征</strong></td><td align="left">说明网络层如何利用 IP 协议进行可靠的 通信。</td></tr><tr><td align="left"><strong>IPv4 数据包</strong></td><td align="left">说明 IPv4 数据包中主要报头字段的作用。</td></tr><tr><td align="left"><strong>IPv6 数据包</strong></td><td align="left">说明 IPv6 数据包中主要报头字段的作用。</td></tr><tr><td align="left"><strong>主机路由方式</strong></td><td align="left">说明网络设备如何使用路由表将数据包引导至 目的网络。</td></tr><tr><td align="left"><strong>路由器路由表</strong></td><td align="left">说明路由器路由表中各个字段的作用。</td></tr></tbody></table><h1 id="1、网络层的特征"><a href="#1、网络层的特征" class="headerlink" title="1、网络层的特征"></a>1、网络层的特征</h1><h2 id="1-1、网络层"><a href="#1-1、网络层" class="headerlink" title="1.1、网络层"></a>1.1、网络层</h2><p>网络层即 OSI 第 3 层，提供能够让终端设备跨整个网络交换数据的服务。如图所示，IP 版本 4 (IPv4) 和 IP 版本 6 (IPv6) 是主要的网络层通信协议。其他网络层协议包括路由协议，如开放式最短路径优先协议(OSPF)，和消息传递协议，如Internet控制消息协议(ICMP)。</p><p>为了实现跨网络边界的端到端通信，网络层协议执行四个基本操作:</p><ul><li><strong>终端设备编址</strong> - 必须为终端设备配置唯一的 IP 地址，以便在网络上进行识别。</li><li><strong>封装</strong> - 网络层将来自传输层的协议数据单元 (PDU) 封装到数据包中。封装过程中会添加 IP 报头信息，例如来源（发送）和目的（接收）主机的 IP 地址。封装过程由 IP 数据包的源主机执行。</li><li><strong>路由</strong> - 网络层提供服务，将数据包转发至另一网络上的目的主机。要传送到其他网络，数据包必须经过路由器的处理。<strong>路由器的作用是为数据包选择最佳路径，并将其转发至目的主机，该过程称为路由。</strong>数据包可能需要经过很多路由器才能到达目的主机。<strong>数据包在到达目的主机的过程中经过的每个路由器均称作一跳。</strong></li><li><strong>解封</strong> - 当数据包到达目的主机的网络层时，主机会检查数据包的 IP 报头。如果在报头中的目的 IP 地址与其自身的 IP 地址匹配，IP 报头将被会从数据包中删除。网络层解封数据包后，后继的第 4 层 PDU 会向上传递到传输层的相应服务。解封过程由 IP 数据包的目的主机执行。</li></ul><p><strong>传输层（OSI 第 4 层）负责管理每台主机上的运行进程之间的数据传输，而网络层通信协议（即，IPv4和IPv6）则指定从一台主机向另一台主机传送数据时使用的数据包结构和处理过程。</strong>网络层工作时无需考虑每个数据包中所携带的数据，这使其能够为多台主机之间的多种类型的通信传送数据包。</p><p>数据-(传输层封装)-&gt;数据段-(网络层封装)-&gt;数据包-(数据链路层封装)-&gt;帧-(物理层转换)-&gt;位——&gt;位-&gt;帧-&gt;数据包-&gt;数据段-&gt;数据</p><h2 id="1-2、IP封装"><a href="#1-2、IP封装" class="headerlink" title="1.2、IP封装"></a>1.2、IP封装</h2><p>IP 通过添加 IP 报头将传输层（网络层之上的层）数据段或其他数据进行封装。IP报头用于将数据包传送到目的主机。</p><p>该图显示了网络层 PDU 如何封装传输层 PDU 来创建 IP 数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.1.png"></p><p>逐层封装数据的流程使我们可以开发和扩展位于不同层的服务而不影响其他层。这意味着传输层数据段可以随时通过 IPv4 或 IPv6 进行封装，或使用未来可能开发出的任何新协议进行封装。</p><p>IP数据包在通过网络传输到其目的地时，会被第3层设备（即路由器和第3层交换机）检查IP报头。需要注意的是，从数据包离开源主机到达目的主机之前，IP编址信息保持不变，除非是由为IPv4执行网络地址转换(NAT)（后边会讲）的设备进行转换。</p><p>路由器实施路由协议以在网络之间路由数据包。这些中间设备所执行的路由进程会检查数据包报头中的网络层地址。在任何情况下，数据包的数据部分，即封装的传输层 PDU或其他数据，在网络层的各个过程中都保持不变。</p><h2 id="1-3、IP特征"><a href="#1-3、IP特征" class="headerlink" title="1.3、IP特征"></a>1.3、IP特征</h2><p>IP 被设计为一种低开销协议。它只提供通过互连的网络系统从源主机向目的主机传送数据包所必需的功能。该协议并不负责跟踪和管理数据包的流动。这些功能（如果需要）将由其他层的其他协议（主要是第 4 层的 TCP）执行。</p><p>这些是IP的基本特征：</p><ul><li><strong>无连接</strong> - 发送数据包前不与目的地建立连接。</li><li><strong>尽力而为</strong> - IP本质上是不可靠的，因为不保证数据包交付。</li><li><strong>介质无关性</strong> - 其工作与传输数据的介质（即铜缆、光纤或无线）无关。</li></ul><h2 id="1-4、无连接"><a href="#1-4、无连接" class="headerlink" title="1.4、无连接"></a>1.4、无连接</h2><p>IP 是无连接协议，这意味着发送数据前IP不会创建专用的端到端连接。无连接通信的概念类似于不事先通知收件人就邮寄信件。</p><p>无连接数据通信按照同样的原理工作。IP 在转发数据包前，并不需要初步交换控制信息来创建端到端连接。</p><h2 id="1-5、“尽力而为”（Best-Effort）"><a href="#1-5、“尽力而为”（Best-Effort）" class="headerlink" title="1.5、“尽力而为”（Best Effort）"></a>1.5、“尽力而为”（Best Effort）</h2><p>IP 也不需要报头中包含其他字段来维持建立的连接。此过程显著降低了 IP 的开销。但是，由于没有预先建立端到端连接，发送数据包时，发送方不知道目的地是否存在和正常运行，同时发送数据包时，也不会知道目的地是否接收数据包，或者，目的设备是否可以访问并读取数据包。</p><p>IP 协议不保证交付的所有数据包都能被收到。图中显示了 IP 协议不可靠或尽力交付的特征。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.2.png"></p><p>作为一个不可靠的网络层协议，IP 不能确保所有发送的数据包都能收到。其他协议将管理跟踪数据包的过程并确保数据包的送达。</p><h2 id="1-6、介质无关性"><a href="#1-6、介质无关性" class="headerlink" title="1.6、介质无关性"></a>1.6、介质无关性</h2><p>不可靠表示 IP 不具备管理和恢复未送达数据包或已损坏数据包的能力。这是因为，在根据传输位置信息传输 IP 数据包时，数据包不包含可以经过处理以通知发送方信息交付是否成功的消息。传送到时，数据包可能已经损坏或顺序错乱，或者根本就没有传送成功。如果出错，IP 无法重新传输数据包。</p><p>如果数据包顺序错乱或丢失，则使用数据或上层服务的应用程序必须解决这些问题。这让 IP 可以非常有效地发挥作用。在 TCP/IP 协议簇中，可靠性是TCP协议在传输层的功能。</p><p>IP 的工作与在协议栈低层传送数据的介质无关。IP 数据包既可以作为电信号通过铜缆传送，也可以作为光信号通过光纤传送或作为无线电信号无线传送。</p><p>OSI 数据链路层负责接收数据包并准备数据包以在通信介质上传输。这就意味着 IP 数据包的交付不限于任何特定的介质。</p><p>但是，网络层会考虑介质的一个重要特征：每种介质可以传输的最大 PDU 大小。此特征称为**最大传输单位 (MTU)**。数据链路层和网络层之间的部分控制通信就是确定数据包的最大尺寸。数据链路层将 MTU 值向上传送到网络层。网络层会由此确定可以传送的数据包的大小。</p><p>有时，中间设备（通常是路由器），在将IPv4数据包从一个介质转发到具有更小 MTU 的介质时，必须分割数据包。此过程称为数据包分片或分片。分片会导致延迟。IPv6 数据包不能被路由器分片。</p><h1 id="2、IPv4数据包"><a href="#2、IPv4数据包" class="headerlink" title="2、IPv4数据包"></a>2、IPv4数据包</h1><h2 id="2-1、IPv4数据包报头"><a href="#2-1、IPv4数据包报头" class="headerlink" title="2.1、IPv4数据包报头"></a>2.1、IPv4数据包报头</h2><p>IPv4 是主要网络层通信协议之一。IPv4 数据包报头用于确保此数据包在到达目的地终端设备的路上被传递到其下一站。</p><p>IPv4 数据包报头是由包含重要数据包信息的字段组成。这些字段中包含的二进制数字由第 3 层进程进行检查。</p><h2 id="2-2、IPv4数据包报头字段"><a href="#2-2、IPv4数据包报头字段" class="headerlink" title="2.2、IPv4数据包报头字段"></a>2.2、IPv4数据包报头字段</h2><p>每个字段的二进制值均用于确定 IP 数据包的各种设置。协议报头图（从左到右、从上到下阅读）可提供在讨论协议字段时参考的直观图。图中所示的 IP 协议报头图标识了 IPv4 数据包中的字段。</p><p><strong>IPv4数据包报头中的字段</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.3.png"></p><p>IPv4 报头中的重要字段包括以下：</p><ul><li><strong>版本 -</strong> 包含一个 4 位二进制值 0100，用于标识这是 IPv4 数据包。</li><li><strong>差分服务或区分服务 (DS) -</strong> 以前称为服务类型 (ToS) 字段，DS 字段是一个 8 位字段，用<strong>于确定每个数据包的优先级</strong>。DiffServ 字段的六个最高有效位是区分服务代码点 (DSCP)位，而后两位是显式拥塞通知 (ECN) 位。</li><li><strong>报头校验和 -</strong> 这用于检测 IPv4 报头中的损坏。</li><li><strong>生存时间 (TTL) -</strong> TTL包含一个 8 位二进制值，用于限制数据包的生命周期。IPv4 数据包的源设备设置初始 TTL 值。当数据包每被路由器处理一次，数值就减少一。如果 TTL 字段的值减为零，则路由器将丢弃该数据包并向源 IP 地址发送互联网控制消息协议 (ICMP) 超时消息。由于路由器减少每个数据包的 TTL，因此路由器也必须重新计算报头校验和。</li><li><strong>协议 -</strong> 该字段用于标识下一级协议。此 8 位二进制值表示数据包包含的数据负载类型，使网络层将数据传送到相应的上层协议。常用的值包括 ICMP (1)、TCP (6) 和 UDP (17)。</li><li><strong>源 IPv4 地址 -</strong> 包含表示数据包源 IPv4 地址的 32 位二进制值。源 IPv4 地址始终为单播地址。</li><li><strong>目的 IPv4 地址 -</strong> 包含 32 位二进制值，表示数据包的目的 IPv4 地址。目的 IPv4 地址为单播、组播或广播地址。</li></ul><p>两种最常参考的字段是<strong>源和目的 IP 地址</strong>。这些字段用于确定数据包的源位置和目的位置。通常，在从源传输到目的地期间，这些地址不会改变。</p><p><strong>互联网报头长度 (IHL)<strong>、</strong>总长度</strong>和<strong>报头校验和</strong>字段用于识别和验证数据包。</p><p><strong>其他字段用于重新排列分段的数据包</strong>。具体而言，IPv4 数据包使用标识符、标志和片偏移量字段跟踪分段。路由器从一种介质向具有较小 MTU 的另一种介质转发IPv4数据包时必须将它分片。</p><p>注意：选项和填充字段很少使用，因此不在本模块的介绍范围之内。</p><h2 id="2-3、视频-Wireshark中的IPv4报头示例"><a href="#2-3、视频-Wireshark中的IPv4报头示例" class="headerlink" title="2.3、视频-Wireshark中的IPv4报头示例"></a>2.3、视频-Wireshark中的IPv4报头示例</h2><p>略</p><h1 id="3、IPv6数据包"><a href="#3、IPv6数据包" class="headerlink" title="3、IPv6数据包"></a>3、IPv6数据包</h1><h2 id="3-1、IPv4的局限性"><a href="#3-1、IPv4的局限性" class="headerlink" title="3.1、IPv4的局限性"></a>3.1、IPv4的局限性</h2><p>IPv4 今天仍在使用。本主题介绍 IPv6，它最终将取代 IPv4。了解IPv4的局限性和IPv6的优势，有助于您更好地理解为什么需要了解IPv6协议。</p><p>多年来，为应对新的挑战，已经制定了附加议定书和规程。但是，尽管经历了多次变更，IPv4 仍然有三个重要问题：</p><ul><li><strong>IPv4地址耗尽 -</strong> IPv4 的可用唯一公有地址数量有限。尽管有大约 40 亿的 IPv4 地址，但是支持 IP 的新设备数量的不断增加，以及始终在线的连接的增加，和欠发达地区的潜在连接的增加，不断催生更多的地址需求。</li><li><strong>缺乏端到端连接 -</strong> 网络地址转换 (NAT) 是 IPv4 网络中经常实施的一项技术。NAT 为多种设备共享单一的公有 IPv4 地址提供方法。但是，因为共享了公有 IPv4 地址，内部网络主机的 IPv4 地址会隐藏起来。这会给需要端到端连接的技术造成难题。</li><li><strong>增加的网络复杂性</strong> - 虽然NAT延长了IPv4的寿命，但它只是作为一种过渡到IPv6的机制。NAT在其各种实施中增加了网络的复杂性，从而造成延迟并使故障排除更加困难。</li></ul><h2 id="3-2、IPv6概述"><a href="#3-2、IPv6概述" class="headerlink" title="3.2、IPv6概述"></a>3.2、IPv6概述</h2><p>早在 20 世纪 90 年代早期，互联网工程任务组 (IETF) 就增加了对 IPv4 相关问题的关注并开始寻找替代方案。这促使了 IP 版本 6 (IPv6) 的开发。IPv6 解决了 IPv4 的限制并有着显著的功能提升，它能更好地适应当前和可预见的网络需求。</p><p>IPv6 的功能提升包括以下：</p><ul><li><strong>更大的地址空间</strong> - IPv6 地址基于 128 位分层编址，而 IPv4 采用的是 32 位。</li><li><strong>改进数据包处理过程</strong> - IPv6 报头简化为更少的字段。</li><li><strong>消除了对 NAT 的需求</strong> - 有了数额如此巨大的公有 IPv6 地址，私有 IPv4 地址和公有 IPv4 地址之间不再需要 NAT。这可避免需要端到端连接的应用程序遇到某些由 NAT 引起的故障。</li></ul><h2 id="3-3、IPv6数据包报头中的IPv4数据包报头字段"><a href="#3-3、IPv6数据包报头中的IPv4数据包报头字段" class="headerlink" title="3.3、IPv6数据包报头中的IPv4数据包报头字段"></a>3.3、IPv6数据包报头中的IPv4数据包报头字段</h2><p>IPv6 较 IPv4 的一个重大改进是简化的 IPv6 报头。</p><p>例如，IPv4 报头包含 20 个二进制八位组的可变长度报头（如果使用“选项”字段，则高达 60 字节）和 12 个基本报头字段（不包括“选项”字段和“填充”字段）。</p><p>对于 IPv6，某些字段保持不变，某些字段的名称和位置发生了变化，而某些 IPv4 字段不再需要</p><h2 id="3-4、IPv6数据包报头"><a href="#3-4、IPv6数据包报头" class="headerlink" title="3.4、IPv6数据包报头"></a>3.4、IPv6数据包报头</h2><p>下图显示的简化 IPv6 报头包含 40 个二进制八位数的固定长度报头（主要为源和目的 IPv6 地址的长度）。</p><p>IPv6 简化报头允许更高效地处理 IPv6 报头。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.4.png"></p><p>IPv6 数据包报头中的字段包括以下：</p><ul><li><strong>版本 -</strong> 此字段包含一个 4 位二进制值 0110，用于标识这是 IPv6 数据包。</li><li><strong>流量类别 -</strong> 此 8 位字段相当于IPv4 区分服务 (DS)字段。</li><li><strong>流标签 -</strong> 此 20 位字段建议所有含相同流标签的数据包接受相同类型的路由器处理。</li><li><strong>负载长度 -</strong> 此 16 位字段表示 IPv6 数据包的数据部分或负载的长度。这不包括 IPv6 报头的长度，它是固定的 40 字节报头。</li><li><strong>下一报头 -</strong> 此 8 位字段相当于“IPv4 协议”字段。它表示数据包传送的数据负载类型，使网络层将数据传送到相应的上层协议。</li><li><strong>跳数限制 -</strong> 此 8 位字段取代 IPv4 的 TTL 字段。每个转发数据包的路由器均会使此数值减一。当跳数达到 0 时，会丢弃此数据包，并且会向发送主机转发 ICMPv6 超时消息。这表明包没有到达目的地，因为超出了跳数限制。与 IPv4 不同，IPv6 不包括 IPv6 报头校验和，因为此功能同时在下层和上层执行。这意味着校验和不需要在每个路由器降低跳数限制字段时重新计算，这也提高了网络性能。</li><li><strong>源 IPv6 地址 -</strong> 此 128 位字段用于标识发送主机的 IPv6 地址。</li><li><strong>目的 IPv6 地址 -</strong> 此 128 位字段用于标识接收主机的 IPv6 地址。</li></ul><h2 id="3-5、视频-Wireshark中的IPv6报头示例"><a href="#3-5、视频-Wireshark中的IPv6报头示例" class="headerlink" title="3.5、视频-Wireshark中的IPv6报头示例"></a>3.5、视频-Wireshark中的IPv6报头示例</h2><p>略</p><h1 id="4-、主机路由方式"><a href="#4-、主机路由方式" class="headerlink" title="4.、主机路由方式"></a>4.、主机路由方式</h1><h2 id="4-1、主机转发决策"><a href="#4-1、主机转发决策" class="headerlink" title="4.1、主机转发决策"></a>4.1、主机转发决策</h2><p>对于IPv4和IPv6，数据包总是在源主机上创建。源主机必须能够将数据包定向到目的主机。为此，主机终端设备将创建自己的路由表。本主题讨论终端设备如何使用路由表。</p><p>网络层的另一个作用是在主机之间转发数据包。主机可以将数据包发送至如下：</p><ul><li><strong>主机自己</strong> - 主机可以通过向特定的地址发送数据包来向自己发起ping测试，这个特定的地址是：IPv4地址127.0.0.1，或者IPv6地址 ::1，它被称为环回接口。对环回接口执行 ping 操作可以测试主机上的 TCP/IP 协议堆栈。</li><li><strong>本地主机</strong> - 目的主机与发送主机位于同一本地网络。源和目的主机共享同一个网络地址。</li><li><strong>远程主机</strong> - 这是位于远程网络上的目的主机。源和目的主机不共享同一个网络地址。</li></ul><p>数据包是要发送到本地主机还是远程主机是由源端设备决定的。源端设备确定目的 IP 地址是否与源设备本身所在的网络相同。确定方法因 IP 版本不同而异：</p><ul><li><strong>在 IPv4 中</strong> -源设备使用自己的子网掩码以及自己的 IPv4 地址和目的 IPv4 地址来进行此判断。</li><li><strong>在 IPv6 中</strong> -本地路由器将本地网络地址（前缀）通告给网络上的所有设备。</li></ul><p>在家庭或企业网络中，您可能有若干通过中间设备（LAN 交换机和/或无线接入点 (WAP) 等）互联的有线和无线设备。这种中间设备在本地网络上的本地主机之间提供互联服务。本地主机可以互相访问和共享信息，无需任何附加设备。如果主机要将数据包发送到与本主机在同一 IP 网络中的设备，则数据包仅是被转发出主机接口，然后经过中间设备即可直接到达目的设备。</p><p>当然，在大多数情况下我们希望我们的设备不仅仅能够连接本地网段，还能连接其他家庭、企业和互联网。位于本地网段外的设备称为远程主机。如果源设备发送数据包到远程目的设备，则需要借助路由器和路由。路由是确定到达目的地之最佳路径的过程<strong>。连接到本地网段的路由器称为默认网关。</strong></p><h2 id="4-2、默认网关"><a href="#4-2、默认网关" class="headerlink" title="4.2、默认网关"></a>4.2、默认网关</h2><p>默认网关是可以将流量路由到其他网络的网络设备(即，路由器或第3层交换机)。如果把一个网络比作一个房间，那么默认网关就好比是门口。如果要去另一个房间或网络，您就需要找到门口。</p><p>在网络上，默认网关通常是具有以下功能的路由器：</p><ul><li>它拥有与本地网络其他主机位于相同地址范围的本地 IP 地址。</li><li>它可以接受数据到本地网络，并将数据转发出本地网络。</li><li>它向其他网络路由流量。</li></ul><p>需要使用默认网关来发送本地网络之外的流量。如果没有默认网关、未配置默认网关地址或默认网关关闭，则无法将流量转发到本地网络之外。</p><h2 id="4-3、主机路由到默认网关"><a href="#4-3、主机路由到默认网关" class="headerlink" title="4.3、主机路由到默认网关"></a>4.3、主机路由到默认网关</h2><p>主机的路由表通常包括默认网关。在IPv4中，主机通过动态主机配置协议 (DHCP) 动态接收默认网关 IPv4 地址，或者通过手动配置。在 IPv6 中，路由器通告默认网关地址，或者可以在主机上手动配置。</p><p>在图中，PC1 和 PC2 均配置了 IPv4 地址 192.168.10.1作为默认网关。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.5.png"></p><p>配置默认网关会在 PC 的路由表中创建一个默认路由。默认路由是计算机尝试联系远程网络时所用的路由或路径。</p><p>PC1 和 PC2 都会使用默认路由将去往远程网络的所有流量发送到 R1。</p><h2 id="4-4、路由简介"><a href="#4-4、路由简介" class="headerlink" title="4.4、路由简介"></a>4.4、路由简介</h2><p>在 Windows 主机上，使用<strong>route print</strong>或命<strong>netstat -r</strong>令可以显示主机路由表。这两个命令生成相同的输出。输出可能乍一看很晦涩，但是实际上相当容易理解。</p><p>输入<strong>netstat -r</strong>命令或等效的<strong>route print</strong>命令，显示有关当前 TCP/IP 网络连接的三个部分：</p><ul><li><strong>接口列表</strong> - 列出主机上的介质访问控制 (MAC) 地址和每个网络接口的已分配接口编号，包括以太网、Wi-Fi 和蓝牙适配器。</li><li><strong>IPv4 路由表</strong> - 列出所有已知的 IPv4 路由，包括直接连接、本地网络和本地默认路由。</li><li><strong>IPv6 路由表</strong> - 列出所有已知的 IPv6 路由，包括直接连接、本地网络和本地默认路由。</li></ul><h1 id="5、路由简介"><a href="#5、路由简介" class="headerlink" title="5、路由简介"></a>5、路由简介</h1><h2 id="5-1、路由器数据包转发决策"><a href="#5-1、路由器数据包转发决策" class="headerlink" title="5.1、路由器数据包转发决策"></a>5.1、路由器数据包转发决策</h2><p>上一主题讨论了主机路由表。大多数网络还包含作为中间设备的路由器。路由器中也包含路由表。本主题涵盖网络层上路由器的运行。当一台主机发送数据包到另一台主机时，它将查询路由表来确定将数据包发送到哪里。如果目的主机位于远程网络，则数据包会被转发到默认网关，通常是本地路由器。</p><p>当数据包到达路由器接口时会发生什么?</p><p>路由器会检查数据包的目的 IP 地址并搜索其路由表以确定将数据包转发到何处。路由表包含所有已知网络地址（前缀）以及数据包转发位置的列表。这些条目称为路由条目或路由。路由器将使用最佳（最长）匹配的路由条目转发数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.6.png"></p><ol><li>数据包到达路由器 R1 的 G0/0/0 接口。R1 解封第 2 层以太网帧头和帧尾。</li><li>路由器 R1 检查数据包的目的 IPv4 地址，并在其 IPv4 路由表中搜索最佳匹配。路由条目指示此数据包将被转发到路由器 R2。</li><li>路由器 R1 将数据包封装到新的以太网帧头和帧尾中，并将数据包转发到下一个跳路由器 R2。</li></ol><p>下表显示了来自R1路由表的相关信息。</p><p><strong>R1 Routing Table</strong></p><table><thead><tr><th align="left">路由</th><th align="left">下一个跳或 出口接口</th></tr></thead><tbody><tr><td align="left">192.168.10.0 /24</td><td align="left">G0/0/0</td></tr><tr><td align="left">209.165.200.224/30</td><td align="left">G0/0/1</td></tr><tr><td align="left"><strong>10.1.1.0/24</strong></td><td align="left"><strong>通过 R2</strong></td></tr><tr><td align="left">默认路由 0.0.0.0/0</td><td align="left">通过 R2</td></tr></tbody></table><h2 id="5-2、IP路由器路由表"><a href="#5-2、IP路由器路由表" class="headerlink" title="5.2、IP路由器路由表"></a>5.2、IP路由器路由表</h2><p>路由器的路由表包含所有可能的已知目的地网络的路由条目列表。</p><p>路由表存储三种类型的路由条目：</p><ul><li><strong>直连网络-</strong> 这些网络路由条目是活动的路由器接口。当接口配置了 IP 地址并激活时，路由器会添加直连路由。每个路由器接口均连接到一个不同的网段。在图中，R1 IPv4路由表中的直连网络为192.168.10.0/24和209.165.200.224/30。</li><li><strong>远程网络</strong> - 这些网络路由条目连接到其他路由器。路由器通过由管理员明确配置或使用动态路由协议交换路由信息来学习远程网络。在图中，R1 IPv4路由表中的远程网络为10.1.1 /24。</li><li><strong>默认路由</strong> -像主机一样，大多数路由器还包含默认路由条目，即默认网关。当IP路由表中没有更好(更长)的匹配时，将使用默认路由。在图中，R1 IPv4路由表很可能包含一个将所有数据包转发到路由器R2的默认路由。</li></ul><p>该图用于确定路由器 R1 的直连和远程网络。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.7.png"></p><p>R1 有两个直连网络：</p><ul><li>192.168.10.0/24</li><li>209.165.200.224/30</li></ul><p>R1还可以学习远程网络(即10.1.1.0/24和互联网)。</p><p>路由器可通过两种方式获知远程网络：</p><ul><li><strong>手动</strong> - 使用静态路由将远程网络手动输入到路由表中。</li><li><strong>动态</strong> - 使用动态路由协议自动学习远程路由。</li></ul><h2 id="5-3、静态路由"><a href="#5-3、静态路由" class="headerlink" title="5.3、静态路由"></a>5.3、静态路由</h2><p>静态路由是手动配置的路由条目。下图显示了在路由器 R1 上手动配置的静态路由的示例。静态路由包括远程网络地址和下一跳路由器的IP地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.8.png"></p><p>使用静态路由手动配置 R1 以达到 10.1.1.0/24 网络。如果此路径发生变化，R1 将需要一个新的静态路由。</p><p>如果网络拓扑改变，静态路由不会自动更新，必须手动重新配置静态路由。例如，在图中，R1有一条通过R2到达10.1.1.0/24网络的静态路由。如果该路径不再可用，R1将需要重新配置一个新的静态路由，通过R3到达10.1.1.0/24网络。因此，路由器R3需要在其路由表中有一个路由条目，以便将目的地为10.1.1.0/24的数据包发送到R2。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.9.png"></p><p>如果从 R1 到 R2 的路由不再可用，则需要配置通过 R3 的新静态路由。静态路由不会根据拓扑更改自动进行调整。</p><p>静态路由具有以下特征：</p><ul><li>必须手动配置静态路由。</li><li>如果拓扑发生变化，且静态路由不再可用，则管理员需要重新配置静态路由。</li><li>静态路由适用于小型网络且当冗余链路很少或没有冗余链路的情况。</li><li>静态路由通常与动态路由协议一起用于配置默认路由。</li></ul><h2 id="5-4、动态路由"><a href="#5-4、动态路由" class="headerlink" title="5.4、动态路由"></a>5.4、动态路由</h2><p>动态路由协议可让路由器从其他路由器那里自动学习远程网络，包括默认路由。如果使用动态路由协议，则路由器无需网络管理员的参与，即可自动与其它路由器共享路由信息并对拓扑结构的变化作出反应。如果网络拓扑发生变化，路由器将使用动态路由协议共享此信息，并自动更新路由表。</p><p>动态路由协议包括OSPF和增强型内部网关路由协议 (EIGRP)。该图显示了路由器 R1 和 R2 使用路由协议 OSPF 自动共享网络信息的示例。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.10.png"></p><ul><li>R1使用路由协议OSPF让R2了解192.168.10.0/24网络。</li><li>R2使用路由协议OSPF让R1了解10.1.1.0/24网络。</li></ul><p>基本配置只需要网络管理员在动态路由协议中启用直连网络。动态路由协议将自动执行如下操作：</p><ul><li>发现远程网络</li><li>维护最新路由信息</li><li>选择通往目的网络的最佳路径</li><li>当前路径无法再使用时尝试找出新的最佳路径</li></ul><p>当使用静态路由手动配置路由器或使用动态路由协议动态学习远程网络时，远程网络地址和下一跳地址将被输入到IP路由表中。如图所示，如果网络拓扑发生变化，路由器将自动调整并尝试找到新的最佳路径。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.11.png"></p><p>R1、R2和R3 正在使用动态路由协议 OSPF。如果网络拓扑发生变化，则可以自动调整以查找新的最佳路径。</p><p><strong>注意</strong>: 通常一些路由器会同时使用静态路由和动态路由协议。</p><h2 id="5-5、视频-IPv4路由器路由表"><a href="#5-5、视频-IPv4路由器路由表" class="headerlink" title="5.5、视频-IPv4路由器路由表"></a>5.5、视频-IPv4路由器路由表</h2><p>略</p><h2 id="5-6、IPv4路由表简介"><a href="#5-6、IPv4路由表简介" class="headerlink" title="5.6、IPv4路由表简介"></a>5.6、IPv4路由表简介</h2><p>请注意，在图中 R2 连接到了互联网。因此，当路由表中没有与目的IP 地址匹配的特定条目时，管理员将为 R1 配置默认静态路由，将数据包发送到 R2。R1和R2还使用OSPF路由来通告直连的网络。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.12.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN8.13.png"></p><p>特权 EXEC 模式命令 <strong>show ip route</strong> 用于查看思科 IOS 路由器上的 IPv4 路由表。该示例显示了路由器 R1 的 IPv4 路由表。每个路由表条目的开头都有一个代码，用于标识路由的类型或路由的学习方式。常见路由源（代码）包括以下内容：</p><ul><li><strong>L</strong> - 直连的本地接口 IP 地址</li><li><strong>C</strong> - 直连网络</li><li><strong>S</strong> - 静态路由由管理员手动配置</li><li><strong>O</strong> - OSPF</li><li><strong>D</strong> - EIGRP</li></ul><p>路由表显示 R1 的所有已知 IPv4 目的地路由。</p><p>当路由器接口配置了IP地址信息并激活时，将自动创建直连路由。该路由器添加了两个带有代码C(即所连接的网络)，和L(即连接网络的本地接口IP地址)的路由条目。路由条目还标识用于到达网络的出口接口。本示例中的两个直连网络分别为192.168.10.0/24 和 209.165.200.224/30。</p><p>路由器R1和R2还使用OSPF动态路由协议交换路由器信息。在示例路由表中，R1 具有 10.1.1.0/24 网络的路由条目，它通过 OSPF 路由协议从路由器 R2 中动态学习到该条目。</p><p>默认路由具有全都是零的网络地址。例如，IPv4 网络地址为 0.0.0.0。路由表中的静态路由条目以 S\ * 的代码开头，如示例中突出显示的那样。</p><h1 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h1><p>注：</p><p>1、如果目的主机与源主机位于同一局域网中，则不需要默认网关。如果数据包需要发送到局域网之外，则需要默认网关。</p><p>2、主机可以通过向网络 <strong>127.0.0.0/8</strong> 内的一个特殊IPv4地址发送数据包来对环回接口执行 ping 操作。</p><p>3、IPv4不提供对IPsec的天然支持</p><p>4、MTU由数据链路层传递到网络层</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（七）</title>
      <link href="/2021/111659734.html"/>
      <url>/2021/111659734.html</url>
      
        <content type="html"><![CDATA[<h1 id="七、以太网交换"><a href="#七、以太网交换" class="headerlink" title="七、以太网交换"></a>七、以太网交换</h1><p>以太网和无线局域网是当前使用最广泛的两种LAN技术。以太网支持高达 100 Gbps 的带宽，这就是其受欢迎的原因。</p><p><strong>模块目标</strong>: 说明以太网如何在交换网络中运行。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>以太网帧</strong></td><td align="left">说明以太网子层与帧字段之间的关系。</td></tr><tr><td align="left"><strong>以太网 MAC 地址</strong></td><td align="left">描述以太网 MAC 地址。</td></tr><tr><td align="left"><strong>MAC 地址表</strong></td><td align="left">说明交换机如何构建 MAC 地址表和转发帧。</td></tr><tr><td align="left"><strong>交换机速率和转发方法</strong></td><td align="left">阐述第 2 层交换机端口上可用的交换机转发方法 和端口设置。</td></tr></tbody></table><h1 id="1、以太网帧"><a href="#1、以太网帧" class="headerlink" title="1、以太网帧"></a>1、以太网帧</h1><h2 id="1-1、以太网封装"><a href="#1-1、以太网封装" class="headerlink" title="1.1、以太网封装"></a>1.1、以太网封装</h2><p>本模块首先讨论以太网技术，包括解释 MAC 子层和以太网帧字段。</p><p>以太网是如今广泛使用的两种局域网技术之一，另一种是无线局域网（WLAN）。它使用有线通信，包括双绞线、光纤链路和同轴电缆。</p><p>以太网在数据链路层和物理层运行，是 IEEE 802.2 和 802.3 标准中定义的一系列网络技术。以太网支持的数据带宽为：</p><ul><li>10 Mbps</li><li>100 Mbps</li><li>1000 Mbps (1 Gbps)</li><li>10,000 Mbps (10 Gbps)</li><li>40,000 Mbps (40 Gbps)</li><li>100,000 Mbps (100 Gbps)</li></ul><p><strong>以太网由数据链路层和物理层的协议定义</strong></p><h2 id="1-2、数据链路子层"><a href="#1-2、数据链路子层" class="headerlink" title="1.2、数据链路子层"></a>1.2、数据链路子层</h2><p>IEEE 802 LAN/MAN 协议，包括以太网，使用以下两个单独的数据链路层子层进行操作。它们是**逻辑链路控制 (LLC) 和介质访问控制 (MAC)**，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.1.png"></p><h2 id="1-3、MAC子层"><a href="#1-3、MAC子层" class="headerlink" title="1.3、MAC子层"></a>1.3、MAC子层</h2><p>MAC 子层负责数据封装和访问介质。</p><p><strong>数据封装</strong></p><p>IEEE 802.3 数据封装包括以下内容：</p><ul><li><strong>以太网帧</strong> - 这是以太网帧的内部结构。</li><li><strong>以太网寻址</strong> - 以太网帧中包含源和目的MAC 地址，用于将该以太网帧从以太网网卡传送到同一LAN上的以太网网卡。</li><li><strong>以太网错误检测</strong> - 以太网帧中包含用于错误检测的帧校验序列 (FCS) 帧尾。</li></ul><p><strong>访问介质</strong></p><p>如图所示，IEEE 802.3 MAC 子层包含了在各种介质(包括铜和光纤)上不同类型的以太网通信标准的规格。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.2.png"></p><p>回想一下，使用总线拓扑或集线器的传统以太网是一种共享的半双工介质。半双工介质上的以太网使用争用访问方法，即载波侦听多路访问/冲突检测 (CSMA/CD)，这确保一次只有一个设备进行传输。CSMA/CD 允许多个设备共享相同的半双工介质，如果多台设备同时传输，则会发生冲突。它还提供了一种回退重传算法。</p><p>如今的以太网 LANs 使用的交换机是全双工的。在全双工模式下运行的以太网交换机不需要通过 CSMA/CD 进行访问控制。</p><h2 id="1-4、以太网帧字段"><a href="#1-4、以太网帧字段" class="headerlink" title="1.4、以太网帧字段"></a>1.4、以太网帧字段</h2><p>以太网帧大小的最小值为 64 个字节，最大值为 1518 个字节。这包括从“目的 MAC 地址”字段到“帧校验序列 (FCS)”字段的所有字节。在描述帧的大小时，不包含“前导码”字段。</p><p>任何长度小于 64 个字节的帧都被接收站点视为“冲突碎片”或“残帧”而自动丢弃。超过 1500 个字节的数据帧被视为“巨帧”或“小型巨型帧”。</p><p>如果发送的帧小于最小值或者大于最大值，接收设备将会丢弃该帧。帧之所以被丢弃，可能是因为冲突或其他多余信号。它们被视为无效。大多数快速以太网和千兆以太网交换机和网卡通常都支持巨帧。</p><p>这张图显示了以太网帧中的每个字段。有关每个字段功能的详细信息，请参阅表格。</p><p><strong>Ethernet Frame Fields</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.3.png"></p><p><strong>Ethernet Frame Fields Detail</strong></p><table><thead><tr><th align="left">字段</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">前导码和帧首定界符字段</td><td align="left">前导码（7 字节）和帧首定界符（SFD），也称为 帧首（1 字节），该字段用于发送设备 与接收设备之间的同步。帧开头的八个字节 用于引起接收节点的注意。基本上，前几个字节的 作用是告诉接收方准备接收新帧。</td></tr><tr><td align="left">目的 MAC 地址字段</td><td align="left">该 6 字节字段是预期接收方的标识符。读者应该还记得， 此地址被第2层用来协助设备 确定帧是否发送到目的地。帧中的地址将会与设备中的 MAC 地址进行比对。如果匹配， 设备就接受该帧。可以是单播、组播或广播 地址。</td></tr><tr><td align="left">源 MAC 地址字段</td><td align="left">该 6 字节字段标识发出帧的网卡 或接口。</td></tr><tr><td align="left">类型/长度</td><td align="left">该字段包含两个字节，标识封装于以太网帧中的 上层协议。常见值为十六进制，0x800 用于 IPv4， 0x86DD 用于 IPv6，0x806 用于 ARP。 <strong>注意</strong>：您也可能会看到此字段称为 EtherType、类型或长度。</td></tr><tr><td align="left">数据字段</td><td align="left">该字段（46-1500 字节）包含来自 较高层的封装数据，一般是第3层PDU或更常见的IPv4 数据包。所有帧至少必须有 64 个字节。<strong>如果封装的是小数据包， 则使用填充位将帧 增大到最小值</strong>。</td></tr><tr><td align="left">帧校验序列字段</td><td align="left">“帧校验序列 (FCS)”字段（4 个字节）用于检测帧中 的错误。它使用循环冗余校验 (CRC)。发送设备 在帧的 FCS 字段中包含 CRC 的结果。接收设备 接收帧并生成 CRC 以查找 错误。如果计算匹配，就不会发生错误。计算 不匹配则表明数据已经改变。因此， 帧会被丢弃。数据的变化可能是 由于代表比特位的电信号受到干扰所致。</td></tr></tbody></table><h2 id="1-5、检测"><a href="#1-5、检测" class="headerlink" title="1.5、检测"></a>1.5、检测</h2><p>1、<strong>LLC数据链路子层</strong>通过软件驱动程序控制网络接口</p><p>2、MAC子层的功能：<strong>控制对介质的访问，检查接收位中的错误，使用CSMA/CD或CSMA/CA来支持以太网技术</strong></p><h1 id="2、以太网MAC地址"><a href="#2、以太网MAC地址" class="headerlink" title="2、以太网MAC地址"></a>2、以太网MAC地址</h1><h2 id="2-1、MAC地址和十六进制"><a href="#2-1、MAC地址和十六进制" class="headerlink" title="2.1、MAC地址和十六进制"></a>2.1、MAC地址和十六进制</h2><p>在网络中，IPv4 地址使用十进制以10为基数的数制系统和二进制以2为基数的数制系统来表示。IPv6 地址和以太网地址使用十六进制 以16为基数的数制系统表示。</p><h2 id="2-2、以太网MAC地址"><a href="#2-2、以太网MAC地址" class="headerlink" title="2.2、以太网MAC地址"></a>2.2、以太网MAC地址</h2><p>在以太网中，每台网络设备都连接到同一个共享介质。MAC 地址用于标识本地网段上的物理源和目的设备。MAC 编址为 OSI 模型的数据链路层提供了设备识别方法。</p><p>以太网 MAC 地址是使用 12个十六进制数字表示的 48 位地址，因为一个字节等于 8 位，我们也可以说 一个MAC 地址长度为 6 个字节。</p><p>当供应商为设备或以太网接口分配 MAC 地址时，供应商必须执行以下操作：</p><ul><li>使用其分配的 OUI 作为前 6 个十六进制数字。</li><li>为后 6 个十六进制数字分配唯一值。</li></ul><p>因此，以太网 MAC 地址由6个十六进制供应商 OUI 代码和6个十六进制供应商分配的值组成</p><p>供应商有责任确保其设备不被分配相同的 MAC 地址。但是，由于制造过程中出现的错误、某些虚拟机部署方式中的错误或使用多种软件工具之一进行的修改，可能存在重复的 MAC 地址。若出现以上任一情况，必须在新网卡或软件中修改 MAC 地址。</p><h2 id="2-3、帧处理"><a href="#2-3、帧处理" class="headerlink" title="2.3、帧处理"></a>2.3、帧处理</h2><p>MAC 地址通常称为烧录地址 (BIA)，因为传统上该地址被烧录到网卡的只读存储器（ROM）中。这意味着该地址会永久编码到 ROM 芯片中。</p><p><strong>注意</strong>: 在现代 PC 操作系统和网卡中，可以在软件中更改MAC 地址。当试图访问基于 BIA 进行过滤的网络时，这一点非常有用。因此，根据 MAC 地址来过滤或控制流量就不再安全了。</p><p>当计算机启动时，网卡将 MAC 地址从 ROM 复制到 RAM 中。设备在向以太网络转发消息时，以太网报头包含这些：</p><ul><li><strong>源 MAC 地址</strong> – 这是源设备网卡的 MAC 地址。</li><li><strong>目的 MAC 地址</strong> -这是目标设备网卡的 MAC 地址。</li></ul><p>收到以太网帧时，网卡会查看帧中的目的 MAC 地址是否与设备 RAM 中存储的物理 MAC 地址匹配。如果不匹配，设备就会丢弃帧。如果与帧中的目的 MAC 匹配，则网卡会将帧向上传送到 OSI 层进行解封处理。</p><p>**注意:**如果目的 MAC 地址是主机为其成员的广播或组播组时，以太网网卡也会接收帧。</p><p>任何作为以太网帧的源或目的设备都有一个以太网网卡，因此也有一个MAC地址。这些设备包括工作站、服务器、打印机、移动设备和路由器。</p><h2 id="2-4、单播MAC地址"><a href="#2-4、单播MAC地址" class="headerlink" title="2.4、单播MAC地址"></a>2.4、单播MAC地址</h2><p>在以太网中，第 2 层单播、组播和广播通信会使用不同的 MAC 地址。</p><p>单播 MAC 地址是帧从一台发送设备去往一台目的设备时使用的唯一地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.4.png"></p><p>在动画中的示例中，IPv4 地址为 192.168.1.5 的主机（源）向 IPv4 单播地址为 192.168.1.200 的服务器请求网页。要传送和接收单播数据包，目的 IP 地址必须包含于 IP 包报头中。相应的目的 MAC 地址也必须出现于以太网帧报头中。只有 IP 地址和 MAC 地址相结合才能将数据传送到特定的目的主机。</p><p>源主机用来确定目的IPv4地址所对应的目的 MAC 地址的流程称为地址解析协议 (ARP)。源主机用来确定目的IPv6地址所对应的目的 MAC 地址的流程称为邻居发现 (ND)。</p><p><strong>注意:</strong> 源 MAC 地址必须始终为单播地址。</p><h2 id="2-5、广播MAC地址"><a href="#2-5、广播MAC地址" class="headerlink" title="2.5、广播MAC地址"></a>2.5、广播MAC地址</h2><p>以太网广播帧由以太网LAN上的每个设备接收和处理。以太网广播的功能如下：</p><ul><li>它有一个十六进制（在二进制中是 48 个 1）FF-FF-FF-FF-FF-FF的目的 MAC 地址。</li><li>它向除输入端口以外的所有以太网交换机端口泛洪。</li><li>路由器不会转发该帧。</li></ul><p>如果封装的数据是IPv4广播包，这意味着该数据包包含一个目的IPv4地址，该地址的主机部分全部为一(1)。这种地址值表示本地网络（广播域）中的所有主机都将接收和处理该数据包。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.5.png"></p><p>如动画所示，源主机向其网络中的所有设备发送 IPv4 广播数据包。IPv4 目的地址为广播地址 192.168.1.255。如果 IPv4 广播数据包被封装在以太网帧内，则目的 MAC 地址为十六进制（在二进制中是 48 个 1）的 FF-FF-FF-FF-FF-FF 广播 MAC 地址。</p><p>IPv4 的 DHCP 是使用以太网和 IPv4 广播地址的一个协议示例。</p><p>但是，并非所有以太网广播都带有 IPv4 广播数据包。例如，ARP 请求不使用 IPv4，但 ARP 消息却作为以太网广播发送。</p><h2 id="2-6、组播MAC地址"><a href="#2-6、组播MAC地址" class="headerlink" title="2.6、组播MAC地址"></a>2.6、组播MAC地址</h2><p>以太网组播帧由属于同一组多播组的以太网LAN上的一组设备接收和处理。以太网组播的功能如下：</p><ul><li><strong>当封装数据为IPv4组播包时，目的MAC地址为01-00-5E;当封装数据为IPv6组播包时，目的MAC地址为33-33</strong>。</li><li>当封装的数据不是IP时，还有其他预留的组播目的MAC地址，如生成树协议(STP)和链路层发现协议(LLDP)。</li><li>除非交换机被配置为用于组播窥探，否则它将向除传入端口之外的所有以太网交换机端口泛洪。</li><li>它不会由路由器转发，除非路由器配置为路由组播数据包。</li></ul><p>如果封装的数据是一个IP组播包，则属于组播组的设备都分配有该组播组IP地址。IPv4 组播地址的范围为 224.0.0.0 到 239.255.255.255。IPv6 组播地址的范围以 ff00::/8 开头。由于组播地址代表一组地址（有时称为主机组），因此只能用作数据包的目的地址。源地址始终应为单播地址。</p><p>如同单播和广播地址一样，组播 IP 地址也需要相应的组播 MAC 地址才能在本地网络中传送帧。组播MAC地址与IPv4或IPv6组播地址相关联，并使用来自IPv4或IPv6的编址信息。</p><p>单击动画中的 “播放” 以查看如何处理组播帧。在此示例中，目的 MAC 地址和目的 IP 地址都是广播。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.6.png"></p><p><strong>路由协议和其他网络协议会使用组播地址。</strong>视频和图像软件等应用程序也可能使用组播地址，尽管组播应用程序并不常见。</p><h1 id="3、MAC地址表"><a href="#3、MAC地址表" class="headerlink" title="3、MAC地址表"></a>3、MAC地址表</h1><h2 id="3-1、交换机基础知识"><a href="#3-1、交换机基础知识" class="headerlink" title="3.1、交换机基础知识"></a>3.1、交换机基础知识</h2><p>既然您已经了解了所有关于以太网MAC地址的知识，现在就该讨论交换机如何使用这些地址将帧转发(或丢弃)到网络上的其他设备。如果交换机只是转发出它接收到的每一帧到所有端口，您的网络将会非常拥挤，以至于它可能会完全停止工作。</p><p>第 2 层以太网交换机使用 MAC 地址做出转发决策。它完全忽视帧的数据部分的协议，例如 IPv4 数据包，一个ARP消息或一个IPv6 ND数据包。交换机仅根据第 2 层以太网 MAC 地址做出转发决策。</p><p>一个以太网交换机检查它的MAC地址表，为每个帧做出一个转发决策，不像传统的以太网集线器，向除了传入端口以外的所有端口重复发出比特位。如图所示，四端口交换机已启动。如表所示，MAC地址表还未获知四台连接的 PC 的 MAC 地址。</p><p><strong>注意</strong>: 缩短 MAC 地址是为了便于演示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.7.png"></p><p>交换机MAC地址表示空的</p><p><strong>注意</strong>: MAC 地址表有时也称为内容可寻址内存 (CAM) 表。虽然 CAM 表这一术语相当常见，但在本课程中，我们将称其为 MAC 地址表。</p><h2 id="3-2、交换机学习和转发"><a href="#3-2、交换机学习和转发" class="headerlink" title="3.2、交换机学习和转发"></a>3.2、交换机学习和转发</h2><p>交换机通过检查端口传入帧的源 MAC 地址来动态构建 MAC 地址表。交换机通过匹配帧中的目的 MAC 地址与 MAC 地址表中的条目来转发帧。</p><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p><strong>检查源MAC地址</strong></p><p>进入交换机的每个帧被检查，以确定其中是否有可被学习的新信息。它是通过<strong>检查帧的源 MAC 地址和帧进入交换机的端口号</strong>来完成这一步的。如果源 MAC 地址不存在，会将其和传入端口号一并添加到表中。如果源 MAC 地址已存在于表中，则交换机会更新该条目的刷新计时器。默认情况下，大多数以太网交换机将条目在表中保留 5 分钟。</p><p>如图所示，PC-A 正在向 PC-D 发送以太网帧。如表所示该交换机将 PC-A 的 MAC 地址添加到MAC地址表中。</p><p><strong>注意</strong>: 如果源 MAC 地址已经保存在表中，但是对应的是不同的端口，那么交换机会将其视为一个新的条目。使用相同的 MAC 地址和最新的端口号来替换该条目。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.13.png"></p><ol><li>PC-A 发送一个以太网帧。</li><li>交换机会把PC-A 的端口号和 MAC 地址添加到 MAC 地址表中。</li></ol><h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p><strong>查找目的MAC地址</strong></p><p>如果目的 MAC 地址为单播地址，该交换机会看帧中的目的 MAC 地址与 MAC 地址表中的条目是否匹配。如果表中存在该目的MAC地址，交换机会从指定端口转发帧。<strong>如果表中不存在该目的MAC地址，交换机会从除传入端口外的所有端口转发帧。这称为未知单播。</strong></p><p>如图所示，交换机的表中没有目的主机 PC-D 的 MAC 地址，因此交换机会从除端口 1 外的所有端口转发帧。</p><p><strong>注意</strong>: 如果目的 MAC 地址为广播或组播，该帧也将被泛洪到除传入端口外的所有端口。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.8.png"></p><ol><li>目的 MAC 地址不在表中</li><li>交换机将该帧转发到所有端口。</li></ol><h2 id="3-3、过滤帧"><a href="#3-3、过滤帧" class="headerlink" title="3.3、过滤帧"></a>3.3、过滤帧</h2><p>交换机是从不同的设备接收帧，因此它可以通过检查每个帧的源 MAC 地址来填充它的 MAC 地址表。如果MAC 地址表包含目的MAC 地址，则交换机将“滤过”该帧并将其从单个端口转发出去。</p><h3 id="PC-D-到转换机"><a href="#PC-D-到转换机" class="headerlink" title="PC-D 到转换机"></a>PC-D 到转换机</h3><p>在图中，PC-D 正在回复 PC-A。 交换机在端口 4 上的传入帧中看到 PC-D 的 MAC 地址。然后，交换机将 PC-D 的 MAC 地址放入与端口 4 关联的 MAC 地址表中。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.9.png"></p><p>交换机会把PC-D 的端口号和 MAC 地址添加到 MAC 地址表中。</p><h3 id="交换机到PC-A"><a href="#交换机到PC-A" class="headerlink" title="交换机到PC-A"></a>交换机到PC-A</h3><p>下一步，因为该交换机的MAC地址表中存在 PC-A 的目的 MAC 地址，它将仅从端口 1 将该帧发出去，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.10.png"></p><ol><li>该交换机有目的MAC地址条目。</li><li>交换机过滤帧，仅将其从端口1发出。</li></ol><h3 id="PC-A到交换机再到PC-D"><a href="#PC-A到交换机再到PC-D" class="headerlink" title="PC-A到交换机再到PC-D"></a>PC-A到交换机再到PC-D</h3><p>下一步，PC-A 向 PC-D 发送另一帧，如图所示。MAC 地址表中已包含 PC-A 的 MAC 地址，因此该条目的五分钟刷新计时器被重置。下一步，因为该交换机的表中存在 PC-D 的目的 MAC 地址，它将仅从端口 4 将该帧发出去。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.11.png"></p><ol><li>交换机从 PC-A 接收另一帧，并刷新端口 1 的 MAC 地址条目的计时器。</li><li>该交换机具有目的MAC 地址的最近条目，并过滤帧，只将其从端口4转发出去。</li></ol><h2 id="3-4、视频-相连交换机上的MAC地址表"><a href="#3-4、视频-相连交换机上的MAC地址表" class="headerlink" title="3.4、视频-相连交换机上的MAC地址表"></a>3.4、视频-相连交换机上的MAC地址表</h2><p>交换机的单个端口可以与多个 MAC 地址关联。这种情况在交换机与另一个交换机连接时很常见。交换机为每个收到的帧中的源 MAC 地址创建一条有单独的 MAC 地址表条目。</p><h2 id="3-5、视频-将帧发送到默认网关"><a href="#3-5、视频-将帧发送到默认网关" class="headerlink" title="3.5、视频-将帧发送到默认网关"></a>3.5、视频-将帧发送到默认网关</h2><p>如果一台设备的 IP 地址在远程网络上，则不能将以太网帧直接发送到目的设备。而是将以太网帧发送到默认网关（路由器）的 MAC 地址。</p><h2 id="3-6、练习交换（重要）"><a href="#3-6、练习交换（重要）" class="headerlink" title="3.6、练习交换（重要）"></a>3.6、练习交换（重要）</h2><p>略</p><h1 id="4、交换机速率和转发方法"><a href="#4、交换机速率和转发方法" class="headerlink" title="4、交换机速率和转发方法"></a>4、交换机速率和转发方法</h1><h2 id="4-1、思科交换机上的帧转发方法"><a href="#4-1、思科交换机上的帧转发方法" class="headerlink" title="4.1、思科交换机上的帧转发方法"></a>4.1、思科交换机上的帧转发方法</h2><p>正如您在上一主题中了解到的那样，交换机使用其 MAC 地址表来确定用于转发帧的端口。对于思科交换机，实际上有两种帧转发的方法，根据具体情况，有充分的理由使用其中一种来代替另一种。</p><p>在过去，交换机使用下面的两种转发方法之一来进行网络端口间的数据交换：</p><ul><li><strong>存储转发交换</strong> - 这个帧转发的方法接收整个帧并计算CRC。CRC 根据帧中的比特位为 1 的位数量，使用数学公式来确定收到的帧是否有错。如果 CRC 有效，则交换机查找目的地址，目的地址决定了转发接口。帧然后从正确的端口转发出去。</li><li><strong>直通交换</strong> - 这种帧转发的方法在收到整个帧之前即转发帧。在可以转发帧之前，至少必须读取帧的目的地址。</li></ul><p>存储转发交换的一大优点是，它可以在传播帧之前确定帧是否有错误。当在帧中检测到错误时，交换机丢弃该帧。丢弃有错的帧可减少损坏的数据所耗用的带宽量。存储转发交换对于融合网络中的服务质量 (QoS) 分析是必需的，在融合网络中，必须对帧进行分类以划分流量优先级。例如，IP 语音数据流的优先级需要高于 Web 浏览流量。</p><h2 id="4-2、直通交换"><a href="#4-2、直通交换" class="headerlink" title="4.2、直通交换"></a>4.2、直通交换</h2><p>在直通交换中，交换机在收到数据时立即处理数据，即使传输尚未完成。交换机只缓冲帧的一部分，缓冲的量仅足以读取目的 MAC 地址，以便确定转发数据时应使用的端口。目的 MAC 地址位于帧中前导码后面的前 6 个字节。交换机在其交换表中查找目的 MAC 地址，确定转发端口，然后通过指定的交换机端口将帧转发到其目的地。<strong>交换机对该帧不执行任何错误检查</strong>。</p><p>直通交换有两种变体：</p><ul><li><strong>快速转发交换 -</strong> 快速转发交换提供最低程度的延时。快速转发交换在读取目的地址之后立即转发数据包。由于快速转发交换在收到整个数据包之前就开始转发，因此有时候中继数据包时会出错。这种情况并不经常发生，而且目的网络适配器在收到含错数据包时会将其丢弃。在快速转发模式下，延时是指从收到第一个位到传出第一个位之间的时间差。快速转发交换是典型的直通交换方法。</li><li><strong>免分片交换 -</strong> 在免分片交换中，交换机在转发之前存储帧的前 64 个字节。可以将免分片交换视为存储转发交换和直通交换之间的折衷。免分片交换只存储帧的前 64 个字节的原因是，大部分网络错误和冲突都发生在前 64 个字节。免分片交换在转发帧之前对帧的前 64 个字节执行小错误检查以确保没有发生过冲突，并且尝试通过这种方法来增强快速转发交换功能。免分片交换是存储转发交换的高延时和高完整性与快速转发交换的低延时和弱完整性之间的折衷。</li></ul><p>某些交换机可配置为按端口执行直通交换，当达到用户定义的错误阈值时，这些端口自动切换为存储转发。当错误率低于该阈值时，端口自动恢复到直通切换。</p><h2 id="4-3、交换机上的内存缓冲"><a href="#4-3、交换机上的内存缓冲" class="headerlink" title="4.3、交换机上的内存缓冲"></a>4.3、交换机上的内存缓冲</h2><p>以太网交换机在转发帧之前，可以使用缓冲技术存储帧。当目的端口由于拥塞而繁忙时，也可以使用缓冲。交换机将帧存储起来，直到可以传输。</p><p>如表所示，有两种内存缓冲方法：</p><p><strong>Memory Buffering Methods</strong></p><table><thead><tr><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>基于端口的内存</strong></td><td align="left">帧存储在链接到特定传入端口和传出 端口的队列中。只有当队列前面的所有帧都成功传输后， 才会将帧传输到传出端口。由于目地端口繁忙， 单个帧可能会造成内存中所有帧的传输延迟。即使其他帧可以传送到开放的目的端口， 这种延迟仍然会发生。</td></tr><tr><td align="left"><strong>共享内存</strong></td><td align="left">将所有帧存储到由所有交换端口共享的公共内存缓冲区中， 并且动态分配一个端口所需的 缓冲区内存量。缓冲区中的帧动态地链接到目的端口， 允许在一个端口上接收数据包，然后 在另一个端口上发送，而无需移动到另一个队列。</td></tr></tbody></table><p>而且共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少。这对于非对称交换非常重要，因为它允许在不同端口上使用不同的数据速率，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p><p>而且共享内存缓冲也意味着存储较大帧的能力，丢弃的帧可能较少。这对于非对称交换非常重要，因为它允许在不同端口上使用不同的数据速率，比如将服务器连接到 10 Gbps 的交换机端口，而pc连接到 1 Gbps 的端口。</p><h2 id="4-4、双工和速率设置"><a href="#4-4、双工和速率设置" class="headerlink" title="4.4、双工和速率设置"></a>4.4、双工和速率设置</h2><p>交换机上最基本的两个设置是<strong>带宽</strong>(有时称为“速率”)<strong>和每个交换机端口的双工设置</strong>。交换机端口和连接的设备（例如计算机或另一台交换机）的双工设置和带宽设置必须匹配。</p><p>用于以太网通信的双工设置有两种：</p><ul><li><strong>全双工</strong> – 连接的两端均可同时收发信息。</li><li><strong>半双工</strong> – 一次只能是连接的两端中其中一端发送信息。</li></ul><p><strong>自动协商</strong>是大多数以太网交换机和网卡的一项可选功能。它使两个设备自动协商最佳速率和双工性能。如果两台设备具有最高常见带宽的功能，则会选择全双工。</p><p>在图中，PC-A 的以太网网卡可在全双工或半双工模式下，以及以 10 Mbps 或 100 Mb速率运行。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN7.12.png"></p><p>PC-A 连接到交换机 S1 的端口 1 上，可在全双工或半双工模式下运行以及以 10 Mbps、100 Mbps 或 1000 Mbps (1 Gbps) 的速率运行。如果两台设备使用自动协尚，则工作模式为全双工和 100 Mbps。</p><p><strong>注意</strong>: 大多数思科交换机和以太网网卡默认采用自动协商功能，以提高速率和实现双工。<strong>千兆以太网端口仅以全双工模式运行。</strong></p><p>双工不匹配是以太网链路出现性能问题的常见原因之一。当链路上的一个端口在半双工模式下运行，而另一个端口在全双工模式下运行时，就会发生双工不匹配</p><p>当链路上的一个或两个端口被重置时，会发生双工不匹配，自动协调过程并不会使链路上的两个端口的配置相同。当用户重新配置链路的一端而忘记重新配置另一端时，也会出现这样的情况。链路的两端均应都使用或都不使用自动协商。最佳实践是将两个以太网交换端口都配置为全双工。</p><h2 id="4-5、Auto-MDIX"><a href="#4-5、Auto-MDIX" class="headerlink" title="4.5、Auto-MDIX"></a>4.5、Auto-MDIX</h2><p>设备之间的连接曾经要求使用交叉线或直通线。所需的线缆类型取决于互连设备的类型。</p><p><strong>交叉线用于连接相似的设备，而直通电缆主要用于连接不同的设备。</strong></p><p><strong>注意</strong>: <strong>路由器和主机之间的直连需要使用交叉线。</strong></p><p>现在，大多数交换机设备都支持<strong>自动介质相关接口交叉</strong> (auto-MDIX) 功能。当该功能启用时，交换机可检测连接到端口的线缆类型，并相应地配置接口。因此，如果要连接到交换机上的铜缆 10/100/1000 端口，您既可以使用交叉线，也可以使用直通线，而无需考虑连接另一端的设备类型。</p><p>在运行思科 IOS Release 12.2(18)SE 或更高版本的交换机上，默认启用 auto-MDIX 功能。当然，该功能可以被禁用。因此，您应始终使用正确的线缆类型，而不是依赖auto-MDIX 功能。Auto-MDIX 可以使用接口配置命令 <strong>mdix auto</strong> 重新启用。</p><h1 id="单元检测"><a href="#单元检测" class="headerlink" title="单元检测"></a>单元检测</h1><p>1、MAC地址必须<strong>全球唯一</strong></p><p>2、如果以太网网络上的主机接收到的帧的目的 MAC 地址与其自己的 MAC 地址不匹配，它会丢弃该帧，如果匹配，网卡会将帧传送至下一个 OSI 层。</p><p>3、以太网帧将控制信息添加到网络协议层数据中</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（六）</title>
      <link href="/2021/111654579.html"/>
      <url>/2021/111654579.html</url>
      
        <content type="html"><![CDATA[<h1 id="六、数据链路"><a href="#六、数据链路" class="headerlink" title="六、数据链路"></a>六、数据链路</h1><p>每个网络都有物理组件和连接组件的介质。不同类型的介质需要有关数据的不同信息，以便接受数据并在物理网络上移动数据。</p><p>数据必须有帮助才能在不同介质之中移动。数据链路层提供了这种帮助。</p><p><strong>模块目标</strong>: 说明数据链路层中的介质访问控制如何支持网络间的通信。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>数据链路层的用途</strong></td><td align="left">阐述在准备通过特定介质传输通信数据时， 数据链路层的用途和功能。</td></tr><tr><td align="left"><strong>拓扑</strong></td><td align="left">比较 WAN 和 LAN 拓扑下，介质访问控制方法的 不同特征。</td></tr><tr><td align="left"><strong>数据链路层帧</strong></td><td align="left">阐述数据链路层帧的特征和功能。</td></tr></tbody></table><h1 id="1、数据链路层的用途"><a href="#1、数据链路层的用途" class="headerlink" title="1、数据链路层的用途"></a>1、数据链路层的用途</h1><h2 id="1-1、数据链路层"><a href="#1-1、数据链路层" class="headerlink" title="1.1、数据链路层"></a>1.1、数据链路层</h2><p>OSI模型的数据链路层(第2层)为物理网络准备网络数据。数据链路层负责<strong>网络接口卡 (NIC) 到网络接口卡</strong>的通信。数据链路层执行以下操作：</p><ul><li>允许上层访问介质。上层协议完全不知道用于转发数据的介质类型。</li><li>接受数据，通常是第 3 层数据包（即 IPv4 或 IPv6），并将它们封装到第 2 层帧中。</li><li>控制数据在介质上的放置和接收方式，</li><li>通过网络介质在终端之间交换帧。</li><li>接收封装的数据，通常是第 3 层数据包，并将它们定向到适当的上层协议。</li><li>执行错误检测并拒绝任何损坏的帧。</li></ul><p>在计算机网络中，节点是可以沿通信路径接收、创建、存储或转发数据的设备。节点可以是笔记本电脑或移动电话等终端设备，也可以是中间设备如以太网交换机。</p><p>如果没有数据链路层，则网络层协议（如 IP）必须提供连接到传输路径中可能存在的各种类型介质所需的连接。此外，每当开发出一种新的网络技术或介质时，IP 必须做出相应调整。</p><p>该图显示了数据链路层如何将第2层以太网目的和源网卡信息添加到第3层数据包的示例。然后，它会将此信息转换为物理层（即第 1 层）支持的格式。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.1.png"></p><h2 id="1-2、IEEE-802LAN-MAN-数据链路子层"><a href="#1-2、IEEE-802LAN-MAN-数据链路子层" class="headerlink" title="1.2、IEEE 802LAN/MAN 数据链路子层"></a>1.2、IEEE 802LAN/MAN 数据链路子层</h2><p>IEEE 802 LAN/MAN 标准专用于以太网局域网、无线局域网 (WLAN)、无线个人区域网 (WPAN) 和其他类型的局域网和城域网。IEEE 802 LAN/MAN 数据链路层由以下两个子层组成：</p><ul><li><strong>逻辑链路控制 (LLC)</strong> - 这个 IEEE 802.2 子层在上层的网络软件与下层的设备硬件之间进行通信。它放入帧中的信息用于确定帧所使用的网络层协议。此信息允许多个第 3 层协议（如 IPv4 和 IPv6）使用相同的网络接口和介质。</li><li><strong>介质访问控制 (MAC)</strong> - 在硬件上实现这个子层（IEEE 802.3、802.11 或 802.15）。它负责数据封装和介质访问控制。它提供数据链路层寻址，并与各种物理层技术集成。</li></ul><p>该图显示了数据链路层的两个子层（LLC 和 MAC）。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.2.png"></p><p>LLC 子层获取网络协议数据（通常是 IPv4 或 IPv6数据包）并加入第2层控制信息，帮助将数据包传送到目的节点。 </p><p>MAC子层控制网卡和负责在有线或无线LAN/MAN介质上发送和接收数据的其他硬件。</p><p>MAC 子层提供数据封装：</p><ul><li><strong>帧定界</strong> - 在成帧过程中提供重要的定界符，用来标识帧中的字段。这些定界符位可以在发送节点与接收节点之间提供同步。</li><li><strong>编址</strong> - 提供源和目的编址，用于在同一共享介质上的设备之间传输第 2 层帧。</li><li><strong>错误检测</strong> - 包含一个帧尾，用于检测传输错误。</li></ul><p>MAC 子层还提供介质访问控制，允许多个设备通过共享（半双工）介质进行通信。全双工通信不需要访问控制。</p><h2 id="1-3、提供介质访问"><a href="#1-3、提供介质访问" class="headerlink" title="1.3、提供介质访问"></a>1.3、提供介质访问</h2><p>在数据包从本地主机传送到远程主机的过程中，其遇到的各种网络环境可能具有不同的特性。例如，以太网 LAN 通常由许多争用网络介质访问的主机组成。MAC 子层解决了这个问题。对于串行链路，访问方法可能只包括两个设备之间的直接连接，通常是两个路由器。因此，它们不需要 IEEE 802 MAC 子层所使用的技术。</p><p>路由器接口将数据包封装到适当的帧中。使用合适的介质访问控制方法来访问每个链路。在任意指定的网络层数据包交换过程中，可能存在多次数据链路层和介质的转换。</p><p>在路径上的每一跳，路由器都执行以下第 2 层功能：</p><ol><li>从介质接受帧</li><li>解封帧</li><li>将数据包重新封装到新帧中</li><li>从适合该物理网络网段的介质转发新帧</li></ol><p>若路由器具有连接到 LAN 的一个以太网接口和连接到 WAN 的一个串行接口。在处理帧的过程中，路由器将使用数据链路层服务从某个介质接收帧，再将它解封到第 3 层 PDU，然后将 PDU 重新封装到新帧中，再将帧放到网络下一链路的介质中。</p><h2 id="1-4、数据链路层标准"><a href="#1-4、数据链路层标准" class="headerlink" title="1.4、数据链路层标准"></a>1.4、数据链路层标准</h2><p>与 TCP/IP 的上层协议不同，数据链路层协议通常不是由征求意见 (RFC) 文档定义的。互联网工程任务组 (IETF) 虽然维护着 TCP/IP 协议簇上层的工作协议和服务，但它没有定义TCP/IP模型的网络接入层的功能和操作。</p><p>定义适用于网络接入层（即，OSI的物理和数据链路层）的开放标准和协议的工程组织包括：</p><ul><li>电气电子工程师协会 (IEEE)</li><li>国际电信联盟 (ITU)</li><li>国际标准化组织 (ISO)</li><li>美国国家标准学会 (ANSI)</li></ul><h2 id="1-5、检测"><a href="#1-5、检测" class="headerlink" title="1.5、检测"></a>1.5、检测</h2><p><strong>注：</strong></p><p><strong>1、MAC子层负责将帧放置在介质上以及从介质中删除帧</strong></p><p><strong>2、确定所使用的介质控制方法是所涉及的介质共享类型和拓扑</strong></p><h1 id="2、拓扑"><a href="#2、拓扑" class="headerlink" title="2、拓扑"></a>2、拓扑</h1><h2 id="2-1、物理和逻辑拓扑"><a href="#2-1、物理和逻辑拓扑" class="headerlink" title="2.1、物理和逻辑拓扑"></a>2.1、物理和逻辑拓扑</h2><p>数据链路层为物理网络准备网络数据。它必须知道网络的逻辑拓扑，以便能够确定从一个设备向另一个设备传输帧需要什么。本主题介绍了数据链路层与不同逻辑网络拓扑一起工作的方式。</p><p>网络拓扑是指网络设备及它们之间的互连布局或关系。</p><p>描述 LAN 和 WAN 网络时使用两种类型的拓扑：</p><ul><li><strong>物理拓扑</strong> - 标识物理连接，以及终端设备和中间设备（即，路由器、交换机和无线接入点）如何互连。这个拓扑还可能包括特定的设备位置，如房间号和设备机架上的位置。物理拓扑通常是点对点拓扑或星型拓扑。</li><li><strong>逻辑拓扑</strong> - 是指网络将帧从一个节点传输到另一节点的方法。此拓扑使用设备接口和第 3 层 IP 寻址方案识别虚拟连接。</li></ul><p>在控制对介质的数据访问时，<strong>数据链路层“看见”的是网络的逻辑拓扑</strong>。<strong>正是逻辑拓扑在影响网络成帧和介质访问控制的类型。</strong></p><h3 id="物理拓扑"><a href="#物理拓扑" class="headerlink" title="物理拓扑"></a>物理拓扑</h3><p>该图显示了一个小型示例网络的示例物理（ <strong>物理层</strong> ）拓扑。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.3.png"></p><h3 id="逻辑拓扑"><a href="#逻辑拓扑" class="headerlink" title="逻辑拓扑"></a>逻辑拓扑</h3><p>下图显示了同一网络的示例逻辑（ <strong>逻辑</strong> ）拓扑。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.4.png"></p><h2 id="2-2、WAN拓扑"><a href="#2-2、WAN拓扑" class="headerlink" title="2.2、WAN拓扑"></a>2.2、WAN拓扑</h2><h3 id="点对点"><a href="#点对点" class="headerlink" title="点对点"></a>点对点</h3><p>这是最简单和最常见的 WAN 拓扑。它由两个终端之间的永久链接组成。</p><h3 id="中心辐射型"><a href="#中心辐射型" class="headerlink" title="中心辐射型"></a>中心辐射型</h3><p>这是星型拓扑的 WAN 版本，在该拓扑中一个中心站点使用点对点链路互连分支机构站点。如果不经过中心站点，分支站点就不能与其他分支站点交换数据。</p><h3 id="网状"><a href="#网状" class="headerlink" title="网状"></a>网状</h3><p>该拓扑可用性高，但要求每个终端系统都与其他各个系统互连。因此管理成本和物理成本都会非常高。每条链路实质上是另一节点的点对点链路。</p><p>混合拓扑是任何拓扑的变体或组合。例如，部分网状就是一种混合拓扑，因为其中一些而并非所有的终端设备都是互连的。</p><h2 id="2-3、点对点WAN拓扑"><a href="#2-3、点对点WAN拓扑" class="headerlink" title="2.3、点对点WAN拓扑"></a>2.3、点对点WAN拓扑</h2><p>如图所示，物理点对点拓扑直接连接两个节点。在这种布局中，两个节点无需与其他主机共享介质。此外，当使用串行通信协议，如点对点协议(PPP)时，节点无需判定收到的帧是指向它还是指向另一节点。因此，逻辑数据链路协议将非常简单，因为介质中的所有帧都只去往或来自这两个节点。节点将帧放置到一端的介质上，然后点对点线路另一端的节点从介质取走帧。</p><p><strong>注意</strong>: 通过以太网进行的点对点连接需要设备确定传入帧是否发往此节点。</p><p>使用多个中间设备，距离较远的源节点和目的节点彼此可以间接相连。但是，在网络中使用物理设备并不会影响逻辑拓扑，如图所示。在图中，添加中间物理连接不会改变逻辑拓扑。逻辑点对点连接相同。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.5.png"></p><h2 id="2-4、LAN拓扑"><a href="#2-4、LAN拓扑" class="headerlink" title="2.4、LAN拓扑"></a>2.4、LAN拓扑</h2><p>在多路访问局域网中，终端设备（即节点）使用<strong>星型或扩展星型</strong>拓扑相互连接。在这种类型的拓扑中，终端设备连接到一个中央中间设备。扩展星型通过连接多个以太网交换机来扩展此拓扑。星型和扩展星型拓扑安装简单、扩展性好（易于添加和删除终端设备），而且故障排除容易。早期的星型拓扑使用以太网集线器互连终端设备。</p><p>有时可能只有两个设备连接在以太网局域网上。两个相互连接的路由器就是一个例子。这是在点对点拓扑上使用以太网的一个示例。</p><p><strong>传统LAN拓扑</strong></p><p>早期的以太网和传统令牌环局域网技术包括另外两种拓扑结构:</p><ul><li><strong>总线</strong> - 所有终端系统都相互连接，并在两端以某种形式端接。终端设备互连时不需要基础设施设备（例如交换机）。传统的以太网络中会使用采用同轴电缆的总线拓扑，因为它价格低廉而且安装简易。</li><li><strong>环</strong> - 终端系统与其各自的邻居相连，形成一个环状。与总线拓扑不同，环拓扑不需要端接。传统的光纤分布式数据接口 (FDDI) 和令牌环网络使用环拓扑。</li></ul><p>下图说明终端设备如何在局域网中互连。网络图形中经常用直线来代表包含一个简单星型和一个扩展星型的以太网 LAN。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.6.png"></p><h2 id="2-5、半双工和全双工通信"><a href="#2-5、半双工和全双工通信" class="headerlink" title="2.5、半双工和全双工通信"></a>2.5、半双工和全双工通信</h2><p>理解双工通信在讨论局域网拓扑时非常重要，因为它指的是两个设备之间的数据传输方向。有两种常见的双工模式。</p><p><strong>半双工通信</strong></p><p>两台设备都可以通过该介质发送和接收，但无法同时执行这两个操作。WLAN和带有以太网集线器的传统总线拓扑使用半双工模式。半双工每次只允许一台设备通过共享介质发送或接收。</p><p><strong>全双工通信</strong></p><p>两台设备都可以在共享介质上同时发送和接收。数据链路层假定介质随时可供两个节点实现传输。默认情况下，以太网交换机在全双工模式下运行，但是如果与以太网集线器等设备连接，它们则可以在半双工模式下运行。</p><p>总之，半双工通信限制为每次在一个方向进行数据交换。全双工允许同时发送和接收数据。</p><p>两个互连设备，比如一个主机网卡和以太网交换机上的一个接口，必须采用同一双工模式运行。否则，将会出现双工不匹配，导致链路效率低下和延时。</p><h2 id="2-6、访问控制方法"><a href="#2-6、访问控制方法" class="headerlink" title="2.6、访问控制方法"></a>2.6、访问控制方法</h2><p>某些多路访问网络需要使用规则来管理设备共享物理介质的方式。对于共享介质，有两种基本的访问控制方法：</p><ul><li>基于竞争的访问</li><li>受控访问</li></ul><p><strong>基于竞争的访问</strong></p><p>在基于竞争的多路访问网络中，所有节点都工作在半双工方式，争夺介质的使用。然而，一次只有一台设备能够发送。因此，当多台设备同时传输时，会使用一个处理过程。基于竞争的访问方法示例如下：</p><ul><li>在传统总线拓扑以太网局域网上使用载波侦听多路访问/冲突检测(CSMA/CD)</li><li>在无线局域网上使用载波侦听多路访问/冲突避免(CSMA/CA)</li></ul><p><strong>受控访问</strong></p><p>在基于控制的多路访问网络中，每个节点都有自己的时间来使用介质。这种确定性的传统网络类型效率很低，因为设备必须等到轮到自己才能访问介质。使用受控访问的多路访问网络的示例包括：</p><ul><li>传统令牌环</li><li>传统ARCNET</li></ul><p><strong>注意</strong>: 如今，<strong>以太网网络以全双工方式运行</strong>，不需要访问方法。</p><h2 id="2-7、基于竞争的访问-CSMA-CD"><a href="#2-7、基于竞争的访问-CSMA-CD" class="headerlink" title="2.7、基于竞争的访问-CSMA/CD"></a>2.7、基于竞争的访问-CSMA/CD</h2><p>基于竞争的访问网络示例如下：</p><ul><li><strong>无线局域网（WLAN）（使用 CSMA/CA）</strong></li><li>传统总线拓扑以太网局域网（使用 CSMA/CD）</li><li>使用集线器的传统以太网局域网（使用 CSMA/CD）</li></ul><p>这些网络在半双工模式下运行，意味着一台设备一次只能发送或接收。这需要有一个进程来管理设备何时可以发送以及当多台设备同时发送时会发生什么情况。</p><p>如果两台设备同时传输，则会发生冲突。对于传统以太网局域网，两台设备将会检测到网络上的冲突。这就是 CSMA/CD 的冲突检测 (CD) 部分。网卡通过比较传输的数据与接收的数据，或通过识别介质中的信号振幅是否高于正常状况来实现。两台设备发送的数据会损坏且需重新发送。</p><h3 id="PC1发送一个帧"><a href="#PC1发送一个帧" class="headerlink" title="PC1发送一个帧"></a>PC1发送一个帧</h3><p>PC1 有一个以太网帧要发送给 PC3。PC1 的网卡需要确定是否有设备正在通过介质传输。如果它没有检测到载波信号，也就是说，它没有收到来自其他设备的传输，则假定网络可用于发送。</p><p>当介质可用时，PC1 NIC 发送以太网帧，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.7.png"></p><h3 id="集线器接受帧"><a href="#集线器接受帧" class="headerlink" title="集线器接受帧"></a>集线器接受帧</h3><p>以太网集线器接收并发送帧。以太网集线器也称为多端口中继器。传入端口上收到的任何位都会重新生成，并通过所有其他端口发送出去，如图所示。</p><p>如果另一台设备，比如 PC2，想要发送，但当前正在接收一个帧，则它必须等待信道空闲，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.8.png"></p><h3 id="集线器发送帧"><a href="#集线器发送帧" class="headerlink" title="集线器发送帧"></a>集线器发送帧</h3><p>与集线器连接的所有设备都将收到该帧。然后，由于帧拥有 PC3 的目的数据链路地址，只有该设备会接受并被全帧复制。所有其他设备的网卡都将忽略该帧，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.9.png"></p><h2 id="2-8、基于竞争的访问-CSMA-CA"><a href="#2-8、基于竞争的访问-CSMA-CA" class="headerlink" title="2.8、基于竞争的访问-CSMA/CA"></a>2.8、基于竞争的访问-CSMA/CA</h2><p>IEEE 802.11 WLAN 所使用的另一种 CSMA 形式为载波侦听多路访问/冲突避免 (CSMA/CA)。</p><p>CMSA/CA 采用一种与 CSMA/CD 类似的方法来检测介质是否空闲。CMSA/CA 采用其他技术。在无线环境中，设备可能无法检测到冲突。CMSA/CA 不会检测冲突，但会通过在传输之前等待来尝试避免冲突。每台设备发送时都会包含传输所需的持续时间。所有其他无线设备都会收到此信息，知道介质将有多长时间不可用。</p><p>在图中，如果主机 A 从接入点接收到一个无线帧，那么主机 B 和 C 也会看到该帧以及介质有多久不可用。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.10.png"></p><p>当无线设备发送 802.11 帧后，接收方会返回确认，以使发送方知道帧已到达。</p><p>不管是使用集线器的以太网 LAN，还是 WLAN，基于竞争的系统在介质使用率高的情况下都无法很好地扩展。</p><p><strong>注意</strong>: 使用交换机的以太网 LAN 不使用基于竞争的系统，因为交换机和主机网卡在全双工模式下运行。</p><h1 id="3、数据链路帧"><a href="#3、数据链路帧" class="headerlink" title="3、数据链路帧"></a>3、数据链路帧</h1><h2 id="3-1、帧"><a href="#3-1、帧" class="headerlink" title="3.1、帧"></a>3.1、帧</h2><p>本主题详细讨论数据链路帧在网络中移动时发生的情况。附加到帧的信息由正在使用的协议决定。</p><p>数据链路层通过使用帧头和帧尾将其封装以创建帧，从而准备封装后的数据（通常是IPv4或IPv6数据包），以便在本地介质上进行传输。</p><p>数据链路协议负责同一网络中的网卡间通信。虽然有许多描述数据链路层帧的不同数据链路层协议，但每种帧均有三个基本组成部分：</p><ul><li>帧头</li><li>数据</li><li>帧尾</li></ul><p>与其他封装协议不同，数据链路层以帧尾的形式在帧的末尾附加信息。</p><p>所有数据链路层协议均将数据封装于帧的数据字段内。但是，由于协议的不同，帧结构以及帧头和帧尾中包含的字段会存在差异。</p><p>没有一种帧结构能满足通过所有类型介质的全部数据传输需求。根据环境的不同，帧中所需的控制信息量也相应变化，以匹配介质和逻辑拓扑的访问控制需求。例如，WLAN帧必须包含避免冲突的过程，因此与以太网帧相比需要额外的控制信息。</p><h2 id="3-2、帧字段"><a href="#3-2、帧字段" class="headerlink" title="3.2、帧字段"></a>3.2、帧字段</h2><p>成帧技术将位流拆分成可破解的多个分组，且将控制信息作为不同字段值插入帧头和帧尾中。此格式使物理信号具备能被节点识别且可在目的地解码成数据包的一种结构。</p><p>图中显示了通用帧字段。并非所有协议均包含全部此类字段。特定数据链路协议的标准定义了实际帧格式。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.11.png"></p><p>帧字段包括以下内容：</p><ul><li><strong>帧开始和停止指示标志</strong> - 用于标识帧的开始和结束位置的限制。</li><li><strong>编址</strong> - 表示介质上的源节点和目的节点。</li><li><strong>类型</strong> - 用于标识数据字段中的第 3 层协议。</li><li><strong>控制</strong> - 用于标识特殊流量控制服务，比如服务质量 (QoS)。QoS 为某些类型的消息提供转发优先权。例如，IP 语音 (VoIP) 帧通常优先接收，因为它们对延迟敏感。</li><li><strong>数据</strong> - 包含帧负载（即数据包报头、数据段报头和数据）。</li><li><strong>错误检测</strong> - 包含在数据之后以形成帧尾。</li></ul><p>数据链路层协议将帧尾添加到各帧结尾处。在一个叫做错误检测的过程中，帧尾会判断帧是否到达时没有错误。它将组成帧的各个位的逻辑或数学摘要放入帧尾中。要将错误检测添加到数据链路层，因为介质中的信号可能遭受干扰、失真或丢失，从而大幅更改这些信号所代表的位值。</p><p>发送节点会创建帧内容的逻辑摘要，称为循环冗余校验 (CRC) 值。此值将放入帧校验序列 (FCS) 字段中以代表帧内容。在以太网尾部，FCS 为接收节点提供一种方法，用于确定帧是否出现传输错误。</p><h2 id="3-3、第2层地址"><a href="#3-3、第2层地址" class="headerlink" title="3.3、第2层地址"></a>3.3、第2层地址</h2><p>数据链路层提供了通过共享本地介质传输帧时要用到的编址。此层中的设备地址称为物理地址。数据链路层地址包含在帧头中，它指定了帧在本地网络中的目的节点。它通常位于帧的开头，因此网卡可以在接受帧的其余部分之前快速确定它是否匹配自己的第 2 层地址。帧头还可能包含帧的源地址。</p><p>与分层式第 3 层逻辑地址不同，物理地址不会表示设备位于哪个网络。相反，物理地址对于特定设备是唯一的。即使设备移至另一网络或子网，它将仍使用相同的第 2 层物理地址。因此，第2层地址仅用于在相同的共享介质中，在相同的IP网络上连接设备。</p><p>当 IP 数据包从主机到路由器、从路由器到路由器和最终从路由器到主机传输时，沿途中的每个点上都会将 IP 数据包封装到新的数据链路帧中。每个数据链路帧包含发送帧的网卡的源数据链路地址和接收帧的网卡的目的数据链路地址。</p><h3 id="主机到路由器"><a href="#主机到路由器" class="headerlink" title="主机到路由器"></a>主机到路由器</h3><p>源主机将第 3 层IP数据包封装成第 2 层帧。在帧头中，主机将其第 2 层地址添加为源地址，R1 的第 2 层地址添加为目的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.12.png"></p><h3 id="路由器到路由器"><a href="#路由器到路由器" class="headerlink" title="路由器到路由器"></a>路由器到路由器</h3><p>R1将第 3 层IP数据包封装成新的第 2 层帧。在帧头中，R1将其第 2 层地址添加为源地址，R2 的第 2 层地址添加为目的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.13.png"></p><h3 id="路由器到主机"><a href="#路由器到主机" class="headerlink" title="路由器到主机"></a>路由器到主机</h3><p>R2将第 3 层IP数据包封装成新的第 2 层帧。在帧头中，R2将其第 2 层地址添加为源地址，服务器的第 2 层地址添加为目的地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN6.14.png"></p><p>数据链路层地址仅用于本地传送。该层地址在本地网络之外无任何意义。将它与第 3 层进行比较，我们发现在第 3 层中，无论途中有多少个网络跳点，数据包报头中的址址都会从源主机传送到目的主机。</p><p>如果数据必须传递到另一网段上，则需要使用中间设备，比如路由器。路由器必须根据物理地址接受帧并解封帧，以便检查分层地址，即 IP 地址。路由器使用 IP 地址可以确定目的设备的网络地址以及到达该地址的最佳路径。当知道要将数据包转发到何处时，路由器会为数据包创建一个新帧，并将新帧发送到通往最终目的地的下一网段。</p><h3 id="3-4、LAN和WAN上的帧"><a href="#3-4、LAN和WAN上的帧" class="headerlink" title="3.4、LAN和WAN上的帧"></a>3.4、LAN和WAN上的帧</h3><p>以太网协议由有线局域网使用。无线通信属于无线局域网（IEEE 802.11）协议范围。这些协议都是为多路访问网络而设计的。</p><p>WAN 传统上在各种类型的点对点、中心辐射和全网状拓扑中使用其他类型的协议。多年来，一些常见的广域网协议包括：</p><ul><li>点对点协议 (PPP)</li><li>高级数据链路控制 (HDLC)</li><li>帧中继</li><li>异步传输模式 (ATM)</li><li>X.25</li></ul><p>这些第2层协议现在正在被以太网在广域网中取代。</p><p>在 TCP/IP 网络中，所有 OSI 第 2 层协议都与 OSI 第 3 层的 IP 一起使用。但是，所用的第 2 层协议取决于<strong>逻辑拓扑和物理介质</strong>。</p><p>每个协议执行指定第 2 层逻辑拓扑的介质访问控制。这意味着在执行这些协议时，有很多种不同的网络设备都可以充当运行在数据链路层上的节点。这些设备包括计算机上的网卡以及路由器和第 2 层交换机上的接口。</p><p>用于特定网络拓扑的第 2 层协议取决于实施该拓扑的技术。所使用的技术取决于网络规模（根据主机数量和地理范围判断）以及通过网络提供的服务。</p><p>LAN 通常使用能支持大量主机的高带宽技术。由于 LAN 的地理范围相对较小（单个建筑物或多个建筑物的园区），用户的密集度高，因此这种技术比较节约成本。</p><p>但是，对于服务范围较广（例如一个城市或多个城市）的 WAN，使用高带宽技术通常不够经济。长距离物理链路的成本以及长距离传送信号的技术一般都会使带宽容量降低。</p><p>带宽差异常会导致 LAN 和 WAN 使用不同的协议。</p><p>数据链路层协议包括：</p><ul><li>以太网</li><li>802.11 无线</li><li>点对点协议 (PPP)</li><li>高级数据链路控制 (HDLC)</li><li>帧中继</li></ul><h2 id="3-5、检测"><a href="#3-5、检测" class="headerlink" title="3.5、检测"></a>3.5、检测</h2><p>注：第2层和第3层地址字段的正确顺序是：目的网卡地址、源网卡地址、源IP地址、目的IP地址</p><h1 id="4、单元检测"><a href="#4、单元检测" class="headerlink" title="4、单元检测"></a>4、单元检测</h1><p>1、在数据链路层使用<strong>MAC地址</strong>来唯一地标识一个以太网设备</p><p>2、网卡的<strong>MAC地址</strong>使其放置在OSI模型的数据链路层</p><p>3、通过以太网电缆连接到中央设备可以创建<strong>星型</strong>物理拓扑</p><p>4、逻辑链路控制子层的作用是：<strong>识别正在使用的网络层协议</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（五）</title>
      <link href="/2021/110640234.html"/>
      <url>/2021/110640234.html</url>
      
        <content type="html"><![CDATA[<h1 id="五、数制系统"><a href="#五、数制系统" class="headerlink" title="五、数制系统"></a>五、数制系统</h1><p>这是一个网络中计算机的 32 位 IPv4 地址：11000000.10101000.00001010.00001010。它以二进制显示。</p><p>这是以点分十进制显示的同一台计算机的 IPv4 地址：192.168.10.10。</p><p>而IPv6 地址是 128 位！为了使这些地址更易于管理，IPv6 使用 0-9 和字母 A-F组成的十六进制系统。</p><p>作为网络管理员，您必须知道如何将二进制地址转换为点分十进制地址，以及将点分十进制地址转换为二进制地址。您还需要知道如何将点分十进制转换为十六进制，反之亦然。</p><p><strong>模块目标</strong>: 十进制、二进制和十六进制数之间的相互转换。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>二进制数制系统</strong></td><td align="left">在十进制与二进制之间进行数字转换。</td></tr><tr><td align="left"><strong>十六进制数制系统</strong></td><td align="left">在十进制与十六进制之间进行数字转换。</td></tr></tbody></table><h1 id="1、二进制数制系统"><a href="#1、二进制数制系统" class="headerlink" title="1、二进制数制系统"></a>1、二进制数制系统</h1><h2 id="1-1、二进制和IPv4地址"><a href="#1-1、二进制和IPv4地址" class="headerlink" title="1.1、二进制和IPv4地址"></a>1.1、二进制和IPv4地址</h2><p>IPv4地址以二进制开头，仅包含1和0。这很难管理，因此网络管理员必须将它们转换为十进制。本主题向您展示了几种实现它的方法。</p><p>二进制是指包含数字 0 和 1 位的数制系统。相比之下，十进制数制系统是由数字 0 - 9 共 10 位数字组成。</p><p>理解二进制对于我们很重要，因为<strong>主机、服务器和网络设备使用二进制编址</strong>。具体地说，它们使用二进制 IPv4 地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN5.1.png"></p><p>每一个地址包含一串 32 位字符串，并分为四个部分，称为二进制八位组。每一个二进制八位组包含 8 位（或 1 个字节），用句点分隔。例如，为图中的 PC1 分配的 IPv4 地址为 11000000.10101000.00001010.00001010。其默认网关地址将为 R1 千兆以太网接口地址 11000000.10101000.00001010.00000001。</p><p>二进制可以与主机和网络设备很好地协同工作。然而，这对人类来说是非常具有挑战性的。</p><p><strong>为了方便人们使用，IPv4 地址通常表达为点分十进制记法。</strong>为 PC1 分配的 IPv4 地址为 192.168.10.10，其默认网关地址为 192.168.10.1，如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN5.2.png"></p><p>为了扎实理解网络编址，必须了解二进制编址，并且掌握在 IPv4 地址的二进制和点分十进制之间转换的技能。此部分介绍如何在以 2（二进制） 为基数的数制系统和 10 （十进制）为基数的数制系统之间进行转换。</p><h2 id="以下有关二进制数和十进制数的转换均省略"><a href="#以下有关二进制数和十进制数的转换均省略" class="headerlink" title="以下有关二进制数和十进制数的转换均省略"></a>以下有关二进制数和十进制数的转换均省略</h2><h1 id="2、十六进制数制系统"><a href="#2、十六进制数制系统" class="headerlink" title="2、十六进制数制系统"></a>2、十六进制数制系统</h1><p><strong>十六进制数制系统在网络中用于表示以太网 MAC 地址和 IP V6 地址。</strong></p><p>IPv6地址长度为128位，每 4 位以一个十六进制数字表示，共 32 个十六进制值。IPv6 地址不区分大小写，可用大写或小写书写。</p><p>如图所示，书写 IPv6 地址的首选格式为 x: x: x: x: x: x: x: x，每个“x”均包括四个十六进制值。在指 IPv4 地址的 8 位时，我们使用术语八位组。在 IPv6 中，十六进制数是指代 16 位或四个十六进制值数据段的非官方术语。每个“x”均为一个十六进制数、16 位或四个十六进制值</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN5.3.png"></p><p>图中的示例拓扑显示了 IPv6 十六进制地址。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN5.4.png"></p><h2 id="以下十进制数与十六进制数的转换均省略"><a href="#以下十进制数与十六进制数的转换均省略" class="headerlink" title="以下十进制数与十六进制数的转换均省略"></a>以下十进制数与十六进制数的转换均省略</h2>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（四）</title>
      <link href="/2021/110624468.html"/>
      <url>/2021/110624468.html</url>
      
        <content type="html"><![CDATA[<h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><p>OSI模型的物理层位于协议栈的底部。它是 TCP/IP 模型的网络接入层的一部分。如果没有物理层，就没有网络。</p><p><strong>模块目标</strong>: 说明物理层协议、服务和网络介质如何支持数据网络间的通信。</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>物理层的用途</strong></td><td align="left">阐述网络中物理层的用途和功能。</td></tr><tr><td align="left"><strong>物理层的特征</strong></td><td align="left">描述物理层的特征。</td></tr><tr><td align="left"><strong>铜缆布线</strong></td><td align="left">明确铜缆布线的基本特征。</td></tr><tr><td align="left"><strong>UTP 布线</strong></td><td align="left">说明如何使用 UTP（非屏蔽双绞线）电缆进行以太网布线。</td></tr><tr><td align="left"><strong>光纤布线</strong></td><td align="left">描述光纤布线以及光纤布线相比其他介质的主要优势。</td></tr><tr><td align="left"><strong>无线介质</strong></td><td align="left">使用有线和无线介质连接设备。</td></tr></tbody></table><h1 id="1、物理层的用途"><a href="#1、物理层的用途" class="headerlink" title="1、物理层的用途"></a>1、物理层的用途</h1><h2 id="1-1、物理连接"><a href="#1-1、物理连接" class="headerlink" title="1.1、物理连接"></a>1.1、物理连接</h2><p>不管是在家连接本地打印机还是将其连接到另一国家/地区的网站上，在进行网络通信之前，都必须在本地网络上建立一个<strong>物理连接</strong>。物理连接可以<strong>通过线缆进行有线连接</strong>，也可以<strong>通过无线电波进行无线连接</strong>。</p><p>物理连接类型的使用取决于<strong>网络设置</strong>。例如，在很多企业办公室，员工的台式电脑或笔记本电脑通过线缆物理连接到一台共享交换机上。这种类型的设置称为有线网络。数据通过物理电缆传输。</p><p>除了有线连接，许多企业还提供笔记本电脑、平板电脑和智能手机的无线连接。使用无线设备时，数据通过无线电波传输。随着个人和企业都发现了无线连接的优点，无线连接变得越来越普遍。无线网络上的设备必须连接无线接入点 (AP，(Wireless) Access Point)或无线路由器</p><p><strong>无线路由器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.1.png"></p><p>这些是接入点的组件：</p><ol><li>无线天线（在上图所示的路由器中，这些天线是嵌入式的。）</li><li>几个以太网交换端口</li><li>互联网端口</li></ol><p>与公司办公室类似，大多数家庭提供有线和无线网络连接。</p><p><strong>网络接口卡</strong></p><p>网络接口卡 (NIC) 将设备连接到网络。以太网网卡用于有线连接，而无线局域网（WLAN）网卡用于无线连接。最终用户设备可能包括一种或两种类型的网卡。例如，网络打印机可能只有以太网网卡，因此必须通过以太网电缆连接到网络。其他设备，例如平板电脑和智能手机，可能只包含 WLAN 网卡，必须使用无线连接。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.2.png"></p><p>在连接网络时，所有物理连接的性能水平并不是相等的。</p><h2 id="1-2、物理层"><a href="#1-2、物理层" class="headerlink" title="1.2、物理层"></a>1.2、物理层</h2><p>OSI 物理层通过网络介质传输构成数据链路层帧的比特（位）。该层从数据链路层接收完整的帧，并将这些帧编码为一系列信号，传输到本地介质上。帧由经过编码的<strong>比特（位）</strong>构成，这些位可以被终端设备或中间设备接收。</p><p>封装过程的最后一部分为通过物理介质发送的位。物理层将帧编码，并创建电子、光纤或无线电波信号来代表每个帧中的位。然后，将这些信号通过介质<strong>逐个发送</strong>。</p><p>目的节点物理层从介质上检索每个信号，将其还原为位表示方式，然后将这些位作为一个完整的帧向上传递到数据链路层。</p><h1 id="2、物理层的特征"><a href="#2、物理层的特征" class="headerlink" title="2、物理层的特征"></a>2、物理层的特征</h1><h2 id="2-1、物理层标准"><a href="#2-1、物理层标准" class="headerlink" title="2.1、物理层标准"></a>2.1、物理层标准</h2><p><strong>OSI 上层的协议及操作是使用软件工程师和计算机科学家设计的软件来执行的。TCP/IP 协议簇中的服务和协议是由互联网工程任务组 (IETF) 定义的。</strong></p><p>物理层由工程师开发的电子电路、介质和连接器组成。因此，由相关的电气和通信工程组织定义管制该硬件的标准是很合适的。</p><p>在物理层标准的制定和维护中涉及许多不同的国际和国家组织、政府监管机构和私营企业。例如，物理层硬件、介质、编码和信令标准由以下组织定义和管理：</p><ul><li>国际标准化组织 (ISO)</li><li>电信工业协会/电子工业协会 (TIA/EIA)</li><li>国际电信联盟 (ITU)</li><li>美国国家标准学会 (ANSI)</li><li>电气电子工程师协会 (IEEE)</li><li>国家级电信管理局包括美国联邦通信委员会 (FCC) 和欧洲电信标准协会 (ETSI)。</li></ul><p>除了这些组织之外，通常还有地方性布线标准组织，例如 CSA（加拿大标准协会）、CENELEC（欧洲电工标准化委员会）和 JSA/JIS（日本标准协会），开发本地规范。</p><h2 id="2-2、物理组件"><a href="#2-2、物理组件" class="headerlink" title="2.2、物理组件"></a>2.2、物理组件</h2><p>物理层标准管理三个功能区：</p><ul><li><strong>物理组件</strong></li><li><strong>编码</strong></li><li><strong>信令</strong></li></ul><p><strong>物理组件</strong></p><p>物理组件是电子硬件设备、介质和其他连接器，它们用于传输用于表示位的信号。网卡、接口和连接器、线缆材料以及线缆设计等硬件组件均按照物理层的相关标准进行规定。Cisco 1941 路由器上的各种端口和接口也属于物理组件，根据标准使用特定连接器和引脚。</p><h2 id="2-3、编码"><a href="#2-3、编码" class="headerlink" title="2.3、编码"></a>2.3、编码</h2><p><strong>编码或线路编码是一种将数据位流转换为预先定义“代码”的方法</strong>。这些代码就是位的编组，用于提供一种可预测模式，以便发送者和接收者均能识别。换句话说，编码是用于表示数字信息的方法或模式。这类似于摩尔斯电码如何使用一系列点和短划线编码消息。</p><p>例如，曼彻斯特编码的 0 位表示为从高到低的电压转换，而 1 位表示为从低到高的电压转换。转换在每个位周期的中间进行。这种类型的编码用于 10 Mbps 的以太网。更快的数据速率需要更复杂的编码。曼彻斯特编码用于较旧的以太网标准，如 10BASE-T。 以太网 100BASE-TX 使用 4B/5B 编码。1000BASE-T 使用 8B/10B 编码。</p><h2 id="2-4、信令"><a href="#2-4、信令" class="headerlink" title="2.4、信令"></a>2.4、信令</h2><p>物理层必须在介质上生成代表“1”和“0”的<strong>电信号</strong>、<strong>光信号</strong>或<strong>无线信号</strong>。表示位的方法称为<strong>信令方法</strong>。物理层标准必须定义哪种类型的信号代表“1”，而哪种类型的信号代表“0”。这可以简单到只是改变电信号或光脉冲的级别。例如，长脉冲可能代表 1，而短脉冲可能代表 0。</p><h3 id="铜缆"><a href="#铜缆" class="headerlink" title="铜缆"></a>铜缆</h3><p>铜缆上传输的电信号</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.3.png"></p><h3 id="光缆"><a href="#光缆" class="headerlink" title="光缆"></a>光缆</h3><p>光缆上传输的光脉冲</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.4.png"></p><h3 id="无线介质"><a href="#无线介质" class="headerlink" title="无线介质"></a>无线介质</h3><p>无线传输的微博信号</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.5.png"></p><h2 id="2-5、带宽"><a href="#2-5、带宽" class="headerlink" title="2.5、带宽"></a>2.5、带宽</h2><p>不同的物理介质所支持的位传输速率不同。数据传输的讨论通常都会提及带宽。<strong>带宽是介质承载数据的能力</strong>。数字带宽可以测量<strong>在给定时间内从一个位置流向另一个位置的数据量</strong>。带宽通常使用千位每秒 (kbps)、兆位每秒 (Mbps) 或千兆位每秒 (Gbps) 来度量。有时带宽被认为是位传输的速度，而这是不准确的。例如，在 10Mbps 和 100Mbps 的以太网上，都以电的速率发送位。不同的是每秒传输的位的数量。</p><p>多种因素的结合，决定了网络的实际带宽：</p><ul><li>物理介质的属性</li><li>信令和检测网络信号所选用的技术</li></ul><p>物理介质属性、当前技术和物理法则共同扮演确定可用带宽的角色。</p><p>该表显示了带宽的常用计量单位。</p><table><thead><tr><th align="left"><strong>带宽单位</strong></th><th align="left"><strong>缩写</strong></th><th align="left"><strong>当量</strong></th></tr></thead><tbody><tr><td align="left">位/秒</td><td align="left">bps</td><td align="left">1 bps = 带宽的基本单位</td></tr><tr><td align="left">千位/秒</td><td align="left">Kbps</td><td align="left">1 Kbps = 1,000 bps = 103bps</td></tr><tr><td align="left">兆位/秒</td><td align="left">Mbps</td><td align="left">1 Mbps = 1,000,000 bps = 106 bps</td></tr><tr><td align="left">千兆位/秒</td><td align="left">Gbps</td><td align="left">1 Gbps = 1,000,000,000 bps = 109 bps</td></tr><tr><td align="left">兆兆位/秒</td><td align="left">Tbps</td><td align="left">1 Tbps = 1,000,000,000,000 bps = 1012 bps</td></tr></tbody></table><h2 id="2-6、带宽术语"><a href="#2-6、带宽术语" class="headerlink" title="2.6、带宽术语"></a>2.6、带宽术语</h2><p>用来衡量带宽质量的术语包括:</p><ul><li>延迟</li><li>吞吐量</li><li>实际吞吐量</li></ul><p><strong>延迟</strong></p><p>延迟是指数据从一个给定点传送到另一给定点所用的时间，包括时延。</p><p><strong>吞吐量</strong></p><p>吞吐量是给定时段内通过介质传输的位的量度。</p><p>在拥有多个网段的网际网络或网络中，吞吐量不能超过从源到目的地之间路径的最低链路。纵使这些网段全部或多数具备高速带宽，它也只使用那段低速率路径的吞吐量，这就会造成整个网络的吞吐量瓶颈。</p><p>由于各种因素的影响，吞吐量经常与物理层实施中指定的带宽不符。吞吐量通常低于带宽。影响吞吐量的因素有很多:</p><ul><li>流量大小</li><li>流量类型</li><li>从源通往目的地的过程中遇到的网络设备数量所造成的延时。</li></ul><p><strong>实际吞吐量</strong></p><p>用于评估可用数据传输的第三个测量标准称为实际吞吐量。实际吞吐量是在给定时间段内传输的有用数据的衡量标准。实际吞吐量就是吞吐量减去建立会话、确认、封装和重传所产生的流量开销。</p><p><strong>实际吞吐量总是低于吞吐量，而吞吐量通常低于带宽。</strong></p><h1 id="3、铜缆布线"><a href="#3、铜缆布线" class="headerlink" title="3、铜缆布线"></a>3、铜缆布线</h1><h2 id="3-1、铜缆布线的特征"><a href="#3-1、铜缆布线的特征" class="headerlink" title="3.1、铜缆布线的特征"></a>3.1、铜缆布线的特征</h2><p>铜缆布线是当今网络中最常用的布线类型。事实上，铜缆布线不仅仅是电缆的一种。有三种不同类型的铜缆布线，每一种都用于特定的情况。</p><p>网络使用铜介质是因为其价格低廉、易于安装、对电流的电阻低。但是，铜介质受到距离和信号干扰的限制。</p><p>在铜缆中，通过<strong>电脉冲</strong>传输数据。目的设备网络接口中的探测器接收的信号必须可成功解码为与发送的信号相符。但是，信号传输的距离越远，信号下降就越多。这称为<strong>信号衰减</strong>。因此，所有铜介质必须严格遵循指导标准所指定的距离限制。</p><p>电脉冲的时间和电压值易受两个干扰源的干扰：</p><ul><li><strong>电磁干扰 (EMI) 或射频干扰 (RFI)</strong> - EMI 和 RFI 干扰信号会扭曲和损坏通过铜介质承载的数据信号。EMI 和 RFI 的潜在来源包括无线电波和电磁设备（如荧光灯或电动机）。</li><li><strong>串扰</strong> - 串扰是一根电线中信号的电场或磁场对邻近电线中的信号造成的干扰。在电话线上，串扰会由相邻电路中另一语音会话的接听部分引起。具体而言，当电流流经电线时，会在电线周围产生一个较小的环形磁场，而相邻电线可能接收到该磁场。</li></ul><p>为了应对 EMI 和 RFI 的负面影响，某些类型的铜缆会用金属屏蔽套包裹，并要求适当的接地连接。</p><p>为了应对串扰的负面影响，某些类型的铜缆将相反电路线对绞合在一起以有效消除串扰。</p><p>使用以下建议也可以限制电子噪音对铜缆的影响：</p><ul><li>选择的电缆类型或类别要适合特定的网络环境。</li><li>设计电缆基础设施时应规避建筑结构中已知和潜在的干扰源。</li><li>使用包括正确处理和端接电缆的布线技术。</li></ul><h2 id="3-2、铜缆布线的类型"><a href="#3-2、铜缆布线的类型" class="headerlink" title="3.2、铜缆布线的类型"></a>3.2、铜缆布线的类型</h2><p>见以下内容</p><h2 id="3-3、非屏蔽双绞线（UTP）"><a href="#3-3、非屏蔽双绞线（UTP）" class="headerlink" title="3.3、非屏蔽双绞线（UTP）"></a>3.3、非屏蔽双绞线（UTP）</h2><p>Unshielded Twisted Pair</p><p>非屏蔽双绞线 (UTP) 布线是<strong>最常用</strong>的网络介质。通过 <strong>RJ-45 连接器</strong>端接的 UTP 布线用于网络主机与中间网络设备的互连，例如<strong>交换机和路由器</strong>。</p><p>在 LAN 中，UTP 电缆由四对用颜色标记的电线组成。这些电线绞合在一起，并用软塑料套包裹，以避免较小的物理损坏。电线的扭绞有助于防止电线之间的串扰。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.6.png"></p><p>图中的数字表明了非屏蔽双绞线的一些关键特征:</p><ol><li>外层护套可防止铜缆受到物理损坏。</li><li>线对扭绞可防止信号串扰。</li><li>颜色编码的塑料绝缘层使电线之间相互隔离并标识每个线对。</li></ol><h2 id="3-4、屏蔽双绞线（STP）"><a href="#3-4、屏蔽双绞线（STP）" class="headerlink" title="3.4、屏蔽双绞线（STP）"></a>3.4、屏蔽双绞线（STP）</h2><p>屏蔽双绞线 (STP) 比 UTP 布线提供更好的噪声防护。但是，与 UTP 电缆相比，STP 电缆更加昂贵而且不易安装。和 UTP 相同，STP 也使用 <strong>RJ-45 连接器</strong>。</p><p>STP 电缆结合屏蔽技术来应对 EMI 和 RFI，使用线缆扭绞技术来应对串扰。为了充分利用屏蔽的优势，STP 电缆使用<strong>特殊屏蔽 STP 数据连接器</strong>进行端接。如果电缆接地不正确，屏蔽就相当于一个天线，会接听多余信号。</p><p>显示的 STP 电缆有四对电线，每一对使用金属箔包裹，然后整体再用金属编织网或金属箔包裹。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.7.png"></p><p>图中的数字表明了屏蔽双绞线的一些关键特征:</p><ol><li>外层护套</li><li>金属编织或箔屏蔽</li><li>金属箔屏蔽</li><li>双绞线</li></ol><h2 id="3-5、同轴电缆"><a href="#3-5、同轴电缆" class="headerlink" title="3.5、同轴电缆"></a>3.5、同轴电缆</h2><p>同轴电缆，或简称同轴，由于它的两根导线共享同一个中轴而得名。如图所示，同轴电缆包括：</p><ul><li>一根用于传输电子信号的铜导线。</li><li>包裹着铜导线的柔软的塑料绝缘层。</li><li>绝缘材料的表皮是编织铜线或金属箔，作用相当于电路中的第二条电线，而且还可作为内部导体的屏蔽层。这个第二层，或称屏蔽层，还可减少许多外部电磁干扰。</li><li>整个电缆由一层电缆表皮覆盖，使其免于较小的物理损坏。</li></ul><p>同轴电缆使用许多不同类型的连接器。图中显示了<strong>卡口式Neill–Concelman (BNC)、N 型和 F 型连接器。</strong></p><p>虽然 UTP 电缆在现代以太网安装中最终取代了同轴电缆，但在以下情形中仍采用同轴电缆设计：</p><ul><li><strong>无线安装</strong> - <strong>用同轴电缆将天线连接到无线设备。</strong>同轴电缆可传送天线和无线电设备之间的射频 (RF) 能量。</li><li><strong>有线电视互联网安装</strong> - 有线电视服务提供商为其客户提供互联网连接，他们会使用光缆替换同轴电缆和支撑放大元件部分。但是，客户所在地的布线仍采用同轴电缆。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.8.png"></p><p>图中的数字表明了同轴电缆的一些关键特征:</p><ol><li>外层护套</li><li>铜网屏蔽</li><li>塑料绝缘层</li><li>铜质导线</li></ol><h1 id="4、UTP布线"><a href="#4、UTP布线" class="headerlink" title="4、UTP布线"></a>4、UTP布线</h1><h2 id="4-1、UTP布线的属性"><a href="#4-1、UTP布线的属性" class="headerlink" title="4.1、UTP布线的属性"></a>4.1、UTP布线的属性</h2><p>在用作网络介质时，UTP电缆由四对用颜色标记的铜线组成。这些铜线扭绞在一起，并用软塑料套包裹。在安装过程中，它尺寸较小是有利的。</p><p>UTP 电缆并不使用屏蔽层来对抗 EMI 和 RFI 的影响。相反，电缆设计者发现他们可以通过以下方式来减少串扰的负面影响：</p><ul><li><strong>抵消</strong> - 电缆设计者现在对电路中的电线进行配对。当电路中的两根电线紧密排列时，彼此的磁场正好相反。因此，这两个磁场相互抵消，也抵消了所有的外部 EMI 和 RFI 干扰信号。</li><li><strong>变化每个线对中的扭绞次数</strong> - 为了进一步增强配对电线的抵消效果，设计者会变化电缆中每个线对的扭绞次数。UTP 电缆必须遵守精确的规定来管理每米（3.28 英尺）电缆所允许的扭绞次数或编织数。</li></ul><p>UTP 电缆仅通过线对扭绞的抵消效果来减小信号衰减，并为网络介质中的线对提供有效的自屏蔽。</p><h2 id="4-2、UTP布线标准和连接器"><a href="#4-2、UTP布线标准和连接器" class="headerlink" title="4.2、UTP布线标准和连接器"></a>4.2、UTP布线标准和连接器</h2><p>UTP 布线遵循由 TIA/EIA 共同制定的标准。具体而言，TIA/EIA-568 规定了 LAN 安装的商业布线标准，它是 LAN 布线环境中最常用的标准。定义的一些要素如下：</p><ul><li>电缆类型</li><li>电缆长度</li><li>连接器</li><li>电缆端接</li><li>测试电缆的方法</li></ul><p>电气电子工程师协会 (IEEE) 定义了铜缆的电气特性。IEEE 按照它的性能对 UTP 布线划分等级。<strong>电缆分类的依据是它们承载更高速率带宽的能力。</strong>例如，5类电缆通常用于 100BASE-TX 快速以太网安装。其他类别包括增强型 5类电缆、6类电缆 和 6a 类电缆。</p><p>为了支持更高的数据传输速率，人们设计和构造了更高类别的电缆。随着新的千兆位以太网技术的开发和运用，如今已经很少采用 5e 类电缆，新建筑安装推荐使用 6 类电缆。</p><p>下图显示了三种类型的UTP电缆:</p><p>-3 类电缆最初用于语音线路的语音通信，但后来用于数据传输。 -5 类和5e 类电缆用于数据传输。5类电缆支持 100Mbps，5e 类电缆支持 1000 Mbps -6类电缆在每对线之间增加了一个分隔器以支持更高的速度。 6类电缆支持高达 10 Gbps。 -7类电缆也支持 10 Gbps。 -8类电缆支持 40 Gbps。</p><p>一些制造商制造的电缆超出了 TIA/EIA 6a 类电缆的规格，将其称为 7 类电缆。</p><p>下图显示了 UTP 电缆类别之间的结构差异。在顶部是3类电缆，有四根电线。在中间是5类电缆 和 5e类电缆，有四对双绞线。底部是6类电缆，有四对双绞线，每对之间都有一个塑料分隔器。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.9.png"></p><h3 id="RJ-45-UTP-插头"><a href="#RJ-45-UTP-插头" class="headerlink" title="RJ-45 UTP 插头"></a>RJ-45 UTP 插头</h3><p>UTP 电缆的端头通常为 RJ-45 连接器。TIA/EIA-568 标准描述为以太网电缆进行引脚分配（引出线）的电线颜色标记。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.10.png"></p><h3 id="RJ-45-UTP-插口"><a href="#RJ-45-UTP-插口" class="headerlink" title="RJ-45 UTP 插口"></a>RJ-45 UTP 插口</h3><p>插槽，如图所示，是网络设备、墙壁、小间隔板插座或配线面板的插座型组件。如果端接不正确，每根电缆都将是物理层性能降低的潜在源头。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.11.png"></p><h3 id="端接不良的-UTP-电缆"><a href="#端接不良的-UTP-电缆" class="headerlink" title="端接不良的 UTP 电缆"></a>端接不良的 UTP 电缆</h3><p>此图显示了端接不良的UTP电缆的示例。端接不良的连接器解开的电线裸露在外，且没有被电线表皮全部覆盖。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.12.png"></p><h3 id="端接良好的-UTP-电缆"><a href="#端接良好的-UTP-电缆" class="headerlink" title="端接良好的 UTP 电缆"></a>端接良好的 UTP 电缆</h3><p>下图显示了端接良好的 UTP 电缆。端接良好的连接器解开的电线长度恰好能满足连接器的连接需要。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.13.png"></p><p>注意：电缆端连接不当会影响传输性能</p><h2 id="4-3、直通和交叉UTP电缆"><a href="#4-3、直通和交叉UTP电缆" class="headerlink" title="4.3、直通和交叉UTP电缆"></a>4.3、直通和交叉UTP电缆</h2><p>根据不同的布线约定，不同的场合可能需要使用不同的 UTP 电缆。这意味着要按照不同的顺序将电缆中的单个电线连接到 RJ-45 连接器的不同引脚组中。</p><p>以下是通过使用指定的布线约定得到的主要电缆类型：</p><ul><li><strong>以太网直通电缆</strong> -最常见的网络电缆类型。它通常用于<strong>主机到交换机和交换机到路由器的互连</strong>。</li><li><strong>以太网交叉电缆</strong> -用于<strong>互连相似设备的电缆</strong>。例如，交换机到交换机、主机到主机或路由器到路由器的连接。但是，由于网卡使用介质相关接口交叉（auto-MDIX）来自动检测电缆类型并进行内部连接，因此现在已将交叉电缆视为传统电缆。</li></ul><p><strong>注意</strong>: 另一种类型的电缆是思科专有的<strong>全反电缆</strong>。它用于连接<strong>路由器或交换机的控制台端口</strong>。</p><p>在设备间错误使用交叉电缆或直通电缆不会损坏设备，但也无法连通设备并进行通信。这种常见错误，如果没有连通，首先应进行故障排除，检查设备连接是否正确。</p><p>该图标识了 568A 和 568B 标准的各个线对。</p><h3 id="T568A-and-T568B-Standards"><a href="#T568A-and-T568B-Standards" class="headerlink" title="T568A and T568B Standards"></a>T568A and T568B Standards</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.14.png"></p><p>该表显示了这些电缆的 UTP 电缆类型、相关标准以及典型应用。</p><h3 id="Cable-Types-and-Standards"><a href="#Cable-Types-and-Standards" class="headerlink" title="Cable Types and Standards"></a>Cable Types and Standards</h3><table><thead><tr><th align="left">电缆类型</th><th align="left">标准</th><th align="left">应用</th></tr></thead><tbody><tr><td align="left">以太网直通线</td><td align="left">两端均为 T568A 或两端均为 T568B</td><td align="left">将网络主机连接到交换机或集线器之类的网络设备</td></tr><tr><td align="left">以太网交叉线</td><td align="left">一端为 T568A，另一端为 T568B</td><td align="left">连接两个网络主机或连接两台网络中间设备 （交换机到交换机或路由器到路由器）</td></tr><tr><td align="left">全反电缆</td><td align="left">思科专有</td><td align="left">使用适配器连接工作站串行端口与路由器 控制台端口。</td></tr></tbody></table><h1 id="5、光纤布线"><a href="#5、光纤布线" class="headerlink" title="5、光纤布线"></a>5、光纤布线</h1><h2 id="5-1、光纤布线的属性"><a href="#5-1、光纤布线的属性" class="headerlink" title="5.1、光纤布线的属性"></a>5.1、光纤布线的属性</h2><p>正如您所知，光纤布线是网络中使用的另一种类型的布线。因为它是<strong>昂贵</strong>的，所以在各种类型的铜缆布线中并不常用。但是光纤布线具有某些特性，使其成为某些情况下的最佳选择，您将在本主题中发现这一点。</p><p>与其他网络介质相比，光缆能够以更远的距离和更高的带宽传输数据。不同于铜缆，光缆传输信号的衰减更少，并且<strong>完全不受 EMI 和 RFI 影响</strong>。<strong>光纤常用于互连网络设备</strong>。</p><p>光纤是一种由非常纯的玻璃制成的极细透明的弹性线束，和人的头发差不多大。通过光缆传输时，位会被编码成光脉冲。光缆用作波导管或“光导管”，以最少的信号丢失来传输两端之间的光。</p><h2 id="5-2、光纤介质的类型"><a href="#5-2、光纤介质的类型" class="headerlink" title="5.2、光纤介质的类型"></a>5.2、光纤介质的类型</h2><p>光缆通常分为两种类型：</p><ul><li>单模光纤 (SMF)，Single Mode Fiber</li><li>多模光纤 (MMF)，Multi Mode Fiber</li></ul><h3 id="单模光纤"><a href="#单模光纤" class="headerlink" title="单模光纤"></a>单模光纤</h3><p>单模光纤包含一个极小的芯，使用昂贵的激光技术来发送单束光，如图所示。单模光纤在跨越数百公里的长距离传输情况下很受欢迎，例如应用于长途电话和有线电视中的光纤。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.15.png"></p><h3 id="多模光纤"><a href="#多模光纤" class="headerlink" title="多模光纤"></a>多模光纤</h3><p>多模光纤包含一个稍大的芯，<strong>使用 LED 发射器发送光脉冲</strong>。具体而言，LED 发出的光从不同角度进入多模光纤，如图所示。普遍用于 LAN 中，因为它们可以由低成本的 LED 提供支持。它可以通过长达 550 米的链路提供高达 10 Gb/s 的带宽。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.16.png"></p><p>多模和单模光纤之间的主要区别之一就是<strong>色散的数量</strong>。色散是指光脉冲在时间上的分布。色散增加意味着信号强度损失增加。多模光纤具有比单模光纤更大的色散。这就是为什么多模光纤在信号丢失之前只能传播 500 米。</p><p><strong>与单模光纤相比，多模光纤有更短的距离限制。通常用于校园网内的局域网</strong></p><h2 id="5-3、光纤布线的使用"><a href="#5-3、光纤布线的使用" class="headerlink" title="5.3、光纤布线的使用"></a>5.3、光纤布线的使用</h2><p>目前光纤布线用于四类行业：</p><ul><li><strong>企业网络</strong> - 用于主干布线和基础设施设备互连。</li><li><strong>光纤到户 (FTTH)</strong> - 用于为家庭和小型企业提供不间断宽带服务。</li><li><strong>长距离传输网络</strong> - 由服务提供商用于连接国家/地区与城市。</li><li><strong>水下有线网络</strong> - 用于提供可靠高速、高容量的网络解决方案，使其在深度与横跨海洋的距离相当的严酷海下环境中仍能生存。在互联网上搜索“海底电缆电信地理地图”，以在线查看各种地图。</li></ul><h2 id="5-4、光纤连接器"><a href="#5-4、光纤连接器" class="headerlink" title="5.4、光纤连接器"></a>5.4、光纤连接器</h2><p>光纤连接器在光纤末端连接。有多种类型的光纤连接器。各种连接器类型的主要区别在于尺寸和耦合方式。企业根据其装备来决定将要使用的连接器类型。</p><p><strong>注意</strong>: 一些交换机和路由器具有通过<strong>小型可插拔（SFP）收发器</strong>支持光纤连接器的端口。在互联网上搜索各种类型的 SFP。</p><h3 id="直通式（ST）接头"><a href="#直通式（ST）接头" class="headerlink" title="直通式（ST）接头"></a>直通式（ST）接头</h3><p>ST接头是最早使用的连接器类型之一。该连接器可使用“扭转开关”卡口类机制牢固锁定。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.17.png"></p><h3 id="用户连接器（SC）接口"><a href="#用户连接器（SC）接口" class="headerlink" title="用户连接器（SC）接口"></a>用户连接器（SC）接口</h3><p>SC有时称为方形连接器或标准连接器。它们是一种广泛采用的 LAN 和 WAN 连接器，使用推拉机制以确保正向插入。此类连接器同时用于多模和单模光纤。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.18.png"></p><h3 id="朗讯连接器（LC）单工连接器"><a href="#朗讯连接器（LC）单工连接器" class="headerlink" title="朗讯连接器（LC）单工连接器"></a>朗讯连接器（LC）单工连接器</h3><p>LC 单工连接器是 SC 连接器的较小版本。有时称为小型或本地连接器，因尺寸更小而迅速受到人们的欢迎。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.19.png"></p><h3 id="双工多模LC连接器"><a href="#双工多模LC连接器" class="headerlink" title="双工多模LC连接器"></a>双工多模LC连接器</h3><p>双工多模 LC 连接器，与 LC 单工连接器类似，但使用双工连接器。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.20.png"></p><p>直到最近，光还只能在光纤上沿一个方向传播。因此，<strong>需要两根光纤来支持全双工操作</strong>。因此，光纤跳线是将两根光纤线缆捆绑在一起，并通过一对标准的单光纤接头端接。<strong>有些光纤连接器可以在单个连接器上同时传送和接收光纤，称为双工连接器</strong>，如图中的双工多模 LC 连接器所示。诸如100BASE-BX之类的BX标准使用不同的波长在单个光纤上发送和接收数据。</p><h2 id="5-5、光纤插拔线"><a href="#5-5、光纤插拔线" class="headerlink" title="5.5、光纤插拔线"></a>5.5、光纤插拔线</h2><p>需要使用光纤接插线（即光纤跳线）互连基础设施设备。人们使用不同颜色来区分单模和多模接插线。黄色表皮的是单模光缆，橙色（或浅绿色）的是多模光缆。</p><h3 id="SC-SC多模接插线"><a href="#SC-SC多模接插线" class="headerlink" title="SC-SC多模接插线"></a>SC-SC多模接插线</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.21.png"></p><h3 id="LC-LC单模接插线"><a href="#LC-LC单模接插线" class="headerlink" title="LC-LC单模接插线"></a>LC-LC单模接插线</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.22.png"></p><h3 id="ST-LC多模接插线"><a href="#ST-LC多模接插线" class="headerlink" title="ST-LC多模接插线"></a>ST-LC多模接插线</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.23.png"></p><h3 id="SC-ST单模接插线"><a href="#SC-ST单模接插线" class="headerlink" title="SC-ST单模接插线"></a>SC-ST单模接插线</h3><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN4.24.png"></p><p><strong>注意</strong>: 光缆在未使用时应该用一个小塑料盖保护起来。</p><h2 id="5-6、光纤与铜缆"><a href="#5-6、光纤与铜缆" class="headerlink" title="5.6、光纤与铜缆"></a>5.6、光纤与铜缆</h2><p>与铜缆相比，使用光缆有许多优点。表中显示了其中一些不同点。</p><p>目前，在大多数企业环境中，<strong>光纤主要用作数据分布层设备间的高流量点对点连接的主干布线。它也用于拥有多栋建筑物的校园建筑物互连。</strong>光缆不会导电且信号丢失率低，因此非常适合这些场合应用。</p><h3 id="UTP-and-Fiber-Optic-Cabling-Comparison"><a href="#UTP-and-Fiber-Optic-Cabling-Comparison" class="headerlink" title="UTP and Fiber-Optic Cabling Comparison"></a>UTP and Fiber-Optic Cabling Comparison</h3><table><thead><tr><th align="left"><strong>实施问题</strong></th><th align="left"><strong>UTP 布线</strong></th><th align="left"><strong>光纤布线</strong></th></tr></thead><tbody><tr><td align="left">支持的带宽</td><td align="left">10 Mb/s - 10 Gb/s</td><td align="left">10 Mb/s - 100 Gb/s</td></tr><tr><td align="left">距离</td><td align="left">相对较短（1 至 100 米）</td><td align="left">相对较长（1 至 100,000 米）</td></tr><tr><td align="left">不易受到 EMI 和 RFI 干扰</td><td align="left">低</td><td align="left">高（完全不受影响）</td></tr><tr><td align="left">不易受电气危险的影响</td><td align="left">低</td><td align="left">高（完全不受影响）</td></tr><tr><td align="left">介质和连接器成本</td><td align="left">最低</td><td align="left">最高</td></tr><tr><td align="left">安装技能要求</td><td align="left">最低</td><td align="left">最高</td></tr><tr><td align="left">安全预防措施</td><td align="left">最低</td><td align="left">最高</td></tr></tbody></table><h1 id="6、无线介质"><a href="#6、无线介质" class="headerlink" title="6、无线介质"></a>6、无线介质</h1><h2 id="6-1、无线介质的属性"><a href="#6-1、无线介质的属性" class="headerlink" title="6.1、无线介质的属性"></a>6.1、无线介质的属性</h2><p>您可以使用平板电脑或智能手机来学习本课程。这是因为有了无线介质才变得可能，这是连接到网络物理层的第三种方式。</p><p><strong>无线介质使用无线电或微波频率来承载代表数据通信二进制数字的电磁信号。</strong></p><p>无线介质提供所有介质中最好的移动特性，而且启用无线的设备数量不断增加。<strong>无线现在是用户连接到家庭和企业网络的主要方式。</strong></p><p>以下是无线网络的一些局限性:</p><ul><li><strong>覆盖面积</strong> - 无线数据通信技术非常适合开放环境。但是，在楼宇和建筑物中使用的某些建筑材料以及当地地形将会限制它的有效覆盖。</li><li><strong>干扰</strong> - 无线电易受干扰，可能会受到家庭无绳电话、某些类型的荧光灯、微波炉和其他无线通信装置等常见设备的干扰。</li><li><strong>安全性</strong> - 无线通信覆盖无需进行介质的物理接线。因此，未获得网络访问授权的设备和用户可以访问传输。所以<strong>网络安全是无线网络管理的重要组成部分</strong>。</li><li><strong>共享介质</strong> - WLAN 以<strong>半双工模式</strong>运行，意味着一台设备一次只能发送或接收。无线介质由所有无线用户共享。许多用户同时访问WLAN会导致每个用户的带宽减少。</li></ul><p>虽然无线在桌面连接中逐渐普及，但<strong>铜缆和光纤仍是部署网络中间设备（如路由器和交换机）最常见的物理层介质。</strong></p><h2 id="6-2、无线介质的类型"><a href="#6-2、无线介质的类型" class="headerlink" title="6.2、无线介质的类型"></a>6.2、无线介质的类型</h2><p>无线数据通信的 IEEE 和电信行业标准包括<strong>数据链路层和物理层</strong>。在其中每个标准中，物理层规范适用的领域包括以下：</p><ul><li>数据到无线电信号编码</li><li>传输频率和功率</li><li>信号接收和解码要求</li><li>天线的设计和施工</li></ul><p>这些是无线标准：</p><ul><li><strong>Wi-Fi (IEEE 802.11)</strong> - 无线 LAN (WLAN) 技术，通常称为 Wi-Fi。WLAN 使用一种称为“载波侦听多路访问/冲突避免 (CSMA/CA)”的争用协议。无线 NIC 在传输数据之前必须先侦听，以确定无线信道是否空闲。如果其他无线设备正在传输，则 NIC 必须等待信道空闲。Wi-Fi 是 Wi-Fi 联盟的标记。Wi-Fi 与基于 IEEE 802.11 标准的认证 WLAN 设备结合使用。</li><li><strong>蓝牙 (IEEE 802.15)</strong> - 这是一个无线个人局域网 (WPAN) 标准，通常称为 “蓝牙”。它采用设备配对过程进行通信，距离为 1 到 100 米。</li><li><strong>WiMAX (IEEE 802:16)</strong> - 通常称为微波接入全球互通 (WiMAX)，这个无线标准采用点到多点拓扑结构，提供无线带宽接入。</li><li><strong>Zigbee (IEEE 802.15.4)</strong> - Zigbee是一种用于低数据速率、低功耗通信的规范。它适用于需要短距离、低数据速率和长电池寿命的应用。<strong>Zigbee 通常用于工业和物联网 (IoT) 环境，如无线照明开关和医疗设备数据采集</strong></li></ul><p><strong>注意</strong>: 其他无线技术，例如移动电话和卫星通信，也可以提供数据网络连接。但是，这些无线技术不属于本模块的范围。</p><h2 id="6-3、无线LAN"><a href="#6-3、无线LAN" class="headerlink" title="6.3、无线LAN"></a>6.3、无线LAN</h2><p>常见的无线数据实施方式是使设备通过LAN以无线方式连接。通常，WLAN 要求具备下列网络设备：</p><ul><li><strong>无线接入点 (AP)</strong> - 集中用户的无线信号，并连接到现有基于铜介质的网络基础设施，如以太网。如家庭和小型企业无线路由器将路由器、交换机和接入点的功能整合到了一起。</li><li><strong>无线网卡适配器</strong> - 能够为每台网络主机提供无线通信。</li></ul><p>随着技术的发展，许多以太网 WLAN 标准应运而生。在购买无线设备时，必须确保它的<strong>兼容性和互操作性</strong>。</p><p>无线数据通信技术的益处是显而易见的，尤其是节省了昂贵的房屋布线，而且方便主机移动。网络管理员必须制定和应用严格的安全策略和流程保护WLAN，防止网络遭受不速之客的访问和破坏。</p><h1 id="单元测验"><a href="#单元测验" class="headerlink" title="单元测验"></a>单元测验</h1><p>网络管理员正在排查服务器上的连接问题。使用测试仪，管理员注意到服务器网卡生成的信号失真并且无法使用。错误被分类在OSI模型的<strong>物理层</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（三）</title>
      <link href="/2021/102912629.html"/>
      <url>/2021/102912629.html</url>
      
        <content type="html"><![CDATA[<h1 id="三、协议和模型"><a href="#三、协议和模型" class="headerlink" title="三、协议和模型"></a>三、协议和模型</h1><p>说明网络协议如何能让设备访问本地和远程网络资源</p><table><thead><tr><th align="left"><strong>主题标题</strong></th><th align="left"><strong>主题目标</strong></th></tr></thead><tbody><tr><td align="left"><strong>规则</strong></td><td align="left">描述确保成功通信所需的规则 类型。</td></tr><tr><td align="left"><strong>协议</strong></td><td align="left">说明为什么协议对网络通信不可或缺。</td></tr><tr><td align="left"><strong>协议簇</strong></td><td align="left">说明遵守协议簇的意义所在。</td></tr><tr><td align="left"><strong>标准组织</strong></td><td align="left">阐述标准组织在建立网络互通协议方面 发挥的作用。</td></tr><tr><td align="left"><strong>参考模型</strong></td><td align="left">阐述 TCP/IP 模型和 OSI 模型如何帮助促进 通信过程的标准化。</td></tr><tr><td align="left"><strong>数据封装</strong></td><td align="left">说明数据封装如何实现跨网络数据 传输。</td></tr><tr><td align="left"><strong>数据访问</strong></td><td align="left">说明本地主机如何访问本地网络中的资源。</td></tr></tbody></table><h1 id="1、规则"><a href="#1、规则" class="headerlink" title="1、规则"></a>1、规则</h1><h2 id="1-1、视频-气泡中的设备"><a href="#1-1、视频-气泡中的设备" class="headerlink" title="1.1、视频-气泡中的设备"></a>1.1、视频-气泡中的设备</h2><p>略</p><h2 id="1-2、通信基础知识"><a href="#1-2、通信基础知识" class="headerlink" title="1.2、通信基础知识"></a>1.2、通信基础知识</h2><p>人们使用许多不同的通信方式来交流观点。然而，所有通信方法都有以下三个共同要素：</p><ul><li><p><strong>消息源(发送方)</strong> 消息源是需要向其他人或设备发送消息的人或电子设备。</p></li><li><p><strong>消息目的地(接收方)</strong> 目的地接收并解释消息。</p></li><li><p><strong>信道</strong> 这由为消息从源传送到目的地提供路径的介质组成。</p></li></ul><h2 id="1-3、通信协议"><a href="#1-3、通信协议" class="headerlink" title="1.3、通信协议"></a>1.3、通信协议</h2><p>无论是面对面通信还是通过网络通信，消息的发送都是由被称为协议的规则来管理的。不同类型的通信方式，会有不同的特定协议。在日常的个人通信中，通过一种介质（如电话）通信时采用的规则不一定与使用另一种介质（如邮寄信件）时的规则相同。</p><p><strong>消息源-&gt;发送方-&gt;传输介质-&gt;接收方-&gt;消息目的地</strong></p><h2 id="1-4、规则建立"><a href="#1-4、规则建立" class="headerlink" title="1.4、规则建立"></a>1.4、规则建立</h2><p>在彼此通信之前，个人必须使用既定规则或协议来管理会话。</p><p>协议必须考虑到以下要求，才能成功地传递被接收者理解的消息:</p><ul><li>标识出发送方和接收方</li><li>通用语言和语法</li><li>传递的速度和时间</li><li>证实或确认要求</li></ul><h2 id="1-5、网络协议要求"><a href="#1-5、网络协议要求" class="headerlink" title="1.5、网络协议要求"></a>1.5、网络协议要求</h2><p>网络通信中使用的协议共享许多基本特质。除了识别源和目的地之外，计算机和网络协议还定义了消息在网络中如何传输的细节。</p><p>常用的计算机协议包含以下要求：</p><ul><li>消息编码</li><li>消息格式和封装</li><li>消息大小</li><li>消息时序</li><li>消息传输选项</li></ul><h2 id="1-6、消息编码"><a href="#1-6、消息编码" class="headerlink" title="1.6、消息编码"></a>1.6、消息编码</h2><p>在发送消息时，首先执行的步骤之一是编码。</p><p>编码是将信息转换为另一种广为接受的形式的过程，目的是为了便于传输信息。</p><p>解码是编码的逆向过程，用来解释信息。</p><p>消息来源-&gt;编码器-&gt;发送方-&gt;传输介质“信道”-&gt;接送方-&gt;解码器-&gt;消息目的地</p><h2 id="1-7、消息格式和封装"><a href="#1-7、消息格式和封装" class="headerlink" title="1.7、消息格式和封装"></a>1.7、消息格式和封装</h2><p>当消息从源发送到目的地时，必须使用特定的格式或结构，以便传递和处理。</p><p>正确标识消息的来源及其目的地是格式化过程的一部分</p><p>消息格式取决于<strong>消息的类型</strong>和<strong>传递信道</strong>。</p><p>互联网协议 (IP)是一种具有与信封示例类似功能的协议。在图中，互联网协议版本 6 (IPv6) 数据包的字段标识数据包的来源及其目的地。IP 负责通过一个或多个网络将消息从消息源发送到目的地。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.1.png"></p><h2 id="1-8、消息大小"><a href="#1-8、消息大小" class="headerlink" title="1.8、消息大小"></a>1.8、消息大小</h2><p>主机之间的编码必须采用适合介质的格式。通过网络发送的消息先由发送主机转换成<strong>位</strong>。根据用来传输的网络介质，将每个位编码成声音、光波或电子脉冲等信号形式。目的主机接收并解码信号，解释收到的消息。</p><h2 id="1-9、消息时序"><a href="#1-9、消息时序" class="headerlink" title="1.9、消息时序"></a>1.9、消息时序</h2><ul><li><strong>流量控制-</strong> 这是管理数据传输速率的过程。流量控制定义了可以发送多少信息以及传递信息的速率。例如，如果一个人讲话太快，对方就难以听清和理解。在网络通信中，源设备和目的设备使用网络协议来协商和管理信息流。</li><li><strong>响应超时</strong> -如果一个人提问之后在合理的时间内没有得到回答，就会认为没有获得回答并作出相应的反应。此人可能会重复这个问题，也可能继续谈话。网络上的主机会使用网络协议来指定等待响应的时长，以及在响应超时的情况下执行什么操作。</li><li><strong>访问方法</strong> -这决定人们可以发送消息的时间。当设备想要在无线局域网上传输时，有必要使用 WLAN 网络接口卡 (NIC) 来确定无线介质是否可用。</li></ul><h2 id="1-10、消息传输方式"><a href="#1-10、消息传输方式" class="headerlink" title="1.10、消息传输方式"></a>1.10、消息传输方式</h2><p>网络通信有三种类型的数据通信传输方式</p><ul><li><strong>单播</strong> - 信息正在传输到单个终端设备。</li><li><strong>组播</strong> - 信息正在传输到一个或多个终端设备。</li><li><strong>广播</strong> - 信息正在传输到所有终端设备。</li></ul><h2 id="1-11、关于节点图标的注释"><a href="#1-11、关于节点图标的注释" class="headerlink" title="1.11、关于节点图标的注释"></a>1.11、关于节点图标的注释</h2><p>网络文档和拓扑通常使用节点图标表示网络和终端设备，节点通常表示为一个圆。</p><p>该图显示了使用节点图标代替计算机图标的三种不同传输方式的比较。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.2.png"></p><h1 id="2、协议"><a href="#2、协议" class="headerlink" title="2、协议"></a>2、协议</h1><h2 id="2-1、网络协议概述"><a href="#2-1、网络协议概述" class="headerlink" title="2.1、网络协议概述"></a>2.1、网络协议概述</h2><p>网络协议定义了用于设备之间交换消息的通用格式和规则集。</p><p>协议由软件、硬件或两者中的终端设备和中间设备实现。</p><p>每个网络协议都有自己的功能、格式和通信规则。</p><table><thead><tr><th align="left"><strong>协议类型</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>网络通信协议</strong></td><td align="left">这类协议使两个或多个设备能够在一个或多个 网络上通信。以太网技术家族涉及多种协议， 例如IP，<strong>传输控制协议</strong>（<strong>TCP</strong>，Transmission Control Protocol）， <strong>超文本传输协议</strong>（<strong>HTTP</strong>，HyperText Transfer Protocol）等。</td></tr><tr><td align="left"><strong>网络安全协议</strong></td><td align="left">这类协议保护数据以提供身份验证、数据完整性和 数据加密。安全协议的示例包括<strong>安全外壳协议</strong> <strong>(SSH</strong>，Secure Shell)、<strong>安全套接字层协议</strong> (<strong>SSL</strong>，Secure Sockets Layer) 和<strong>传输层安全协议</strong> (<strong>TLS</strong>，Transport Layer Security)。</td></tr><tr><td align="left"><strong>路由协议</strong></td><td align="left">这类协议使路由器能够交换路由信息，比较路径 信息，然后选择到达目标网络的 最佳路径。路由协议的示例包括<strong>开放最短路径优先协议</strong> (<strong>OSPF</strong>，Open Shortest Path First)和<strong>边界网关协议</strong> (<strong>BGP</strong>，Border Gateway Protocol)。</td></tr><tr><td align="left"><strong>服务发现协议。</strong></td><td align="left">这类协议用于设备或服务的自动检测。 服务发现协议的示例包括发现用于IP地址分配 服务的<strong>动态主机配置协议</strong>（<strong>DHCP</strong>，Dynamic Host Configuration Protocol）， 和用于执行域名到IP地址转换的 <strong>域名系统</strong>（<strong>DNS</strong>，Domain Name System）。</td></tr></tbody></table><h2 id="2-2、网络协议的功能"><a href="#2-2、网络协议的功能" class="headerlink" title="2.2、网络协议的功能"></a>2.2、网络协议的功能</h2><p>网络通信协议负责在终端设备之间进行网络通信所需的各种功能。</p><p>计算机和网络设备使用商定的协议进行通信。下表列出了这些协议的功能。</p><table><thead><tr><th align="left"><strong>功能</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>编址</strong></td><td align="left">这使用已定义的编址方案来标识消息的发送者 和预期的接收者。提供编址的协议示例 包括以太网，IPv4和IPv6。</td></tr><tr><td align="left"><strong>可靠性</strong></td><td align="left">此功能提供了有保证的传输机制， 以防消息在传输过程中丢失或损坏。TCP 提供可靠的传输。</td></tr><tr><td align="left"><strong>流量控制</strong></td><td align="left">此功能可确保数据在两个通信设备之间 高效传输。TCP 提供流量控制服务。</td></tr><tr><td align="left"><strong>排序</strong></td><td align="left">此功能唯一地标记每个传输的数据段。接收设备 使用排序信息正确地 重组信息。如果数据段丢失，延迟或未按顺序接收， 这将很有用。TCP 提供排序服务。</td></tr><tr><td align="left"><strong>差错检测</strong></td><td align="left">此功能用于确定传输过程中数据 是否已损坏。提供差错检测的各种协议包括 以太网，IPv4，IPv6和TCP。</td></tr><tr><td align="left"><strong>应用接口</strong></td><td align="left">此功能包含用于网络应用程序之间的进程间 通信的信息。例如，访问网页时， 使用HTTP或HTTPS协议在客户端和服务器Web进程 之间进行通信。</td></tr></tbody></table><h2 id="2-3、协议交互"><a href="#2-3、协议交互" class="headerlink" title="2.3、协议交互"></a>2.3、协议交互</h2><p>通过计算机网络发送的消息通常需要使用多种协议，每种协议都有自己的功能和格式。</p><ul><li><strong>超文本传输协议(HTTP)</strong>-该协议控制Web服务器和Web客户端进行交互的方式。HTTP定义了客户端和服务器之间的请求和响应的内容和格式。客户端·软件和Web服务器软件都将HTTP作为应用程序的一部分来实现。HTTP依靠其他协议来控制客户端和服务器之间传输消息的方式。</li><li><strong>传输控制协议(TCP)</strong>-此协议管理各个会话。TCP负责保证信息的可靠传输和管理终端设备之间的流量控制。</li><li><strong>互联网协议(IP)</strong>-此协议负责将消息从发送方传输给接收方。路由器使用IP来跨多个网络转发消息。</li><li><strong>以太网</strong>-此协议负责将消息从一个NIC（Network Interface Card，网卡/网络适配器）传输到同一个以太网局域网(LAN)上的另一个NIC。</li></ul><h1 id="3、协议簇"><a href="#3、协议簇" class="headerlink" title="3、协议簇"></a>3、协议簇</h1><h2 id="3-1、网络协议簇"><a href="#3-1、网络协议簇" class="headerlink" title="3.1、网络协议簇"></a>3.1、网络协议簇</h2><p>在许多情况下，协议必须能够与其他协议配合使用，以便让在线体验为您提供网络通信所需的一切。</p><p>执行某种通信功能所需的一组内在相关协议称为协议簇。</p><p>要形象地表现协议簇中的协议如何互动，最佳方法之一就是将这种互动看成一个堆栈。协议栈展示了协议簇中的单个协议是如何实施的。协议显示为分层结构，每种上层服务都依赖于其余下层协议所定义的功能。协议栈的下层负责通过网络传输数据和向上层提供服务，而上层则负责处理发送的消息内容。</p><p>如图所示，我们可以使用分层结构来描述面对面通信中出现的活动。底层是物理层，有两个人用声音大声说出词语。中间是规则层，规定了通信的要求，包括必须选择一种通用语言。顶部是内容层，这是实际说出通信内容的地方。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.3.png"></p><p>协议簇是共同作用、帮助某个问题的规则集。</p><h2 id="3-2、协议簇的演变"><a href="#3-2、协议簇的演变" class="headerlink" title="3.2、协议簇的演变"></a>3.2、协议簇的演变</h2><p>协议簇是提供全面的网络通信服务的一组协议。</p><p>在网络通信和互联网的发展过程中，出现了几个相互竞争的协议簇，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.4.png"></p><p><strong>互联网协议簇或TCP/IP</strong>-这是目前使用的最常见和最相关的协议簇。TCP/IP协议簇是由互联网工程任务组（IETF）维护的开放标准协议簇。</p><p><strong>开放系统互连（OSI，Open System Interconnection）协议</strong>-这是1997年由国际标准化组织（ISO）和国际电信联盟（ITU）联合开发的一系列协议。OSI协议还包括了一个被称为OSI参考模型的七层模型。OSI参考模型对其协议的功能进行分类。如今，OSI主要以其分层模型而闻名。OSI协议在很大程度上已经被TCP/IP所取代。</p><p><strong>Apple Talk</strong> - 一个由苹果公司于1985年为苹果设备发布的短期专有协议簇。1995年，苹果公司采用TCP/IP技术取代了AppleTalk。</p><p><strong>Novell NetWare</strong> - 一种短暂的专有协议套件和网络操作系统，由诺维尔公司在1983年使用IPX网络协议开发。1995年，Novell采用TCP/IP取代了IPX。</p><h2 id="3-3、TCP-IP协议示例"><a href="#3-3、TCP-IP协议示例" class="headerlink" title="3.3、TCP/IP协议示例"></a>3.3、TCP/IP协议示例</h2><p>TCP/IP协议可用于应用层、传输层和互联网层。网络接入层中没有 TCP/IP 协议。最常见的网络接入层LAN协议是以太网和WLAN(无线LAN)协议。网络接入层协议负责通过物理介质传输 IP 数据包。</p><p>图中显示了用于在主机的web浏览器和web服务器之间发送数据包的三种TCP/IP协议的示例。HTTP、TCP 和 IP 是所使用的 TCP/IP 协议。在网络接入层，示例中使用了以太网。然而，这里也可以使用一种无线标准，如WLAN或蜂窝服务。</p><p>该图显示了用于在主机的web浏览器和web服务器之间发送数据包的TCP/IP协议。网络拓扑显示了一个连接到互联网云的主机和一个连接到Web服务器的主机。所显示的表示数据包的信封在互联网和服务器之间正在流动。从数据包辐射出的是每一层使用的协议的信息。自上而下是:应用层和超文本传输协议(HTTP);传输层和传输控制协议(TCP);互联网层和互联网协议(IP);以及网络接口层和以太网。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.5.png"></p><h2 id="3-4、TCP-IP协议簇"><a href="#3-4、TCP-IP协议簇" class="headerlink" title="3.4、TCP/IP协议簇"></a>3.4、TCP/IP协议簇</h2><p>如今，TCP/IP 协议簇包含许多协议，并且不断发展以支持新服务。图中显示一些较为常用的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.6.png"></p><p>TCP/IP是当今互联网和网络使用的协议簇。TCP/IP对于供应商和制造商来说有两个重要的方面：</p><ul><li><strong>开放标准协议簇</strong>-这意味着它对公众是免费的，任何供应商都可以在他们的硬件和软件中使用它。</li><li><strong>基于标准的协议簇</strong>-这意味着它已经受到网络行业认可并已获得标准组织的批准。这确保了来自不同制造商的产品能够成功地互操作。</li></ul><h3 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h3><p><strong>域名系统</strong></p><ul><li><strong>DNS</strong> - 域名系统（Domain Name System）。将域名（例如 cisco.com）转换为 IP 地址。</li></ul><p><strong>主机配置</strong></p><ul><li><strong>DHCPv4</strong> - IPv4动态主机配置协议（Dynamic Host Configuration Protocol  version four）。DHCPv4 服务器在启动时动态地将 IPv4 编址信息分配给 DHCPv4 客户端，并允许在不再需要时重新使用这些地址。</li><li><strong>DHCPv6</strong> - IPv6动态主机配置协议（Dynamic Host Configuration Protocol  version six）。DHCPv6类似于DHCPv4。DHCPv6服务器在启动时动态地将IPv6编址信息分配给DHCPv6客户端。</li><li><strong>SLAAC</strong> - 无状态地址自动配置（Stateless Auto Address Configuration）。一种允许设备在不使用DHCPv6服务器的情况下获得其IPv6编址信息的方法。</li></ul><p><strong>邮件</strong></p><ul><li><strong>SMTP</strong> - 简单邮件传输协议（Simple Mail Transfer Protocol）。使客户端能够将邮件发送到邮件服务器，并使服务器能够将邮件发送到其他服务器。</li><li><strong>POP3</strong> - 邮局协议第 3 版（Post Office Protocol 3）。使客户端能够从邮件服务器检索电子邮件并将电子邮件下载到客户端本地邮件应用程序。</li><li><strong>IMAP</strong> - 互联网消息访问协议（Internet Mail Access Protocol）。使客户端能够访问存储在邮件服务器上的电子邮件，并在服务器上维护电子邮件。</li></ul><p><strong>文件传输</strong></p><ul><li><strong>FTP</strong> - 文件传输协议（File Transfer Protocol）。它设置规则，使得一台主机上的用户能够通过网络访问另一台主机或向其传输文件。FTP是一种可靠、面向连接且进行确认的文件传输协议。</li><li><strong>SFTP</strong> - SSH文件传输协议（Secure File Transfer Protocol）。作为安全外壳 (SSH)协议的扩展，SFTP可用于建立安全的文件传输会话，在该会话中对文件传输进行加密。SSH 是一种安全远程登录的方法，通常用于访问设备的命令行。</li><li><strong>TFTP</strong> - 简单文件传输协议（Trivial File Transfer Protocol）。这是一个简单的，无连接的文件传输协议，使用尽最大努力、无需确认的文件传输方式。它使用的开销比FTP少。</li></ul><p><strong>Web和Web服务</strong></p><ul><li><strong>HTTP</strong> - 超文本传输协议（HyperText Transfer Protocol）。这是有关在万维网上交换文本、图形图像、音频、视频以及其他多媒体文件的一组规则集。</li><li><strong>HTTPS</strong> - 安全 HTTP（Hyper Text Transfer Protocol over SecureSocket Layer）。这是一种安全的HTTP形式，它对在万维网上交换的数据进行加密。</li><li><strong>REST</strong> - 具象状态传输协议（Representational State Transfer）。它使用应用程序编程接口 (API) 和 HTTP 请求创建 Web 应用程序的 Web 服务。</li></ul><h3 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h3><p><strong>面向连接</strong></p><ul><li><strong>TCP</strong> - 传输控制协议（Transmission Control Protocol）。它使运行在不同主机上的进程之间能够进行可靠的通信，并提供可靠的、需要确认的传输，以确保传输成功。</li></ul><p><strong>无连接</strong></p><ul><li><strong>UDP</strong> - 用户数据报协议（User Datagram Protocol）。它允许一台主机上运行的进程向另一台主机上运行的进程发送数据包。但是，UDP不会确认数据报传输是否成功。</li></ul><h3 id="互联网层"><a href="#互联网层" class="headerlink" title="互联网层"></a>互联网层</h3><p><strong>Internet 协议</strong></p><ul><li><strong>IPv4</strong> - 互联网协议第 4 版（Internet Protocol version four)。它接收来自传输层的消息段，将消息打包成数据包，并为通过网络进行端到端传递的数据包进行地址分配。IPv4 使用 32 位地址。</li><li><strong>IPv6</strong> - 互联网协议第 6 版（Internet Protocol version six）。与 IPv4 类似，但使用 128 位地址。</li><li><strong>NAT</strong> - 网络地址转换（Network Address Translation）。将私有网络 IPv4 地址转换为全球唯一的公有 IPv4 地址。</li></ul><p><strong>消息传送</strong></p><ul><li><strong>ICMPv4</strong> - IPv4 互联网控制消息协议（ Internet Control Message Protocol version four) 。<strong>目的主机针对数据包传输中出现的错误，向源主机提供反馈。</strong></li><li><strong>ICMPv6</strong> - 用于 IPv6 的ICMP（ Internet Control Message Protocol version six) 。与 ICMPv4 类似的功能，但用于 IPv6 数据包。</li><li><strong>ICMPv6 ND</strong> - IPv6 邻居发现（ Internet Control Message Protocol version six  Neighbor Discovery) 。包括用于<strong>地址解析</strong>和<strong>重复地址检测</strong>的四个协议消息。</li></ul><p><strong>路由协议</strong></p><ul><li><strong>OSPF</strong> - 开放最短路径优先协议（Open Shortest Path First）。它使用基于区域的分层设计的链路状态路由协议。OSPF是一种开放式标准内部路由协议。</li><li><strong>EIGRP</strong> — 增强型内部网关路由协议（Enhanced Interior Gateway Routing Protocol）。这是一种思科开发的开放标准路由协议，使用基于带宽、延迟、负载和可靠性的复合度量。</li><li><strong>BGP</strong> - 边界网关协议（Border Gateway Protocol）。这是一种开放标准的外部网关路由协议，用于互联网服务提供商(ISP)之间。BGP 还通常用于 ISP 与其大型私有客户端之间来交换路由信息。</li></ul><h3 id="网络接入层"><a href="#网络接入层" class="headerlink" title="网络接入层"></a>网络接入层</h3><p>地址解析</p><ul><li><strong>ARP</strong> - 地址解析协议（Address Resolution Protocol）。提供 IPv4 地址与硬件地址之间的动态地址映射。</li></ul><p><strong>注意</strong>：您可能会看到其他文档状态，表明 ARP 在互联网层（OSI 第 3 层）运行。但是，在本课程中，我们声明 ARP 在网络接入层（OSI 第 2 层）运行，因为它的主要目的是发现目标的 MAC 地址。MAC 地址是第 2 层地址。</p><p>数据链路协议</p><ul><li><strong>以太网</strong> - 为网络接入层的布线和信令标准定义规则。</li><li><strong>WLAN</strong> - 无线局域网（wireless local-area-network）。定义 2.4 GHz 和 5 GHz 无线电频率的无线信号规则。</li></ul><h2 id="3-5、TCP-IP通信过程"><a href="#3-5、TCP-IP通信过程" class="headerlink" title="3.5、TCP/IP通信过程"></a>3.5、TCP/IP通信过程</h2><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.7.png"></p><p>1、数据逐层封装为（以太网（IP（TCP（数据））））</p><p>2、封装后的数据编码为二进制数</p><p>3、从Web服务器发送到Web客户端</p><p>4、客户端解码</p><p>5、解封装获得数据</p><h1 id="4、标准组织"><a href="#4、标准组织" class="headerlink" title="4、标准组织"></a>4、标准组织</h1><h2 id="4-1、开放标准"><a href="#4-1、开放标准" class="headerlink" title="4.1、开放标准"></a>4.1、开放标准</h2><p>尽管有许多不同的网络组件制造商，但他们都必须使用相同的标准。在网络中，标准是由国际标准组织制定的。</p><p>开放标准鼓励互操作性、竞争和创新。它们还能确保没有任何一家公司的产品能够垄断市场或占有不公平竞争优势。</p><p>标准组织通常是中立于厂商的非营利性组织。它的建立是为了发展和推广开放标准的概念。这些组织对维护一个开放的互联网，允许自由访问规范和协议并允许所有供应商实施这些规范和协议起着至关重要的作用。</p><p>标准组织可能会独立起草规则集，也可能在其他情况下将某个专有协议作为一个标准的基础。如果要使用专有协议，通常就会涉及到创建了该协议的供应商。</p><h2 id="4-2、互联网标准"><a href="#4-2、互联网标准" class="headerlink" title="4.2、互联网标准"></a>4.2、互联网标准</h2><p>各个组织在互联网和 TCP/IP 协议标准的推广和建立方面具有不同的责任。</p><p>该图显示了参与互联网开发和支持的标准组织。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.8.png"></p><ul><li><strong>Internet 协会 (ISOC)</strong> –（Internet Society） 负责在全世界推进互联网的开放式开发、发展和使用。</li><li><strong>互联网架构委员会 (IAB)</strong> - （Interactive Advertising Bureau）负责互联网标准的整体管理和发展。</li><li><strong>互联网工程任务组 (IETF)</strong> - （Internet Engineering Task Force）负责开发、更新和维护互联网和 TCP/IP 技术。包括用于开发新协议和更新现有协议的流程和文档，称为征求意见 (RFC) 文档。</li><li><strong>互联网研究任务组 (IRTF)</strong> - （Internet Research Task Force）负责互联网和 TCP/IP 协议相关的长期研究，包括反垃圾电子邮件研究组（Anti-Spam Research Group，ASRG）、密码技术研究组（Crypto Forum Research Group，CFRG）和对等网络研究组（Peer-to-Peer Research Group，P2PRG）等。</li></ul><p>该图显示了参与互联网开发和支持的标准组织，包括 IANA 和 ICANN。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.9.png"></p><ul><li><strong>互联网名称与数字地址分配机构 (ICANN)</strong> - 总部设在美国，ICANN负责协调 IP 地址分配、域名的管理和 TCP/IP 协议中使用的其他信息的分配。</li><li><strong>互联网编号指派机构 (IANA)</strong> - 负责监督和管理 ICANN 中的 IP 地址分配、域名管理和协议标识符。</li></ul><h2 id="4-3、电子和通信标准"><a href="#4-3、电子和通信标准" class="headerlink" title="4.3、电子和通信标准"></a>4.3、电子和通信标准</h2><p>其他标准组织有责任推广和建立电子与通信标准，这些标准用于通过有线或无线介质将 IP 数据包作为电子信号传输。</p><p>这些标准组织包括：</p><ul><li><strong>电气电子工程师协会</strong>**(<strong>IEEE</strong>，读作“I-triple-E”） –（Institute of Electrical and Electronics Engineers）是为致力于推动诸多行业领域的技术创新和标准创建的工程师设立的组织，涉及的领域包括电力与能源、医疗保健、电信和网络。重要的 IEEE 网络标准包括 802.3 以太网和 802.11 无线局域网标准。可在互联网上搜索其他 IEEE 网络标准。</li><li><strong>美国电子工业协会 (EIA)</strong>- 当时名为无线电制造商协会（Radio Manufacturers’ Association：RMA），该组织因其在用于<strong>安装网络设备的电线、连接器和 19 英寸机架方面</strong>的标准而知名。</li><li><strong>电信工业协会 (TIA)</strong>- 该组织负责开发各种领域的通信标准，包括无线电设备、手机信号塔、IP 语音 (VoIP) 设备和卫星通信等。</li><li><strong>国际电信联盟电信标准局 (ITU-T)</strong> - （Telecommunication Standardization Sector of the International Telecommunications Union）是最大最早的通信标准组织之一。ITU-T 定义视频压缩、Internet 协议电视 (IPTV) 和宽带通信的标准，例如数字用户线路 (DSL)。</li></ul><h2 id="4-4、实验-研究网络标准"><a href="#4-4、实验-研究网络标准" class="headerlink" title="4.4、实验-研究网络标准"></a>4.4、实验-研究网络标准</h2><p>略</p><h1 id="5、参考模型"><a href="#5、参考模型" class="headerlink" title="5、参考模型"></a>5、参考模型</h1><h2 id="5-1、使用分层模型的优点"><a href="#5-1、使用分层模型的优点" class="headerlink" title="5.1、使用分层模型的优点"></a>5.1、使用分层模型的优点</h2><p>诸如网络运行方式之类的复杂概念可能很难解释和理解。因此，可以使用分层模型将网络的运行模块化为可管理的层。</p><p>这些是使用分层模型来描述网络协议及其工作方式的优点：</p><ul><li>有助于协议设计，因为对于在特定层工作的协议而言，它们的工作方式及其与上下层之间的接口都已经确定。</li><li>促进竞争，因为可以同时使用不同厂商的产品。 </li><li>避免一个协议层的技术或功能变化影响相邻的其他层。 </li><li>提供了描述网络功能和能力的通用语言。</li></ul><p>如图所示，有两个分层模型用于描述网络运行：</p><p>开放式系统互联(OSI)参考模型 TCP/IP 参考模型</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.10.png"></p><h2 id="5-2、OSI参考模型"><a href="#5-2、OSI参考模型" class="headerlink" title="5.2、OSI参考模型"></a>5.2、OSI参考模型</h2><p>OSI 参考模型详细罗列了每一层可以实现的功能和服务。 这种类型的模型通过描述特定层必须完成什么但不规定如何完成来保持各类网络协议和服务中的一致性。</p><p>它还描述了各层与其上、下层之间的交互。本课程中所讨论的 TCP/IP 协议同时围绕 OSI 和 TCP/IP 模型而构造。下表显示了OSI模型每一层的详细信息。在本课程中，随着我们对协议更加详细的讨论，各层的功能和层与层之间的关系将变得更加明显。</p><table><thead><tr><th align="left"><strong>OSI 模型层</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>7 - 应用层</strong></td><td align="left">应用层包含用于进程间通信 的协议。</td></tr><tr><td align="left"><strong>6 - 表示层</strong></td><td align="left">表示层用常用方式表示数据 在应用层服务之间的传输。</td></tr><tr><td align="left"><strong>5 - 会话层</strong></td><td align="left">会话层向表示层提供服务，组织对话并 管理数据交换。</td></tr><tr><td align="left"><strong>4 - 传输层</strong></td><td align="left">传输层定义服务以对数据进行分段，传输和 重组，以进行终端设备之间的单独 通信。</td></tr><tr><td align="left"><strong>3 - 网络层</strong></td><td align="left">网络层为所标识的终端设备之间通过网络 交换独立的数据的片段提供服务。</td></tr><tr><td align="left"><strong>2 - 数据链路层</strong></td><td align="left">数据链路层协议描述了设备之间通过 公共介质交换数据帧的方法。</td></tr><tr><td align="left"><strong>1 - 物理层</strong></td><td align="left">物理层协议描述了机械的、电气的、功能的 和程序化的方法，以激活，维护和解除物理连接， 实现与网络设备之间的位 设备。</td></tr></tbody></table><p><strong>注意</strong>: 我们提及 TCP/IP 模型的各层时只使用其名称，而提及 OSI 模型的七个层时则通常使用编号而非名称。例如，物理层指 OSI 模型的第 1 层，数据链路层指第2层，诸如此类。</p><h2 id="5-3、TCP-IP协议模型"><a href="#5-3、TCP-IP协议模型" class="headerlink" title="5.3、TCP/IP协议模型"></a>5.3、TCP/IP协议模型</h2><p>用于网际通信的 TCP/IP 协议模型建立于二十世纪七十年代早期，有时称为互联网模型。 这种类型的模型与特定的协议簇结构紧密配合。</p><p>TCP/IP 模型描述了 TCP/IP 协议簇中每个协议层实现的功能，因此属于协议模型。TCP/IP 也用作参考模型。下表显示了TCP/IP模型每一层的详细信息。</p><table><thead><tr><th align="left"><strong>TCP/IP 模型层</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>4 - 应用层</strong></td><td align="left">向用户提供数据，以及编码和对话控制。</td></tr><tr><td align="left"><strong>3 - 传输层</strong></td><td align="left">支持各种设备之间通过不同网络通信。</td></tr><tr><td align="left"><strong>2 - 互联网层</strong></td><td align="left">确定通过网络的最佳路径。</td></tr><tr><td align="left"><strong>1 - 网络接入层</strong></td><td align="left">控制组成网络的硬件设备和介质。</td></tr></tbody></table><p>标准的定义和 TCP/IP 协议都在公开的论坛中讨论，并在向公众开放的 IETF RFC 集中加以定义。RFC 由网络工程师撰写，并发送给其他 IETF 成员征求意见。</p><h2 id="5-4、OSI模型与TCP-IP模型的比较"><a href="#5-4、OSI模型与TCP-IP模型的比较" class="headerlink" title="5.4、OSI模型与TCP/IP模型的比较"></a>5.4、OSI模型与TCP/IP模型的比较</h2><p>还可以根据 OSI 参考模型描述构成 TCP/IP 协议簇的协议。在 OSI 模型中，TCP/IP 模型的网络接入层和应用层被进一步划分，用于描述这些协议层需要实现的不同功能。</p><p>TCP/IP 协议簇在网络接入层并没有指定通过物理介质传输时使用的协议，而只是描述了从互联网层到物理网络协议的传递。而 OSI 模型第 1 层和第 2 层则论述了接入介质所需的步骤以及通过网络发送数据的物理手段。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.11.png"></p><p>主要相似性在于传输层和网络层；然而，这两种模型在与每层的上下层的相关方式上不同：</p><ul><li>OSI 模型第 3 层是网络层，与 TCP/IP 的互联网层形成直接映射。该层用于描述通过网际网络编址并路由消息的协议。</li><li>OSI 模型第 4 层是传输层，与 TCP/IP 的传输层形成直接映射。该层描述了可以在源主机和目的主机之间提供有序可靠的数据传输的常用服务和功能。</li><li>TCP/IP 应用层包括几个协议，为各种最终用户应用程序提供特定功能。OSI 模型第 5 层、第 6 层和第 7 层供应用程序软件开发人员和厂商参考，用于生产需要在网络上运行的应用程序。</li><li>当涉及各层的协议时，TCP/IP 和 OSI 模型都很常用。由于 OSI 模型将数据链路层与物理层区分开来，当涉及这些较低层时通常使用这种模型。</li></ul><h2 id="5-5、Packet-Tracer-调查运行中的-TCP-IP-和-OSI-模型"><a href="#5-5、Packet-Tracer-调查运行中的-TCP-IP-和-OSI-模型" class="headerlink" title="5.5、Packet Tracer - 调查运行中的 TCP/IP 和 OSI 模型"></a>5.5、Packet Tracer - 调查运行中的 TCP/IP 和 OSI 模型</h2><p>数据在网络中传递时，将被分割成较小片段并进行标识，以便在数据到达目的地时重新组合这些片段。每个片段会被指定一个特定名称，并将其与 TCP/IP 和 OSI 模型中的特定层相关联。这个指定的名称称为**协议数据单元 (PDU)**。</p><h1 id="6、数据封装"><a href="#6、数据封装" class="headerlink" title="6、数据封装"></a>6、数据封装</h1><h2 id="6-1、对消息分段"><a href="#6-1、对消息分段" class="headerlink" title="6.1、对消息分段"></a>6.1、对消息分段</h2><p>理论上来说，可以将一次通信的内容（如音乐视频或有很多很大的附件的电子邮件）作为一大块连续的高容量比特流，通过网络从源发送到目的地。但是，这会给其他需要使用相同通信通道或链路的设备带来问题。这种大型数据流会导致严重的延迟。而且，一旦互联网络基础架构中的任何链路在传输期间出现故障，那么整个消息都会丢失，必须全部重传。</p><p>所以，更好的办法是先将数据划分为更小、更易于管理的片段，然后再通过网络发送。分段是将数据流划分成更小的单元，以便在通过网络传输的过程。分段是必要的，因为数据网络使用TCP/IP协议簇以单独的IP数据包发送数据。每个数据包都是单独发出的，类似于把一封长信作为一系列独立的明信片寄出。包含同一目的地数据段的数据包可以通过不同的路径发送。</p><p>这导致消息分段有两个主要好处:</p><ul><li><strong>提高速度</strong> - 由于将大数据流分段成为数据包，因此可以在不独占通信链路的情况下，通过网络发送大量数据。这允许许多不同的会话在称为多路复用的网络上交错。</li><li><strong>提高效率</strong> - 如果单个数据段由于网络故障或网络拥塞而无法到达其目的地，则只需要重新传输该段，而不需要重新发送整个数据流。</li></ul><h2 id="6-2、排序"><a href="#6-2、排序" class="headerlink" title="6.2、排序"></a>6.2、排序</h2><p>使用分段和多路复用在网络上传输消息要面临的挑战是增加了该过程的复杂程度。试想一下，这就如同您要邮寄一封 100 页的信件，但每个信封里只能装一页纸。因此，将需要100个信封，每一个信封都需要分别写好地址。100个不同的信封装着的100页的信有可能顺序是混乱的。因此，信封中的信息需要包含一个序列号，以确保接收者可以按适当的顺序重新组装页面。</p><p>在网络通信中，每个消息段也必须经过类似的过程才能确保其到达正确目的设备并重新组装成原始消息的内容，TCP 负责对单独的数据段进行排序。</p><h2 id="6-3、协议数据单元"><a href="#6-3、协议数据单元" class="headerlink" title="6.3、协议数据单元"></a>6.3、协议数据单元</h2><p>在通过网络介质传输应用程序数据的过程中，随着数据沿协议栈向下传递，每层都要添加各种协议信息。此过程称为<strong>封装</strong>。</p><p><strong>注意</strong>: 虽然UDP PDU被称为数据报，但IP数据包有时也被称为IP数据报。</p><p>一段数据在任意协议层的表示形式称为协议数据单元 (PDU)。在封装过程中，后续的每一层都根据使用的协议封装其从上一层接收的 PDU。在该过程的每个阶段，PDU 都以不同的名称来反映其新功能。尽管目前对 PDU 的命名没有通用约定，但本课程中根据 TCP/IP 协议簇的协议来命名 PDU。图中显示了每种形式数据的 PDU。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.12.png"></p><ul><li>数据 - 一般术语，泛指应用层使用的 PDU</li><li>段 - 传输层 PDU</li><li>数据包 - 网络层 PDU</li><li>帧 - 数据链路层 PDU</li><li>位 - 通过介质实际传输数据时使用的物理层 PDU</li></ul><p><strong>注意</strong>：如果传输报头是TCP，那么它是一个数据段。如果传输报头是 UDP，那么它是一个数据报。</p><h2 id="6-4、封装示例"><a href="#6-4、封装示例" class="headerlink" title="6.4、封装示例"></a>6.4、封装示例</h2><p>在网络中发送消息时，封装过程自上而下工作。在各层，上层信息被视为封装协议内的数据。例如，TCP 分段被视为 IP 数据包内的数据。</p><p>封装示例见3.5</p><h2 id="6-5、解封示例"><a href="#6-5、解封示例" class="headerlink" title="6.5、解封示例"></a>6.5、解封示例</h2><p>接收主机上的过程与之相反，称为“解封”。解封是接收设备用来删除一个或多个协议报头的过程。数据在朝着最终用户应用程序沿协议栈向上移动的过程中被解封。</p><p>解封示例见3.5</p><h1 id="7、数据访问"><a href="#7、数据访问" class="headerlink" title="7、数据访问"></a>7、数据访问</h1><h2 id="7-1、地址"><a href="#7-1、地址" class="headerlink" title="7.1、地址"></a>7.1、地址</h2><p>正如您刚刚了解到的，在网络中对消息进行分段是必要的。但是，如果未正确编址这些分段的消息，它们将无处可去。本主题概述了网络地址。</p><p>网络层和数据链路层负责将数据从源设备传输到目的设备。</p><p>如图所示，两层中的协议都包含源地址和目的地址，但它们的地址具有不同的用途。</p><ul><li>网络层源地址和目的地址 - 负责将 IP 数据包从原始源设备传输到可能处于同一网络或远程网络中的最终目的设备。</li><li>数据链路层源地址和目的地址 – 负责将数据链路帧从一个网络接口卡 (NIC) 传输到同一网络上的另一个 NIC。</li><li><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.13.png"></li></ul><h2 id="7-2、第三层逻辑地址"><a href="#7-2、第三层逻辑地址" class="headerlink" title="7.2、第三层逻辑地址"></a>7.2、第三层逻辑地址</h2><p>IP 地址是网络层（或第 3 层）逻辑地址，用于将 IP 数据包从原始源设备传输到最终目的设备，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.14.png"></p><p>IP 数据包包含两个 IP 地址：</p><ul><li><p>源 IP 地址 - 发送设备（数据包的始源设备）的 IP 地址。</p></li><li><p>目的 IP 地址 - 接收设备（数据包的最终目的设备）的 IP 地址。</p><p>IP 地址表示始源IP地址和最终目的IP地址。无论源和目的地在同一IP网络上还是在不同的IP网络上，都是如此。</p></li></ul><p>IP 地址包含两部分：</p><ul><li>网络部分(IPv4)或前缀(IPv6) – 地址最左边的部分，表示 IP 地址是哪个网络的成员。同一网络中所有设备的地址都有相同的网络部分。</li><li>主机部分(IPv4)或接口ID(IPv6) - 地址的其余部分，用于识别网络上的特定设备。这部分对于网络中的每个设备或接口都是唯一的。</li></ul><p><strong>注意</strong>: 子网掩码(IPv4)或前缀长度(IPv6)用于将IP地址的网络部分与主机部分区分开来。</p><h2 id="7-3、同一网络中的设备"><a href="#7-3、同一网络中的设备" class="headerlink" title="7.3、同一网络中的设备"></a>7.3、同一网络中的设备</h2><p>在本示例中，客户端计算机 PC1 与同一 IP 网络中的 FTP 服务器进行通信。</p><ul><li><strong>源IPv4地址</strong> - 发送设备的IPv4地址，即客户端计算机PC1：192.168.1.110。</li><li><strong>目的IPv4地址</strong> - 接收设备的IPv4地址，即服务器，Web服务器：172.16.1.99。</li></ul><p>注意图中源 IPv4 地址和目的 IPv4 地址的网络部分在同一网络中。注意图中，源IPv4地址的网络部分和目的IPv4地址的网络部分是相同的，因此，源和目的地在同一个网络上。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.15.png"></p><h2 id="7-4、数据链路层地址的作用：相同的IP网络"><a href="#7-4、数据链路层地址的作用：相同的IP网络" class="headerlink" title="7.4、数据链路层地址的作用：相同的IP网络"></a>7.4、数据链路层地址的作用：相同的IP网络</h2><p>当 IP 数据包的发送方和接收方处于同一网络中时，数据链路帧将直接发送到接收设备。在以太网中，数据链路地址称为以太网介质访问控制（MAC）地址，在图中突出显示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.19.png"></p><p>MAC 地址是以太网网卡的物理内嵌地址。</p><ul><li>源 MAC 地址 - 这是发送封装有 IP 数据包的数据链路帧的设备的数据链路地址，或以太网 MAC 地址。PC1 以太网网卡的 MAC 地址为 AA-AA-AA-AA-AA-AA，以十六进制表示法表示。</li><li>目的MAC地址 - 当接收设备与发送设备在同一网络中时，这就是接收设备的数据链路层地址。在本例中，目的MAC地址就是FTP服务器的MAC地址： CC-CC-CC-CC-CC-CC-CC，用十六进制记法表示。</li></ul><p>现在可以将封装有 IP 数据包的帧从 PC1 直接传送到 FTP 服务器。</p><h2 id="7-5、远程网络中的设备"><a href="#7-5、远程网络中的设备" class="headerlink" title="7.5、远程网络中的设备"></a>7.5、远程网络中的设备</h2><p>但是当设备与远程网络中的另一设备通信时，网络层地址和数据链路层地址的作用是什么？在以下示例中，客户端计算机 PC1 与另一 IP 网络中名为 Web 服务器的服务器进行通信。</p><h2 id="7-6、网络层地址的作用"><a href="#7-6、网络层地址的作用" class="headerlink" title="7.6、网络层地址的作用"></a>7.6、网络层地址的作用</h2><p>当数据包的发送方与接收方位于不同网络时，源 IP 地址和目的 IP 地址将代表位于不同网络的主机。这将由目的主机 IP 地址的网络部分来表明。</p><ul><li><strong>源IPv4地址</strong> – 发送设备的IPv4地址，即客户端计算机PC1：192.168.1.110。</li><li><strong>目的IPv4地址</strong> – 接收设备的IPv4地址，即服务器，Web服务器：172.16.1.99。</li></ul><p>注意图中源 IPv4 地址和目的 IPv4 地址的网络部分在不同的网络中。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.20.png"></p><h2 id="7-7、数据链路层地址的作用：不同的IP网络"><a href="#7-7、数据链路层地址的作用：不同的IP网络" class="headerlink" title="7.7、数据链路层地址的作用：不同的IP网络"></a>7.7、数据链路层地址的作用：不同的IP网络</h2><p>当 IP 数据包的发送方和接收方位于不同网络时，以太网数据链路帧不能直接发送到目的主机，因为在发送方的网络中无法直接到达该主机。必须将以太网帧发送到称为路由器或默认网关的另一设备。在我们的示例中，默认网关是 R1。R1 有一个以太网数据链路地址与 PC1 位于同一网络中。这使 PC1 能够直接到达路由器。</p><ul><li>源 MAC 地址 - 发送设备 PC1 的以太网 MAC 地址。PC1 以太网接口的 MAC 地址是 AA-AA-AA-AA-AA-AA。</li><li>目的 MAC 地址 - 当接收设备（目的 IP 地址）与发送设备位于不同网络时，发送设备使用默认网关或路由器的以太网 MAC 地址。在本示例中，目的 MAC 地址是 R1 的以太网接口的 MAC 地址：11-11-11-11-11-11。这是连接到与PC1相同的网络的接口，如图所示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.21.png"></p><p>现在可以将封装有 IP 数据包的以太网帧传送到 R1。R1 将数据包转发到目的地（Web 服务器）。这可能意味着 R1 会将数据包转发到另一个路由器，或者如果目的地所在的网络与 R1 相连的话直接转发到 Web 服务器。</p><p>必须在本地网络的每台主机上配置默认网关的 IP 地址。所有指向远程网络中目的地的数据包都会发送到默认网关。</p><h2 id="7-8、数据链路层地址"><a href="#7-8、数据链路层地址" class="headerlink" title="7.8、数据链路层地址"></a>7.8、数据链路层地址</h2><p>数据链路层（第 2 层）物理地址具有不同的作用。数据链路层地址的作用是将数据链路层帧从一个网络接口传输到同一网络中的另一个网络接口。</p><p>在 IP 数据包可以通过有线或无线网络发送之前，必须将其封装成数据链路层帧，以便通过物理介质传输。</p><p><strong>主机到路由器：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.16.png"></p><p><strong>路由器到路由器：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.17.png"></p><p><strong>路由器到服务器：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ITN3.18.png"></p><p>当 IP 数据包从主机到路由器、从路由器到路由器和最终从路由器到主机传输时，沿途中的每个点上都会将 IP 数据包封装到新的数据链路层帧中。每个数据链路层帧包含发送帧的 NIC 卡的源数据链路层地址和接收帧的 NIC 卡的目的数据链路层地址。</p><p>第 2 层数据链路层协议仅用于在同一网络中的 NIC 之间传输数据包。路由器会将其 NIC 上收到的第 2 层信息删除，添加新的数据链路层信息，然后将数据包从通往最终目的地路径的出口 NIC 上转发出去。</p><p>IP 数据包会封装到包含以下数据链路层信息的数据链路层帧中：</p><ul><li>源数据链路层地址 - 发送数据链路层帧的网卡的物理地址。</li><li>目的数据链路层地址 - 接收数据链路层帧的 NIC 的物理地址。该地址为下一跳路由器，或最终目的设备的地址。</li></ul><h2 id="7-9、实验-安装Wireshark"><a href="#7-9、实验-安装Wireshark" class="headerlink" title="7.9、实验-安装Wireshark"></a>7.9、实验-安装Wireshark</h2><p>略</p><h2 id="7-10、实验-使用Wireshark查看网络流量"><a href="#7-10、实验-使用Wireshark查看网络流量" class="headerlink" title="7.10、实验-使用Wireshark查看网络流量"></a>7.10、实验-使用Wireshark查看网络流量</h2><p>略</p><h2 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h2><p>网络层地址是逻辑地址，长度可以使32位，也可以是128位；</p><p>数据链路层地址是物理地址，表示为12个十六进制数字。</p><h1 id="单元检测："><a href="#单元检测：" class="headerlink" title="单元检测："></a>单元检测：</h1><p>传输层为终端设备之间的每个通信定义了数据分段、传输和重组服务</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（二）</title>
      <link href="/2021/102315660.html"/>
      <url>/2021/102315660.html</url>
      
        <content type="html"><![CDATA[<h1 id="二、交换机和终端设备的基本配置"><a href="#二、交换机和终端设备的基本配置" class="headerlink" title="二、交换机和终端设备的基本配置"></a>二、交换机和终端设备的基本配置</h1><p><strong>模块标题</strong>: 交换机和终端设备的基本配置</p><p><strong>模块目标</strong>: 在网络交换机和终端设备上执行初始设置，包括密码、IP 地址设置和默认网关参数。</p><table><thead><tr><th align="left">主题标题</th><th align="left">主题目标</th></tr></thead><tbody><tr><td align="left"><strong>思科 IOS 访问</strong></td><td align="left">说明如何访问思科 IOS 设备以进行配置。</td></tr><tr><td align="left"><strong>IOS 导航</strong></td><td align="left">说明如何在思科 IOS 中导航，以配置网络设备。</td></tr><tr><td align="left"><strong>命令结构</strong></td><td align="left">描述思科 IOS 软件的命令结构。</td></tr><tr><td align="left"><strong>基本设备配置</strong></td><td align="left">使用 CLI（命令行接口）配置思科 IOS 设备。</td></tr><tr><td align="left"><strong>保存配置</strong></td><td align="left">使用 IOS 命令来保存当前运行的配置。</td></tr><tr><td align="left"><strong>端口和地址</strong></td><td align="left">说明设备如何通过网络介质进行通信。</td></tr><tr><td align="left"><strong>配置 IP 地址</strong></td><td align="left">为主机设备配置 IP 地址。</td></tr><tr><td align="left"><strong>验证连接</strong></td><td align="left">验证两个终端设备之间的连接。</td></tr></tbody></table><h1 id="1、思科IOS访问"><a href="#1、思科IOS访问" class="headerlink" title="1、思科IOS访问"></a>1、思科IOS访问</h1><h2 id="1-1、操作系统"><a href="#1-1、操作系统" class="headerlink" title="1.1、操作系统"></a>1.1、操作系统</h2><p>所有终端设备和网络设备都需要有<strong>操作系统 (OS,Operating system)<strong>。如图所示，操作系统中直接与计算机硬件交互的部分称为</strong>内核</strong>。与应用程序和用户连接的部分则称为<strong>外壳</strong>。用户可以使用<strong>命令行界面 (CLI，command-line interface) 或图形用户界面 (GUI，Graphical User Interface )</strong> 与外壳交互。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco1.1.png"></p><ul><li><strong>外壳</strong>-允许用户从计算机请求特定任务的用户界面。这些请求可以通过CLI或GUI界面发起</li><li><strong>内核</strong>-在计算机的硬件和软件之间进行通信，并对如何使用硬件资源满足软件要求进行管理</li><li><strong>硬件</strong>-计算机的物理组成部分，包括下层的电子元件</li></ul><p>使用 CLI 时，用户在命令提示符下用键盘输入命令，从而在基于文本的环境中与系统直接交互</p><h2 id="1-2、GUI"><a href="#1-2、GUI" class="headerlink" title="1.2、GUI"></a>1.2、GUI</h2><p>GUI（比如 Windows、OS X、Apple iOS 或 Android）允许用户利用图形图标、菜单和窗口环境与系统交互。</p><p>但是，GUI 并不总是能够提供 CLI 上可用的所有功能。GUI 也可能发生故障、崩溃，或者就是无法按照指示运行。因此，通常通过 CLI 访问网络设备。<strong>与 GUI 相比，CLI 消耗资源更少，而且非常稳定。</strong></p><p><strong>注意</strong>: 家用路由器的操作系统通常称为固件。配置家用路由器的常用方法是使用基于 Web 浏览器的 GUI。</p><h2 id="1-3、操作系统的用途"><a href="#1-3、操作系统的用途" class="headerlink" title="1.3、操作系统的用途"></a>1.3、操作系统的用途</h2><p>通过 GUI，PC 操作系统使用户能够做到：</p><ul><li>使用鼠标做出选择和运行程序</li><li>输入文本和基于文本的命令</li><li>在显示器上查看输出</li></ul><p>基于 CLI 的网络操作系统，使网络技术人员能够做到：</p><ul><li>使用键盘运行基于 CLI 的网络程序</li><li>使用键盘输入文本和基于文本的命令</li><li>在显示器上查看输出</li></ul><h2 id="1-4、访问方法"><a href="#1-4、访问方法" class="headerlink" title="1.4、访问方法"></a>1.4、访问方法</h2><p>默认情况下，交换机将转发流量，无需配置即可工作。</p><table><thead><tr><th align="left"><strong>方法</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>控制台 (Console)</strong></td><td align="left">这是一种物理管理端口，可通过该端口对思科设备进行<strong>带外访问</strong>。带外访问是指通过仅用于设备维护的专用管理通道进行访问。使用控制台端口的优势在于，即使没有配置任何网络服务，也可以访问设备，例如执行初始配置时。控制台连接需要运行终端仿真软件的计算机和用于连接设备的特殊控制台电缆。</td></tr><tr><td align="left"><strong>安全外壳(SSH，Secure Shell)</strong></td><td align="left">SSH 是一种带内且被推荐的方法，它使用虚拟接口通过网络远程建立安全的 CLI连接。不同于控制台连接，SSH 连接需要设备上具有有效的网络服务，包括配置了地址的有效接口。大部分思科 IOS 版本配备了 SSH 服务器和 SSH 客户端，可用于与其他设备建立 SSH 会话。</td></tr><tr><td align="left"><strong>Telnet</strong></td><td align="left">Telnet 使用虚拟接口通过网络远程建立 CLI 会话，这种带内方法并<strong>不安全</strong>。与 SSH 不同，Telnet 不提供安全的加密连接，只能在实验室环境中使用。用户身份验证、密码和命令通过网络以明文形式发送。最好的做法是使用 SSH 而不是 Telnet。思科 IOS 包括 Telnet 服务器和 Telnet 客户端。</td></tr></tbody></table><p><strong>注意:</strong> 某些设备，比如路由器，还可以支持<strong>传统辅助端口</strong>，这种辅助端口可使用调制解调器通过电话连接远程建立 CLI 会话。类似于控制台连接，AUX 端口也是带外连接，且不需要配置或提供网络服务。</p><h2 id="1-5、终端仿真程序"><a href="#1-5、终端仿真程序" class="headerlink" title="1.5、终端仿真程序"></a>1.5、终端仿真程序</h2><p>有些终端仿真程序可以通过控制台端口的串行连接或 SSH/Telnet 连接进行网络设备连接。这些程序允许您通过调整窗口大小、更改字体大小和更改配色方案来提高工作效率。</p><p>1、PuTTY</p><p>2、Tera Term</p><p>3、SecureCRT</p><p>注：</p><p>1、通过控制台端口将计算机连接到思科设备需要特殊的控制台电缆</p><p>2、思科设备上的AUX端口通过电话线提供带外连接</p><h1 id="2、主要命令模式"><a href="#2、主要命令模式" class="headerlink" title="2、主要命令模式"></a>2、主要命令模式</h1><h2 id="2-1、主要命令模式"><a href="#2-1、主要命令模式" class="headerlink" title="2.1、主要命令模式"></a>2.1、主要命令模式</h2><ul><li><strong>用户 EXEC 模式</strong> - 该模式功能有限，但可用于有效执行基本操作。它只允许有限数量的基本监控命令，不允许执行任何可能改变设备配置的命令。用户 EXEC 模式由采用 <strong>&gt;</strong> 符号结尾的 CLI 提示符标识。</li><li><strong>特权 EXEC 模式</strong> - 要执行配置命令，网络管理员必须访问特权 EXEC 模式。较高级别的配置模式，比如全局配置模式，只能通过特权 EXEC 模式访问。特权 EXEC 模式由采用**#** 符号结尾的提示符标识。</li></ul><h2 id="2-2、配置模式子配置模式"><a href="#2-2、配置模式子配置模式" class="headerlink" title="2.2、配置模式子配置模式"></a>2.2、配置模式子配置模式</h2><p>要配置设备，用户必须进入全局配置模式。</p><p>全局配置模式由在设备名称之后加(config)#结尾的提示符标识</p><p>如：<code>Switch(config)#</code></p><p>在全局配置模式下，用户可以进入不同的子配置模式。其中的每种模式可以用于配置 IOS 设备的特定部分或特定功能。</p><p>两个常见的子配置模式包括：</p><ul><li><strong>线路配置模式</strong> - 用于配置控制台、SSH、Telnet 或 AUX 访问。</li><li><strong>接口配置模式</strong> - 用于配置交换机端口或路由器网络接口。</li></ul><p>当使用 CLI 时，每种模式由该模式独有的命令提示符来标识。默认情况下，每个提示符都以设备名称开头。命令提示符中设备名称后的部分用于表明模式。</p><p>例如：</p><p>线路配置模式的默认提示符是 <code>Switch(config-line)#</code> </p><p>默认的接口配置模式提示符是 <code>Switch(config-if)#</code></p><h2 id="2-3、视频-IOS-CLI主要命令模式"><a href="#2-3、视频-IOS-CLI主要命令模式" class="headerlink" title="2.3、视频-IOS CLI主要命令模式"></a>2.3、视频-IOS CLI主要命令模式</h2><p>略</p><h2 id="2-4、在IOS模式之间导航"><a href="#2-4、在IOS模式之间导航" class="headerlink" title="2.4、在IOS模式之间导航"></a>2.4、在IOS模式之间导航</h2><p>多种命令用于进出命令提示符</p><p>从用户模式切换到特权模式（使能模式）：<code>enable</code></p><p>返回用户模式：<code>disable</code></p><p>进出全局配置模式：<code>configure terminal</code></p><p>返回特权模式：<code>exit</code></p><p>许多不同的子配置模式</p><p>线路子配置模式：<code>line+访问的管理线路类型+编号</code>   如：<code>line console 0</code></p><p>退出子配置模式返回全局配置模式：<code>exit</code></p><p>从任何子配置模式切换到特权模式：<code>end</code>或输入组合键ctrl+z</p><p>从一个子配置模式切换到另一个子配置模式：如</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Switch(config-line)# interface FastEthernet 0&#x2F;1Switch(config-if)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-5、视频-在IOS模式之间导航"><a href="#2-5、视频-在IOS模式之间导航" class="headerlink" title="2.5、视频-在IOS模式之间导航"></a>2.5、视频-在IOS模式之间导航</h2><p>略</p><h2 id="2-6、关于语法检查器练习的说明"><a href="#2-6、关于语法检查器练习的说明" class="headerlink" title="2.6、关于语法检查器练习的说明"></a>2.6、关于语法检查器练习的说明</h2><p>思科网院为您提供了不同的模拟工具，帮助您建立配置和故障排除技能。</p><p>更先进的仿真工具，如Packet Tracer，可让您输入缩写命令，就像在真实设备上一样。</p><h2 id="2-7、语法检查器-在IOS模式之间导航"><a href="#2-7、语法检查器-在IOS模式之间导航" class="headerlink" title="2.7、语法检查器-在IOS模式之间导航"></a>2.7、语法检查器-在IOS模式之间导航</h2><p>语法模拟，略</p><h1 id="3、命令结构"><a href="#3、命令结构" class="headerlink" title="3、命令结构"></a>3、命令结构</h1><h2 id="3-1、基本IOS命令结构"><a href="#3-1、基本IOS命令结构" class="headerlink" title="3.1、基本IOS命令结构"></a>3.1、基本IOS命令结构</h2><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.1.png"></p><ul><li><strong>关键字</strong> - 这些是在操作系统中定义的特定参数。（在图中为 ip protocols）。</li><li><strong>参数</strong> - 这些没有预先定义，它是由用户来定义的值或变量。（在图中为 192.168.10.5）。</li></ul><p>输入包括关键字和参数在内的完整命令后，按<strong>Enter</strong>键将该命令提交给命令解释程序。</p><h2 id="3-2、IOS命令语法检查"><a href="#3-2、IOS命令语法检查" class="headerlink" title="3.2、IOS命令语法检查"></a>3.2、IOS命令语法检查</h2><table><thead><tr><th align="left"><strong>约定</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>粗体</strong></td><td align="left">粗体文本表示您需要原样输入的命令和关键字， 如显示的那样。</td></tr><tr><td align="left"><em>斜体</em></td><td align="left">斜体文本指示由您提供值的参数。</td></tr><tr><td align="left"><strong>[<strong>x</strong>]</strong></td><td align="left">方括号表示可选元素（关键字或参数）。</td></tr><tr><td align="left"><strong>{<strong>x</strong>}</strong></td><td align="left">大括号表示必需元素（关键字或参数）。</td></tr><tr><td align="left">**[**x **{**y <strong>|</strong> z <strong>}]</strong></td><td align="left">方括号中的大括号和垂直线表示 可选元素中的必填选项。空格用于清楚地描述 命令的各个部分。</td></tr></tbody></table><p>例如，使用 <strong>description</strong> 命令的语法是 <strong>description</strong> 空格加字符串。参数是用户提供的空格加字符串的值。<strong>description</strong>命令通常用于描述接口的用途。</p><p>例如，输入命令<code>description Connects to the main headquarter office switch</code>，描述的是另一台设备在连接末端的什么位置。</p><p><code>ping ip-address </code>其中的命令是ping，用户定义的参数是目的设备的IP地址。</p><p>例如，<code>ping 10.10.10.5</code></p><p><code>traceroute ip-address</code>其中的命令是traceroute，用户定义的参数是目的设备的IP地址。</p><p>例如 <code>traceroute 192.168.254.254</code></p><h2 id="3-3、IOS帮助功能"><a href="#3-3、IOS帮助功能" class="headerlink" title="3.3、IOS帮助功能"></a>3.3、IOS帮助功能</h2><p><strong>上下文相关帮助</strong>使您能够快速找到以下问题的答案：</p><ul><li>每个命令模式中有哪些命令可用?</li><li>哪些命令以特定字符或字符组开头?</li><li>哪些参数和关键字可用于特定命令？</li></ul><p>要访问上下文相关帮助，请直接在 CLI 中输入一个**?**</p><p><strong>命令语法检查</strong>用于验证用户输入的命令是否有效。输入命令后，命令行解释程序将从左向右评估命令。如果解释程序可以理解该命令，则用户要求执行的操作将被执行，且 CLI 将返回到相应的提示符。然而，如果解释程序无法理解用户输入的命令，它将提供反馈，说明该命令存在的问题。</p><h2 id="3-4、视频-上下文相关的帮助和命令语法检查"><a href="#3-4、视频-上下文相关的帮助和命令语法检查" class="headerlink" title="3.4、视频-上下文相关的帮助和命令语法检查"></a>3.4、视频-上下文相关的帮助和命令语法检查</h2><p>略</p><h2 id="3-5、热键和快捷方式"><a href="#3-5、热键和快捷方式" class="headerlink" title="3.5、热键和快捷方式"></a>3.5、热键和快捷方式</h2><p>命令和关键字可缩写为可唯一确定该命令或关键字的最短字符数。</p><p>例如，<strong>configure</strong>命令可缩写为<strong>conf</strong>，因为<strong>configure</strong>是唯一一个以<strong>conf</strong>开头的命令。不能缩写为<strong>con</strong>，因为以<strong>con</strong>开头的命令不止一个。关键字也可缩写。</p><p>该表列出了用于增强命令行编辑的键盘输入。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Tab</strong></td><td align="left">补全部分输入的命令项。</td></tr><tr><td align="left"><strong>Backspace</strong></td><td align="left">删除光标左边的字符。</td></tr><tr><td align="left"><strong>Ctrl-D</strong></td><td align="left">删除光标所在的字符。</td></tr><tr><td align="left"><strong>Ctrl-K</strong></td><td align="left">删除从光标到命令行尾的所有字符。</td></tr><tr><td align="left"><strong>Esc D</strong></td><td align="left">删除从光标到词尾的所有字符。</td></tr><tr><td align="left"><strong>Ctrl+U</strong> 或 <strong>Ctrl+X</strong></td><td align="left">删除从光标到命令行首的 所有字符。</td></tr><tr><td align="left"><strong>Ctrl-W</strong></td><td align="left">删除光标左边的单词。</td></tr><tr><td align="left"><strong>Ctrl-A</strong></td><td align="left">将光标移至行首。</td></tr><tr><td align="left"><strong>向左箭头</strong> 或 <strong>Ctrl+B</strong></td><td align="left">将光标左移一个字符。</td></tr><tr><td align="left"><strong>Esc B</strong></td><td align="left">将光标向后左移一个单词。</td></tr><tr><td align="left"><strong>Esc F</strong></td><td align="left">将光标向前右移一个单词。</td></tr><tr><td align="left"><strong>向右箭头</strong> 或 <strong>Ctrl+F</strong></td><td align="left">将光标右移一个字符。</td></tr><tr><td align="left"><strong>Ctrl-E</strong></td><td align="left">将光标移至命令行尾。</td></tr><tr><td align="left"><strong>向上箭头</strong> 或 <strong>Ctrl+P</strong></td><td align="left">调出历史记录缓冲区中的命令， 从最近输入的命令开始。</td></tr><tr><td align="left"><strong>Ctrl+R</strong> 或 <strong>Ctrl+I</strong> 或 <strong>Ctrl+L</strong></td><td align="left">收到控制台消息后重新显示系统提示符和 命令行。</td></tr></tbody></table><p>注：IOS命令行无法识别delete键</p><p>当命令输出产生的文本超过终端窗口中可以显示的文本时，IOS 将显示一个 <strong>“–More–”</strong> 提示。下表描述了显示此提示时可以使用的键盘输入。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>回车</strong> 键</td><td align="left">显示下一行。</td></tr><tr><td align="left"><strong>空格</strong>键</td><td align="left">显示下一屏。</td></tr><tr><td align="left">任何其他按键</td><td align="left">结束显示字符串，返回特权模式。</td></tr></tbody></table><p>此表列出了用于退出操作的命令。</p><table><thead><tr><th align="left"><strong>键盘输入</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left"><strong>Ctrl-C</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。处于设置模式下时，用于中止并返回命令 提示符。</td></tr><tr><td align="left"><strong>Ctrl-Z</strong></td><td align="left">处于任何配置模式下时，用于结束该配置模式并返回 特权模式。</td></tr><tr><td align="left"><strong>Ctrl-Shift-6</strong></td><td align="left">通用中断序列用于中止 DNS lookup、traceroutes、 pings等。</td></tr></tbody></table><h2 id="3-6、视频-热键和快捷方式"><a href="#3-6、视频-热键和快捷方式" class="headerlink" title="3.6、视频-热键和快捷方式"></a>3.6、视频-热键和快捷方式</h2><p>略</p><h2 id="3-7、Packet-Tracer-导航IOS"><a href="#3-7、Packet-Tracer-导航IOS" class="headerlink" title="3.7、Packet Tracer-导航IOS"></a>3.7、Packet Tracer-导航IOS</h2><p>略</p><h2 id="3-8、实验-使用Tera-Term连接控制台来导航IOS"><a href="#3-8、实验-使用Tera-Term连接控制台来导航IOS" class="headerlink" title="3.8、实验-使用Tera Term连接控制台来导航IOS"></a>3.8、实验-使用Tera Term连接控制台来导航IOS</h2><p>略</p><h1 id="4、基本设备配置"><a href="#4、基本设备配置" class="headerlink" title="4、基本设备配置"></a>4、基本设备配置</h1><h2 id="4-1设备名称"><a href="#4-1设备名称" class="headerlink" title="4.1设备名称"></a>4.1设备名称</h2><p>任何设备上的第一个配置命令应该是为其提供一个唯一的设备名称或主机名。默认情况下，所有设备都有一个出厂的默认名称。</p><p>例如，思科 IOS 交换机是出厂名称是 “Switch。”</p><p>默认主机名应更改为更具描述性的名称。通过审慎地选择名称，就很容易记住、记录和鉴别网络设备。以下是对主机的一些重要命名指南：</p><ul><li>以字母开头</li><li>不包含空格</li><li>以字母或数字结尾</li><li>仅使用字母、数字和破折号</li><li>长度少于 64 个字符</li></ul><p>组织必须选择一个命名约定，以便能够轻松直观地识别特定设备。IOS 设备中所用的主机名会保留字母的大小写状态。</p><p>当确定命名约定后，接下来的步骤就是使用 CLI 将名称应用到设备。</p><p>如示例改变设备的名称：</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">Switch# configure terminalSwitch(config)# hostname Sw-Floor-1Sw-Floor-1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>:要使交换机返回默认提示符，请使用<code>no hostname</code>全局配置命令。</p><p>每次添加或修改设备时，请始终确保更新相关文档。请在文档中通过地点、用途和地址来标识设备。</p><h2 id="4-2、密码准则"><a href="#4-2、密码准则" class="headerlink" title="4.2、密码准则"></a>4.2、密码准则</h2><p>Cisco IOS 可配置为使用分层模式密码允许对网络设备拥有不同的访问权限。</p><p>所有网络设备都应该通过使用密码保护特权EXEC、用户EXEC和远程Telnet访问来限制管理访问。此外，所有密码都应加密，并提供法律通知。</p><h2 id="4-3、配置密码"><a href="#4-3、配置密码" class="headerlink" title="4.3、配置密码"></a>4.3、配置密码</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Sw-Floor-1 # configure terminalSw-Floor-1(config)# line console 0&#x2F;&#x2F;进入线路控制台配置模式，0 用于代表第一个（而且在大多数情况下是唯一的一个）控制台接口。Sw-Floor-1(config-line)# password cisco&#x2F;&#x2F;使用password +设置的密码 命令指定用户 EXEC 模式密码。Sw-Floor-1(config-line)# login&#x2F;&#x2F;使用login命令启用用户 EXEC 访问Sw-Floor-1(config-line)# endSw-Floor-1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要使管理员能够访问所有 IOS 命令（包括配置设备），您必须获得特权 EXEC 模式访问权限。这是最重要的访问方法，因为它提供了对设备的完整访问权限。</p><p>要保护特权 EXEC 访问，请使用<strong>enable secret</strong> <em>password</em> 全局配置命令</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Sw-Floor-1# configure terminalSw-Floor-1(config)# enable secret classSw-Floor-1(config)# exitSw-Floor-1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>虚拟终端 (VTY) 线路支持通过Telnet或SSH对设备的远程访问。许多思科交换机支持第 0 到 15 的 16 条 VTY 线路。</p><p>要保护 VTY 线路的安全，请使用 <strong>line vty 0 15</strong> 全局配置命令进入线路 VTY 模式。接下来，使用<strong>password</strong> <em>password</em> 命令指定VTY密码。最后，使用<strong>login</strong>命令启用 VTY 访问。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Sw-Floor-1 # configure terminalSw-Floor-1(config)# line vty 0 15Sw-Floor-1(config-line)# password cisco Sw-Floor-1(config-line)# login Sw-Floor-1(config-line)# endSw-Floor-1#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-4、加密密码"><a href="#4-4、加密密码" class="headerlink" title="4.4、加密密码"></a>4.4、加密密码</h2><p>启动配置文件和运行配置文件以明文显示大多数密码。这会带来安全威胁，因为任何人如果访问这些文件，就可以发现这些密码。</p><p>要加密所有明文密码，请使用全局配置命令 <strong>service password-encryption</strong> ，如示例所示。</p><pre class="line-numbers language-none"><code class="language-none">Sw-Floor-1 # configure terminalSw-Floor-1(config)# service password-encryptionSw-Floor-1(config)#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>该命令对所有未加密的密码进行弱加密。这种加密仅适用于配置文件中的密码，而不适用于通过网络发送的密码。此命令的用途在于防止未经授权的人员查看配置文件中的密码。</p><p>使用<strong>show running-config</strong>命令验证密码现在是否已加密。</p><h2 id="4-5、横幅消息"><a href="#4-5、横幅消息" class="headerlink" title="4.5、横幅消息"></a>4.5、横幅消息</h2><p>尽管要求用户输入密码是防止未经授权的人员进入网络的有效方法，但同时必须向试图访问设备的人员声明仅授权人员才可访问设备。出于此目的，可向设备输出中加入一条标语。</p><p>要在网络设备上创建当日消息标语，请使用**banner motd #<em><strong>当日消息</strong></em>#**全局配置命令。命令语法中的“#”称为定界符。它会在消息前后输入。</p><p><strong>定界符</strong>可以是未出现在消息中的任意字符。因此，经常使用“#”之类的字符。命令执行完毕后，系统将向之后访问设备的所有用户显示该标语，直到该标语被删除为止。</p><p>如：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Sw-Floor-1 # configure terminalSw-Floor-1(config)# banner motd #Authorized Access Only#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="4-6、视频-保护对交换机的管理访问"><a href="#4-6、视频-保护对交换机的管理访问" class="headerlink" title="4.6、视频-保护对交换机的管理访问"></a>4.6、视频-保护对交换机的管理访问</h2><p>略</p><h2 id="4-7、语法检查器-基本设备配置"><a href="#4-7、语法检查器-基本设备配置" class="headerlink" title="4.7、语法检查器-基本设备配置"></a>4.7、语法检查器-基本设备配置</h2><p>略</p><h1 id="5、保存配置"><a href="#5、保存配置" class="headerlink" title="5、保存配置"></a>5、保存配置</h1><h2 id="5-1、配置文件"><a href="#5-1、配置文件" class="headerlink" title="5.1、配置文件"></a>5.1、配置文件</h2><p>您现在了解了如何在交换机上执行基本配置，包括密码和标语消息。本主题将向您展示如何保存您的配置。</p><ul><li><strong>startup-config(启动配置文件)</strong> -存储在 NVRAM 中的配置文件。它包含在启动时或重启时用到的所有命令。当设备断电后，其中的内容不会消失。</li><li><strong>running-config(运行配置文件)</strong> -存储在随机存取存储器（RAM）中。它反映了当前的配置。修改运行配置会立即影响思科设备的运行。RAM 是易失性存储器。如果设备断电或重新启动，则它会丢失所有内容。</li></ul><p>特权 EXEC 模式命令<strong>show running-config</strong>用于查看正在运行的配置。</p><p>要查看启动配置文件，请使用特权 EXEC 命令<strong>show startup-config</strong>。</p><p>如果设备断电或重新启动，所有未保存的配置更改都会丢失。</p><p>要将对运行配置所作的更改保存到启动配置文件中，请使用特权 EXEC 模式命令<code>copy running-config startup-config</code></p><h2 id="5-2、修改运行配置"><a href="#5-2、修改运行配置" class="headerlink" title="5.2、修改运行配置"></a>5.2、修改运行配置</h2><p>如果对运行配置所作的更改未能实现预期的效果，而且运行配置文件尚未保存，您可以将设备恢复到以前的配置。单独删除更改的命令，或使用特权 EXEC 模式命令 <code>reload</code>重新加载设备都能恢复启动配置，后者的缺点是，在一段很短的时间内设备将会离线，导致网络中断。</p><p>当开始重新加载时，IOS 会检测到发生更改的运行配置没有保存到启动配置中。因此，它将显示一则提示消息，询问是否保存更改。要放弃更改，请输入<strong>n</strong>或<strong>no</strong> 。</p><p>或者，如果将不理想的更改保存到了启动配置文件中，则可能需要清除所有配置。这需要删除启动配置文件并重新启动设备。使用特权 EXEC 模式命令<code>erase startup-config</code>可删除启动配置。在发出此命令后，交换机将提示您确认。按<strong>Enter</strong>键接受。</p><p>从 NVRAM 中删除启动配置后，请重新加载设备以从内存中清除当前的运行配置文件。重新加载时，交换机将会加载设备出厂默认的启动配置。</p><h2 id="5-3、视频-修改运行配置"><a href="#5-3、视频-修改运行配置" class="headerlink" title="5.3、视频-修改运行配置"></a>5.3、视频-修改运行配置</h2><p>略</p><h2 id="5-4、将配置捕获到文本文件中"><a href="#5-4、将配置捕获到文本文件中" class="headerlink" title="5.4、将配置捕获到文本文件中"></a>5.4、将配置捕获到文本文件中</h2><p>配置文件也可以保存并存档到文本文档中。这一系列步骤可确保获取当前配置文件的一份副本以供稍后编辑或重新使用。</p><p>例如，假定交换机已经配置，而且运行配置已经保存到设备上。</p><p><strong>步骤 1.</strong> 打开一个与交换机连接的终端仿真软件，比如 PuTTY 或 Tera Term。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.2.png"></p><p><strong>步骤 2.</strong> 在终端软件中启用日志记录，并指定名称和文件位置以保存日志文件。图中显示<strong>All session output</strong>都将捕获到指定文件中（即 MySwitchLogs）。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.3.png"></p><p>**步骤 3.**在特权EXEC模式下使用 <code>show running-config</code>或<code>show startup-config</code>命令。终端窗口中显示的文本将保存到所选的文件中。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Switch# show running-configBuilding configuration...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>步骤 4.</strong> 在终端软件中禁用日志记录。图片显示了如何通过选择<strong>None</strong>会话日志记录选项禁用日志记录。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.4.png"></p><p>所创建的文本文件可用作设备当前实施方式的记录。在用于将保存的配置恢复到设备之前，可能需要对该文件进行编辑。</p><p>要将配置文件恢复到设备中，请执行以下操作：</p><p><strong>步骤 1.</strong> 在设备上进入全局配置模式。</p><p><strong>步骤 2.</strong> 将文本文件复制并粘贴到与交换机相连的终端窗口中。</p><p>文件中的文本将作为 CLI 中的命令应用，并成为设备上的运行配置。这是手动配置设备的一种便利方法。</p><h1 id="6、端口和地址"><a href="#6、端口和地址" class="headerlink" title="6、端口和地址"></a>6、端口和地址</h1><h2 id="6-1、IP地址"><a href="#6-1、IP地址" class="headerlink" title="6.1、IP地址"></a>6.1、IP地址</h2><p>使用 IP 地址，是设备能够相互查找并在 Internet 上建立端到端通信的主要方式。网络中的每个终端设备都必须配置 IP 地址。</p><p>IPv4 地址的结构称为点分十进制记法，用 0 到 255 之间的四个十进制数字表示。IPv4 地址会分配给连接到网络的各个设备。</p><p><strong>注意</strong>: 本课程中的 IP 同时包括 IPv4 和 IPv6 协议。IPv6 是 IP 的最新版本，正在替换更常见的 IPv4。</p><p>对于 IPv4 地址，<strong>子网掩码</strong>也是必要设置。IPv4 子网掩码是将地址的网络部分与主机部分区分开来的 32 位值。子网掩码，与 IPv4 地址相结合，可用于确定设备属于哪个子网。</p><p><strong>默认网关</strong>地址是主机将用于访问远程网络（包括 Internet）的路由器的 IP 地址。</p><p>IPv6 地址长度为 128 位，写作十六进制值字符串。每 4 位以一个十六进制数字表示；共 32 个十六进制值。由四个十六进制数字组以冒号 (:) 分隔。IPv6 地址不区分大小写，可用大写或小写书写。</p><h2 id="6-2、接口和端口"><a href="#6-2、接口和端口" class="headerlink" title="6.2、接口和端口"></a>6.2、接口和端口</h2><p>网络通信取决于最终用户设备接口、网络设备接口以及连接设备的线缆。每个物理接口都有对其进行定义的规范或标准。连接接口的线缆必须设计为匹配接口的物理标准。网络介质类型包括双绞线铜缆、光缆、同轴电缆和无线，如图所示。</p><p>不同类型的网络介质有不同的特性和优点。并非所有网络介质都具有相同的特征。并非所有介质都适用于同一目的。各种介质类型之间的差异包括：</p><ul><li>介质可以成功传送信号的距离</li><li>要安装介质的环境</li><li>必须传输的数据量和速度</li><li>介质和安装的成本</li></ul><p>互联网上的每条链路不仅需要采用特定的网络介质，而且需要采用特定的网络技术。</p><p>例如，以太网是当今最常用的局域网 (LAN) 技术。在使用线缆物理连接到网络的最终用户设备、交换设备和其他网络设备上，均可找到以太网端口。</p><p>思科 IOS 第 2 层交换机有物理端口，可用于连接设备。这些端口不支持第 3 层 IP 地址。因此，交换机有一个或多个交换机<strong>虚拟接口</strong> (SVI)。这些是虚拟接口，是因为设备上没有任何物理硬件与之关联。SVI 会在软件中创建。</p><p>虚拟接口可以让您使用 IPv4和IPv6 通过网络远程管理交换机。每台交换机的默认配置中都“现成”带有一个 SVI。默认 SVI 是接口 VLAN1。</p><p><strong>注意</strong>: 第2 层交换机不需要 IP 地址。分配给 SVI 的 IP 地址用于远程访问交换机。2层交换机无需使用 IP 地址就可以工作。</p><h1 id="7、配置IP地址"><a href="#7、配置IP地址" class="headerlink" title="7、配置IP地址"></a>7、配置IP地址</h1><h2 id="7-1、为终端设备进行手动IP地址配置"><a href="#7-1、为终端设备进行手动IP地址配置" class="headerlink" title="7.1、为终端设备进行手动IP地址配置"></a>7.1、为终端设备进行手动IP地址配置</h2><p>IPv4 地址信息可以手动输入到终端设备中或使用动态主机配置协议 (DHCP，Dynamic Host Configuration Protocol) 自动分配。</p><p>要在 Windows 主机上手动配置 IPv4 地址，请打开<strong>Control Panel &gt; Network Sharing Center &gt; Change adapter settings</strong>然后选择适配器。接下来右键单击并选择<strong>Properties</strong>以显示 <strong>Local Area Connection Properties</strong>，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.5.png"></p><p>选中 Internet 协议版本 4（TCP/IPv4），然后单击 <strong>Properties</strong> 以打开 <strong>Internet Protocol Version 4 (TCP/IPv4) Properties</strong> 窗口，如图所示。配置 IPv4 地址和子网掩码信息，以及默认网关。</p><p><strong>注意</strong>: IPv6 地址和配置选项类似于 IPv4。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.6.png"></p><p><strong>注意</strong>: DNS 服务器地址是域名系统 (DNS，Domain Name System) 服务器的 IPv4 和IPv6地址，用于将 IP 地址转换为域名</p><h2 id="7-2、自动配置终端设备的IP地址"><a href="#7-2、自动配置终端设备的IP地址" class="headerlink" title="7.2、自动配置终端设备的IP地址"></a>7.2、自动配置终端设备的IP地址</h2><p>终端通常默认使用 DHCP 进行 IPv4 地址自动配置。DHCP 是用于几乎每个网络的技术。要想理解 DHCP 为什么如此普遍，最好的方法是想象一下如果没有它，我们需要做的所有额外工作。</p><p>在网络中，DHCP 可以为每台启用 DHCP 的终端设备自动配置 IPv4 地址。如果每次连接到网络都必须手动输入 IPv4 地址、子网掩码、默认网关和 DNS 服务器，想象一下要花费的时间。将这个时间乘以组织中的所有用户和所有设备，您就会看到问题。手动配置还可能因复制另一设备的 IPv4 地址而增加配置错误的风险。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/cisco2.7.png"></p><p>如图所示，要在 Windows PC 上配置 DHCP，您只需选择 <strong>Obtain an IP address automatically</strong> 和 <strong>Obtain DNS server address automatically</strong>。您的 PC 将会找到 DHCP 服务器，并为其分配在网络上通信所需的地址设置。</p><p><strong>注意</strong>: IPv6 使用 DHCPv6 和 SLAAC（无状态地址自动配置）进行动态地址分配。</p><h2 id="7-3、语法检查器-验证Windows-PC-IP-配置"><a href="#7-3、语法检查器-验证Windows-PC-IP-配置" class="headerlink" title="7.3、语法检查器-验证Windows PC IP 配置"></a>7.3、语法检查器-验证Windows PC IP 配置</h2><p><code>ipconfig</code>命令，可以显示Windows PC上的IP配置设置。输出将显示从 DHCP 服务器接收的 IPv4 地址、子网掩码和网关信息。</p><h2 id="7-4、交换机虚拟接口配置"><a href="#7-4、交换机虚拟接口配置" class="headerlink" title="7.4、交换机虚拟接口配置"></a>7.4、交换机虚拟接口配置</h2><p>要远程访问交换机，SVI 上必须配置 IP 地址和子网掩码。要在交换机上配置 SVI，请使用全局配置命令 <code>interface vlan 1</code>。Vlan 1 并不是一个实际物理接口，而是一个虚拟接口。然后使用接口配置命令 <strong>ip address</strong> <em>ip-address subnet-mask</em> 配置 IPv4 地址。最后，使用接口配置命令 <code>no shutdown</code> 启用虚拟接口。</p><p>在这些命令配置后，交换机即可使用所有 IPv4 要素进行网络通信。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Sw-Floor-1# configure terminalSw-Floor-1(config)# interface vlan 1Sw-Floor-1(config-if)# ip address 192.168.1.20 255.255.255.0Sw-Floor-1(config-if)# no shutdownSw-Floor-1(config-if)# exitSw-Floor-1(config)# ip default-gateway 192.168.1.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-5、语法检查器-配置交换机虚拟接口"><a href="#7-5、语法检查器-配置交换机虚拟接口" class="headerlink" title="7.5、语法检查器-配置交换机虚拟接口"></a>7.5、语法检查器-配置交换机虚拟接口</h2><p>略</p><h2 id="7-6、Packet-Tracer-实施基本连接"><a href="#7-6、Packet-Tracer-实施基本连接" class="headerlink" title="7.6、Packet Tracer - 实施基本连接"></a>7.6、Packet Tracer - 实施基本连接</h2><p>略</p><h1 id="8、验证连接"><a href="#8、验证连接" class="headerlink" title="8、验证连接"></a>8、验证连接</h1><h2 id="8-1、视频练习-测试接口配置"><a href="#8-1、视频练习-测试接口配置" class="headerlink" title="8.1、视频练习-测试接口配置"></a>8.1、视频练习-测试接口配置</h2><p><code>show ip interface brief</code>：检验交换机接口状况</p><p>略</p><h2 id="8-2、视频练习-测试端到端连接"><a href="#8-2、视频练习-测试端到端连接" class="headerlink" title="8.2、视频练习-测试端到端连接"></a>8.2、视频练习-测试端到端连接</h2><p><strong>ping</strong>命令可用于测试与网络上的另一设备或互联网上的一个网站的连接。</p><p>如：<code>ping 192.168.1.2</code></p><h1 id="单元测试："><a href="#单元测试：" class="headerlink" title="单元测试："></a>单元测试：</h1><p>注：</p><p>路由器和交换机配置的更改在输入命令后立即生效。</p><p>运行配置文件修改后立即影响设备的操作</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ITN网络课程笔记（一）</title>
      <link href="/2021/102344374.html"/>
      <url>/2021/102344374.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、当今网络"><a href="#一、当今网络" class="headerlink" title="一、当今网络"></a>一、当今网络</h1><p>连接到网络并直接参与网络通信的所有计算机都属于主机。某些主机也被称为客户端。</p><p>术语“<strong>主机</strong>”特指网络上为通信目的而分配了一个数字的设备，这个数字用来表示特定网络中的主机。这个数字称为互联网协议（IP，Internet Protocol）地址，<strong>IP地址</strong>标识主机和主机所连接的网络</p><p><strong>服务器</strong>是装有特殊软件，可以为网络上其他终端设备提供信息（例如电子邮件或网页）的计算机。每项服务都需要单独的服务器软件。安装有服务器软件的计算机可以同时向多个不同客户端提供服务。</p><p><strong>客户端</strong>是主机的一种类型。客户端软件用于请求和显示从服务器获取的信息</p><p>Web 浏览器（例如 Chrome 或 FireFox）是典型的<strong>客户端软件</strong>。一台计算机也可以运行多种类型的客户端软件</p><p>客户端和服务器软件通常运行在单独的服务器上，但一台计算机也可以同时兼任两个角色。在小企业和家庭中，许多计算机在网络中既是服务器又是客户端。这种网络称为<strong>对等网络</strong>。</p><p>优点：</p><blockquote><p>易于安装</p><p>复杂度低</p><p>成本低，因为可能不需要网络设备和专用服务器</p><p>可用于简单的任务，例如传输文件和共享打印机</p></blockquote><p>缺点：</p><blockquote><p>无集中管理</p><p>不安全</p><p>不可扩展</p><p>所有设备皆可用作客户端和服务器，这会降低其性能</p></blockquote><p><strong>终端设备</strong>是指通过网络传输的消息的来源或目的地。</p><p>为了区分不同的终端设备，网络中的每台终端设备都有一个地址。当一台终端设备发起通信时，会使用目的终端设备的地址来指定应该将消息发送到哪里。</p><p>常见终端设备：<strong>台式计算机</strong>，<strong>笔记本电脑</strong>，<strong>打印机</strong>，<strong>IP电话</strong>，<strong>无线平板电脑</strong>，<strong>网真端点</strong></p><p><strong>中间设备</strong>可以将单个终端连接到网络中。它们可以将多个独立的网络连接起来，形成互联网络。这些中间设备提供连接并确保数据在网络中传输。</p><p>中间设备使用目的终端设备地址以及有关网络互连的信息来决定消息在网络中应该采用的路径。</p><p>常用中间设备：<strong>无线路由器</strong>，<strong>LAN交换机</strong>，<strong>路由器</strong>，<strong>多层交换机</strong>，<strong>防火墙设备</strong></p><p>中间网络设备执行以下部分或全部功能：</p><blockquote><p>重新生成并重新传输通信信号</p><p>维护有关网络和互联网络中存在哪些路径的信息</p><p>将错误和通信故障通知其它设备</p><p>发生链路故障时按照备用路径转发数据</p><p>根据优先级别分类和转发消息</p><p>根据安全设置允许或拒绝数据的通行</p></blockquote><p>注意：未显示的是传统<strong>以太网集线器</strong>。以太网集线器也被称为<strong>多端口中继器</strong>。重新生成并重新传输通信信号。</p><p><strong>所有中间设备都具有中继器的功能</strong></p><p>通信通过<strong>网络介质</strong>在网络上传输。介质为消息从源设备传送到目的设备提供了通道。</p><p>常见网络介质：</p><p><strong>金属线电缆</strong>——数据被编码为电脉冲</p><p><strong>玻璃或塑料光纤（光缆）</strong>——数据被编码为光脉冲</p><p><strong>无线传输</strong>——数据时通过调制特定频率的电磁波进行编码的</p><p>图可以让人们轻松了解大型网络中的设备连接方式。这种网络“图”被称为“<strong>拓扑图</strong>”。要形象地表现网络的组织和工作方式，必须掌握识别物理网络组件的逻辑表示方式的能力。                        </p><p>我们还使用专门的术语来描述这些设备和介质是如何相互连接的:</p><p><strong>网络接口卡（NIC）</strong>——将设备物理连接到网络</p><p><strong>物理端口</strong>——网络设备上的接口或插口，介质通过它连接到终端设备或其他网络设备</p><p><strong>接口</strong>——网络设备上连接到独立网络的专用端口。由于路由器连接到了不同的网络，路由器上的端口称为<strong>网络端口</strong></p><p>“端口”和“接口”往往可以互换使用</p><p>拓扑图有两类：物理图，逻辑图</p><p><strong>物理拓扑图：</strong></p><p>物理拓扑图说明了中间设备和电缆安装的物理位置，如图所示。您可以看到，这些设备所在的房间已在此物理拓扑中定位标记。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/wulituoputu.png"></p><p><strong>逻辑拓扑图：</strong></p><p>逻辑拓扑图说明了设备、端口和网络的编址方案，如图所示。您可以查看哪些终端设备连接到哪些中间设备以及正在使用哪些介质。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/luojituoputu.png"></p><p>简单的家庭网络允许您在一些本地终端设备之间共享资源，如打印机、文档、图片和音乐。</p><p>小型办公室和家庭办公室(SOHO)网络允许人们在家里或远程办公室工作。许多个体经营者使用这种类型的网络来宣传和销售产品、订货以及联系客户。许多计算机既是服务器又是客户端，因此是对等网络</p><p>企业和大型组织通过网络对网络服务器上的信息进行整合、存储和访问。网络提供了电子邮件、即时消息和员工之间的协作。许多组织使用自己的网络通过互联网向客户提供产品和服务。</p><p>互联网是现存最大的网络。术语“互联网”是指“众多网络所组成的网络”。它实际是一个专用网络和公共网络互连的集合。</p><p><strong>小型家庭网络：</strong>小型家庭网络将少量的几台计算机互联并将它们连接到互联网。</p><p><strong>小型办公室和家庭办公室（SOHO）网络：</strong>小型办公室/家庭办公室 (SOHO) 网络可让一个家庭办公室或远程办公室内的计算机连接到企业网络或访问集中的共享资源。</p><p><strong>大中型网络：</strong>中大型网络（例如大型企业和学校使用的网络）可能有许多站点，包含成百上千台相互连接的主机。</p><p><strong>全球网络：</strong>互联网是由网络组成的网络，连接全球亿万台计算机。</p><p>网络基础设施在以下方面存在巨大差异：</p><ul><li>覆盖的区域大小</li><li>连接的用户数量</li><li>可用的服务数量和类型</li><li>职责范围</li></ul><p>两种最常见的网络基础设施类型是<strong>局域网 (LAN)</strong> 和**广域网 (WAN)**。</p><p>局域网 (LAN) 是在较小地理区域内提供访问的网络基础设施。局域网通常用于企业、家庭或小型企业网络中的部门。</p><p>广域网 (WAN) 是针对广泛地理区域内的其他网络提供访问的网络基础设施，通常由通信服务提供商拥有并管理。</p><p><strong>LAN (Local Area Network)</strong> :</p><p>LAN 是覆盖较小地理区域的网络基础设施。局域网具有如下特点:</p><ul><li>LAN 在有限区域（如家庭、学校、办公大楼或园区）内互连终端设备。</li><li>LAN 通常由一个组织或个人管理。实行网络级管控、安全控制并制定访问控制策略。</li><li>LAN 为内部终端设备和中间设备提供高速带宽。</li></ul><p><strong>WAN (Wide Area Network)</strong> :</p><p>WAN 是覆盖广泛地理区域的网络基础设施。WAN 通常由服务提供商 (SP,Service Provider) 或互联网服务提供商 (ISP,Internet Service Provider) 管理。</p><p>WAN 具有如下特点:</p><ul><li>WAN 互连广泛地理区域（例如各大城市、州、省、国家/地区或大陆之间）内的 LAN。</li><li>WAN 通常由多个服务提供商管理。</li><li>WAN 通常提供 LAN 之间的较慢链路。</li></ul><p><strong>互联网：</strong></p><p>互联网是一个遍及全球的互相连接的网络（简称互联网络或互联网）的集合。</p><p>互联网不属于任何个人或团体。要确保通过这种多元化基础设施有效通信，需要采用统一的公认技术和标准，也需要众多网络管理机构相互协作。为了维护互联网协议和进程的结构和标准化，人们建立了许多组织。这些组织包括互联网工程任务组 (IETF,Internet Engineering Task Force)、互联网名称与数字地址分配机构 (ICANN,The Internet Corporation for Assigned Name and Numbers) 和互联网架构委员会 (IAB,Internet Architecture Board)，以及许多其他组织。</p><p><strong>内部网</strong>和<strong>外部网</strong></p><p>术语“内部网”表示一个组织的私有局域网和广域网连接。内部网的设计旨在仅允许该组织的成员、员工或其他获得授权的人员进行访问。</p><p>组织可以使用外联网为在其他组织工作，但需要本组织数据的人提供安全访问。以下是外联网的一些例子：</p><ul><li>公司为外部供应商和承包商提供访问。</li><li>医院为医生提供预约系统，以便医生为患者安排预约。</li><li>当地教育局为其管辖区的学校提供预算和人员信息。</li></ul><p><strong>Internet访问技术</strong></p><p>家庭用户、远程工作人员和小型办公室通常需要连接到互联网服务提供商 (ISP) 才能访问互联网。不同 ISP 和地理位置的连接选项各不相同。但是，常见的选择包括<strong>宽带电缆、宽带数字用户线路 (DSL)、无线 WAN 和移动服务</strong>。</p><p>组织通常需要访问其他企业站点和互联网，支持 <strong>IP 电话、视频会议和数据中心存储</strong>等企业服务需要的快速连接。SP 提供企业级互连。最常见的企业级服务包括<strong>业务 DSL、租用线路和城域以太网</strong>。</p><p><strong>家庭和小型办公室 Internet 连接：</strong></p><p><strong>有线电视：</strong>通常由有线电视服务提供商提供，互联网数据信号在输送有线电视信号的同一电缆上进行传输。它提供了<u>高带宽、高可用性和始终在线</u>的互联网连接。</p><p><strong>DSL (Digital Subscriberloop 数字用户环路)调制解调器：</strong>数字用户线也可提供高带宽、高可用性和始终在线的互联网连接。DSL通过电话线路运行。通常小型办公室和家庭办公室用户会选择使用非对称DSL (ADSL)，这种方式的特点是<u>下载速度高于上传速度</u></p><p><strong>蜂窝网：</strong>蜂窝网互联网接入使用手机网络进行连接。只要您能收到蜂窝网信号，就能获得蜂窝网互联网的接入。性能会<u>受手机功能和手机基站的限制</u></p><p><strong>卫星：</strong>对于根本没有互联网连接的地方来说，获得卫星互联网访问非常有用。卫星天线要求有到卫星的清晰视线</p><p><strong>拨号电话：</strong>使用<u>电话线和调制解调器</u>，费用相对较低。拨号调制解调器连接提供的低带宽不足以用于大型数据传输，但对旅行过程中的移动访问非常有用</p><p>连接选项取决于<u>地理位置和服务提供商</u>的可用性。</p><p><strong>企业Internet连接：</strong></p><p>企业连接选项与家庭用户选项有所不同。企业可能需要更<strong>高带宽、专用带宽和托管服务</strong>。可用连接选项取决于附近的服务提供商类型。</p><p><strong>专用租用线路：</strong> 租用线路是服务提供商网络内连接地理位置分散的办公室的保留电路，提供个人语音和/或数据网络。电路按月或按年租用。</p><p><strong>城域以太网：</strong>有时被称为以太网 WAN. 在本模块中，我们把它称为城域以太网。城域以太网将 LAN 访问技术扩展到 WAN 中。以太网是一种 LAN 技术，您将在后面的模块中学习。</p><p><strong>DSL：</strong>企业 DSL 提供各种格式。一种常见的选择是对称数字用户线路 (SDSL)，它类似于 DSL 的普通用户版本，但是提供<u>相同的上传和下载速度</u>。</p><p><strong>卫星：</strong>当有线解决方案不可用时，卫星服务可以提供连接。</p><p>连接选项取决于<u>地理位置和运营商</u>的可用性。</p><p><strong>融合网络：</strong></p><p><strong>传统的独立网络</strong></p><p>每个网络使用不同的技术传送通信信号，每个网络都有自己的一套规则和标准来确保成功通信，这些独立网络无法相互通信，多个服务在多个网络上运行。</p><p><strong>融合的网络</strong></p><p>与专用网络不同，融合网络能够通过相同的网络基础设施，在许多不同类型的设备之间传输数据、语音和视频。此网络基础设施采用一组相同的规则、协议和实施标准。融合数据网络在一个网络中传送多种服务。</p><p><strong>网络结构：</strong></p><p>指支持基础设施的技术以及通过该网络传输数据的编程服务及规则或协议</p><p>网络可靠性的四个方面：</p><p><strong>容错能力，可扩展能力，服务质量（QoS），安全性</strong></p><p><strong>1、容错能力</strong></p><p>容错网络是在发生故障时限制受影响设备数量的网络。这种网络能够在发生故障时快速恢复。这些网络依赖于消息的源与目的地之间的多条路径。如果一条路径失败，消息将立即通过不同的链路发送。有多条路径到达目的地被称为<strong>冗余</strong>。</p><p>实施<strong>分组交换网络</strong>是可靠网络提供冗余的一种方法。分组交换将流量分割成通过共享网络发送的数据包。</p><p>单个消息，例如一份电子邮件或一段视频流，会分割成多个消息块，称为数据包。每个数据包拥有所需的消息源和目的地的编址信息。网络内的路由器基于当时的网络状况交换数据包。</p><p>这意味着，单个消息中的所有数据包，可能会采用完全不同的路径到达目的地。</p><p><strong>2、可扩展性</strong></p><p>可扩展的网络可以快速扩展，以支持新用户和应用程序。它不会降低现有用户正在访问的服务的性能。</p><p><strong>3、服务质量</strong></p><p>随着数据、语音和视频内容不断融合到同一网络上，QoS 成为了用于管理拥塞和确保向所有用户可靠传输内容的主要机制。</p><p>当带宽需求超过可用量时，就会造成拥塞。网络带宽用一秒内传输的位数进行衡量，或表示为位/秒 (bps)。在尝试通过网络实现并发通信时，网络带宽需求可能超过可用范围，从而造成网络拥塞。</p><p>如果流量规模大于可通过网络传输的量，设备会将数据包保存在内存中，直至有资源可以传输它们。</p><p><strong>4、网络安全</strong></p><p>网络基础设施安全和信息安全</p><p>一方面要保护提供网络连接的设备的安全，另一方面要防止有人未经授权访问网络上的管理软件</p><p>网络管理员还必须保护通过网络传输的数据包中包含的信息和联网设备中存储的信息。为了实现网络安全性目标，需要满足三个主要要求：</p><ul><li><strong>机密性</strong> - 数据机密性意味着只有预定和授权收件人可以访问并读取数据。</li><li><strong>完整性</strong> - 数据完整性表示保证信息在从源到目的地的传输过程中不会被更改。</li><li><strong>可用性</strong> - 数据可用性表示保证授权用户及时可靠地访问数据服务。</li></ul><p><strong>网络趋势：</strong></p><p>新的网络趋势：<strong>自带设备（BYOD，Bring Your Own Device），在线协作，视频通信，云计算</strong></p><p><strong>1、自带设备（BYOD）：</strong></p><p>BYOD 使最终用户能够自由地使用个人工具通过企业或园区网络访问信息和相互通信，意味着设备由任何使用者在任意地点使用。</p><p><strong>2、在线协作：</strong></p><p>人们连接网络的目的并不只是访问数据应用程序，还有与他人进行协作。协作的定义是“与合办项目中的其他人合作的行为”。</p><p><strong>3、视频通信：</strong></p><p>顾名思义</p><p><strong>4、云计算：</strong></p><p>云计算是我们访问和存储数据的方式之一。云计算使我们可以在互联网上存储个人文件，甚至可以在服务器上备份整个硬盘驱动器。使用云可以访问文字处理和图片编辑等应用程序。</p><p>数据中心是用于容纳计算机系统和相关组件的设施。</p><p>云提供商通常将数据存储在分布式数据中心中</p><table><thead><tr><th align="left">云类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><strong>公有云</strong></td><td align="left">在公有云中提供的云应用和云服务， 可供大众使用。服务可能免费，也可能按 即用即付模式提供，比如按在线存储付费。公有 云利用互联网提供服务。</td></tr><tr><td align="left"><strong>私有云</strong></td><td align="left">私有云提供的基于云的应用和服务专供 特定组织或实体（例如政府）使用。私有 云可以使用组织的私有网络来搭建， 虽然构建和维护私有云的成本很高。私有 云也可以由具有严格访问安全控制的外部组织 管理。</td></tr><tr><td align="left"><strong>混合云</strong></td><td align="left">混合云由两个或多个云组成（例如：部分私有， 部分公共），其中每个部分仍然是一个不同的对象，但两者都 使用单一架构进行连接。混合云中的个人 将能够根据用户访问权限对各种服务进行 不同程度的访问。</td></tr><tr><td align="left"><strong>社区云</strong></td><td align="left">社区云是专为特定实体或组织使用而创建的。公共云和社区云之间的区别在于为团体定制的功能需求。例如，医疗机构必须遵从要求特殊身份验证和保密性的政策与法律（比如 HIPAA）。社区云由具有类似需求和关注的多个组织使用。社区云类似于公共云环境，但是具有一定级别的安全性、隐私性，甚至具有私有云的法规合规性。</td></tr></tbody></table><p><strong>家庭中的技术趋势：</strong></p><p>智能家庭技术，它集成在日常设备中，允许它们与其他设备互连，从而使日常设备更加“智能”或自动化。</p><p><strong>电力线网络</strong></p><p><strong>无线宽带：</strong></p><p><strong>无线互联网服务提供商</strong> (WISP，Wireless Internet Service Provider) 是使用类似家庭无线局域网 (WLAN) 的无线技术，将用户连接到专用的接入点或热点的 ISP。</p><p><strong>无线宽带服务</strong></p><p><strong>安全威胁：</strong></p><p><strong>几种常见外部威胁：</strong></p><ul><li><strong>病毒、蠕虫和特洛伊木马</strong> - 这些包括在用户设备上运行的恶意软件或代码。</li><li><strong>间谍软件和广告软件</strong> -这些是安装在用户设备上的软件类型。这些软件会秘密收集有关用户的信息。</li><li><strong>零日攻击（也称零小时攻击）</strong> - 在出现漏洞的第一天发起的攻击。</li><li><strong>威胁发起者攻击</strong> -恶意人员攻击用户设备或网络资源。</li><li><strong>拒绝服务攻击</strong> - 使网络设备上的应用和进程减缓或崩溃的攻击。</li><li><strong>数据拦截和盗窃</strong> - 通过公司网络捕获私人信息的攻击。</li><li><strong>身份盗窃</strong> - 窃取用户的登录凭证来访问私人数据的攻击。</li></ul><p><strong>安全解决方案：</strong></p><p>家庭或小型办公室网络的基本安全组件：</p><ul><li><strong>防病毒和反间谍软件</strong> - 这些应用帮助防止终端设备感染恶意软件。</li><li><strong>防火墙过滤</strong> -防火墙过滤阻止未经授权的进出网络访问。这可以是基于主机的防火墙系统，用于阻止未经授权访问终端设备，也可以是家用路由器上的基本过滤服务，用于阻止外部人员未经授权访问网络。</li></ul><p>大型网络和公司网络使用防病毒、反间谍软件和防火墙过滤，但它们也有其他安全要求:</p><ul><li><strong>专用防火墙系统</strong> -提供更高级的防火墙功能，更详细地过滤大量数据流。</li><li><strong>访问控制列表 (ACL， Access Control List )</strong> -基于IP地址和应用程序，进一步过滤访问和流量转发。</li><li><strong>入侵防御系统 (IPS，Intrusion Prevention System)</strong> - 识别快速扩散的威胁，例如零日攻击或零小时攻击。</li><li><strong>虚拟专用网络 (VPN，Virtual Private Network)</strong> - 为远程工作人员提供对组织机构的安全访问。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思科 网络 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go的基础语法学习</title>
      <link href="/2021/091932739.html"/>
      <url>/2021/091932739.html</url>
      
        <content type="html"><![CDATA[<h1 id="Go的简介"><a href="#Go的简介" class="headerlink" title="Go的简介"></a>Go的简介</h1><p>Go是一门<strong>编译语言</strong></p><p>它把所有的代码编译成一个可执行文件，在编译的过程中，Go编译器能够捕获一些错误</p><p>而Python等语言使用解释器，随着程序的运行，一个语句一个语句的进行翻译，这些是解释型语言</p><h1 id="Go的安装"><a href="#Go的安装" class="headerlink" title="Go的安装"></a>Go的安装</h1><p>1、go语言中文网下载安装包</p><p>2、打开vscode下载Go插件</p><p>3、部署Go代理</p><p>打开命令行，分别输入</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">go env -w GO111MODULE&#x3D;ongo env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>4、重启vscode（很重要！！！！不能忘）</p><p>5、在vscode中ctrl+shift+p，输入go，点开Go:Install/Update Tools全选所有安装包，点击确认</p><h1 id="Go的学习（一）"><a href="#Go的学习（一）" class="headerlink" title="Go的学习（一）"></a>Go的学习（一）</h1><p><strong>Print，Println 函数</strong></p><p>•可以传递若干个参数，之间用逗号分开。</p><p>•参数可以是字符串、数字、数学表达式等等。 </p><p>//println光标定位在下一行的开头</p><p><strong>格式化打印printf函数</strong></p><p>Printf 的第一个参数必须是字符串</p><p>•这个字符串里包含了像 %v 这样的格式化动词，它的值由第二个参数的值所代替。</p><p>•如果指定了多个格式化动词，那么它们的值由后边的参数值按其顺序进行替换。</p><p><strong>const：声明常量</strong></p><p><strong>var：声明变量</strong></p><p>go语言里++运算符只能放在后缀，而不能放在前缀</p><p><strong>使用 rand 包，可以生成伪随机数</strong></p><p>•例如，Intn 可以返回一个指定范围的随机整数</p><p>•import 的路径是 “math/rand”</p><p><strong>Boolean类型</strong></p><p>只有true和false两种情况</p><p><strong>strings.Contains函数</strong></p><p>•来自 strings 包的 Contains 函数可以判断某个字符串是否包含另外要给字符串</p><p><strong>使用 switch 做分支</strong></p><p>有一个 fallthrough 关键字，它用来执行下一个 case 的 body 部分。</p><p><strong>变量及作用域</strong></p><p>•在 Go 里面，作用域的范围就是 { } 之间的部分 </p><p><strong>短声明</strong></p><p>•count := 10</p><p>可以在无法使用 var 的地方使用，如if语句，for语句,switch语句中</p><p><strong>package 作用域</strong></p><p>若变量是在main函数外声明的，那么它拥有package作用域，如果 main package 有多个函数，那么该变量对它们都可见</p><p>注：短声明不可用来声明 package 作用域的变量</p><h1 id="Go的学习（二）"><a href="#Go的学习（二）" class="headerlink" title="Go的学习（二）"></a>Go的学习（二）</h1><h2 id="实数"><a href="#实数" class="headerlink" title="实数"></a>实数</h2><p><strong>声明浮点型变量</strong></p><p>只要数字含有小数部分，那么它的类型默认就是 float64</p><p>如果你使用一个整数来初始化某个变量，那么你必须指定它的类型为 float64，否则它就是一个整数类型</p><p><strong>浮点数类型</strong></p><p>Go 语言里有两种浮点数类型：</p><p><strong>•默认是 float64</strong></p><p>•64 位的浮点类型</p><p>•占用 8 字节内存</p><p>•某些编程语言把这种类型叫做 double（双精度）</p><p><strong>•float32</strong> </p><p>•占用 4 字节内存</p><p>•精度比 float64 低</p><p>有时叫做单精度类型</p><p><strong>零值</strong></p><p>•Go 里面每个类型都有一个默认值，它称作零值。</p><p>•当你声明变量却不对它进行初始化的时候，它的值就是零值。</p><p><strong>显示浮点类型</strong></p><p>•使用 Print 或 Println 打印浮点类型的时候，默认的行为是尽可能的多显示几位小数</p><p>如果你不想这样，那么你应该使用 Printf 函数，结合 %f 格式化动词来指定显示小数的位数</p><p><strong>%f 格式化动词</strong></p><p>•它由两部分组成：</p><p>•宽度：会显示出的最少字符个数（包含小数点和小数）</p><p>•如果宽度大于数字的个数，那么左边会填充空格</p><p>•如果没指定宽度，那么就按实际的位数进行显示</p><p>•精度：小数点后边显示的位数</p><p>•如果想使用 0 代替空格作为填充：</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%05.2f\n"</span><span class="token punctuation">,</span>third<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>浮点类型精度较低，不适合用于金融类计算为了尽量最小化舍入错误，建议先做乘法，再做除法</p><p><strong>整数</strong></p><p>Go 提供了 10 种整数类型：</p><p>•不可以存小数部分</p><p>•范围有限</p><p>•通常根据数值范围来选取整数类型</p><p>最常用的整数类型是 int，无符号整数类型是 uint</p><p><strong>打印数据类型</strong></p><p>•在 Printf 里使用 %T 就可以打印出数据的类型。</p><p><strong>打印十六进制</strong></p><p>•打印十六进制的数，使用 %x 格式化动词</p><p><strong>打印每个 bit</strong></p><p>•使用 %b 格式化动词</p><p>math 包里，为与架构无关的整数类型，定义了最大、最小值常量</p><h2 id="很大的数"><a href="#很大的数" class="headerlink" title="很大的数"></a>很大的数</h2><p><strong>使用big包</strong></p><p>如何把 24 x 1018 转化为 big.Int 类型？</p><p>•首先 new 一个 big.Int</p><p>•再通过 SetString 函数把数值的字符串形式，和几进制传递进行即可。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">distance <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>big<span class="token punctuation">.</span>Int<span class="token punctuation">)</span>distance<span class="token punctuation">.</span><span class="token function">SetString</span><span class="token punctuation">(</span><span class="token string">"24000000000000000000"</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>distance<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在 Go 里面，常量是可以无类型的（untyped），这种无类型的数值字面值就是由 big 包所支持的。这使你可以操作很大的数（超过18的10¹⁸）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span> distance <span class="token operator">=</span> <span class="token number">2400000000000000</span> #不会报错fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>distance<span class="token punctuation">)</span>  #会报错，因为<span class="token builtin">println</span>默认传入值为<span class="token builtin">int</span>类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>尽管 Go 编译器使用 big 包来处理无类型的数值常量，但是常量和 big.Int 的值是不能互换的。</p><p><strong>多语言文本</strong></p><p>字符串字面值/原始字符串字面值</p><p>•字符串字面值可以包含转义字符，例如 \n</p><p>•但如果你确实想得到 \n 而不是换行的话，可以使用 ` 来代替 “，这叫做原始字符串字面值。</p><p><strong>字符，code points，runes，bytes</strong></p><p>Unicode 联盟为超过 100 万个字符分配了相应的数值，这个数叫做 code point。</p><p>•为了表示这样的 unicode code point，Go 语言提供了 rune 这个类型，它是 int32 的一个类型别名。</p><p>•而 byte 是 uint8 类型的别名，目的是用于二进制数据。</p><p>•byte 倒是可以表示由 ASCII 定义的英语字符，它是 Unicode 的一个子集（共128个字符）</p><p><strong>类型别名</strong></p><p>类型别名就是同一个类型的另一个名字，所以，rune 和 int32 可以互换使用。</p><p>如果想打印字符而不是数值，使用 %c 格式化动词</p><p><strong>string</strong></p><p>•可一个给某个变量赋予不同的 string 值，但是 string 本身是不可变的</p><p>当字符串需要支持西班牙语，俄语，汉语等，应把字符解码成rune类型，然后再进行操作</p><p>•使用 utf-8 包，它提供可以按 rune 计算字符串长度的方法。</p><p>DecodeRuneInString 函数会返回第一个字符，以及字符所占的字节数。</p><p>RuneCountInString函数会返回按rune计算字符串的长度</p><p>使用 range 关键字，可以遍历各种集合</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">question <span class="token operator">:=</span><span class="token string">"abcdefg"</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>c <span class="token operator">:=</span><span class="token keyword">range</span> question <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v %c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span>c<span class="token operator">:=</span> <span class="token keyword">range</span> question <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%c "</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类型间转换</strong></p><p>连接两个字符串，可以使用 + 运算符，如果想连接字符串和数值，会报错</p><p>整型和浮点类型也不能混着用</p><p><strong>数值类型间的转换</strong></p><p>如果想把 age 转化成 浮点类型，需要使用目标类型将其“包裹”起来</p><p><strong>从浮点类型转为整数类型</strong></p><p>可以从浮点类型转化为整数类型，小数点后边的部分会被截断，而不是舍入</p><p>•无符号和有符号整数类型之间也需要转换</p><p>•不同大小的整数类型之间也需要转换</p><p>•可以通过 math 包提供的 max、min 常量，来判断转换的时候是否超过最大最小值</p><p><strong>字符串转换</strong></p><p>把 rune、byte 转化为 string</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> pi <span class="token builtin">rune</span> <span class="token operator">=</span> <span class="token number">960</span>fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>pi<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>想把数值转化为string，它的值必须能转化为 code point</p><p>可以用strconv 包的 Itoa 函数 （Integer to ASCII）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">str <span class="token operator">:=</span> <span class="token string">"Launch in T minus"</span> <span class="token operator">+</span> strconv<span class="token punctuation">.</span><span class="token function">Itoa</span><span class="token punctuation">(</span>countdown<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"seconds."</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>另外一种把数值转化为 string 的方式是使用 Sprintf 函数，和 Printf 略类似，但是会返回一个 string</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">countdown <span class="token operator">:=</span> <span class="token number">9</span>str <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Launch in T minus %v seconds."</span><span class="token punctuation">,</span>countdown<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>strconv 包里面还有个 Atoi（ASCII to Integer） 函数</p><p>由于字符串里面可能包含任意字符，或者要转换的数字字符串太大，所以 Atoi 函数可能会发生错误</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">countdown <span class="token punctuation">,</span>err <span class="token operator">:=</span> strconv<span class="token punctuation">.</span><span class="token function">Atoi</span><span class="token punctuation">(</span><span class="token string">"10"</span><span class="token punctuation">)</span><span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>countdown<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：Go 是静态类型语言，一旦某个变量被声明，那么它的类型就无法再改变了</p><p><strong>布尔类型的转换</strong></p><p>•Print 家族的函数，会把 bool 类型的值打印成 true/false 的文本</p><p>注意：如果你想使用 string(false), int(false)；bool(1), bool(“yes”) 等类似的方式进行转换，那么 Go 编译器会报错</p><p>某些语言里，经常把 1 和 0 当作 true 和 false，但是在 Go 里面不行</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn@1.7/go_func.png"></p><p><strong>声明新类型</strong></p><p>关键字 type 可以用来声明新类型</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> celsius <span class="token builtin">float64</span><span class="token keyword">var</span> temperature celsius <span class="token operator">=</span> <span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>可以将方法与同包中声明的任何类型相关联，但不可以是 int、float64 等预声明的类型进行关联。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> celsius <span class="token builtin">float64</span><span class="token keyword">type</span> kelvin <span class="token builtin">float64</span><span class="token keyword">func</span> <span class="token function">kelvinToCelsius</span><span class="token punctuation">(</span>k kelvin<span class="token punctuation">)</span> celsius <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">celsius</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">273.15</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>k kelvin<span class="token punctuation">)</span> <span class="token function">celsius</span><span class="token punctuation">(</span><span class="token punctuation">)</span> celsius<span class="token punctuation">&#123;</span>    <span class="token comment">//表示clesius是kelvin的一个方法</span><span class="token keyword">return</span> <span class="token function">celsius</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">273.15</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上例中，celsius 方法虽然没有参数。但它前面却又一个类型参数的接收者。</p><p>每个方法可以有多个参数，但只能有一个接收者。</p><p>在方法体中，接收者的行为和其它参数一样</p><p>调用：变量.方法()</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn@1.7/go_fangfa.png"></p><p><strong>闭包和匿名函数</strong></p><p>匿名函数就是没有名字的函数，在 Go 里也称作函数字面值。</p><p>因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的。</p><p>闭包（closure）就是由于匿名函数封闭并包围作用域中的变量而得名的。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"fmt"</span><span class="token keyword">type</span> kelvin <span class="token builtin">float64</span><span class="token comment">//sensor function type</span><span class="token keyword">type</span> sensor <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> kelvin<span class="token keyword">func</span> <span class="token function">realSensor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> kelvin <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">&#125;</span>fun <span class="token function">calibrate</span><span class="token punctuation">(</span>s sensor<span class="token punctuation">,</span>offset kelvin<span class="token punctuation">)</span> sensor<span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> kelvin <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token function">s</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> offset    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    sensor <span class="token operator">:=</span> <span class="token function">calibrate</span><span class="token punctuation">(</span>realSensor<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">sensor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go语言学习（三）"><a href="#Go语言学习（三）" class="headerlink" title="Go语言学习（三）"></a>Go语言学习（三）</h2><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> planets<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token builtin">string</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用复合字面值初始化数组</strong></p><p>复合字面值（composite literal）是一种给复合类型初始化的紧凑语法</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dwarfs <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"Ceres"</span><span class="token punctuation">,</span><span class="token string">"Pluto"</span><span class="token punctuation">,</span><span class="token string">"Haumea"</span><span class="token punctuation">,</span><span class="token string">"Makemake"</span><span class="token punctuation">,</span><span class="token string">"Eris"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在复合字面值里使用 … 作为数组的长度，这样 Go 编译器会为你算出数组的元素数量</p><p>无论哪种方式，数组的长度都是固定的。</p><h2 id="切片slice"><a href="#切片slice" class="headerlink" title="切片slice"></a>切片slice</h2><p>使用的是半开区间，例如 planets[0:4]，包含索引 0、1、2、3 对应的元素，不包括索引 4 对应的元素。</p><p>Go 里面很多函数都倾向于使用 slice 而不是数组作为参数。</p><p>想要获得与底层数组相同元素的 slice，那么可以使用 [:] 进行切分</p><p>切分数组并不是创建 slice 唯一的方法，可以直接声明 slice</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dwarfs <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"Ceres"</span><span class="token punctuation">,</span><span class="token string">"Pluto"</span><span class="token punctuation">,</span><span class="token string">"Haumea"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>append函数为内置函数，可以将元素添加到slice里面</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn@1.7/go_append.png"></p><p><strong>限制新建切片容量的三索引切分操作</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go">terrstrial <span class="token operator">:=</span> planets<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span>#新建含有四个元素的planets切片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当 slice 的容量不足以执行 append 操作时，Go 必须创建新数组并复制旧数组中的内容。</p><p>可以使用 make 函数对 slice 进行预分配</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">dwarfs <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>#新建长度为<span class="token number">0</span>，容量为<span class="token number">10</span>的切片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>•尽量避免额外的内存分配和数组复制操作。</p><p>声明 Printf、append 这样的可变参数函数，需要在函数的最后一个参数前面加上 … 符号。</p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 是 Go 提供的另外一种集合：</p><p>•它可以将 key 映射到 value。</p><p>•可快速通过 key 找到对应的 value</p><p>•它的 key 几乎可以是任何类型</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">#逗号与ok写法<span class="token keyword">if</span> moon<span class="token punctuation">,</span>ok <span class="token operator">:=</span> temperature<span class="token punctuation">[</span><span class="token string">"Moon"</span><span class="token punctuation">]</span><span class="token punctuation">;</span> ok<span class="token punctuation">&#123;</span>fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"On average the moon is %v \n"</span><span class="token punctuation">,</span>moon<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Where is the moon?"</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn@1.7/go_map.png"></p><p>map类型在赋值给新变量或传递至函数/方法的时候会创建相应的副本，即如果对原map里某个对象修改，则该副本也会被修改</p><p>•除非你使用复合字面值来初始化 map，否则必须使用内置的 make 函数来为 map 分配空间。</p><p>•创建 map 时，make 函数可接受一个或两个参数</p><p>第二个参数用于为指定数量的 key 预先分配空间</p><h1 id="Go语言学习（四）"><a href="#Go语言学习（四）" class="headerlink" title="Go语言学习（四）"></a>Go语言学习（四）</h1><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><p><strong>定义struct</strong></p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> location <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>lat<span class="token punctuation">,</span>long <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>通过复合字面值初始化 struct</strong></p><p>•两种形式：</p><p>•通过成对的字段和值进行初始化</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">opportunity <span class="token operator">:=</span> location<span class="token punctuation">&#123;</span>lat<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1.9462</span><span class="token punctuation">,</span> long<span class="token punctuation">:</span><span class="token number">354.4734</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>•按字段定义的顺序进行初始化</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">insight <span class="token operator">:=</span> location<span class="token punctuation">&#123;</span><span class="token number">4.5</span><span class="token punctuation">,</span><span class="token number">135.9</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>将 struct 编码为 JSON</strong></p><p>json 包的 Marshal 函数可以将 struct 中的数据转化为 JSON 格式</p><p>•Marshal 函数只会对 struct 中被导出的字段（大写字母开头）进行编码。</p><p>•Go 语言中的 json 包要求 struct 中的字段必须以大写字母开头，类似 CamelCase 驼峰型命名规范。</p><p><strong>但有时候我们需要 snake_case 蛇形命名规范，那么该怎么办？</strong></p><p>•可以为字段注明标签，使得 json 包在进行编码的时候能够按照标签里的样式修改字段名。（例子 21.10）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> location <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>lat <span class="token builtin">float64</span> <span class="token string">'json:"latitude"'</span>long <span class="token builtin">float64</span> <span class="token string">'json:"longitude"'</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Go-语言没有-class"><a href="#Go-语言没有-class" class="headerlink" title="Go 语言没有 class"></a>Go 语言没有 class</h2><p>Go 和其它经典语言不同，它没有 class，没有对象，也没有继承。但是 Go 提供了 struct 和方法。</p><p><strong>方法可以被关联到你声明的类型上</strong></p><p>•可以使用 struct 复合字面值来初始化你所要的数据。</p><p>但如果 struct 初始化的时候还要做很多事情，那就可以考虑写一个构造用的函数。</p><p>•Go 语言没有专用的构造函数，但以 new 或者 New 开头的函数，通常是用来构造数据的。例如 newPerson()，NewPerson()</p><p>小写字母开头只能在本包中使用，大写字母开头可以在别的包中使用</p><p>•有一些用于构造的函数的名称就是 New（例如 errors 包里面的 New 函数）。</p><p>Go 语言没有 class，但使用 struct 并配备几个方法也可以达到同样的效果。</p><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>•Go 通过结构体实现组合（composition）。</p><p>•Go 提供了“嵌入”（embedding）特性，它可以实现方法的转发（forwarding）</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> report <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>sol <span class="token builtin">int</span>temperature temperaturelocationlocation<span class="token punctuation">&#125;</span><span class="token keyword">type</span> temperature <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>high<span class="token punctuation">,</span> low celsius<span class="token punctuation">&#125;</span><span class="token keyword">type</span> location <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>lat<span class="token punctuation">,</span> long <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> celsius <span class="token builtin">float64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="转发方法"><a href="#转发方法" class="headerlink" title="转发方法"></a>转发方法</h2><p>•Go 可以通过 struct 嵌入 来实现方法的转发。</p><p>在 struct 中只给定字段类型，不给定字段名即可。</p><p>在 struct 中，可以转发任意类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> report <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>sol <span class="token builtin">int</span>temperature location<span class="token punctuation">&#125;</span> <span class="token comment">//temperature和location就是struct的嵌入</span><span class="token keyword">type</span> temperature <span class="token keyword">struct</span><span class="token punctuation">&#123;</span>high<span class="token punctuation">,</span> low celsius<span class="token punctuation">&#125;</span><span class="token keyword">type</span> location <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>lat<span class="token punctuation">,</span> long <span class="token builtin">float64</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> celsius <span class="token builtin">float64</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命名冲突时，其本身的方法比转发的方法优先级更高</p><p>•优先使用对象组合而不是类的继承。</p><p>•对传统的继承不是必需的；所有使用继承解决的问题都可以通过其它方法解决。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>•接口关注于类型可以做什么，而不是存储了什么。</p><p>•接口通过列举类型必须满足的一组方法来进行声明。</p><p>•在 Go 语言中，不需要显式声明接口。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">typpe talker <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span><span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> martian <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token punctuation">(</span>m martian<span class="token punctuation">)</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token string">"nack nack"</span><span class="token punctuation">&#125;</span><span class="token keyword">type</span> laser <span class="token builtin">int</span> <span class="token keyword">func</span> <span class="token punctuation">(</span>l laser<span class="token punctuation">)</span> <span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> strings<span class="token punctuation">.</span><span class="token function">Repeat</span><span class="token punctuation">(</span><span class="token string">"pew "</span><span class="token punctuation">,</span><span class="token function">int</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> shouter <span class="token punctuation">(</span>t talker<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    louder <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">ToUpper</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">talk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>louder<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>•为了复用，通常会把接口声明为类型。</p><p>•按约定，接口名称通常以 er 结尾。</p><p>•Go 标准库导出了很多只有单个方法的接口。</p><p>•Go 通过简单的、通常只有单个方法的接口……来鼓励组合而不是继承，这些接口在各个组件之间形成了简明易懂的界限。</p><h2 id="Go语言学习（五）"><a href="#Go语言学习（五）" class="headerlink" title="Go语言学习（五）"></a>Go语言学习（五）</h2><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>大致与c语言中的指针相似</p><p>•C 语言中的内存地址可以通过例如 address++ 这样的指针运算进行操作，但是在 Go 里面不允许这种不安全操作。</p><p>•和结构体一样，可以把 &amp; 放在数组的复合字面值前面来创建指向数组的指针。</p><p>数组在执行索引或切片操作时会自动解引用</p><p>•与 C 语言不一样，Go 里面数组和指针式两种完全独立的类型。</p><p>•Slice 和 map 的复合字面值前面也可以放置 &amp; 操作符，但是 Go 并没有为它们提供自动解引用的功能。</p><p>•Go 语言在变量通过点标记法进行调用的时候，自动使用 &amp; 取得变量的内存地址。</p><p><strong>内部指针</strong></p><p>•它用于确定结构体中指定字段的内存地址。</p><p>•&amp; 操作符不仅可以获得结构体的内存地址，还可以获得结构体中指定字段的内存地址。</p><p><strong>隐式的指针</strong></p><p>•map 就是一种隐式指针。</p><p><strong>slice 指向数组</strong></p><p>•每个 slice 内部都会被表示为一个包含 3 个元素的结构，它们分别指向：</p><p>•数组的指针</p><p>•slice 的容量</p><p>•slice 的长度</p><p>•当 slice 被直接传递至函数或方法时，slice 的内部指针就可以对底层数据进行修改。</p><p>指向 slice 的显式指针的唯一作用就是修改 slice 本身：slice 的长度、容量以及起始偏移量。</p><h2 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h2><p>nil即为其他语言中的NULL</p><p><strong>nil slice</strong></p><p>•如果 slice 在声明之后没有使用复合字面值或内置的 make 函数进行初始化，那么它的值就是 nil。</p><p>•幸运的是，range、len、append 等内置函数都可以正常处理值为 nil 的 slice。</p><p>•虽然空 slice 和值为 nil 的 slice 并不相等，但它们通常可以替换使用。</p><p><strong>nil map</strong></p><p>•和 slice 一样，如果 map 在声明后没有使用复合字面值或内置的 make 函数进行初始化，那么它的值将会是默认的 nil</p><p><strong>nil 接口</strong></p><p>•声明为接口类型的变量在未被赋值时，它的零值是 nil。</p><p>•对于一个未被赋值的接口变量来说，它的接口类型和值都是 nil，并且变量本身也等于 nil。</p><p>•当接口类型的变量被赋值后，接口就会在内部指向该变量的类型和值。</p><p>•在 Go 中，接口类型的变量只有在类型和值都为 nil 时才等于 nil。</p><p>•即使接口变量的值仍为 nil，但只要它的类型不是 nil，那么该变量就不等于 nil。</p><p><strong>处理错误</strong></p><p><strong>defer 关键字</strong></p><p>•使用 defer 关键字，Go 可以确保所有 deferred 的动作可以在函数返回前执行。</p><p>•可以 defer 任意的函数和方法。</p><p>•defer 并不是专门做错误处理的。</p><p>•defer 可以消除必须时刻惦记执行资源释放的负担</p><p><strong>New error</strong></p><p>•errors 包里有一个构造用 New函数，它接收 string 作为参数用来表示错误信息。该函数返回 error 类型。</p><p><strong>自定义错误类型</strong></p><p>•error 类型是一个内置的接口：任何类型只要实现了返回 string 的 Error() 方法就满足了该接口。</p><p>•可以创建新的错误类型。</p><p>•按照惯例，自定义错误类型的名字应以 Error 结尾。</p><p><strong>类型断言</strong></p><p>•使用类型断言，你可以把接口类型转化成底层的具体类型。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">err<span class="token punctuation">.</span><span class="token punctuation">(</span>SudokuRrror<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如何 panic</p><p>•Go 里有一个和其他语言异常类似的机制：panic，但它很少出现。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go">#创建<span class="token builtin">panic</span><span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"I forgot my towel"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>错误值、panic、os.Exit ?</p><p>•通常，更推荐使用错误值，其次才是 panic。</p><p>•panic 比 os.Exit 更好：panic 后会执行所有 defer 的动作，而 os.Exit 则不会。</p><p>recover函数</p><p>•为了防止 panic 导致程序崩溃，Go 提供了 recover 函数。</p><p>•defer 的动作会在函数返回前执行，即使发生了 panic。</p><p>•但如果 defer 的函数调用了 recover，panic 就会停止，程序将继续运行。</p><h1 id="Go语言学习（六）"><a href="#Go语言学习（六）" class="headerlink" title="Go语言学习（六）"></a>Go语言学习（六）</h1><h2 id="goroutine-和并发（concurrent）"><a href="#goroutine-和并发（concurrent）" class="headerlink" title="goroutine 和并发（concurrent）"></a>goroutine 和并发（concurrent）</h2><p><strong>goroutine</strong></p><p>•在 Go 中，独立的任务叫做 goroutine</p><p>•虽然 goroutine 与其它语言中的协程、进程、线程都有相似之处，但 goroutine 和它们并不完全相同</p><p>•Goroutine 创建效率非常高</p><p>•Go 能直截了当的协同多个并发（concurrent）操作</p><p>•在某些语言中，将顺序式代码转化为并发式代码需要做大量修改</p><p>•在 Go 里，无需修改现有顺序式的代码，就可以通过 goroutine 以并发的方式运行任意数量的任务。</p><p><strong>只需在调用前面加一个 go 关键字即可启动goroutine</strong></p><p>•每次使用 go 关键字都会产生一个新的 goroutine。</p><p>•表面上看，goroutine 似乎在同时运行，但由于计算机处理单元有限，其实技术上来说，这些 goroutine 不是真的在同时运行。</p><p>•计算机处理器会使用“分时”技术，在多个 goroutine 上轮流花费一些时间。</p><p>•在使用 goroutine 时，各个 goroutine 的执行顺序无法确定。</p><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">&#123;</span><span class="token keyword">go</span> <span class="token function">sleepyGopher</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">&#125;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token keyword">func</span> <span class="token function">sleepyGopher</span><span class="token punctuation">(</span>id <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"... snore ..."</span><span class="token punctuation">,</span>id<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="通道-channel"><a href="#通道-channel" class="headerlink" title="通道 channel"></a>通道 channel</h2><p>•通道（channel）可以在多个 goroutine 之间安全的传值。</p><p>•通道可以用作变量、函数参数、结构体字段…</p><p>•创建通道用 make 函数，并指定其传输数据的类型</p><p>• c := make(chan int)</p><h2 id="通道channel发送，接受"><a href="#通道channel发送，接受" class="headerlink" title="通道channel发送，接受"></a>通道channel发送，接受</h2><p>•使用左箭头操作符 &lt;- 向通道发送值 或 从通道接收值</p><p>•向通道发送值：c &lt;- 99</p><p>•从通道接收值：r := &lt;- c</p><p>•发送操作会等待直到另一个 goroutine 尝试对该通道进行接收操作为止。</p><p>•执行发送操作的 goroutine 在等待期间将无法执行其它操作</p><p>•未在等待通道操作的 goroutine 让然可以继续自由的运行</p><p>•执行接收操作的 goroutine 将等待直到另一个 goroutine 尝试向该通道进行发送操作为止。</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn@1.7/go_channel.png"></p><p><strong>使用 select 处理多个通道</strong></p><p>•等待不同类型的值。</p><p>•time.After 函数，返回一个通道，该通道在指定时间后会接收到一个值（发送该值的 goroutine 是 Go 运行时的一部分）。</p><p>•select 和 switch 有点像。</p><p>•该语句包含的每个 case 都持有一个通道，用来发送或接收数据。</p><p>•select 会等待直到某个 case 分支的操作就绪，然后就会执行该 case 分支。</p><p>•注意：即使已经停止等待 goroutine，但只要 main 函数还没返回，仍在运行的 goroutine 将会继续占用内存。</p><p>•select 语句在不包含任何 case 的情况下将永远等下去。</p><h2 id="nil-通道"><a href="#nil-通道" class="headerlink" title="nil 通道"></a>nil 通道</h2><p>•如果不使用 make 初始化通道，那么通道变量的值就是 nil（零值）</p><p>•对 nil 通道进行发送或接收不会引起 panic，但会导致永久阻塞。</p><p>•对 nil 通道执行 close 函数，那么会引起 panic</p><p>•nil 通道的用处：</p><p>•对于包含 select 语句的循环，如果不希望每次循环都等待 select 所涉及的所有通道，那么可以先将某些通道设为 nil，等到发送值准备就绪之后，再将通道变成一个非 nil 值并执行发送操作。</p><h2 id="阻塞和死锁"><a href="#阻塞和死锁" class="headerlink" title="阻塞和死锁"></a>阻塞和死锁</h2><p>•当 goroutine 在等待通道的发送或接收时，我们就说它被阻塞了。</p><p>•除了 goroutine 本身占用少量的内存外，被阻塞的 goroutine 并不消耗任何其它资源。</p><p>•goroutine 静静的停在那里，等待导致其阻塞的事情来解除阻塞。</p><p>•当一个或多个 goroutine 因为某些永远无法发生的事情被阻塞时，我们称这种情况为死锁。而出现死锁的程序通常会崩溃或挂起。</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>•Go 允许在没有值可供发送的情况下通过 close 函数关闭通道</p><p>•例如 close(c)</p><p>•通道被关闭后无法写入任何值，如果尝试写入将引发 panic。</p><p>•尝试读取被关闭的通道会获得与通道类型对应的零值。</p><p>•注意：如果循环里读取一个已关闭的通道，并没检查通道是否关闭，那么该循环可能会一直运转下去，耗费大量 CPU 时间</p><p>•执行以下代码可得知通道是否被关闭：</p><p>•v, ok := &lt;- c</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bresenham算法斜率各种情况</title>
      <link href="/2021/091249915.html"/>
      <url>/2021/091249915.html</url>
      
        <content type="html"><![CDATA[<h1 id="Bresenham算法总结"><a href="#Bresenham算法总结" class="headerlink" title="Bresenham算法总结"></a>Bresenham算法总结</h1><p>注：</p><p>1、y(i+1)指的是y右下角标为i+1，yi指的是y右下角标为i</p><p>2、y=mx+b</p><p>3、△x，△y均为后减前</p><p>4、d1为（xi+1，yi）到直线的距离，d2为（xi+1，yi+/-1）到直线的距离</p><h2 id="0-lt-m-lt-1"><a href="#0-lt-m-lt-1" class="headerlink" title="0&lt;m&lt;1"></a>0&lt;m&lt;1</h2><table><thead><tr><th>初始：   p0=2△y-△x</th></tr></thead><tbody><tr><td>当pk≥0时：x(i+1)=xi+1          y(i+1)=yi+1         p(i+1)=pi+2△y-2△x</td></tr><tr><td>否则：x(i+1)=xi+1         y(i+1)=yi       p(i+1)=pi+2△y</td></tr></tbody></table><h2 id="m-gt-1"><a href="#m-gt-1" class="headerlink" title="m&gt;1"></a>m&gt;1</h2><table><thead><tr><th>初始： p0=2△x-△y</th></tr></thead><tbody><tr><td>当pk≥0时：x(i+1)=xi+1          y(i+1)=yi+1         p(i+1)=pi+2△x-2△y</td></tr><tr><td>否则：x(i+1)=xi         y(i+1)=yi+1      p(i+1)=pi+2△x</td></tr></tbody></table><h2 id="1-lt-m-lt-0"><a href="#1-lt-m-lt-0" class="headerlink" title="-1&lt;m&lt;0"></a>-1&lt;m&lt;0</h2><table><thead><tr><th>初始：  p0=-2△y-△x</th></tr></thead><tbody><tr><td>当pk≥0时：x(i+1)=xi+1          y(i+1)=yi-1         p(i+1)=pi-2△y-2△x</td></tr><tr><td>否则：x(i+1)=xi+1         y(i+1)=yi       p(i+1)=pi-2△y</td></tr></tbody></table><h2 id="m-lt-1"><a href="#m-lt-1" class="headerlink" title="m&lt;-1"></a>m&lt;-1</h2><table><thead><tr><th>初始：  p0=-2△x-△y</th></tr></thead><tbody><tr><td>当pk≥0时：x(i+1)=xi+1          y(i+1)=yi-1         p(i+1)=pi-2△x-2△y</td></tr><tr><td>否则：x(i+1)=xi         y(i+1)=yi-1      p(i+1)=pi-2△x</td></tr></tbody></table><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>推导发现：m&gt;1时即为0&lt;m&lt;1时x变为y的情况，-1&lt;m&lt;0时即为0&lt;m&lt;1时y变为-y的情况</p>]]></content>
      
      
      <categories>
          
          <category> 图形与动画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（六）（完结）</title>
      <link href="/2021/090719033.html"/>
      <url>/2021/090719033.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习（六）"><a href="#MySQL学习（六）" class="headerlink" title="MySQL学习（六）"></a>MySQL学习（六）</h1><h2 id="事务（重点，非常重要）"><a href="#事务（重点，非常重要）" class="headerlink" title="事务（重点，非常重要）"></a>事务（重点，非常重要）</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>一个事务其实就是一个完整的<strong>业务逻辑</strong>。<br>是一个最小的工作单元。不可再分。</p><p>什么是一个完整的业务逻辑？<br>        假设转账，从A账户向B账户中转账10000.<br>        将A账户的钱减去10000（update语句）<br>        将B账户的钱加上10000（update语句）<br>        这就是一个完整的业务逻辑。</p><p>以上的操作是一个最小的工作单元，要么同时成功，要么同时失败，不可再分。<br>这两个update语句要求必须同时成功或者同时失败，这样才能保证钱是正确的。</p><h3 id="只有DML语句才会有事务这一说，其它语句和事务无关！！！"><a href="#只有DML语句才会有事务这一说，其它语句和事务无关！！！" class="headerlink" title="只有DML语句才会有事务这一说，其它语句和事务无关！！！"></a>只有DML语句才会有事务这一说，其它语句和事务无关！！！</h3><p>​    insert<br>​    delete<br>​    update<br>​    只有以上的三个语句和事务有关系，其它都没有关系。</p><p>因为 只有以上的三个语句是数据库表中数据进行增、删、改的。<br>只要你的操作一旦涉及到数据的增、删、改，那么就一定要考虑安全问题。</p><p>数据安全第一位！！！</p><h3 id="假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗"><a href="#假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗" class="headerlink" title="假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗"></a>假设所有的业务，只要一条DML语句就能完成，还有必要存在事务机制吗</h3><p>正是因为做某件事的时候，需要多条DML语句共同联合起来才能完成，所以需要事务的存在。如果任何一件复杂的事儿都能一条DML语句搞定，那么事务则没有存在的价值了。</p><p>到底什么是事务呢？<br>        说到底，说到本质上，一个事务其实就是多条DML语句同时成功，或者同时失败！<br>事务：就是批量的DML语句同时成功，或者同时失败！    </p><h3 id="事务是怎么做到多条DML语句同时成功和同时失败的呢？"><a href="#事务是怎么做到多条DML语句同时成功和同时失败的呢？" class="headerlink" title="事务是怎么做到多条DML语句同时成功和同时失败的呢？"></a>事务是怎么做到多条DML语句同时成功和同时失败的呢？</h3><p>InnoDB存储引擎：提供一组用来记录事务性活动的日志文件</p><p>事务开启了：<br>    insert<br>    insert<br>    insert<br>    delete<br>    update<br>    update<br>    update<br>事务结束了！</p><p>在事务的执行过程中，每一条DML的操作都会记录到“事务性活动的日志文件”中。<br>在事务的执行过程中，我们可以提交事务，也可以回滚事务。</p><p><strong>提交事务：</strong></p><p>清空事务性活动的日志文件，将数据全部彻底持久化到数据库表中。<br>提交事务标志着，事务的结束。并且是一种全部成功的结束。</p><p><strong>回滚事务：</strong></p><p>将之前所有的DML操作全部撤销，并且清空事务性活动的日志文件<br>回滚事务标志着，事务的结束。并且是一种全部失败的结束。</p><h3 id="怎么提交事务，怎么回滚事务："><a href="#怎么提交事务，怎么回滚事务：" class="headerlink" title="怎么提交事务，怎么回滚事务："></a>怎么提交事务，怎么回滚事务：</h3><p>提交事务：commit; 语句<br>回滚事务：rollback; 语句（回滚永远都是只能回滚到上一次的提交点！）</p><p>事务对应的英语单词是：transaction</p><p>mysql默认情况下是支持自动提交事务的。（自动提交）<br>            即每执行一条DML语句，则提交一次！</p><p>这种自动提交实际上是不符合我们的开发习惯，因为一个业务通常是需要多条DML语句共同执行才能完成的，为了保证数据<br>的安全，必须要求同时成功之后再提交，所以不能执行一条就提交一条。</p><p>怎么将mysql的自动提交机制关闭掉呢？<br>        先执行这个命令：start transaction;</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 演示事务 use bjpowernode; select * from dept_bak; start transaction; #关闭自动提交机制 insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;); insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;); select * from dept_bak; rollback; #回滚 select * from dept_bak; #提交事务 use bjpowernode; select * from dept_bak; start transaction; insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;); insert into dept_bak values(10,&#39;abc&#39;, &#39;tj&#39;); select * from dept_bak; commit ;  #提交 select * from dept_bak;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><p><strong>A：原子性</strong><br>        说明事务是最小的工作单元。不可再分。</p><p><strong>C：一致性</strong><br>        所有事务要求，在同一个事务当中，所有操作必须同时成功，或者同时失败，<br>        以保证数据的一致性。</p><p><strong>I：隔离性</strong><br>        A事务和B事务之间具有一定的隔离。<br>        教室A和教室B之间有一道墙，这道墙就是隔离性。<br>        A事务在操作一张表的时候，另一个事务B也操作这张表会怎样？</p><p>​        多线程并发访问同一张表</p><p><strong>D：持久性</strong><br>        事务最终结束的一个保障。事务提交，就相当于将没有保存到硬盘上的数据<br>        保存到硬盘上！</p><h4 id="重点研究一下事务的隔离性！！！"><a href="#重点研究一下事务的隔离性！！！" class="headerlink" title="重点研究一下事务的隔离性！！！"></a>重点研究一下事务的隔离性！！！</h4><p>A教室和B教室中间有一道墙，这道墙可以很厚，也可以很薄。这就是事务的<strong>隔离级别</strong>。这道墙越厚，表示隔离级别就越高。</p><p>事务和事务之间的隔离级别有哪些呢？4个级别</p><p><strong>读未提交：</strong>read uncommitted（最低的隔离级别）《没有提交就读到了》<br>            什么是读未提交？<br>                事务A可以读取到事务B未提交的数据。<br>            这种隔离级别存在的问题就是：<br>                脏读现象！(Dirty Read)<br>                我们称读到了脏数据。<br>            这种隔离级别一般都是理论上的，大多数的数据库隔离级别都是二档起步！</p><p><strong>读已提交：</strong>read committed《提交之后才能读到》<br>            什么是读已提交？<br>                事务A只能读取到事务B提交之后的数据。<br>            这种隔离级别解决了什么问题？<br>                解决了脏读的现象。<br>            这种隔离级别存在什么问题？<br>                不可重复读取数据。<br>                什么是不可重复读取数据呢？<br>                    在事务开启之后，第一次读到的数据是3条，当前事务还没有<br>                    结束，可能第二次再读取的时候，读到的数据是4条，3不等于4<br>                    称为不可重复读取。</p><p>​            这种隔离级别是比较真实的数据，每一次读到的数据是绝对的真实。<br>​            oracle数据库默认的隔离级别是：read committed</p><p><strong>可重复读：</strong>repeatable read《提交之后也读不到，永远读取的都是刚开启事务时的数据》<br>            什么是可重复读取？<br>                事务A开启之后，不管是多久，每一次在事务A中读取到的数据<br>                都是一致的。即使事务B将数据已经修改，并且提交了，事务A<br>                读取到的数据还是没有发生改变，这就是可重复读。<br>            可重复读解决了什么问题？<br>                解决了不可重复读取数据。<br>            可重复读存在的问题是什么？<br>                可以会出现幻影读。<br>                每一次读取到的数据都是幻象。不够真实！</p><p>​            早晨9点开始开启了事务，只要事务不结束，到晚上9点，读到的数据还是那样！<br>​            读到的是假象。不够绝对的真实。</p><p><strong>序列化/串行化：</strong>serializable（最高的隔离级别）<br>            这是最高隔离级别，效率最低。解决了所有的问题。<br>            这种隔离级别表示事务排队，不能并发！<br>            synchronized，线程同步（事务同步）<br>            每一次读取到的数据都是最真实的，并且效率是最低的。</p><h4 id="验证各种隔离级别"><a href="#验证各种隔离级别" class="headerlink" title="验证各种隔离级别"></a>验证各种隔离级别</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查看隔离级别SELECT @@tx_isolation<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>+—————–+<br>| @@tx_isolation  |<br>+—————–+<br>| REPEATABLE-READ |<br>+—————–+<br>mysql默认的隔离级别</p><p><strong>验证：read uncommited</strong></p><p>被测试的表t_user</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global transaction isolation level read uncommitted; #修改隔离级别为read uncommitted<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开两个窗口A和B分别进行事务A和事务B</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#第一步，事务Ause bjpowernode;#第二步，事务Buse bjpowernode;#第三步，事务Astart transaction;select * from t_user; #此时没有数据#第四步，事务Bstart transaction;insert into t_user values(&#39;zhangsan&#39;);#第五步，事务Aselect * from t_user; #此时B还未提交，A就能查到新添加的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证：read commited</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global transaction isolation level read committed;#修改隔离级别为read commited<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开两个窗口A和B分别进行事务A和事务B</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#Ause bjpowernode;#Buse bjpowernode;#Astart transaction;#Bstart transaction;#Aselect * from t_user; #此时为空#Binsert into t_user values(&#39;zhangsan&#39;);#Aselect * from t_user; #此时仍为空#Bcommit;#Aselect * from t_user; #B提交后A才能查到数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证：repeatable read</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global transaction isolation level repeatable read;#修改隔离级别为repeatable read<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开两个窗口A和B分别进行事务A和事务B</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#Ause bjpowernode;#Buse bjpowernode;#Astart transaction;#Bstart transaction;#Aselect * from t_user;    #此时读取结果为空#Binsert into t_user values(&#39;lisi&#39;);insert into t_user values(&#39;wangwu&#39;);commit;#Aselect * from t_user;   #此时读取结果仍为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>验证：serializable</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">set global transaction isolation level serializable;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开两个窗口A和B分别进行事务A和事务B</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#Ause bjpowernode;#Buse bjpowernode;#Astart transaction;#Bstart transaction;#Aselect * from t_user;    #此时读取结果为空insert into t_user values(&#39;abc&#39;);#Bselect * from t_user;    #此时光标会卡着不动，直到事务A进行commit;之后才会自动得到查询结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h2><h3 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h3><p>索引是在数据库表的字段上添加的，是为了提高查询效率存在的一种机制。<br>一张表的一个字段可以添加一个索引，当然，多个字段联合起来也可以添加索引。<br>索引相当于一本书的目录，是为了缩小扫描范围而存在的一种机制。</p><p>索引是各种数据库进行优化的重要手段。优化的时候优先考虑的因素就是索引。</p><p>对于一本字典来说，查找某个汉字有两种方式：<br>        第一种方式：一页一页挨着找，直到找到为止，这种查找方式属于全字典扫描。<br>        效率比较低。<br>        第二种方式：先通过目录（索引）去定位一个大概的位置，然后直接定位到这个位置，做局域性扫描，缩小扫描的范围，快速的查找。这种查找方式属于通过索引检索，效率较高。</p><p>t_user<br>    id(idIndex)    name(nameIndex)    email(emailIndex)        address  (emailAddressIndex)<br>    1                zhangsan…<br>    2                lisi<br>    3                wangwu<br>    4                zhaoliu<br>    5                hanmeimei<br>    6                jack</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from t_user where name &#x3D; &#39;jack&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上的这条SQL语句会去name字段上扫描，为什么？<br>        因为查询条件是：name=’jack’</p><p>如果name字段上没有添加索引（目录），或者说没有给name字段创建索引，<br>    MySQL会进行全扫描，会将name字段上的每一个值都比对一遍。效率比较低。</p><p>MySQL在查询方面主要就是两种方式：<br>        第一种方式：全表扫描<br>        第二种方式：根据索引检索。</p><p>在mysql当中，主键上，以及unique字段上都会自动添加索引的！！！！</p><p>注意：</p><p>​        在实际中，汉语字典前面的目录是排序的，按照a b c d e f….排序，<br>​        为什么排序呢？因为只有排序了才会有区间查找这一说！（缩小扫描范围<br>​        其实就是扫描某个区间罢了！）</p><p>​        在mysql数据库当中索引也是需要排序的，并且这个索引的排序和TreeSet<br>​        数据结构相同。TreeSet（TreeMap）底层是一个自平衡的二叉树！在mysql<br>​        当中索引是一个B-Tree数据结构。</p><p>遵循左小又大原则存放。采用中序遍历方式遍历取数据。</p><h3 id="索引的实现原理"><a href="#索引的实现原理" class="headerlink" title="索引的实现原理"></a>索引的实现原理</h3><p>id(PK)                    name                        每一行记录在硬盘上都有物理存储编号</p><p>​    100                        zhangsan                    0x1111<br>​    120                        lisi                                0x2222<br>​    99                          wangwu                      0x8888<br>​    88                          zhaoliu                        0x9999<br>​    101                        jack                              0x6666<br>​    55                          lucy                               0x5555<br>​    130                        tom                              0x7777</p><p>提醒1：在任何数据库当中主键上都会自动添加索引对象，id字段上自动有索引，因为id是PK。另外在mysql当中，一个字段上如果有unique约束的话，也会自动创建索引对象。</p><p>提醒2：在任何数据库当中，任何一张表的任何一条记录在硬盘存储上都有一个硬盘的物理存储编号。</p><p>提醒3：在mysql当中，索引是一个单独的对象，不同的存储引擎以不同的形式存在，在MyISAM存储引擎中，索引存储在一个.MYI文件中。在InnoDB存储引擎中索引存储在一个逻辑名称叫做tablespace的当中。在MEMORY存储引擎当中索引被存储在内存当中。不管索引存储在哪里，索引在mysql当中都是一个树的形式存在。（自平衡二叉树：B-Tree）</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/mysql_suoyin.jpg"></p><h3 id="什么条件下，我们会考虑给字段添加索引呢"><a href="#什么条件下，我们会考虑给字段添加索引呢" class="headerlink" title="什么条件下，我们会考虑给字段添加索引呢"></a>什么条件下，我们会考虑给字段添加索引呢</h3><p>条件1：数据量庞大（到底有多么庞大算庞大，这个需要测试，因为每一个硬件环境不同）<br>条件2：该字段经常出现在where的后面，以条件的形式存在，也就是说这个字段总是被扫描。<br>条件3：该字段很少的DML(insert delete update)操作。（因为DML之后，索引需要重新排序。）</p><p>建议不要随意添加索引，因为索引也是需要维护的，太多的话反而会降低系统的性能。<br>建议通过主键查询，建议通过unique约束的字段进行查询，效率是比较高的。</p><h3 id="索引怎么创建和删除"><a href="#索引怎么创建和删除" class="headerlink" title="索引怎么创建和删除"></a>索引怎么创建和删除</h3><p><strong>创建索引：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index emp_ename_index on emp(ename);#给emp表的ename字段添加索引，起名：emp_ename_index<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除索引：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop index emp_ename_index on emp;#将emp表上的emp_ename_index索引对象删除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索"><a href="#在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索" class="headerlink" title="在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索"></a>在mysql当中，怎么查看一个SQL语句是否使用了索引进行检索</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from emp where ename &#x3D; &#39;KING&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>得到：</p><p>+—-+————-+——-+——+—————+——+———+——+——+————-+<br>    | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br>    +—-+————-+——-+——+—————+——+———+——+——+————-+<br>    |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |<br>    +—-+————-+——-+——+—————+——+———+——+——+————-+<br>    扫描14条记录：说明没有使用索引。type=ALL</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index emp_ename_index on emp(ename);explain select * from emp where ename &#x3D; &#39;KING&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>+—-+————-+——-+——+—————–+—————–+———+——-+——+————-+<br>    | id | select_type | table | type | possible_keys   | key             | key_len | ref   | rows | Extra       |<br>    +—-+————-+——-+——+—————–+—————–+———+——-+——+————-+<br>    |  1 | SIMPLE      | emp   | ref  | emp_ename_index | emp_ename_index | 33      | const |    1 | Using where |<br>    +—-+————-+——-+——+—————–+—————–+———+——-+——+————-+</p><h3 id="什么时候索引会失效"><a href="#什么时候索引会失效" class="headerlink" title="什么时候索引会失效"></a>什么时候索引会失效</h3><p><strong>第一种情况：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from emp where ename like &#39;%T&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>ename上即使添加了索引，也不会走索引，为什么？<br>            原因是因为模糊匹配当中以“%”开头了！<br>            尽量避免模糊查询的时候以“%”开始。<br>            这是一种优化的手段/策略。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from emp where ename like &#39;%T&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>+—-+————-+——-+——+—————+——+———+——+——+————-+<br>| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br>+—-+————-+——-+——+—————+——+———+——+——+————-+<br>|  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |<br>+—-+————-+——-+——+—————+——+———+——+——+————-+</p><p>此时是全表扫描 type = ALL</p><p><strong>第2种情况：</strong></p><p>​        使用or的时候会失效，如果使用or那么要求or两边的条件字段都要有索引，才会走索引，如果其中一边有一个字段没有索引，那么另一个字段上的索引也会实现。所以这就是为什么不建议使用or的原因。</p><p>mysql&gt; explain select * from emp where ename = ‘KING’ or job = ‘MANAGER’;<br>        +—-+————-+——-+——+—————–+——+———+——+——+————-+<br>        | id | select_type | table | type | possible_keys   | key  | key_len | ref  | rows | Extra       |<br>        +—-+————-+——-+——+—————–+——+———+——+——+————-+<br>        |  1 | SIMPLE      | emp   | ALL  | emp_ename_index | NULL | NULL    | NULL |   14 | Using where |<br>        +—-+————-+——-+——+—————–+——+———+——+——+————-+</p><p>此时是全表扫描 type = ALL</p><p><strong>第3种情况：</strong></p><p>使用复合索引的时候，没有使用左侧的列查找，索引失效<br>        什么是复合索引？<br>            两个字段，或者更多的字段联合起来添加一个索引，叫做复合索引。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index emp_job_sal_index on emp(job,sal);explain select * from emp where job &#x3D; &#39;MANAGER&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +—-+————-+——-+——+——————-+——————-+———+——-+——+————-+<br>​        | id | select_type | table | type | possible_keys     | key               | key_len | ref   | rows | Extra       |<br>​        +—-+————-+——-+——+——————-+——————-+———+——-+——+————-+<br>​        |  1 | SIMPLE      | emp   | ref  | emp_job_sal_index | emp_job_sal_index | 30      | const |    3 | Using where |<br>​        +—-+————-+——-+——+——————-+——————-+———+——-+——+————-+</p><p>此时用到了索引，type = ref</p><p>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+</p><p>此时是全表扫描 type = ALL</p><p><strong>第4种情况：</strong></p><p>在where当中索引列参加了运算，索引失效。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create index emp_sal_index on emp(sal);explain select * from emp where sal &#x3D; 800;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +—-+————-+——-+——+—————+—————+———+——-+——+————-+<br>​        | id | select_type | table | type | possible_keys | key           | key_len | ref   | rows | Extra       |<br>​        +—-+————-+——-+——+—————+—————+———+——-+——+————-+<br>​        |  1 | SIMPLE      | emp   | ref  | emp_sal_index | emp_sal_index | 9       | const |    1 | Using where |<br>​        +—-+————-+——-+——+—————+—————+———+——-+——+————-+</p><p>此时用到了索引，type = ref</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from emp where sal+1 &#x3D; 800;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+</p><p>此时是全表扫描 type = ALL</p><p><strong>失效的第5种情况：</strong></p><p>在where当中索引列使用了函数</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">explain select * from emp where lower(ename) &#x3D; &#39;smith&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        | id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra       |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+<br>​        |  1 | SIMPLE      | emp   | ALL  | NULL          | NULL | NULL    | NULL |   14 | Using where |<br>​        +—-+————-+——-+——+—————+——+———+——+——+————-+</p><p>此时是全表扫描 type = ALL</p><h3 id="索引在数据库当中有哪些分类"><a href="#索引在数据库当中有哪些分类" class="headerlink" title="索引在数据库当中有哪些分类"></a>索引在数据库当中有哪些分类</h3><p>单一索引：一个字段上添加索引。<br>复合索引：两个字段或者更多的字段上添加索引。</p><p>主键索引：主键上添加索引。<br>唯一性索引：具有unique约束的字段上添加索引。</p><p>…</p><p>注意：唯一性比较弱的字段上添加索引用处不大。</p><h2 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h2><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p>view:站在不同的角度去看待同一份数据。</p><h3 id="怎么创建视图对象和删除视图对象"><a href="#怎么创建视图对象和删除视图对象" class="headerlink" title="怎么创建视图对象和删除视图对象"></a>怎么创建视图对象和删除视图对象</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#表复制create table dept2 as select * from dept;#创建视图对象create view dept2_view as select * from dept2;#删除视图对象drop view dept2_view;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注意：只有DQL语句才能以view的形式创建。<br>        create view view_name as 这里的语句必须是DQL语句;</p><h3 id="用视图做什么"><a href="#用视图做什么" class="headerlink" title="用视图做什么"></a>用视图做什么</h3><p>我们可以面向视图对象进行增删改查，对视图对象的增删改查，会导致原表被操作！（视图的特点：通过对视图的操作，会影响到原表数据。）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#面向视图查询select * from dept2_view; #面向视图插入insert into dept2_view(deptno,dname,loc) values(60,&#39;SALES&#39;, &#39;BEIJING&#39;);#查询原表数据select * from dept2; #原表的数据也会被插入#面向视图删除delete from dept2_view;#查询原表数据select * from dept2; #原表变为空<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对于表关联</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建视图对象create view emp_dept_viewasselect e.ename,e.sal,d.dnamefromemp ejoindept done.deptno &#x3D; d.deptno;#查询视图对象select * from emp_dept_view;#面向视图更新update emp_dept_view set sal &#x3D; 1000 where dname &#x3D; &#39;ACCOUNTING&#39;;#原表数据被更新select * from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="视图对象在实际开发中到底有什么用？（方便，简化开发，利于维护）"><a href="#视图对象在实际开发中到底有什么用？（方便，简化开发，利于维护）" class="headerlink" title="视图对象在实际开发中到底有什么用？（方便，简化开发，利于维护）"></a>视图对象在实际开发中到底有什么用？（方便，简化开发，利于维护）</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create view emp_dept_viewasselect e.ename,e.sal,d.dnamefromemp ejoindept done.deptno &#x3D; d.deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>假设有一条非常复杂的SQL语句，而这条SQL语句需要在不同的位置上反复使用。<br>        每一次使用这个sql语句的时候都需要重新编写，很长，很麻烦，怎么办？<br>            可以把这条复杂的SQL语句以视图对象的形式新建。<br>            在需要编写这条SQL语句的位置直接使用视图对象，可以大大简化开发。<br>            并且利于后期的维护，因为修改的时候也只需要修改一个位置就行，只需要<br>            修改视图对象所映射的SQL语句。</p><p>我们以后面向视图开发的时候，使用视图的时候可以像使用table一样。<br>        可以对视图进行增删改查等操作。视图不是在内存当中，视图对象也是存储在硬盘上的，不会消失。</p><p>再提醒一下：<br>            视图对应的语句只能是DQL语句。<br>            但是视图对象创建完成之后，可以对视图进行增删改查等操作。</p><p>小插曲：<br>            增删改查，又叫做：CRUD。<br>            CRUD是在公司中程序员之间沟通的术语。一般我们很少说增删改查。<br>            一般都说CRUD。</p><p>​            C:Create（增）<br>​            R:Retrive（查：检索）<br>​            U:Update（改）<br>​            D:Delete（删）</p><h3 id="DBA常用命令"><a href="#DBA常用命令" class="headerlink" title="DBA常用命令"></a>DBA常用命令</h3><p>重点掌握：</p><p>数据的导入和导出（数据的备份）<br>其它命令了解一下即可。（这个培训日志文档留着，以后忘了，可以打开文档复制粘贴。）</p><p><strong>数据导出：</strong></p><p>注意：在windows的dos命令窗口中：<br>            mysqldump bjpowernode&gt;D:\bjpowernode.sql -u root -p</p><p>可以导出指定的表吗？<br>            mysqldump bjpowernode emp&gt;D:\bjpowernode.sql -u root -p</p><p><strong>数据导入：</strong></p><p>​        注意：需要先登录到mysql数据库服务器上。<br>​        然后创建数据库：create database bjpowernode;<br>​        使用数据库：use bjpowernode<br>​        然后初始化数据库：source D:\bjpowernode.sql</p><h3 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h3><h4 id="什么是数据库设计范式"><a href="#什么是数据库设计范式" class="headerlink" title="什么是数据库设计范式"></a>什么是数据库设计范式</h4><p>数据库表的设计依据。教你怎么进行数据库表的设计。</p><h4 id="三个数据库设计范式"><a href="#三个数据库设计范式" class="headerlink" title="三个数据库设计范式"></a>三个数据库设计范式</h4><p><strong>第一范式：</strong>要求任何一张表必须有主键，每一个字段原子性不可再分。</p><p><strong>第二范式：</strong>建立在第一范式的基础之上，要求所有非主键字段完全依赖主键，不要产生部分依赖。</p><p><strong>第三范式：</strong>建立在第二范式的基础之上，要求所有非主键字段直接依赖主键，不要产生传递依赖。</p><p>声明：三范式是面试官经常问的，所以一定要熟记在心！</p><p>设计数据库表的时候，按照以上的范式进行，可以避免表中数据的冗余，空间的浪费。</p><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>最核心，最重要的范式，所有表的设计都需要满足。<br>必须有主键，并且每一个字段都是原子性不可再分。</p><p>学生编号 学生姓名 联系方式<br>    1001        张三        <a href="mailto:&#122;&#115;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#122;&#115;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;</a>,1359999999<br>    1002        李四        <a href="mailto:&#108;&#x73;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;">&#108;&#x73;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a>,13699999999<br>    1001        王五        <a href="mailto:&#119;&#x77;&#64;&#49;&#x36;&#51;&#x2e;&#110;&#101;&#116;">&#119;&#x77;&#64;&#49;&#x36;&#51;&#x2e;&#110;&#101;&#116;</a>,13488888888</p><p>以上是学生表，满足第一范式吗？<br>        不满足，第一：没有主键。第二：联系方式可以分为邮箱地址和电话</p><p>学生编号(pk) 学生姓名    邮箱地址            联系电话<br>    1001                张三        <a href="mailto:&#x7a;&#x73;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;">&#x7a;&#x73;&#64;&#x67;&#x6d;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a>    1359999999<br>    1002                李四        <a href="mailto:&#x6c;&#115;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;">&#x6c;&#115;&#x40;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a>    13699999999<br>    1003                王五        <a href="mailto:&#x77;&#119;&#64;&#49;&#54;&#51;&#x2e;&#x6e;&#x65;&#x74;">&#x77;&#119;&#64;&#49;&#54;&#51;&#x2e;&#x6e;&#x65;&#x74;</a>        13488888888</p><h5 id="第二范式："><a href="#第二范式：" class="headerlink" title="第二范式："></a>第二范式：</h5><p>建立在第一范式的基础之上，要求所有非主键字段必须完全依赖主键，不要产生部分依赖。        </p><p>学生编号    学生姓名   教师编号 教师姓名<br>    1001            张三        001        王老师<br>    1002            李四        002        赵老师<br>    1003            王五        001        王老师<br>    1001            张三        002        赵老师</p><p>这张表描述了学生和老师的关系：（1个学生可能有多个老师，1个老师有多个学生）<br>    这是非常典型的：多对多关系！</p><p>分析以上的表是否满足第一范式？<br>        不满足第一范式。</p><p>怎么满足第一范式呢？修改</p><p>学生编号+教师编号(pk)        学生姓名  教师姓名</p><p>​    1001            001                张三            王老师<br>​    1002            002                李四            赵老师<br>​    1003            001                王五            王老师<br>​    1001            002                张三            赵老师</p><p>学生编号 教师编号，两个字段联合做主键，复合主键（PK: 学生编号+教师编号）<br>    经过修改之后，以上的表满足了第一范式。但是满足第二范式吗？<br>        不满足，“张三”依赖1001，“王老师”依赖001，显然产生了部分依赖。<br>        产生部分依赖有什么缺点？<br>            数据冗余了。空间浪费了。“张三”重复了，“王老师”重复了。</p><p>为了让以上的表满足第二范式，你需要这样设计：<br>        使用三张表来表示多对多的关系！！！！</p><p>学生表<br>        学生编号(pk)        学生名字</p><p>​        1001                    张三<br>​        1002                    李四<br>​        1003                    王五</p><p>教师表<br>        教师编号(pk)        教师姓名</p><p>​        001                    王老师<br>​        002                    赵老师</p><p>学生教师关系表<br>        id(pk)            学生编号(fk)            教师编号(fk)</p><p>​        1                        1001                        001<br>​        2                        1002                        002<br>​        3                        1003                        001<br>​        4                        1001                        002</p><p>背口诀：多对多怎么设计？<br>            <strong>多对多，三张表，关系表两个外键</strong>！！！！！！！！！！！！！！！</p><h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><p>​    第三范式建立在第二范式的基础之上<br>​    要求所有非主键字典必须直接依赖主键，不要产生传递依赖。</p><p>学生编号（PK） 学生姓名 班级编号     班级名称<br>        1001                张三        01            一年一班<br>        1002                李四        02            一年二班<br>        1003                王五        03            一年三班<br>        1004                赵六        03            一年三班</p><p>以上表的设计是描述：班级和学生的关系。很显然是1对多关系！<br>            如一个教室中有多个学生。</p><p>分析以上表是否满足第一范式？<br>        满足第一范式，有主键。</p><p>分析以上表是否满足第二范式？<br>        满足第二范式，因为主键不是复合主键，没有产生部分依赖。主键是单一主键。</p><p>分析以上表是否满足第三范式？<br>        第三范式要求：不要产生传递依赖！<br>        一年一班依赖01，01依赖1001，产生了传递依赖。<br>        不符合第三范式的要求。产生了数据的冗余。</p><p>那么应该怎么设计一对多呢</p><p>班级表：一<br>        班级编号(pk)                班级名称<br>        01                                一年一班<br>        02                                一年二班<br>        03                                一年三班</p><p>学生表：多</p><p>学生编号（PK） 学生姓名 班级编号(fk)<br>        1001                张三            01<br>        1002                李四            02<br>        1003                王五            03<br>        1004                赵六            03</p><p>背口诀：<br>            <strong>一对多，两张表，多的表加外键</strong>！！！！！！！！！！！！</p><h5 id="总结表的设计"><a href="#总结表的设计" class="headerlink" title="总结表的设计"></a>总结表的设计</h5><p>一对多：一对多，两张表，多的表加外键！！！！！！！！！！！！</p><p>多对多：多对多，三张表，关系表两个外键！！！！！！！！！！！！！！！</p><p>一对一：</p><p>一对一放到一张表中不就行了吗？为啥还要拆分表？<br>        在实际的开发中，可能存在一张表字段太多，太庞大。这个时候要拆分表。<br>        一对一怎么设计？</p><p>没有拆分表之前：一张表<br>                t_user<br>                id        login_name        login_pwd        real_name        email                address……..</p><p>​                1            zhangsan        123                张三                zhangsan@xxx<br>​                2            lisi            123                李四                lisi@xxx<br>​                …</p><p>这种庞大的表建议拆分为两张：<br>                t_login 登录信息表<br>                id(pk)        login_name        login_pwd    </p><p>​                1                zhangsan        123<br>​                2                lisi            123</p><p>​                t_user 用户详细信息表<br>​                id(pk)        real_name        email                address……..    login_id(fk+unique)</p><p>​                100            张三                zhangsan@xxx                                1<br>​                200            李四                lisi@xxx                                            2</p><p>口诀：一对一，外键唯一！！！！！！！！！！</p><h5 id="嘱咐："><a href="#嘱咐：" class="headerlink" title="嘱咐："></a>嘱咐：</h5><p>数据库设计三范式是理论上的。</p><p>实践和理论有的时候有偏差。</p><p>最终的目的都是为了满足客户的需求，有的时候会拿冗余换执行速度。</p><p>因为在sql当中，表和表之间连接次数越多，效率越低。（笛卡尔积）</p><p>有的时候可能会存在冗余，但是为了减少表的连接次数，这样做也是合理的，并且对于开发人员来说，sql语句的编写难度也会降低。</p><p>面试的时候把这句话说上：他就不会认为你是初级程序员了！</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（五）</title>
      <link href="/2021/09053228.html"/>
      <url>/2021/09053228.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习（五）"><a href="#MySQL学习（五）" class="headerlink" title="MySQL学习（五）"></a>MySQL学习（五）</h1><h2 id="补充增删改查"><a href="#补充增删改查" class="headerlink" title="补充增删改查"></a>补充增删改查</h2><p> <strong>insert语句可以一次插入多条记录吗？【掌握】</strong></p><p>可以</p><pre class="line-numbers language-none"><code class="language-none">insert into t_user(id,name,birth,create_time) values(1,&#39;zs&#39;,&#39;1980-10-11&#39;,now()), (2,&#39;lisi&#39;,&#39;1981-10-11&#39;,now()),(3,&#39;wangwu&#39;,&#39;1982-10-11&#39;,now());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>语法：insert into t_user(字段名1,字段名2) values(),(),(),();</p><p><strong>快速创建表【了解内容】</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table emp2 as select * from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>原理：<br>        将一个查询结果当做一张表新建！！！！！<br>        这个可以完成表的快速复制！！！！<br>        表创建出来，同时表中的数据也存在了！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table mytable as select empno,ename from emp where job &#x3D; &#39;MANAGER&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>将查询结果插入到一张表当中？insert相关的！！！【了解内容】</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table dept_bak as select * from dept;select * from dept_bak;insert into dept_bak select * from dept; #很少用！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>快速删除表中的数据</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">delete from dept_bak;  #这种删除数据的方式比较慢。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>delete语句删除数据的原理？（delete属于DML语句！！！）<br>        表中的数据被删除了，但是这个数据在硬盘上的真实存储空间不会被释放！！！<br>        这种删除缺点是：删除效率比较低。<br>        这种删除优点是：支持回滚，后悔了可以再恢复数据！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">truncate table dept_bak; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>truncate语句删除数据的原理？（这种操作属于DDL操作。）<br>        这种删除效率比较高，表被一次截断，物理删除。<br>        这种删除缺点：不支持回滚。<br>        这种删除优点：快速。</p><p><strong>【truncate比较重要，必须掌握】</strong></p><p>如果有上亿条记录的大表</p><p>删除的时候，使用delete，也许需要执行1个小时才能删除完！效率较低。<br>可以选择使用truncate删除表中的数据。只需要不到1秒钟的时间就删除结束。效率较高。<br>但是使用truncate之前，必须仔细询问客户是否真的要删除，并警告删除之后不可恢复！</p><p>truncate是删除表中的数据，表还在！</p><p><strong>删除表操作</strong></p><p>drop table 表名; </p><p>这不是删除表中的数据，这是把表删除。</p><h2 id="表结构的增删改"><a href="#表结构的增删改" class="headerlink" title="表结构的增删改"></a>表结构的增删改</h2><p>对表结构的修改:添加一个字段，删除一个字段，修改一个字段！！！</p><p>对表结构的修改需要使用：alter（属于DDL语句）</p><p>DDL包括：create drop alter</p><p>第一：在实际的开发中，需求一旦确定之后，表一旦设计好之后，很少的<br>    进行表结构的修改。因为开发进行中的时候，修改表结构，成本比较高。<br>    修改表的结构，对应的java代码就需要进行大量的修改。成本是比较高的。<br>    这个责任应该由设计人员来承担！</p><p>第二：由于修改表结构的操作很少，所以我们不需要掌握，如果有一天<br>    真的要修改表结构，你可以使用工具！！！！</p><p>修改表结构的操作是不需要写到java程序中的。实际上也不是java程序员的范畴。</p><h2 id="约束（非常重要）"><a href="#约束（非常重要）" class="headerlink" title="约束（非常重要）"></a>约束（非常重要）</h2><h3 id="什么是约束"><a href="#什么是约束" class="headerlink" title="什么是约束"></a>什么是约束</h3><p>在创建表的时候，我们可以给表中的字段加上一些约束，来保证这个表中数据的完整性、有效性！！！</p><p>约束的作用就是为了保证：表中的数据有效！！</p><h3 id="约束包括哪些"><a href="#约束包括哪些" class="headerlink" title="约束包括哪些"></a>约束包括哪些</h3><p>非空约束：not null<br>唯一性约束: unique<br>主键约束: primary key （简称PK）<br>外键约束：foreign key（简称FK）<br>检查约束：check（mysql不支持，oracle支持）</p><p>我们这里重点学习四个约束：<br>        not null<br>        unique<br>        primary key<br>        foreign key</p><h3 id="非空约束：not-null"><a href="#非空约束：not-null" class="headerlink" title="非空约束：not null"></a>非空约束：not null</h3><p>非空约束not null约束的字段不能为NULL。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int,name varchar(255) not null  # not null只有列级约束，没有表级约束！);insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);insert into t_vip(id,name) values(2,&#39;lisi&#39;);insert into t_vip(id) values(3);  # 报错，name后面没有值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>小插曲：<br>        xxxx.sql这种文件被称为sql脚本文件。<br>        sql脚本文件中编写了大量的sql语句。<br>        我们执行sql脚本文件的时候，该文件中所有的sql语句会全部执行！<br>        批量的执行SQL语句，可以使用sql脚本文件。<br>        在mysql当中怎么执行sql脚本呢？<br>            mysql&gt; source D:\course\03-MySQL\document\vip.sql</p><p>在实际的工作中，第一天到了公司，项目经理会给你一个xxx.sql文件，<br>        你执行这个脚本文件，你电脑上的数据库数据就有了！</p><h3 id="唯一性约束-unique"><a href="#唯一性约束-unique" class="headerlink" title="唯一性约束: unique"></a>唯一性约束: unique</h3><p>唯一性约束unique约束的字段不能重复，但是可以为NULL</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int,name varchar(255) unique,email varchar(255));insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);insert into t_vip(id,name,email) values(2,&#39;lisi&#39;,&#39;lisi@123.com&#39;);insert into t_vip(id,name,email) values(3,&#39;wangwu&#39;,&#39;wangwu@123.com&#39;);select * from t_vip; # 到这时还会运行成功insert into t_vip(id,name,email) values(4,&#39;wangwu&#39;,&#39;wangwu@sina.com&#39;);# 报错，name重复insert into t_vip(id) values(4);insert into t_vip(id) values(5);#name字段虽然被unique约束了，但是可以为NULL，都为NULL不表示重复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新需求：name和email两个字段联合起来具有唯一性！！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int,name varchar(255) unique,  # 约束直接添加到列后面的，叫做列级约束。email varchar(255) unique);#这张表这样创建是不符合我以上“新需求”的。#这样创建表示：name具有唯一性，email具有唯一性。各自唯一。drop table if exists t_vip;create table t_vip(id int,name varchar(255),email varchar(255),unique(name,email) &#x2F;&#x2F; 约束没有添加在列的后面，这种约束被称为表级约束。);insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);insert into t_vip(id,name,email) values(2,&#39;zhangsan&#39;,&#39;zhangsan@sina.com&#39;);select * from t_vip;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要给多个字段联合起来添加某一个约束的时候，需要使用<strong>表级约束</strong>。</p><p>not null没有表级约束</p><p><strong>unique 和not null的联合使用</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int,name varchar(255) not null unique);desc t_vip;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在mysql当中，如果一个字段同时被not null和unique约束的话，该字段自动变成主键字段。（注意：oracle中不一样！）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);insert into t_vip(id,name) values(2,&#39;zhangsan&#39;);  #报错：name不能重复insert into t_vip(id) values(2);  #报错：name不能为NULL。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="主键约束（primary-key，简称PK）（非常重要）"><a href="#主键约束（primary-key，简称PK）（非常重要）" class="headerlink" title="主键约束（primary key，简称PK）（非常重要）"></a>主键约束（primary key，简称PK）（非常重要）</h3><p>相关术语：</p><p>​        <strong>主键约束：</strong>就是一种约束。<br>​        <strong>主键字段：</strong>该字段上添加了主键约束，这样的字段叫做：主键字段<br>​        <strong>主键值：</strong>主键字段中的每一个值都叫做：主键值。</p><p>主键值是每一行记录的唯一标识。<br>主键值是每一行记录的身份证号！！！</p><p>记住：任何一张表都应该有主键，没有主键，表无效！！</p><p>主键的特征：not null + unique（主键值不能是NULL，同时也不能重复！）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 怎么给一张表添加主键约束drop table if exists t_vip;#1个字段做主键，叫做：单一主键create table t_vip(id int primary key,  #列级约束name varchar(255));insert into t_vip(id,name) values(1,&#39;zhangsan&#39;);insert into t_vip(id,name) values(2,&#39;lisi&#39;);   #到这里运行成功insert into t_vip(id,name) values(2,&#39;wangwu&#39;); #报错，不能重复insert into t_vip(name) values(&#39;zhaoliu&#39;);     #报错，不能为NULL# 可以使用表级约束drop table if exists t_vip;create table t_vip(id int,name varchar(255),primary key(id)  #表级约束);#表级约束主要是给多个字段联合起来添加约束drop table if exists t_vip;# id和name联合起来做主键：复合主键！！！！create table t_vip(id int,name varchar(255),email varchar(255),primary key(id,name));insert into t_vip(id,name,email) values(1,&#39;zhangsan&#39;,&#39;zhangsan@123.com&#39;);insert into t_vip(id,name,email) values(1,&#39;lisi&#39;,&#39;lisi@123.com&#39;);#不会报错，因为id和name只需有其中一个不相同即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在实际开发中不建议使用：复合主键。建议使用单一主键！<br>        因为主键值存在的意义就是这行记录的身份证号，只要意义达到即可，单一主键可以做到。<br>        复合主键比较复杂，不建议使用！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int primary key,name varchar(255) primary key);# 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：一张表，主键约束只能添加1个。（主键只能有1个。）</p><p>主键值建议使用：<br>        int<br>        bigint<br>        char<br>        等类型。</p><p>不建议使用：varchar来做主键。主键值一般都是数字，一般都是定长的！</p><p>主键除了：单一主键和复合主键之外，还可以这样进行分类？<br>        <strong>自然主键</strong>：主键值是一个自然数，和业务没关系。<br>        <strong>业务主键：</strong>主键值和业务紧密关联，例如拿银行卡账号做主键值。这就是业务主键！</p><p>在实际开发中使用业务主键多，还是使用自然主键多一些？<br>            自然主键使用比较多，因为主键只要做到不重复就行，不需要有意义。<br>            业务主键不好，因为主键一旦和业务挂钩，那么当业务发生变动的时候，<br>            可能会影响到主键值，所以业务主键不建议使用。尽量使用自然主键。</p><p>在mysql当中，有一种机制，可以帮助我们自动维护一个主键值</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_vip;create table t_vip(id int primary key auto_increment, #auto_increment表示自增，从1开始，以1递增！name varchar(255));insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);insert into t_vip(name) values(&#39;zhangsan&#39;);select * from t_vip;#会生成八行id从1到8，name均为zhangsan的表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="外键约束（foreign-key，简称FK）（非常重要）"><a href="#外键约束（foreign-key，简称FK）（非常重要）" class="headerlink" title="外键约束（foreign key，简称FK）（非常重要）"></a>外键约束（foreign key，简称FK）（非常重要）</h3><p>外键约束涉及到的相关术语：<br>        <strong>外键约束：</strong>一种约束（foreign key）<br>        <strong>外键字段：</strong>该字段上添加了外键约束<br>        <strong>外键值：</strong>外键字段当中的每一个值。</p><p>业务背景：请设计数据库表，来描述“班级和学生”的信息</p><p>第一种方案：班级和学生存储在一张表中</p><p>t_student<br>        no(pk)            name        classno            classname</p><p>​        1                    jack            100            北京市大兴区亦庄镇第二中学高三1班<br>​        2                    lucy            100            北京市大兴区亦庄镇第二中学高三1班<br>​        3                    lilei            100            北京市大兴区亦庄镇第二中学高三1班<br>​        4                    hanmeimei    100            北京市大兴区亦庄镇第二中学高三1班<br>​        5                    zhangsan        101            北京市大兴区亦庄镇第二中学高三2班<br>​        6                    lisi            101            北京市大兴区亦庄镇第二中学高三2班<br>​        7                    wangwu        101            北京市大兴区亦庄镇第二中学高三2班<br>​        8                    zhaoliu        101            北京市大兴区亦庄镇第二中学高三2班</p><p>分析以上方案的缺点：<br>            数据冗余，空间浪费！！！！<br>            这个设计是比较失败的！</p><p>第二种方案：班级一张表、学生一张表</p><p>t_class 班级表<br>        classno(pk)            classname<br>        100                    北京市大兴区亦庄镇第二中学高三0班<br>        101                    北京市大兴区亦庄镇第二中学高三1班</p><p>t_student 学生表<br>        no(pk)            name                cno(FK引用t_class这张表的classno)<br>        1                    jack                100<br>        2                    lucy                100<br>        3                    lilei                100<br>        4                    hanmeimei        100<br>        5                    zhangsan            101<br>        6                    lisi                101<br>        7                    wangwu            101<br>        8                    zhaoliu            101</p><p>当cno字段没有任何约束的时候，可能会导致数据无效。可能出现一个102，但是102班级不存在。<br>所以为了保证cno字段中的值都是100和101，需要给cno字段添加外键约束。<br>那么：cno字段就是外键字段。cno字段中的每一个值都是外键值。</p><p>注意：<br>            t_class是父表<br>            t_student是子表</p><p>删除表的顺序？<br>                先删子，再删父。</p><p>创建表的顺序？<br>                先创建父，再创建子。</p><p>删除数据的顺序？<br>                先删子，再删父。</p><p>插入数据的顺序？<br>                先插入父，再插入子。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_student;drop table if exists t_class;create table t_class(classno int primary key,classname varchar(255));create table t_student(no int primary key auto_increment,name varchar(255),cno int,foreign key(cno) references t_class(classno));insert into t_class(classno,classname) values(100,&#39;北京市大兴区亦庄镇第二中学高三0班&#39;) ;insert into t_class(classno,classname) values(101,&#39;北京市大兴区亦庄镇第二中学高三1班&#39;) ;insert into t_student(name,cno) values(&#39;jack&#39;,100);insert into t_student(name,cno) values(&#39;lucy&#39;,100);insert into t_student(name,cno) values(&#39;lilei&#39;,100);insert into t_student(name,cno) values(&#39;hanmeimei&#39;,100);insert into t_student(name,cno) values(&#39;zhangsan&#39;,100);insert into t_student(name,cno) values(&#39;lisi&#39;,100);insert into t_student(name,cno) values(&#39;wangwu&#39;,100);insert into t_student(name,cno) values(&#39;zhaoliu&#39;,100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：1、子表中的外键引用的父表中的某个字段，被引用的这个字段不一定是主键，但至少具有unique约束。</p><p>​        2、外键可以为NULL</p><h2 id="存储引擎（了解）"><a href="#存储引擎（了解）" class="headerlink" title="存储引擎（了解）"></a>存储引擎（了解）</h2><h3 id="什么是存储引擎，有什么用呢"><a href="#什么是存储引擎，有什么用呢" class="headerlink" title="什么是存储引擎，有什么用呢"></a>什么是存储引擎，有什么用呢</h3><p>存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）<br>存储引擎这个名字高端大气上档次。<br>实际上存储引擎是一个表存储/组织数据的方式。<br>不同的存储引擎，表存储数据的方式不同。</p><h3 id="怎么给表添加-指定“存储引擎”呢"><a href="#怎么给表添加-指定“存储引擎”呢" class="headerlink" title="怎么给表添加/指定“存储引擎”呢"></a>怎么给表添加/指定“存储引擎”呢</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 展示建表语句show create table t_student;# 可以在建表的时候给表指定存储引擎。CREATE TABLE &#96;t_student&#96; (  &#96;no&#96; int(11) NOT NULL AUTO_INCREMENT,  &#96;name&#96; varchar(255) DEFAULT NULL,  &#96;cno&#96; int(11) DEFAULT NULL,  PRIMARY KEY (&#96;no&#96;),  KEY &#96;cno&#96; (&#96;cno&#96;),  CONSTRAINT &#96;t_student_ibfk_1&#96; FOREIGN KEY (&#96;cno&#96;) REFERENCES &#96;t_class&#96; (&#96;classno&#96;)) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;11 DEFAULT CHARSET&#x3D;utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在建表的时候可以在最后小括号的”)”的右边使用：<br>        ENGINE来指定存储引擎。<br>        CHARSET来指定这张表的字符编码方式。</p><p>结论：<br>            mysql默认的存储引擎是：InnoDB<br>            mysql默认的字符编码方式是：utf8</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#建表时指定存储引擎，以及字符编码方式。create table t_product(id int primary key,name varchar(255))engine&#x3D;InnoDB default charset&#x3D;gbk;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL支持哪些存储引擎"><a href="#MySQL支持哪些存储引擎" class="headerlink" title="MySQL支持哪些存储引擎"></a>MySQL支持哪些存储引擎</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查看mysql版本select version();# 查看支持哪些存储引擎show engines \G# 共九大引擎，版本不同支持情况不同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="常用存储引擎"><a href="#常用存储引擎" class="headerlink" title="常用存储引擎"></a>常用存储引擎</h4><h5 id="MyISAM存储引擎："><a href="#MyISAM存储引擎：" class="headerlink" title="MyISAM存储引擎："></a>MyISAM存储引擎：</h5><p>​    它管理的表具有以下特征：<br>​        使用三个文件表示每个表：<br>​            <strong>格式文件</strong> — 存储表结构的定义（mytable.<strong>frm</strong>）<br>​            <strong>数据文件</strong> — 存储表行的内容（mytable.<strong>MYD</strong>）<br>​            <strong>索引文件</strong> — 存储表上索引（mytable.<strong>MYI</strong>）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。可被转换为压缩、只读表来节省空间</p><p>​            提示一下：对于一张表来说，只要是主键，或者加有unique约束的字段上会自动创建索引。</p><p>​            优势特点：可被转换为压缩、只读表来节省空间</p><p>​            MyISAM不支持事务机制，安全性低。</p><h5 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h5><p>这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。<br>InnoDB支持事务，支持数据库崩溃后自动恢复机制。<br>InnoDB存储引擎最主要的特点是：非常安全。</p><p>它管理的表具有下列主要特征：<br>        – 每个 InnoDB 表在数据库目录中以.frm 格式文件表示<br>        – InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间存储数据+索引。）</p><p>​        – 提供一组用来记录事务性活动的日志文件<br>​        – 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理<br>​        – 提供全 ACID 兼容<br>​        – 在 MySQL 服务器崩溃后提供自动恢复<br>​        – 多版本（MVCC）和行级锁定<br>​        – 支持外键及引用的完整性，包括级联删除和更新</p><p>InnoDB最大的特点就是支持事务：<br>        以保证数据的安全。效率不是很高，并且也不能压缩，不能转换为只读，<br>        不能很好的节省存储空间。</p><h5 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h5><p>使用 MEMORY 存储引擎的表，其数据存储在内存中，且行的长度固定，<br>这两个特点使得 MEMORY 存储引擎非常快。</p><p>MEMORY 存储引擎管理的表具有下列特征：<br>        – 在数据库目录内，每个表均以.frm 格式的文件表示。<br>        – 表数据及索引被存储在内存中。（目的就是快，查询快！）<br>        – 表级锁机制。<br>        – 不能包含 TEXT 或 BLOB 字段。</p><p>MEMORY 存储引擎以前被称为HEAP 引擎。</p><p>MEMORY引擎优点：查询效率是最高的。不需要和硬盘交互。<br>MEMORY引擎缺点：不安全，关机之后数据消失。因为数据和索引都是在内存当中。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（四）</title>
      <link href="/2021/090552770.html"/>
      <url>/2021/090552770.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习（四）"><a href="#MySQL学习（四）" class="headerlink" title="MySQL学习（四）"></a>MySQL学习（四）</h1><h2 id="mysql中的数据类型"><a href="#mysql中的数据类型" class="headerlink" title="mysql中的数据类型"></a>mysql中的数据类型</h2><p><strong>varchar</strong>(最长255)<br>            可变长度的字符串<br>            比较智能，节省空间。<br>            会根据实际的数据长度动态分配空间。</p><p>​            优点：节省空间<br>​            缺点：需要动态分配空间，速度慢。</p><p><strong>char</strong>(最长255)<br>            定长字符串<br>            不管实际的数据长度是多少。<br>            分配固定长度的空间去存储数据。<br>            使用不恰当的时候，可能会导致空间的浪费。</p><p>​            优点：不需要动态分配空间，速度快。<br>​            缺点：使用不当可能会导致空间的浪费。</p><p>​                varchar和char我们应该怎么选择？<br>​                性别字段你选什么？因为性别是固定长度的字符串，所以选择char。<br>​                姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。</p><p><strong>int</strong>(最长11)<br>            数字中的整数型。等同于java的int。</p><p><strong>bigint</strong><br>            数字中的长整型。等同于java中的long。</p><p><strong>float</strong><br>            单精度浮点型数据</p><p><strong>double</strong><br>            双精度浮点型数据</p><p><strong>date</strong><br>            短日期类型</p><p><strong>datetime</strong><br>            长日期类型</p><p><strong>clob</strong><br>            字符大对象<br>            最多可以存储4G的字符串。<br>            比如：存储一篇文章，存储一个说明。<br>            超过255个字符的都要采用CLOB字符大对象来存储。<br>            Character Large OBject:CLOB</p><p><strong>blob</strong><br>            二进制大对象<br>            Binary Large OBject<br>            专门用来存储图片、声音、视频等流媒体数据。<br>            往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，<br>            你需要使用IO流才行。</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><h3 id="表的创建（建表）"><a href="#表的创建（建表）" class="headerlink" title="表的创建（建表）"></a>表的创建（建表）</h3><p>建表属于DDL语句，DDL包括：create drop alter</p><p>create table 表名(字段名1 数据类型, 字段名2 数据类型, 字段名3 数据类型);</p><p>create table 表名(<br>        字段名1 数据类型,<br>        字段名2 数据类型,<br>        字段名3 数据类型<br>    );</p><p>表名：建议以t_ 或者 tbl_开始，可读性强，见名知意。<br>字段名：见名知意。<br>表名和字段名都属于标识符。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 创建一个学生表：学号、姓名、年龄、性别、邮箱地址create table t_student(no int,name varchar(32),sex char(1),age int(3),email varchar(255));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table t_student; #当这张表不存在的时候会报错！drop table if exists t_student; #如果这张表存在的话，删除，更健壮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="插入数据insert-（DML）"><a href="#插入数据insert-（DML）" class="headerlink" title="插入数据insert （DML）"></a>插入数据insert （DML）</h2><p>语法格式：insert into 表名(字段名1,字段名2,字段名3…) values(值1,值2,值3);</p><p>注意：字段名和值要一一对应。什么是一一对应？数量要对应。数据类型要对应。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_student(no,name,sex,age,email) values(1,&#39;zhangsan&#39;,&#39;m&#39;,20,&#39;zhangsan@123.com&#39;);insert into t_student(email,name,sex,age,no) values(&#39;lisi@123.com&#39;,&#39;lisi&#39;,&#39;f&#39;,20,2);insert into t_student(no) values(3);insert into t_student(name) values(&#39;wangwu&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：insert语句但凡是执行成功了，那么必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_student;create table t_student(no int,name varchar(32),sex char(1) default &#39;m&#39;, #指定默认值为mage int(3),email varchar(255));insert into t_student(no) values(1);select * from t_student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>insert语句中的“字段名”可以省略吗？可以，但是前面的字段名省略的话，等于都写上了！所以值也要都写上！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_student values(2); #报错insert into t_student values(2, &#39;lisi&#39;, &#39;f&#39;, 20, &#39;lisi@123.com&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="insert插入日期"><a href="#insert插入日期" class="headerlink" title="insert插入日期"></a>insert插入日期</h3><blockquote><p>补充之前未讲的单行处理函数</p><p>格式化数字：format(数字, ‘格式’)<br>            select ename,format(sal, ‘$999,999’) as sal from emp;</p></blockquote><p><strong>str_to_date：</strong>将字符串varchar类型转换成date类型</p><p><strong>date_format：</strong>将date类型转换成具有一定格式的varchar字符串类型。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">create table t_user(id int,name varchar(32),birth date # 生日也可以使用date日期类型);create table t_user(id int,name varchar(32),birth char(10) # 生日可以使用字符串，没问题。);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：数据库中的有一条命名规范：所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">desc t_user;insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, &#39;01-10-1990&#39;); # 报错，类型不匹配，数据库birth是date类型，这里给了一个字符串varchar。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>可以使用str_to_date函数进行类型转换，str_to_date函数可以将字符串varchar转换成日期类型date</p><p>通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据，需要通过该函数将字符串转换成date。</p><p>语法格式：str_to_date(‘字符串日期’, ‘日期格式’)</p><p>mysql的日期格式：<br>            %Y       年<br>            %m      月<br>            %d       日<br>            %h       时<br>            %i         分<br>            %s        秒</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_user(id,name,birth) values(1, &#39;zhangsan&#39;, str_to_date(&#39;01-10-1990&#39;,&#39;%d-%m-%Y&#39;));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果你提供的日期字符串是这个格式%Y-%m-%d，str_to_date函数就不需要了！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_user(id,name,birth) values(2, &#39;lisi&#39;, &#39;1990-10-01&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>date_format  这个函数可以将日期类型转换成特定格式的字符串。</p><p>用法：date_format(日期类型数据, ‘日期格式’)    </p><p>这个函数通常使用在查询日期方面，设置展示的日期格式。        </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select id,name,date_format(birth, &#39;%m&#x2F;%d&#x2F;%Y&#39;) as birth from t_user;select id,name,birth from t_user;# 以上的SQL语句实际上是进行了默认的日期格式化，# 自动将数据库中的date类型转换成varchar类型。# 并且采用的格式是mysql默认的日期格式：&#39;%Y-%m-%d&#39;select id,name,date_format(birth,&#39;%Y&#x2F;%m&#x2F;%d&#39;) as birth from t_user;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="date和datetime两个类型的区别"><a href="#date和datetime两个类型的区别" class="headerlink" title="date和datetime两个类型的区别"></a>date和datetime两个类型的区别</h4><p>date是短日期：只包括年月日信息。</p><p>datetime是长日期：包括年月日时分秒信息。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">drop table if exists t_user;create table t_user(id int,name varchar(32),birth date,create_time datetime);#id是整数，name是字符串，birth是短日期，create_time是这条记录的创建时间：长日期类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mysql短日期默认格式：%Y-%m-%d<br>mysql长日期默认格式：%Y-%m-%d %h:%i:%s</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_user(id,name,birth,create_time) values(1,&#39;zhangsan&#39;,&#39;1990-10-01&#39;,&#39;2020-03-18 15:49:50&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在mysql当中怎么获取系统当前时间:</p><p><strong>now() 函数</strong>，并且获取的时间带有：时分秒信息！！！！是datetime类型的。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">insert into t_user(id,name,birth,create_time) values(2,&#39;lisi&#39;,&#39;1991-10-01&#39;,now());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="修改update（DML）"><a href="#修改update（DML）" class="headerlink" title="修改update（DML）"></a>修改update（DML）</h2><p>语法格式：<br>    update 表名 set 字段名1=值1,字段名2=值2,字段名3=值3… where 条件;</p><p>注意：没有条件限制会导致所有数据全部更新。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">update t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39; where id &#x3D; 2;update t_user set name &#x3D; &#39;jack&#39;, birth &#x3D; &#39;2000-10-11&#39;, create_time &#x3D; now() where id &#x3D; 2;update t_user set name &#x3D; &#39;abc&#39;;   #把每一行name都会改为abc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="删除数据-delete-（DML）"><a href="#删除数据-delete-（DML）" class="headerlink" title="删除数据 delete （DML）"></a>删除数据 delete （DML）</h2><p>语法格式：delete from 表名 where 条件;</p><p>注意：没有条件，整张表的数据会全部删除！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">delete from t_user where id &#x3D; 2;insert into t_user(id) values(2);delete from t_user;  #删除所有！<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（三）</title>
      <link href="/2021/090541187.html"/>
      <url>/2021/090541187.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习（三）"><a href="#MySQL学习（三）" class="headerlink" title="MySQL学习（三）"></a>MySQL学习（三）</h1><h2 id="把查询结果去除重复记录【distinct】"><a href="#把查询结果去除重复记录【distinct】" class="headerlink" title="把查询结果去除重复记录【distinct】"></a>把查询结果去除重复记录【distinct】</h2><p>注意：原表数据不会被修改，只是查询结果去重。<br>去重需要使用一个关键字：distinct</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select distinct job from emp;select ename,distinct job from emp;  #报错，distinct只能出现在所有字段的最前方。select distinct job,deptno from emp; #distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。select count(distinct job) from emp;  #统计一下工作岗位的数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><p>从一张表中单独查询，称为单表查询。<br>emp表和dept表联合起来查询数据，从emp表中取员工名字，从dept表中取部门名字。<br>这种跨表查询，多张表联合起来查询数据，被称为连接查询。</p><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><p><strong>1、根据语法的年代分类：</strong><br>        <strong>SQL92</strong>：1992年的时候出现的语法<br>        <strong>SQL99</strong>：1999年的时候出现的语法<br>        我们这里重点学习SQL99.(这个过程中简单演示一个SQL92的例子)</p><p><strong>2、根据表连接的方式分类：</strong><br>        <strong>内连接：</strong><br>                        等值连接<br>                        非等值连接<br>                        自连接</p><p>​        <strong>外连接：</strong></p><p>​                        左外连接（左连接）<br>​                        右外连接（右连接）</p><p>​        <strong>全连接（不讲）</strong></p><h3 id="两张表的连接查询"><a href="#两张表的连接查询" class="headerlink" title="两张表的连接查询"></a>两张表的连接查询</h3><h4 id="笛卡尔积现象"><a href="#笛卡尔积现象" class="headerlink" title="笛卡尔积现象"></a>笛卡尔积现象</h4><p>当两张表进行连接查询时，没有任何条件的限制会发生什么现象？</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,dename from emp,dept; # 查询每个员工所在部门名称#会得到14*4&#x3D;56行结果，对emp的每一行，都与dept的每一行进行匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表条数的乘积，这种现象被称为：<strong>笛卡尔积现象</strong>。（笛卡尔发现的，这是一个数学现象。）</p><h4 id="怎么避免笛卡尔积现象？"><a href="#怎么避免笛卡尔积现象？" class="headerlink" title="怎么避免笛卡尔积现象？"></a>怎么避免笛卡尔积现象？</h4><p>连接时加条件，满足这个条件的记录被筛选出来！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,dname from emp, deptwhereemp.deptno &#x3D; dept.deptno;#最终查询的结果条数是14条，但是匹配的过程中，匹配的次数还是56次，只不过进行了四选一。次数没有减少。select e.ename,d.dname from emp e, dept dwheree.deptno &#x3D; d.deptno;#起别名，效率高一些#SQL92语法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。</p><h4 id="内连接之等值连接"><a href="#内连接之等值连接" class="headerlink" title="内连接之等值连接"></a>内连接之等值连接</h4><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查询每个员工所在部门名称，显示员工名和部门名# emp e和dept d表进行连接。条件是：e.deptno &#x3D; d.deptno# SQL92语法：select e.ename,d.dnamefromemp e, dept dwheree.deptno &#x3D; d.deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select e.ename,d.dnamefromemp einner join   #inner可以省略，带着可读性更好dept done.deptno &#x3D; d.deptno; #条件是等量关系，所以被称为等值连接。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>sql99优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where</p><p>SQL99语法：<br>        select<br>            …<br>        from<br>            a<br>        join<br>            b<br>        on<br>            a和b的连接条件<br>        where<br>            筛选条件</p><h4 id="内连接之非等值连接"><a href="#内连接之非等值连接" class="headerlink" title="内连接之非等值连接"></a>内连接之非等值连接</h4><p>条件不是一个等量关系，称为非等值连接</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#找出每个员工的薪资等级，要求显示员工名、薪资、薪资等级select e.ename, e.sal, s.gradefromemp ejoinsalgrade sone.sal between s.losal and s.hisal; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内连接之自连接"><a href="#内连接之自连接" class="headerlink" title="内连接之自连接"></a>内连接之自连接</h4><p>技巧：一张表看做两张表</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查询员工的上级领导，要求显示员工名和对应的领导名select a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;fromemp ajoinemp bona.mgr &#x3D; b.empno; # 员工的领导编号 &#x3D; 领导的员工编号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h4><p>（A和B连接，AB两张表没有主次关系。平等的。）</p><p>内连接的特点：完成能够匹配上这个条件的数据查询出来</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select e.ename,d.dnamefromemp ejoindept done.deptno &#x3D; d.deptno; 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>带有right的是右外连接，又叫做右连接。带有left的是左外连接，又叫做左连接。<br>任何一个右连接都有左连接的写法。任何一个左连接都有右连接的写法。</p><p><strong>右外连接（右连接）：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select e.ename,d.dnamefromemp e right outer join  #outer可以省略，带着可读性强 dept done.deptno &#x3D; d.deptno;#结果会比上述内连接多一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>right表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了<strong>主次关系</strong>。</p><p><strong>左外连接（左连接）：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select e.ename,d.dnamefromdept d left join emp eone.deptno &#x3D; d.deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>连接的查询结果条数一定是 &gt;= 内连接的查询结果条数</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查询每个员工的上级领导，要求显示所有员工的名字和领导名select a.ename as &#39;员工名&#39;, b.ename as &#39;领导名&#39;fromemp aleft joinemp bona.mgr &#x3D; b.empno; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="三张表，四张表怎么连接"><a href="#三张表，四张表怎么连接" class="headerlink" title="三张表，四张表怎么连接"></a>三张表，四张表怎么连接</h3><p>语法：<br>        select<br>            …<br>        from<br>            a<br>        join<br>            b<br>        on<br>            a和b的连接条件<br>        join<br>            c<br>        on<br>            a和c的连接条件<br>        right join<br>            d<br>        on<br>            a和d的连接条件<br>一条SQL中内连接和外连接可以混合。都可以出现！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#找出每个员工的部门名称以及工资等级，要求显示员工名、部门名、薪资、薪资等级select e.ename,e.sal,d.dname,s.gradefromemp ejoindept don e.deptno &#x3D; d.deptnojoinsalgrade sone.sal between s.losal and s.hisal;#找出每个员工的部门名称以及工资等级，还有上级领导，要求显示员工名、领导名、部门名、薪资、薪资等级select e.ename,e.sal,d.dname,s.grade,l.enamefromemp ejoindept don e.deptno &#x3D; d.deptnojoinsalgrade sone.sal between s.losal and s.hisalleft joinemp lone.mgr &#x3D; l.empno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>select语句中嵌套select语句，被嵌套的select语句称为子查询</p><p>子查询可以出现在哪里：</p><p>select<br>        ..(select).<br>    from<br>        ..(select).<br>    where<br>        ..(select).</p><h3 id="where子句中的子查询"><a href="#where子句中的子查询" class="headerlink" title="where子句中的子查询"></a>where子句中的子查询</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出比最低工资高的员工姓名和工资select ename,salfromemp wheresal &gt; min(sal);#报错，where子句中不能直接使用分组函数#实现思路：第一步：查询最低工资是多少select min(sal) from emp;#第二步：找出&gt;800的select ename,sal from emp where sal &gt; 800;#第三步：合并select ename,sal from emp where sal &gt; (select min(sal) from emp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="from子句中的子查询"><a href="#from子句中的子查询" class="headerlink" title="from子句中的子查询"></a>from子句中的子查询</h3><p>技巧：from后面的子查询，可以将子查询的查询结果当做一张临时表</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出每个岗位的平均工资的薪资等级# 第一步：找出每个岗位的平均工资（按照岗位分组求平均值），当成真实存在的表select job,avg(sal) from emp group by job;# 第二步：找到薪资等级表select * from salgrade; # 第三步：表连接select t.*, s.gradefrom(select job,avg(sal) as avgsal from emp group by job) tjoinsalgrade sont.avgsal between s.losal and s.hisal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="select后面出现的子查询"><a href="#select后面出现的子查询" class="headerlink" title="select后面出现的子查询"></a>select后面出现的子查询</h3><p>这个内容不需要掌握，了解即可！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出每个员工的部门名称，要求显示员工名，部门名select e.ename,e.deptno,(select d.dname from dept d where e.deptno &#x3D; d.deptno) as dname from emp e;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：对于select后面的子查询来说，这个子查询只能一次返回1条结果，多于1条，就报错了。！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select e.ename,e.deptno,(select dname from dept) as dnamefromemp e;# 报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="union合并查询结果集"><a href="#union合并查询结果集" class="headerlink" title="union合并查询结果集"></a>union合并查询结果集</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 查询工作岗位是MANAGER和SALESMAN的员工select ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;select ename,job from emp where job in(&#39;MANAGER&#39;,&#39;SALESMAN&#39;);select ename,job from emp where job &#x3D; &#39;MANAGER&#39;unionselect ename,job from emp where job &#x3D; &#39;SALESMAN&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>union的<strong>效率</strong>要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，会成倍的翻，但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。</p><p>union把乘法变成了加法运算</p><p><strong>注意事项：</strong></p><p>1、union在进行结果集合并的时候，要求两个结果集的列数相同。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,job from emp where job &#x3D; &#39;MANAGER&#39;unionselect ename from emp where job &#x3D; &#39;SALESMAN&#39;;#报错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、MYSQL可以，oracle语法严格 ，不可以，报错。要求：结果集合并时列和列的数据类型也要一致。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,job from emp where job &#x3D; &#39;MANAGER&#39;unionselect ename,sal from emp where job &#x3D; &#39;SALESMAN&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="limit（非常重要）"><a href="#limit（非常重要）" class="headerlink" title="limit（非常重要）"></a>limit（非常重要）</h2><p><strong>作用：</strong>将查询结果集的一部分取出来。通常使用在<strong>分页查询</strong>当中</p><p>分页的作用是为了提高用户的体验，因为一次全部都查出来，用户体验差。可以一页一页翻页看。</p><p><strong>使用：</strong></p><p>完整用法：limit startIndex, length<br>        startIndex是起始下标，length是长度。<br>        <strong>起始下标从0开始。</strong></p><p>缺省用法：limit 5; 这是取前5.</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 按照薪资降序，取出排名在前5名的员工select ename,salfromemporder by sal desclimit 5; #取前五<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong>mysql当中limit在order by之后执行！！！！！！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 取出工资排名在[3-5]名的员工select ename,salfromemporder bysal desclimit2, 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>每页显示3条记录<br>        第1页：limit 0,3        [0 1 2]<br>        第2页：limit 3,3        [3 4 5]<br>        第3页：limit 6,3        [6 7 8]<br>        第4页：limit 9,3        [9 10 11]</p><p>每页显示pageSize条记录<br>        第pageNo页：limit (pageNo - 1) * pageSize  , pageSize</p><p><strong>记公式：</strong>limit (pageNo-1)*pageSize , pageSize</p><h2 id="DQL语句大总结"><a href="#DQL语句大总结" class="headerlink" title="DQL语句大总结"></a>DQL语句大总结</h2><p>select<br>        …<br>from<br>        …<br>where<br>        …<br>group by<br>        …<br>having<br>        …<br>order by<br>        …<br>limit<br>        …</p><p>执行顺序<br>        1.from<br>        2.where<br>        3.group by<br>        4.having<br>        5.select<br>        6.order by<br>        7.limit..</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记（二）</title>
      <link href="/2021/090544186.html"/>
      <url>/2021/090544186.html</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL学习（二）"><a href="#MySQL学习（二）" class="headerlink" title="MySQL学习（二）"></a>MySQL学习（二）</h1><h2 id="导入准备好的数据"><a href="#导入准备好的数据" class="headerlink" title="导入准备好的数据"></a>导入准备好的数据</h2><p>bjpowernode.sql  为准备好的数据库表</p><p>输入create database bjpownode 创建数据库</p><p>输入use bjpowernode 使用数据库</p><p>输入以下导入数据</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">source  D:\BaiduNetdiskDownload\learn_mysql\document\bjpowernode.sql #没有分号！<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>source后面是准备数据的路径</p><h2 id="关于导入的表"><a href="#关于导入的表" class="headerlink" title="关于导入的表"></a>关于导入的表</h2><p>dept：部门表 ；emp：员工表；salgrade：工资等级表</p><h2 id="查看表中的数据"><a href="#查看表中的数据" class="headerlink" title="查看表中的数据"></a>查看表中的数据</h2><p>select  * from 表名  </p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select * from emp; #查看员工表所有数据select * from dept;select * from salgrade;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="查看表的结构"><a href="#查看表的结构" class="headerlink" title="查看表的结构"></a>查看表的结构</h2><p>desc 表名</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">desc emp;desc dept;desc salgrade;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="mysql常用命令（续一）"><a href="#mysql常用命令（续一）" class="headerlink" title="mysql常用命令（续一）"></a>mysql常用命令（续一）</h2><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">exit; #退出数据库show databases; #查看所有数据库use test; #使用test数据库create database bjpowernode; #创建名叫bjpowernode的数据库show tables; #查看数据库下有哪些表select version();  #查看mysql数据库的版本号select databse();  #查看当前使用的数据库#mysql中不见分号不执行，分号表示结束#\c可以终止命令输入，或者ctrl+C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="mysql语句学习"><a href="#mysql语句学习" class="headerlink" title="mysql语句学习"></a>mysql语句学习</h2><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><p><strong>查询一个字段</strong> <strong>：</strong> select 字段名 from 表名;</p><p>注意：select和from都是关键字，字段名和表名都是标识符</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select dname from dept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查询两个或多个字段</strong> <strong>：</strong>select 字段名1,字段名2…   from 表名</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select deptno,dname from dept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查询所有字段：</strong>一、把每个字段都写上；二、使用*（效率低，可读性差，实际开发中不建议）</p><p><strong>给查询的列起别名：</strong>使用as关键字起别名（或者直接省略）</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select deptno,dname as deptname from dept;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：1、只是查询结果起了别名，原表不改，select语句不会进行修改操作</p><p>​        2、如果起别名的时候别名里有空格会报错，或者可以使用单引号或者双引号括起来（建议使用单引             号，因为单引号是标准，在oracle中就不能使用双引号，只能使用单引号）</p><p><strong>计算员工年薪：</strong>字段中可以使用数学表达式</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,sal*12 as yearsal from emp;select ename,sal*12 as &#39;年薪&#39; from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>查询出符合条件的数据</p><p><strong>语法格式</strong>：</p><p>select    字段1,字段2,字段3…    from    表名    where     条件;</p><p><strong>所有条件</strong>：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># &#x3D; 等于select empno,ename from emp where sal &#x3D; 800; #查询薪资等于800的员工姓名和编号select empno,sal from emp where ename &#x3D; &#39;SMITH&#39;; #查询SMITH的编号和薪资# &lt;&gt;或!&#x3D; 不等于select empno,ename from emp where sal !&#x3D; 800; #查询薪资不等于800的员工姓名和编号select empno,ename from emp where sal &lt;&gt; 800; #小于号和大于号组成的不等号# &lt; 小于select empno,ename,sal from emp where sal &lt; 2000; #查询薪资小于2000的员工姓名和编号# &lt;&#x3D; 小于等于select empno,ename,sal from emp where sal &lt;&#x3D; 3000; #查询薪资小于等于3000的员工姓名和编号# &gt; 大于select empno,ename,sal from emp where sal &gt; 3000; #查询薪资大于3000的员工姓名和编号# &gt;&#x3D; 大于等于select empno,ename,sal from emp where sal &gt;&#x3D; 3000; #查询薪资大于等于3000的员工姓名和编号select empno,ename,sal from emp where sal &gt;&#x3D; 2450 and sal &lt;&#x3D; 3000; #查询薪资在2450和3000之间的员工信息？包括2450和3000# between … and …. 两个值之间, 等同于 &gt;&#x3D; and &lt;&#x3D;select empno,ename,sal from emp where sal between 2450 and 3000; #使用between,and必须遵循左小右大，闭区间，包括两端的值# is null 为 null（is not null 不为空）#select empno,ename,sal,comm from emp where comm &#x3D; null; #该语句不行，不能使用&#x3D;，null表示什么也没有，不能用等号衡量select empno,ename,sal,comm from emp where comm is null; #查询哪些员工的津贴&#x2F;补助为nullselect empno,ename,sal,comm from emp where comm is not null; #查询哪些员工的津贴&#x2F;补助不为null# and 并且select empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; and sal&gt;2500; #查询工作岗位是MANAGER并且工资大于2500的员工信息# or 或者select empno,ename,job from emp where job &#x3D; &#39;MANAGER&#39; or job &#x3D; &#39;SALESMAN&#39;;#查询工作岗位是MANAGER和SALESMAN的员工select * from emp where sal &gt; 2500 and deptno &#x3D; 10 or deptno &#x3D; 20;#因为and优先级比or高，所以以上语句会先执行and，然后执行or，即将工资大于2500并且部门编号为10的员工，或者20部门所有员工找出来。select * from emp where sal &gt; 2500 and (deptno &#x3D; 10 or deptno &#x3D; 20); #带括号让or先执行# in 包含，相当于多个 or （not in 不在这个范围中），in不是个区间，in后面是具体的值select empno,ename,job from emp where job in(&#39;MANAGER&#39;, &#39;SALESMAN&#39;); #查询工作岗位是MANAGER和SALESMAN的员工select ename,sal from emp where sal in(800, 5000); #不是表示800到5000，而是800和5000select ename,sal from emp where sal not in(800, 5000, 3000);#不在800,5000,3000中的数据#not 可以取非，主要用在 is 或 in 中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h3><p>like，支持%或下划线匹配</p><p>%匹配任意多个字符，下划线匹配任意一个字符，%和_都是特殊符号</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename from emp where ename like &#39;%O%&#39;; #找出名字里含O的select ename from emp where ename like &#39;%T&#39;;  #找出名字以T结尾的select ename from emp where ename like &#39;K%&#39;;  #找出名字以K开始的select ename from emp where ename like &#39;_A%&#39;; #找出第二个字每是A的select ename from emp where ename like &#39;__R%&#39;; #找出第三个字母是R的mysql&gt; select name from t_student where name like &#39;%\_%&#39;; #找出名字里含有下划线的，\转义字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><strong>按单个字段排序：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,sal from emp order by sal; #默认是升序select ename,sal from emp order by sal asc;   #指定升序select ename,sal from emp order by sal desc;  #指定降序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>按两个或多个字段排序：</strong></p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,sal from emp order by sal asc, ename asc;#查询员工名字和薪资，要求按照薪资升序，如果薪资一样的话，再按照名字升序排列。select ename,sal from emp order by 2; #2表示第二列sal，即按薪资排序，不建议在开发中这样写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,sal from emp where sal between 1250 and 3000 order by sal desc;#找出工资在1250到3000之间的员工信息，要求按照薪资降序排列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>第一步：from    第二步：where    第三步：select    第四步：order by（排序总是在最后执行！）</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="数据处理函数"><a href="#数据处理函数" class="headerlink" title="数据处理函数"></a>数据处理函数</h3><p>数据处理函数又被称为<strong>单行处理函数</strong>，特点：一个输入对应一个输出</p><p>与单行处理函数相对的是：<strong>多行处理函数</strong>，多个输入对应一个输出</p><h4 id="单行处理函数"><a href="#单行处理函数" class="headerlink" title="单行处理函数"></a>单行处理函数</h4><p>常见的单行处理函数：</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># lower 转换小写select lower(ename) as ename from emp;# upper 转换大写select upper(name) as name from t_student;# substr 取子串（substr( 被截取的字符串, 起始下标,截取的长度)）select substr(ename, 1, 1) as ename from emp; #下标从1开始，没有0# 找出员工名字第一个字母是A的员工信息# 第一种方法：模糊查询select ename from emp where ename like &#39;A%&#39;;# 第二种方式：substr函数select ename from emp where substr(ename,1,1) &#x3D; &#39;A&#39;;# concat函数进行字符串的拼接select concat(empno,ename) from emp;select concat(upper(substr(name,1,1)),substr(name,2,length(name) - 1)) as result from t_student;#首字母大写# length 取长度select length(ename) enamelength from emp;# trim 去空格select * from emp where ename &#x3D; trim(&#39;   KING&#39;);# str_to_date 将字符串转换成日期# date_format 格式化日期# format 设置千分位# case..when..then..when..then..else..endselect ename,job, sal as oldsal,(case job when &#39;MANAGER&#39; then sal*1.1 when &#39;SALESMAN&#39; then sal*1.5 else sal end) as newsal from emp;#当员工的工作岗位是MANAGER的时候，工资上调10%，当工作岗位是SALESMAN的时候，工资上调50%,其它正常#不修改数据库，只是将查询结果显示为工资上调# round 四舍五入select round(1236.567, 0) as result from emp; #0表示保留到整数位select round(1236.567, 1) as result from emp; #保留1位小数select round(1236.567, 2) as result from emp; #保留2位小数select round(1236.567, -1) as result from emp; #保留到十位# rand() 生成随机数select rand() from emp; #生成0到1的随机数select round(rand()*100,0) from emp; #生成100以内的随机数# ifnull 可以将 null 转换成一个具体值，ifnull是空处理函数，专门处理空的# 在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。# ifnull函数用法：ifnull(数据, 被当做哪个值)，如果“数据”为NULL的时候，把这个数据结构当做哪个值。select ename, (sal + ifnull(comm, 0)) * 12 as yearsal from emp;# 计算每个员工的年薪： 年薪 &#x3D; (月薪 + 月补助) * 12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分组函数（多行处理函数）"><a href="#分组函数（多行处理函数）" class="headerlink" title="分组函数（多行处理函数）"></a>分组函数（多行处理函数）</h4><p>特点：输入多行，最多处理一行</p><p>注：分组函数在使用时必须先进行分组，然后才能使用，如果没有分组，整张表默认为一组</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># max 最大值select max(sal) from emp; #找出最高工资# min 最小值select min(sal) from emp; #找出最低工资# sum 求和select sum(sal) from emp; #计算工资和# avg 平均值select avg(sal) from emp; #计算平均工资# count计数select count(ename) from emp; #计算员工数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>分组函数使用时注意问题：</p><p>一、分组函数自动忽略NULL，不需要提前对NULL进行处理。</p><p>二、分组函数中count(*)和count(具体字段)有什么区别？</p><p>​        count(具体字段)：表示统计该字段下所有不为NULL的元素的总数。</p><p>​        count(*)：统计表当中的总行数。（只要有一行数据count则++）。因为每一行记录不可能都为NULL，都为NULL没有意义，一行数                            据中有一列不为NULL，则这行数据就是有效的。</p><p>三、分组函数不能够直接使用在where子句中。</p><p>四、所有的分组函数可以组合起来一起用。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select sum(sal),min(sal),max(sal),avg(sal),count(*) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="分组查询（非常重要）"><a href="#分组查询（非常重要）" class="headerlink" title="分组查询（非常重要）"></a>分组查询（非常重要）</h2><p>在实际的应用中，可能有这样的需求，需要先进行分组，然后对每一组的数据进行操作，这个时候我们需要使用分组查询。</p><p>select …  from …  group by …</p><p>将之前的关键字全部组合在一起，<strong>使用顺序</strong>:</p><p>select … from … where … group by … order by …</p><p><strong>执行顺序</strong>：1. from  2.where   3.group by    4. select   5.order by</p><p>为什么分组函数不能直接使用在where后面？</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select ename,sal from emp where sal &gt; min(sal); #报错。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为分组函数在使用的时候必须先分组之后才能使用，where执行的时候，还没有分组，所以where后面不能出现分组函数。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">select sum(sal) from emp; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个没有分组，因为select在group by之后执行，所以sum()函数可以用</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出每个工作岗位的工资和# 实现思路：按照工作岗位分组，然后对工资求和select job,sum(sal) from emp group by job;# 执行顺序：先从emp表中查询数据，根据job字段进行分组，然后对每一组的数据进行sum(sal)select ename,job,sum(sal) from emp group by job;# 以上语句在mysql中可以执行，但是毫无意义。# 以上语句在oracle中执行报错，oracle的语法比mysql的语法严格。（mysql的语法相对来说松散一些！）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结论：在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数，其它的一律不能跟。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出每个部门的最高薪资# 实现思路：按照部门编号分组，求每一组的最大值。select deptno,max(sal) from emp group by deptno;# 找出“每个部门，不同工作岗位”的最高薪资# 技巧：两个字段联合成1个字段看。（两个字段联合分组）select deptno, job, max(sal) from emp group by deptno, job;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>having语句：</strong>使用having可以对分完组之后的数据进一步过滤。</p><p>having不能单独使用，having不能代替where，having必须和group by联合使用。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># 找出每个部门最高薪资，要求显示最高薪资大于3000的# 第一步：找出每个部门最高薪资，按照部门编号分组，求每一组最大值。select deptno,max(sal) from emp group by deptno;# 第二步：要求显示最高薪资大于3000select deptno,max(sal) from emp group by deptno having max(sal) &gt; 3000;#这样的两步语句执行效率低#实际思路：先将大于3000的都找出来，然后再分组。select deptno,max(sal) from emp where sal &gt; 3000 group by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优化策略：where和having，优先选择where，where实在完成不了了，再选择having。</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql"># where实现不了的例子# 找出每个部门平均薪资，要求显示平均薪资高于2500的。# 第一步：找出每个部门平均薪资select deptno,avg(sal) from emp group by deptno;# 第二步：要求显示平均薪资高于2500的select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2500;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>输入顺序（不能颠倒）：</strong>        select ..from…where…group by…having…order by…</p><p><strong>执行顺序：</strong>   1.from    2. where    3. group by    4. having    5. select     6.order by</p><p>   从某张表中查询数据，<br>    先经过where条件筛选出有价值的数据。<br>    对这些有价值的数据进行分组。<br>    分组之后可以使用having继续筛选。<br>    select查询出来。<br>    最后排序输出！</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">#找出每个岗位的平均薪资，要求显示平均薪资大于1500的，除MANAGER岗位之外，要求按照平均薪资降序排。select job, avg(sal) as avgsalfromempwherejob &lt;&gt; &#39;MANAGER&#39;group byjobhavingavg(sal) &gt; 1500order byavgsal desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的安装配置与学习笔记（一）</title>
      <link href="/2021/090320639.html"/>
      <url>/2021/090320639.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装MySQL"><a href="#一、安装MySQL" class="headerlink" title="一、安装MySQL"></a>一、安装MySQL</h1><h2 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h2><p>1、进入MySQL官网<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/mysql_install.png"></p><p>​    下载第一个</p><p>2、进入到下载目录里，新建my.ini文件，用记事本打开，输入以下内容</p><pre class="line-numbers language-tex" data-language="tex"><code class="language-tex">[mysqld]#设置3306端口port&#x3D;3306#设置mysql的安装目录basedir&#x3D;D:\xunlei_download\mysql-8.0.26-winx64#设置mysql数据库的数据的存放目录datadir&#x3D;D:\xunlei_download\mysql-8.0.26-winx64\data#允许最大连接数max_connections&#x3D;200#允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors&#x3D;10#服务端使用的字符集默认为UTF8character-set-server&#x3D;utf8#创建新表时将使用的默认存储引擎default-storage-engine&#x3D;INNODB#默认使用“mysql_native_password”插件认证default_authentication_plugin&#x3D;mysql_native_password[mysql]#设置mysql客户端默认字符集default-character-set&#x3D;utf8[client]#设置mysql客户端连接服务端时默认使用的端口port&#x3D;3306default-character-set&#x3D;utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意安装目录和数据存放目录应为你的文件安装地址目录</p><p>3、修改环境变量</p><p>【我的电脑】-&gt;右键【属性】-&gt;【高级系统设置】-&gt;【环境变量】-&gt;系统变量里找到【Path】-&gt;【编辑】-&gt;</p><p>【新建】填入bin文件夹的目录，如D:\xunlei_download\mysql-8.0.26-winx64\bin-&gt;连按三个【确定】</p><h2 id="2、配置"><a href="#2、配置" class="headerlink" title="2、配置"></a>2、配置</h2><p>管理员身份下运行命令行提示符</p><p>输入mysqld –initialize-insecure –user=mysql（此时设置了为没有登录密码）</p><p>输入mysqld -install</p><h2 id="3、启用"><a href="#3、启用" class="headerlink" title="3、启用"></a>3、启用</h2><p>管理员身份下运行命令提示符</p><p>输入net start mysql启用数据库</p><p>输入mysql -u root -p，不用输入密码直接回车</p><p>出现mysql&gt;表示配置完成</p><h2 id="4、注意问题"><a href="#4、注意问题" class="headerlink" title="4、注意问题"></a>4、注意问题</h2><p>1、若遇到mysql Install/Remove of the Service Denided问题，说明没有在管理员身份下运行</p><p>2、若按网上的教程在配置时输入的是mysqld –initialize –console，会自动生成初始密码，若后续忘了密码，可以按照<a href="https://blog.csdn.net/qq_43342301/article/details/91288891?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">教程</a>重置密码</p><h1 id="二、MySQL学习"><a href="#二、MySQL学习" class="headerlink" title="二、MySQL学习"></a>二、MySQL学习</h1><h2 id="mysql常见命令"><a href="#mysql常见命令" class="headerlink" title="mysql常见命令"></a>mysql常见命令</h2><p>命令不区分大小写</p><pre class="line-numbers language-mysql" data-language="mysql"><code class="language-mysql">exit; #退出数据库show databases; #查看所有数据库use test; #使用test数据库create database bjpowernode; #创建名叫bjpowernode的数据库show tables #查看数据库下有哪些表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>数据库当中最基本的单元是表：table</p><p>数据库当中是以表格的形式表示数据的，因为表比较直观</p><p>任何一张表都有行和列：</p><p>行（row）：被称为数据/记录；列（column）：被称为字段（姓名字段、性别字段）</p><p>字段名：一个普通的名字，见名知意</p><p>数据类型：字符串，数字，日期等</p><p>约束：很多种，如唯一性约束，即加了这种约束后，数据不能重复</p><h2 id="SQL语句分类"><a href="#SQL语句分类" class="headerlink" title="SQL语句分类"></a>SQL语句分类</h2><p><strong>DQL</strong>：数据查询语言（凡是带有select关键词的都是查询语言）</p><p>​        select…</p><p><strong>DML</strong>：数据操作语言（凡是对<strong>表当中的数据</strong>进行增删改的都是DML）</p><p>​        insert delete update</p><p>​        insert 增</p><p>​        delete 删</p><p>​        update 改</p><p><strong>DDL</strong>：数据定义语言（凡是带有create、drop、alter的都是DDL）</p><p>​        create：新建，等同于增</p><p>​        drop：删除</p><p>​        alter：修改</p><p>​        这个增删改和DML不同，这个主要是对<strong>表结构</strong>进行操作，不是表中的数据</p><p><strong>TCL</strong>：是事务控制语言，包括：事务提交：commit；事务回滚：rollback；</p><p><strong>DCL</strong>：是数据控制语言，例如：授权grant、撤销权限revoke…</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql 数据库 sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫项目豆瓣榜单（一）</title>
      <link href="/2021/082416001.html"/>
      <url>/2021/082416001.html</url>
      
        <content type="html"><![CDATA[<h1 id="项目概述"><a href="#项目概述" class="headerlink" title="项目概述"></a>项目概述</h1><p>在豆瓣电影Top250<a href="http://movie.douban.com/top250?start=">http://movie.douban.com/top250?start=</a>上爬取每部电影的详情，图片链接，影片中文名，外国名，评分，评价数，概况，相关信息</p><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/top250.png"></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> bs4 <span class="token keyword">import</span> BeautifulSoup<span class="token keyword">import</span> re<span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">,</span>urllib<span class="token punctuation">.</span>error<span class="token keyword">import</span> xlwt<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    baseurl<span class="token operator">=</span><span class="token string">"http://movie.douban.com/top250?start="</span>    <span class="token comment">#1.爬取网页</span>    datalist <span class="token operator">=</span> getData<span class="token punctuation">(</span>baseurl<span class="token punctuation">)</span>    <span class="token comment">#2.解析数据</span>    savepath<span class="token operator">=</span><span class="token string">".\\豆瓣电影Top250.xls"</span>    <span class="token comment">#3.保存数据</span>    saveData<span class="token punctuation">(</span>datalist<span class="token punctuation">,</span>savepath<span class="token punctuation">)</span><span class="token comment">#影片详情链接的规则</span>findLink <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;a href="(.*?)">'</span><span class="token punctuation">)</span> <span class="token comment">#创建正则表达式，表示规则（字符串的模式）</span><span class="token comment">#影片图片</span>findImgSrc <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;img.*src="(.*?)"'</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span><span class="token comment">#影片片名</span>findTitle <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;span class="title">(.*)&lt;/span>'</span><span class="token punctuation">)</span><span class="token comment">#影片评分</span>findRating <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;span class="rating_num" property="v:average">(.*)&lt;/span>'</span><span class="token punctuation">)</span><span class="token comment">#找到评价人数</span>findJudge <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;span>(\d*)人评价&lt;/span>'</span><span class="token punctuation">)</span><span class="token comment">#找到概况</span>findInq <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;span class="inq">(.*)&lt;/span>'</span><span class="token punctuation">)</span><span class="token comment">#找到影片的相关内容</span>findBd <span class="token operator">=</span> re<span class="token punctuation">.</span><span class="token builtin">compile</span><span class="token punctuation">(</span><span class="token string">r'&lt;p class="">(.*?)&lt;/p>'</span><span class="token punctuation">,</span>re<span class="token punctuation">.</span>S<span class="token punctuation">)</span><span class="token comment">#爬取网页</span><span class="token keyword">def</span> <span class="token function">getData</span><span class="token punctuation">(</span>baseurl<span class="token punctuation">)</span><span class="token punctuation">:</span>    datalist<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment">#调用获取页面信息的函数10次</span>        url <span class="token operator">=</span> baseurl <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>i<span class="token operator">*</span><span class="token number">25</span><span class="token punctuation">)</span>        html <span class="token operator">=</span> askURL<span class="token punctuation">(</span>url<span class="token punctuation">)</span>    <span class="token comment">#保存获取到的网页源码</span>        <span class="token comment">#逐一解析数据</span>        soup <span class="token operator">=</span> BeautifulSoup<span class="token punctuation">(</span>html<span class="token punctuation">,</span><span class="token string">"html.parser"</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> soup<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span>class_<span class="token operator">=</span><span class="token string">"item"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment">#查找符合要求的字符串</span>             <span class="token comment">#print(item)   #测试：查看item电影全部信息</span>             data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment">#保存一部电影的所有信息</span>             item <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>             <span class="token comment">#影片详情的链接</span>             link <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findLink<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>   <span class="token comment">#re库用来通过正则表达式查找指定的字符串</span>             data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>link<span class="token punctuation">)</span>                     <span class="token comment">#添加链接</span>             imgSrc <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findImgSrc<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>             data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>imgSrc<span class="token punctuation">)</span>                   <span class="token comment">#添加图片</span>             titles <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findTitle<span class="token punctuation">,</span>item<span class="token punctuation">)</span>   <span class="token comment">#片名可能只有一个中文名，没有外国名</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>titles<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                 ctitle <span class="token operator">=</span> titles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>                 data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>ctitle<span class="token punctuation">)</span>                 otitle <span class="token operator">=</span> titles<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token comment">#去掉无关的符号</span>                 data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>otitle<span class="token punctuation">)</span>                <span class="token comment">#添加外国名</span>             <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>titles<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>             <span class="token comment">#外国名字留空</span>             rating <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findRating<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>             data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>rating<span class="token punctuation">)</span>     <span class="token comment">#添加评分</span>             judgeNum <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findJudge<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>             data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>judgeNum<span class="token punctuation">)</span>      <span class="token comment">#添加评价人数</span>             inq <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findInq<span class="token punctuation">,</span>item<span class="token punctuation">)</span>             <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>inq<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                inq <span class="token operator">=</span> inq<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">"。"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token comment">#去掉句号</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>inq<span class="token punctuation">)</span>                    <span class="token comment">#添加概述</span>             <span class="token keyword">else</span><span class="token punctuation">:</span>                data<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span>                <span class="token comment">#留空</span>             bd <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>findBd<span class="token punctuation">,</span>item<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>             bd <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'&lt;br(\s+)?/>(\s+)?'</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>bd<span class="token punctuation">)</span>  <span class="token comment">#去掉&lt;br/></span>             bd <span class="token operator">=</span> re<span class="token punctuation">.</span>sub<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">,</span>bd<span class="token punctuation">)</span>    <span class="token comment">#替换/</span>             data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>bd<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">#去掉前后的空格</span>             datalist<span class="token punctuation">.</span>append<span class="token punctuation">(</span>data<span class="token punctuation">)</span>   <span class="token comment">#把处理好的一部信息放入datalist</span>    <span class="token keyword">return</span> datalist<span class="token comment">#得到指定一个URL的网页内容</span><span class="token keyword">def</span> <span class="token function">askURL</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span>    head <span class="token operator">=</span> <span class="token punctuation">&#123;</span>            <span class="token comment">#模拟浏览器信息，向豆瓣服务器发送信息</span>        <span class="token string">"User-Agent"</span><span class="token punctuation">:</span><span class="token string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.131 Safari/537.36 Edg/92.0.902.73"</span>    <span class="token punctuation">&#125;</span><span class="token comment">#用户代理，告诉豆瓣我们是浏览器，本质上是伪装，告诉服务器我们可以接受什么样的文件</span>    request <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>head<span class="token punctuation">)</span>    html <span class="token operator">=</span> <span class="token string">""</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        response <span class="token operator">=</span> urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>request<span class="token punctuation">)</span>        html <span class="token operator">=</span> response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">"utf-8"</span><span class="token punctuation">)</span>    <span class="token keyword">except</span> urllib<span class="token punctuation">.</span>error<span class="token punctuation">.</span>URLError <span class="token keyword">as</span> e<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span><span class="token string">"code"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>code<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span><span class="token string">"reason"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>reason<span class="token punctuation">)</span>    <span class="token keyword">return</span> html<span class="token comment">#保存数据</span><span class="token keyword">def</span> <span class="token function">saveData</span><span class="token punctuation">(</span>datalist<span class="token punctuation">,</span>savepath<span class="token punctuation">)</span><span class="token punctuation">:</span>    book <span class="token operator">=</span> xlwt<span class="token punctuation">.</span>Workbook<span class="token punctuation">(</span>encoding<span class="token operator">=</span><span class="token string">"utf-8"</span><span class="token punctuation">,</span>style_compression<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>    sheet <span class="token operator">=</span> book<span class="token punctuation">.</span>add_sheet<span class="token punctuation">(</span><span class="token string">'豆瓣电影Top250'</span><span class="token punctuation">,</span>cell_overwrite_ok <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>    col <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"电影详情链接"</span><span class="token punctuation">,</span><span class="token string">"图片链接"</span><span class="token punctuation">,</span><span class="token string">"影片中文名"</span><span class="token punctuation">,</span><span class="token string">"影片外国名"</span><span class="token punctuation">,</span><span class="token string">"评分"</span><span class="token punctuation">,</span><span class="token string">"评价数"</span><span class="token punctuation">,</span><span class="token string">"概况"</span><span class="token punctuation">,</span><span class="token string">"相关信息"</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        sheet<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>col<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">#列名</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">250</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第%d条"</span> <span class="token operator">%</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        data <span class="token operator">=</span> datalist<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            sheet<span class="token punctuation">.</span>write<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>data<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>    book<span class="token punctuation">.</span>save<span class="token punctuation">(</span>savepath<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">"__main__"</span><span class="token punctuation">:</span>    <span class="token comment">#调用函数</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"爬取完毕！"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>这只是将结果输出到excel表中，教程上还有有关MySQL的输出，可以在学习MySQL后进行补充</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python编程从入门到实践第二版项目实践（一）《外星人入侵》完整代码</title>
      <link href="/2021/081757954.html"/>
      <url>/2021/081757954.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h1><h2 id="安装pygame"><a href="#安装pygame" class="headerlink" title="安装pygame"></a>安装pygame</h2><p>在终端提示符下执行如下命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ python -m pip <span class="token function">install</span> --user pygame<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令让python运行pip模块，将pygame包添加到当前用户的python安装中</p><h1 id="代码总览"><a href="#代码总览" class="headerlink" title="代码总览"></a>代码总览</h1><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/1category.png"></p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><p>注：不用管_pycache_中的代码，运行后会自动生成</p><h2 id="images文件夹"><a href="#images文件夹" class="headerlink" title="images文件夹"></a>images文件夹</h2><p>alien和ship两个位图</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/alien.bmp"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/ship.bmp"></p><h2 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> sys<span class="token keyword">from</span> time <span class="token keyword">import</span> sleep<span class="token keyword">import</span> pygame<span class="token keyword">from</span> pygame<span class="token punctuation">.</span>constants <span class="token keyword">import</span> FULLSCREEN<span class="token keyword">from</span> settings <span class="token keyword">import</span> Settings<span class="token keyword">from</span> game_stats <span class="token keyword">import</span> GameStats<span class="token keyword">from</span> scoreboard <span class="token keyword">import</span> Scoreboard<span class="token keyword">from</span> button <span class="token keyword">import</span> Button<span class="token keyword">from</span> ship <span class="token keyword">import</span> Ship<span class="token keyword">from</span> bullet <span class="token keyword">import</span> Bullet<span class="token keyword">from</span> alien <span class="token keyword">import</span> Alien<span class="token keyword">class</span> <span class="token class-name">AlienInvasion</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""管理游戏资源和行为的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">""""初始化游戏并创建游戏资源"""</span>        pygame<span class="token punctuation">.</span>init<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> Settings<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> pygame<span class="token punctuation">.</span>display<span class="token punctuation">.</span>set_mode<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> pygame<span class="token punctuation">.</span>FULLSCREEN<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>screen_width <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width        self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>screen_height <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>height        pygame<span class="token punctuation">.</span>display<span class="token punctuation">.</span>set_caption<span class="token punctuation">(</span><span class="token string">"Alien Invasion"</span><span class="token punctuation">)</span>        <span class="token comment">#创建存储游戏统计信息的案例</span>        <span class="token comment">#并创建记分牌</span>        self<span class="token punctuation">.</span>stats <span class="token operator">=</span> GameStats<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>sb <span class="token operator">=</span> Scoreboard<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        <span class="token comment">#创建一个用于存储游戏统计信息的实例</span>        self<span class="token punctuation">.</span>ship <span class="token operator">=</span> Ship<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bullets <span class="token operator">=</span> pygame<span class="token punctuation">.</span>sprite<span class="token punctuation">.</span>Group<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>aliens <span class="token operator">=</span> pygame<span class="token punctuation">.</span>sprite<span class="token punctuation">.</span>Group<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_create_fleet<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#创建Play按钮</span>        self<span class="token punctuation">.</span>play_button <span class="token operator">=</span> Button<span class="token punctuation">(</span>self<span class="token punctuation">,</span><span class="token string">"Play"</span><span class="token punctuation">)</span>        <span class="token comment">#设置背景色</span>    <span class="token keyword">def</span> <span class="token function">run_game</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""开始游戏的主循环"""</span>        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_check_events<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>game_active<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>_update_bullets<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>_update_aliens<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_update_screen<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_events</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""响应按键和鼠标事件"""</span>        <span class="token keyword">for</span> event <span class="token keyword">in</span> pygame<span class="token punctuation">.</span>event<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> pygame<span class="token punctuation">.</span>QUIT<span class="token punctuation">:</span>                sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">elif</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> pygame<span class="token punctuation">.</span>KEYDOWN<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_check_keydown_events<span class="token punctuation">(</span>event<span class="token punctuation">)</span>            <span class="token keyword">elif</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> pygame<span class="token punctuation">.</span>KEYUP<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_check_keyup_events<span class="token punctuation">(</span>event<span class="token punctuation">)</span>            <span class="token keyword">elif</span> event<span class="token punctuation">.</span><span class="token builtin">type</span> <span class="token operator">==</span> pygame<span class="token punctuation">.</span>MOUSEBUTTONDOWN<span class="token punctuation">:</span>                mouse_pos <span class="token operator">=</span> pygame<span class="token punctuation">.</span>mouse<span class="token punctuation">.</span>get_pos<span class="token punctuation">(</span><span class="token punctuation">)</span>                self<span class="token punctuation">.</span>_check_play_button<span class="token punctuation">(</span>mouse_pos<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_play_button</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>mouse_pos<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在玩家单击Play按钮时开始新游戏"""</span>        button_clicked <span class="token operator">=</span> self<span class="token punctuation">.</span>play_button<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>collidepoint<span class="token punctuation">(</span>mouse_pos<span class="token punctuation">)</span>        <span class="token keyword">if</span> button_clicked <span class="token keyword">and</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>game_active<span class="token punctuation">:</span>            <span class="token comment">#重置游戏设置</span>            self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>initialize_dynamic_settings<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#重置游戏统计信息</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>reset_stats<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>game_active <span class="token operator">=</span><span class="token boolean">True</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_score<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_level<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_ships<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#清空余下的外星人和子弹</span>            self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#创建一群新的外星人并让飞船居中</span>            self<span class="token punctuation">.</span>_create_fleet<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>center_ship<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#隐藏鼠标光标</span>            pygame<span class="token punctuation">.</span>mouse<span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>                             <span class="token keyword">def</span> <span class="token function">_check_keydown_events</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""响应按键"""</span>        <span class="token keyword">if</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_RIGHT<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>moving_right<span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">elif</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_LEFT<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>moving_left<span class="token operator">=</span><span class="token boolean">True</span>        <span class="token keyword">elif</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_q<span class="token punctuation">:</span>            sys<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">elif</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_SPACE<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_fire_bullet<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_keyup_events</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""响应松开"""</span>        <span class="token keyword">if</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_RIGHT<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>moving_right <span class="token operator">=</span><span class="token boolean">False</span>        <span class="token keyword">elif</span> event<span class="token punctuation">.</span>key <span class="token operator">==</span> pygame<span class="token punctuation">.</span>K_LEFT<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>moving_left <span class="token operator">=</span><span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">_fire_bullet</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""创建一颗新子弹并将其加入编组bullets中"""</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>bullets<span class="token punctuation">)</span> <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bullets_allowed<span class="token punctuation">:</span>            new_bullet <span class="token operator">=</span> Bullet<span class="token punctuation">(</span>self<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>add<span class="token punctuation">(</span>new_bullet<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_update_bullets</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""更新子弹的位置并删除消失的子弹"""</span>        <span class="token comment">#更新子弹的位置</span>        self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#删除消失的子弹</span>        <span class="token keyword">for</span> bullet <span class="token keyword">in</span> self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> bullet<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>bottom <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>bullet<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>_check_bullet_alien_collisions<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_bullet_alien_collisions</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""响应子弹和外星人碰撞"""</span>        <span class="token comment">#删除发生碰撞的子弹和外星人</span>        collisions <span class="token operator">=</span> pygame<span class="token punctuation">.</span>sprite<span class="token punctuation">.</span>groupcollide<span class="token punctuation">(</span>            self<span class="token punctuation">.</span>bullets<span class="token punctuation">,</span>self<span class="token punctuation">.</span>aliens<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> collisions<span class="token punctuation">:</span>            <span class="token keyword">for</span> aliens <span class="token keyword">in</span> collisions<span class="token punctuation">.</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>score <span class="token operator">+=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>alien_points <span class="token operator">*</span> <span class="token builtin">len</span><span class="token punctuation">(</span>aliens<span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_score<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>check_high_score<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>aliens<span class="token punctuation">:</span>            <span class="token comment">#删除现有的子弹并新建一群外星人</span>            self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>_create_fleet<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>increase_speed<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#提高等级</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>level<span class="token operator">+=</span><span class="token number">1</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_level<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_ship_hit</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""响应飞船被外星人撞到"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>ships_left <span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment">#将ships_left减1并更新记分牌</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>ships_left <span class="token operator">-=</span> <span class="token number">1</span>            self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>prep_ships<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#清空余下的外星人和子弹</span>            self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>empty<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#创建一群新的外星人，并将飞船放到屏幕底端的中央</span>            self<span class="token punctuation">.</span>_create_fleet<span class="token punctuation">(</span><span class="token punctuation">)</span>            self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>center_ship<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">#暂停</span>            sleep<span class="token punctuation">(</span><span class="token number">0.5</span><span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>game_active <span class="token operator">=</span> <span class="token boolean">False</span>            pygame<span class="token punctuation">.</span>mouse<span class="token punctuation">.</span>set_visible<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_update_aliens</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""检查是否有外星人位于屏幕边缘，并更新整群外星人的位置"""</span>        <span class="token triple-quoted-string string">"""更新外星人群中所有外星人的位置"""</span>        self<span class="token punctuation">.</span>_check_fleet_edges<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#检测外星人和飞船之间的碰撞</span>        <span class="token keyword">if</span> pygame<span class="token punctuation">.</span>sprite<span class="token punctuation">.</span>spritecollideany<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ship<span class="token punctuation">,</span>self<span class="token punctuation">.</span>aliens<span class="token punctuation">)</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>_ship_hit<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#检查是否有外星人到达了屏幕底端</span>        self<span class="token punctuation">.</span>_check_aliens_bottom<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_aliens_bottom</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""检查是否有外星人到达了屏幕底端"""</span>        screen_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> alien <span class="token keyword">in</span> self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>sprites<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>bottom <span class="token operator">>=</span>screen_rect<span class="token punctuation">.</span>bottom<span class="token punctuation">:</span>                <span class="token comment">#像飞船被撞到一样处理</span>                self<span class="token punctuation">.</span>_ship_hit<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>    <span class="token keyword">def</span> <span class="token function">_create_fleet</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""创建外星人群"""</span>        <span class="token comment">#创建一个外星人</span>        alien <span class="token operator">=</span> Alien<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        alien_width<span class="token punctuation">,</span>alien_height <span class="token operator">=</span> alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>size        available_space_x <span class="token operator">=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>screen_width <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>alien_width<span class="token punctuation">)</span>        number_alien_x <span class="token operator">=</span> available_space_x <span class="token operator">//</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>alien_width<span class="token punctuation">)</span>        <span class="token comment">#计算屏幕可容纳多少行外星人</span>        ship_height <span class="token operator">=</span> self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>height        available_space_y <span class="token operator">=</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>screen_height<span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">*</span>alien_height<span class="token punctuation">)</span><span class="token operator">-</span>ship_height<span class="token punctuation">)</span>        number_rows <span class="token operator">=</span> available_space_y <span class="token operator">//</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>alien_height<span class="token punctuation">)</span>        <span class="token comment">#创建外星人群</span>        <span class="token keyword">for</span> row_number <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number_rows<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> alien_number <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>number_alien_x<span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_create_alien<span class="token punctuation">(</span>alien_number<span class="token punctuation">,</span>row_number<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_create_alien</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>alien_number<span class="token punctuation">,</span>row_number<span class="token punctuation">)</span><span class="token punctuation">:</span>        alien <span class="token operator">=</span> Alien<span class="token punctuation">(</span>self<span class="token punctuation">)</span>        alien_width<span class="token punctuation">,</span> alien_height <span class="token operator">=</span> alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>size        alien<span class="token punctuation">.</span>x <span class="token operator">=</span> alien_width <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> alien_width <span class="token operator">*</span> alien_number        alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x <span class="token operator">=</span> alien<span class="token punctuation">.</span>x        alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y <span class="token operator">=</span> alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>height <span class="token operator">+</span> <span class="token number">2</span><span class="token operator">*</span>alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>height<span class="token operator">*</span> row_number        self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>add<span class="token punctuation">(</span>alien<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_check_fleet_edges</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""有外星人到达边缘时采取相应的措施"""</span>        <span class="token keyword">for</span> alien <span class="token keyword">in</span> self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>sprites<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> alien<span class="token punctuation">.</span>check_edges<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                self<span class="token punctuation">.</span>_change_fleet_direction<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>    <span class="token keyword">def</span> <span class="token function">_change_fleet_direction</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将整群外星人下移，并改变他们的方向"""</span>        <span class="token keyword">for</span> alien <span class="token keyword">in</span> self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>sprites<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            alien<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y <span class="token operator">+=</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>fleet_drop_speed        self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>fleet_direction <span class="token operator">*=</span> <span class="token operator">-</span><span class="token number">1</span>    <span class="token keyword">def</span> <span class="token function">_update_screen</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""更新屏幕上的图像，并切换到新屏幕"""</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>fill<span class="token punctuation">(</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bg_color<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>blitme<span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token keyword">for</span> bullet <span class="token keyword">in</span> self<span class="token punctuation">.</span>bullets<span class="token punctuation">.</span>sprites<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            bullet<span class="token punctuation">.</span>draw_bullet<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>aliens<span class="token punctuation">.</span>draw<span class="token punctuation">(</span>self<span class="token punctuation">.</span>screen<span class="token punctuation">)</span>        <span class="token comment">#显示得分</span>        self<span class="token punctuation">.</span>sb<span class="token punctuation">.</span>show_score<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#如果游戏处于非活动状态，就绘制Play按钮</span>        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>game_active<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>play_button<span class="token punctuation">.</span>draw_button<span class="token punctuation">(</span><span class="token punctuation">)</span>              pygame<span class="token punctuation">.</span>display<span class="token punctuation">.</span>flip<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">if</span> __name__<span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment">#创建游戏实例并运行游戏</span>    ai<span class="token operator">=</span>AlienInvasion<span class="token punctuation">(</span><span class="token punctuation">)</span>    ai<span class="token punctuation">.</span>run_game<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="alien-py"><a href="#alien-py" class="headerlink" title="alien.py"></a>alien.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pygame<span class="token keyword">from</span> pygame<span class="token punctuation">.</span>sprite <span class="token keyword">import</span> Sprite<span class="token keyword">class</span> <span class="token class-name">Alien</span><span class="token punctuation">(</span>Sprite<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""表示单个外星人的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化外星人并设置其初始位置"""</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>screen        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>settings        <span class="token comment">#加载外星人图像并设置其rect属性</span>        self<span class="token punctuation">.</span>image <span class="token operator">=</span> pygame<span class="token punctuation">.</span>image<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'images/alien.bmp'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rect <span class="token operator">=</span> self<span class="token punctuation">.</span>image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#每个外星人最初都在屏幕左上角附近</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x <span class="token operator">=</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>width        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y <span class="token operator">=</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>height        <span class="token comment">#存储外星人的精确水平位置</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">check_edges</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""如果外星人位于屏幕边缘，就返回True"""</span>        screen_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>right <span class="token operator">>=</span> screen_rect<span class="token punctuation">.</span>right <span class="token keyword">or</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>left <span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""向右移动外星人"""</span>        self<span class="token punctuation">.</span>x <span class="token operator">+=</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>alien_speed<span class="token operator">*</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>fleet_direction<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x <span class="token operator">=</span> self<span class="token punctuation">.</span>x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pygame<span class="token keyword">from</span> pygame<span class="token punctuation">.</span>sprite <span class="token keyword">import</span> Sprite<span class="token keyword">class</span> <span class="token class-name">Bullet</span><span class="token punctuation">(</span>Sprite<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""管理飞船所发射子弹的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在飞船当前位置创建一个子弹对象"""</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>screen        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>settings        self<span class="token punctuation">.</span>color <span class="token operator">=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bullet_color        <span class="token comment">#在（0,0）处创建一个表示子弹的矩形，在设置正确的位置</span>        self<span class="token punctuation">.</span>rect <span class="token operator">=</span> pygame<span class="token punctuation">.</span>Rect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bullet_width<span class="token punctuation">,</span>            self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bullet_height<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>midtop <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>ship<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>midtop        <span class="token comment">#存储用小数表示的子弹位置</span>        self<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""向上表示子弹"""</span>        <span class="token comment">#更新表示子弹位置的小数值</span>        self<span class="token punctuation">.</span>y <span class="token operator">-=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bullet_speed        <span class="token comment">#更新表示子弹的rect的位置</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y <span class="token operator">=</span> self<span class="token punctuation">.</span>y    <span class="token keyword">def</span> <span class="token function">draw_bullet</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在屏幕上绘制子弹"""</span>        pygame<span class="token punctuation">.</span>draw<span class="token punctuation">.</span>rect<span class="token punctuation">(</span>self<span class="token punctuation">.</span>screen<span class="token punctuation">,</span>self<span class="token punctuation">.</span>color<span class="token punctuation">,</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="button-py"><a href="#button-py" class="headerlink" title="button.py"></a>button.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pygame<span class="token punctuation">.</span>font<span class="token keyword">class</span> <span class="token class-name">Button</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化按钮的属性"""</span>        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>screen        self<span class="token punctuation">.</span>screen_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#设置按钮的尺寸和其他属性</span>        self<span class="token punctuation">.</span>width<span class="token punctuation">,</span>self<span class="token punctuation">.</span>height <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">,</span><span class="token number">50</span>        self<span class="token punctuation">.</span>button_color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>text_color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>font <span class="token operator">=</span> pygame<span class="token punctuation">.</span>font<span class="token punctuation">.</span>SysFont<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">)</span>        <span class="token comment">#创建按钮的rect对象，并使其居中</span>        self<span class="token punctuation">.</span>rect <span class="token operator">=</span> pygame<span class="token punctuation">.</span>Rect<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>width<span class="token punctuation">,</span>self<span class="token punctuation">.</span>height<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>center <span class="token operator">=</span> self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>center        <span class="token comment">#按钮的标签只需创建一次</span>        self<span class="token punctuation">.</span>_prep_msg<span class="token punctuation">(</span>msg<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">_prep_msg</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>msg<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将msg渲染为图像，并使其在按钮上居中"""</span>        self<span class="token punctuation">.</span>msg_image <span class="token operator">=</span> self<span class="token punctuation">.</span>font<span class="token punctuation">.</span>render<span class="token punctuation">(</span>msg<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span>self<span class="token punctuation">.</span>text_color<span class="token punctuation">,</span>                self<span class="token punctuation">.</span>button_color<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>msg_image_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>msg_image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>msg_image_rect<span class="token punctuation">.</span>center <span class="token operator">=</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>center    <span class="token keyword">def</span> <span class="token function">draw_button</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment">#绘制一个用颜色填充的按钮，在绘制文本</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>fill<span class="token punctuation">(</span>self<span class="token punctuation">.</span>button_color<span class="token punctuation">,</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>blit<span class="token punctuation">(</span>self<span class="token punctuation">.</span>msg_image<span class="token punctuation">,</span>self<span class="token punctuation">.</span>msg_image_rect<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">GameStats</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""跟踪游戏的统计信息"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化统计信息"""</span>        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>settings        self<span class="token punctuation">.</span>reset_stats<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#游戏刚启动时处于活动状态</span>        self<span class="token punctuation">.</span>game_active <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token comment">#任何情况下都不会重置最高得分</span>        self<span class="token punctuation">.</span>high_score <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">def</span> <span class="token function">reset_stats</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化在游戏运行期间可能变化的统计信息"""</span>        self<span class="token punctuation">.</span>ships_left <span class="token operator">=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>ship_limit        self<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">0</span>        self<span class="token punctuation">.</span>level <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="scoreboard-py"><a href="#scoreboard-py" class="headerlink" title="scoreboard.py"></a>scoreboard.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pygame<span class="token punctuation">.</span>font<span class="token keyword">from</span> pygame<span class="token punctuation">.</span>sprite <span class="token keyword">import</span> Group<span class="token keyword">from</span> ship <span class="token keyword">import</span> Ship<span class="token keyword">class</span> <span class="token class-name">Scoreboard</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""显示得分信息的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化显示得分涉及的属性"""</span>        self<span class="token punctuation">.</span>ai_game <span class="token operator">=</span> ai_game        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>screen        self<span class="token punctuation">.</span>screen_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>settings        self<span class="token punctuation">.</span>stats <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>stats                <span class="token comment">#显示得分信息时使用的字体设置</span>        self<span class="token punctuation">.</span>text_color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>font <span class="token operator">=</span> pygame<span class="token punctuation">.</span>font<span class="token punctuation">.</span>SysFont<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">)</span>        <span class="token comment">#准备包括最高得分和当前得分的图像</span>        self<span class="token punctuation">.</span>prep_score<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>prep_high_score<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>prep_level<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>prep_ships<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">prep_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将得分转换为一幅渲染的图像"""</span>        rounded_score <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>score<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        score_str<span class="token operator">=</span><span class="token string">"&#123;:,&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>rounded_score<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>score_image <span class="token operator">=</span> self<span class="token punctuation">.</span>font<span class="token punctuation">.</span>render<span class="token punctuation">(</span>score_str<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span>                self<span class="token punctuation">.</span>text_color<span class="token punctuation">,</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bg_color<span class="token punctuation">)</span>        <span class="token comment">#在屏幕右上角显示得分</span>        self<span class="token punctuation">.</span>score_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>score_image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>score_rect<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>right <span class="token operator">-</span> <span class="token number">20</span>        self<span class="token punctuation">.</span>score_rect<span class="token punctuation">.</span>top <span class="token operator">=</span><span class="token number">20</span>        <span class="token keyword">def</span> <span class="token function">prep_high_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将最高分转换为渲染的图像"""</span>        high_score <span class="token operator">=</span> <span class="token builtin">round</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>high_score<span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>        high_score_str <span class="token operator">=</span> <span class="token string">"&#123;:,&#125;"</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>high_score<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>high_score_image <span class="token operator">=</span> self<span class="token punctuation">.</span>font<span class="token punctuation">.</span>render<span class="token punctuation">(</span>high_score_str<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span>                self<span class="token punctuation">.</span>text_color<span class="token punctuation">,</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bg_color<span class="token punctuation">)</span>        <span class="token comment">#将最高得分放在屏幕顶部中央</span>        self<span class="token punctuation">.</span>high_score_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>high_score_image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>high_score_rect<span class="token punctuation">.</span>centerx <span class="token operator">=</span>self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>centerx        self<span class="token punctuation">.</span>high_score_rect<span class="token punctuation">.</span>top <span class="token operator">=</span>self<span class="token punctuation">.</span>score_rect<span class="token punctuation">.</span>top            <span class="token keyword">def</span> <span class="token function">prep_level</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""将等级转换为渲染的图像"""</span>        level_str <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>level<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>level_image <span class="token operator">=</span> self<span class="token punctuation">.</span>font<span class="token punctuation">.</span>render<span class="token punctuation">(</span>level_str<span class="token punctuation">,</span><span class="token boolean">True</span><span class="token punctuation">,</span>                self<span class="token punctuation">.</span>text_color<span class="token punctuation">,</span>self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>bg_color<span class="token punctuation">)</span>        <span class="token comment">#将等级放在得分下方</span>        self<span class="token punctuation">.</span>level_rect <span class="token operator">=</span> self<span class="token punctuation">.</span>level_image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>level_rect<span class="token punctuation">.</span>right <span class="token operator">=</span> self<span class="token punctuation">.</span>score_rect<span class="token punctuation">.</span>right        self<span class="token punctuation">.</span>level_rect<span class="token punctuation">.</span>top <span class="token operator">=</span>self<span class="token punctuation">.</span>score_rect<span class="token punctuation">.</span>bottom <span class="token operator">+</span> <span class="token number">10</span>    <span class="token keyword">def</span> <span class="token function">prep_ships</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""显示还余下多少飞船"""</span>        self<span class="token punctuation">.</span>ships <span class="token operator">=</span> Group<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> ship_number <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>ships_left<span class="token punctuation">)</span><span class="token punctuation">:</span>            ship <span class="token operator">=</span> Ship<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ai_game<span class="token punctuation">)</span>            ship<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">+</span> ship_number <span class="token operator">*</span> ship<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>width            ship<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">10</span>            self<span class="token punctuation">.</span>ships<span class="token punctuation">.</span>add<span class="token punctuation">(</span>ship<span class="token punctuation">)</span>        <span class="token keyword">def</span> <span class="token function">check_high_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""检查是否诞生了新的最高得分"""</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>score <span class="token operator">></span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>high_score<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>high_score <span class="token operator">=</span> self<span class="token punctuation">.</span>stats<span class="token punctuation">.</span>score            self<span class="token punctuation">.</span>prep_high_score<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token keyword">def</span> <span class="token function">show_score</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在屏幕上显示得分、等级和余下的飞船数"""</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>blit<span class="token punctuation">(</span>self<span class="token punctuation">.</span>score_image<span class="token punctuation">,</span>self<span class="token punctuation">.</span>score_rect<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>blit<span class="token punctuation">(</span>self<span class="token punctuation">.</span>high_score_image<span class="token punctuation">,</span>self<span class="token punctuation">.</span>high_score_rect<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>blit<span class="token punctuation">(</span>self<span class="token punctuation">.</span>level_image<span class="token punctuation">,</span>self<span class="token punctuation">.</span>level_rect<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>ships<span class="token punctuation">.</span>draw<span class="token punctuation">(</span>self<span class="token punctuation">.</span>screen<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Settings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""存储游戏《外星人入侵》中所有设置的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化游戏的静态设置"""</span>        <span class="token comment">#屏幕设置</span>        self<span class="token punctuation">.</span>screen_width<span class="token operator">=</span><span class="token number">1200</span>        self<span class="token punctuation">.</span>screen_height<span class="token operator">=</span><span class="token number">800</span>        self<span class="token punctuation">.</span>bg_color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">230</span><span class="token punctuation">,</span><span class="token number">230</span><span class="token punctuation">,</span><span class="token number">230</span><span class="token punctuation">)</span>        <span class="token comment">#飞船设置</span>        self<span class="token punctuation">.</span>ship_limit <span class="token operator">=</span> <span class="token number">3</span>        <span class="token comment">#子弹设置</span>        self<span class="token punctuation">.</span>bullet_width <span class="token operator">=</span><span class="token number">3</span>        self<span class="token punctuation">.</span>bullet_height<span class="token operator">=</span><span class="token number">15</span>        self<span class="token punctuation">.</span>bullet_color <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">,</span><span class="token number">60</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>bullets_allowed <span class="token operator">=</span> <span class="token number">3</span>        <span class="token comment">#外星人设置</span>        self<span class="token punctuation">.</span>fleet_drop_speed <span class="token operator">=</span> <span class="token number">10</span>        <span class="token comment">#fleet_direction为1表示向右移，为-1表示向左移</span>        self<span class="token punctuation">.</span>fleet_direction <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment">#加快游戏的节奏</span>        self<span class="token punctuation">.</span>speedup_scale <span class="token operator">=</span> <span class="token number">1.1</span>        <span class="token comment">#外星人分数的提高速度</span>        self<span class="token punctuation">.</span>score_scale <span class="token operator">=</span> <span class="token number">1.5</span>        self<span class="token punctuation">.</span>initialize_dynamic_settings<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">initialize_dynamic_settings</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化随游戏进行而变化的设置"""</span>        self<span class="token punctuation">.</span>ship_speed <span class="token operator">=</span> <span class="token number">1.5</span>        self<span class="token punctuation">.</span>bullet_speed <span class="token operator">=</span> <span class="token number">3.0</span>        self<span class="token punctuation">.</span>alien_speed <span class="token operator">=</span> <span class="token number">1.0</span>        <span class="token comment">#fleet_direction 为1表示向右，为-1表示向左</span>        self<span class="token punctuation">.</span>fleet_direction <span class="token operator">=</span> <span class="token number">1</span>        <span class="token comment">#记分</span>        self<span class="token punctuation">.</span>alien_points <span class="token operator">=</span> <span class="token number">50</span>    <span class="token keyword">def</span> <span class="token function">increase_speed</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""提高速度设置和外星人分数"""</span>        self<span class="token punctuation">.</span>ship_speed <span class="token operator">*=</span> self<span class="token punctuation">.</span>speedup_scale        self<span class="token punctuation">.</span>bullet_speed <span class="token operator">*=</span> self<span class="token punctuation">.</span>speedup_scale        self<span class="token punctuation">.</span>alien_speed <span class="token operator">*=</span> self<span class="token punctuation">.</span>speedup_scale        self<span class="token punctuation">.</span>alien_points <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>alien_points <span class="token operator">*</span> self<span class="token punctuation">.</span>score_scale<span class="token punctuation">)</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> pygame<span class="token keyword">from</span> pygame<span class="token punctuation">.</span>sprite <span class="token keyword">import</span> Sprite<span class="token keyword">class</span> <span class="token class-name">Ship</span><span class="token punctuation">(</span>Sprite<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""管理飞船的类"""</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>ai_game<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""初始化飞船并设置其初始位置"""</span>        <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>screen <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>screen        self<span class="token punctuation">.</span>settings <span class="token operator">=</span> ai_game<span class="token punctuation">.</span>settings        self<span class="token punctuation">.</span>screen_rect <span class="token operator">=</span>ai_game<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#加载飞船图像并获取其外接矩形</span>        self<span class="token punctuation">.</span>image <span class="token operator">=</span> pygame<span class="token punctuation">.</span>image<span class="token punctuation">.</span>load<span class="token punctuation">(</span><span class="token string">'images/ship.bmp'</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>rect <span class="token operator">=</span> self<span class="token punctuation">.</span>image<span class="token punctuation">.</span>get_rect<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">#对于每艘新飞船，都将其放在屏幕底部的中央</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>midbottom <span class="token operator">=</span> self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>midbottom        <span class="token comment">#在飞船的属性x中存储小数值</span>        self<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x<span class="token punctuation">)</span>        <span class="token comment">#移动标志</span>        self<span class="token punctuation">.</span>moving_right <span class="token operator">=</span><span class="token boolean">False</span>        self<span class="token punctuation">.</span>moving_left <span class="token operator">=</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""根据移动标志调整飞船位置"""</span>        <span class="token comment">#更新飞船而不是rect对象的x值</span>        <span class="token keyword">if</span> self<span class="token punctuation">.</span>moving_right <span class="token keyword">and</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>right <span class="token operator">&lt;</span> self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>right<span class="token punctuation">:</span>            self<span class="token punctuation">.</span>x <span class="token operator">+=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>ship_speed        <span class="token keyword">if</span> self<span class="token punctuation">.</span>moving_left <span class="token keyword">and</span> self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>left <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>x <span class="token operator">-=</span> self<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>ship_speed        <span class="token comment">#根据self.x更新rect对象</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x <span class="token operator">=</span> self<span class="token punctuation">.</span>x    <span class="token keyword">def</span> <span class="token function">blitme</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""在指定位置绘制飞船"""</span>        self<span class="token punctuation">.</span>screen<span class="token punctuation">.</span>blit<span class="token punctuation">(</span>self<span class="token punctuation">.</span>image<span class="token punctuation">,</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">center_ship</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">"""让飞船在屏幕底端居中"""</span>        self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>midbottom <span class="token operator">=</span> self<span class="token punctuation">.</span>screen_rect<span class="token punctuation">.</span>midbottom        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token builtin">float</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>rect<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>在最后debug的过程中，刚开始都是一些小小的拼写错误，可到最后程序能正常运行的时候却出现了分数、等级不能正常增加，飞船数在碰撞后不能正常减少的问题，我花了两天时间搜遍了几乎所有的资料，然后与源代码文件比对了很长时间，也没发现是哪的错误。直到最后，一次偶然我发现在alien_invasion.py中的init方法里我多敲了一遍<code>self.stats = GameStats(self)</code>，我抱着试一试的态度把它删掉，结果发现都变得正常了。之前与源代码对比的时候，因为觉得init方法应该不会出现什么问题，毕竟能正常运行，而且在其他的语言中多定义一次也大差不差，所以就没怎么注意。现在虽然找出了问题所在，然而却仍不知道为什么多敲一遍会导致这样的错误，如果有人看到了这篇文章，并且知道这个原因的话，希望可以留言告诉我。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸟哥私房菜学习（四）</title>
      <link href="/2021/081132315.html"/>
      <url>/2021/081132315.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、练习机的规划"><a href="#一、练习机的规划" class="headerlink" title="一、练习机的规划"></a>一、练习机的规划</h1><p>最重要的是磁盘分区的配置</p><table><thead><tr><th>所需目录/设备</th><th>磁盘容量</th><th>文件系统</th><th>分区格式</th></tr></thead><tbody><tr><td>BIOS boot</td><td>2MB</td><td>系统自定义</td><td>主要分区</td></tr><tr><td>/boot</td><td>1GB</td><td>xfs</td><td>主要分区</td></tr><tr><td>/</td><td>10GB</td><td>xfs</td><td>LVM方式</td></tr><tr><td>/home</td><td>5GB</td><td>xfs</td><td>LVM方式</td></tr><tr><td>交换分区</td><td>1GB</td><td>swap</td><td>LVM方式</td></tr></tbody></table><h1 id="二、开始安装CentOS-7"><a href="#二、开始安装CentOS-7" class="headerlink" title="二、开始安装CentOS 7"></a>二、开始安装CentOS 7</h1><h2 id="在VMware安装CentOS-7"><a href="#在VMware安装CentOS-7" class="headerlink" title="在VMware安装CentOS 7"></a>在VMware安装CentOS 7</h2><p>由于教材中使用的是虚拟机来做这个练习，而我使用的是VMware安装的CentOS 7，因此我先演示如何在VMware安装CentOS 7</p><p>1、找到CentOS 7的镜像网站（我用的是中科大的镜像站<a href="http://centos.ustc.edu.cn/centos/7/isos/">http://centos.ustc.edu.cn/centos/7/isos/</a>）</p><p>2、下载<strong>everything版本</strong>，文件较大，可能会出现下载失败的情况，多试几次</p><p>3、打开VMware，创建新的虚拟机，选择<strong>自定义配置</strong></p><p>4、按照如下的步骤逐步进行设置</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install1.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install2.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install3.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install4.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install5.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install6.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install7.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install8.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install9.png"></p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/install10.png"></p><p>全部进行完后点完成即可</p><h2 id="选择安装模式与启动"><a href="#选择安装模式与启动" class="headerlink" title="选择安装模式与启动"></a>选择安装模式与启动</h2><p>由于教材上的安装较为繁琐，这里简约说明，未提及的说明是不用管的，若未看懂的参考教材</p><p><strong>加入强制使用GPT分区的安装参数</strong></p><p>1、使用箭头键，将光标移动到【Install CentOS 7】选项</p><p>2、按下键盘的【Tab】按键，让光标移动到界面最下方输入额外的内核参数</p><p>3、在出现的界面中输入以下参数</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">vmlinuz <span class="token assign-left variable">initrd</span><span class="token operator">=</span>initrd img inst.stage2<span class="token operator">=</span>hd:LABEL<span class="token operator">=</span>CentOS<span class="token punctuation">\</span>x207<span class="token punctuation">\</span>x20x86_64 rd.live.check quiet inst.gpt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按下回车</p><p>等待会后，进入安装流程选择中文，按下【继续】</p><h3 id="设置日期，时间和键盘布局"><a href="#设置日期，时间和键盘布局" class="headerlink" title="设置日期，时间和键盘布局"></a>设置日期，时间和键盘布局</h3><ul><li>进入【日期和时间】项目，城市选择上海，若时间不正确自行调整</li><li>进入【键盘】项目，键盘布局右侧点击【选项】，找到Ctrl+Shift，选中，点击【确定】</li></ul><h3 id="安装源设置与软件选择"><a href="#安装源设置与软件选择" class="headerlink" title="安装源设置与软件选择"></a>安装源设置与软件选择</h3><ul><li>进入【安装源】项目，确定已有自动检测的安装介质</li><li>进入【软件选择】项目，选中【带GUI的服务器】</li></ul><h3 id="磁盘分区与文件系统设置（重点）"><a href="#磁盘分区与文件系统设置（重点）" class="headerlink" title="磁盘分区与文件系统设置（重点）"></a>磁盘分区与文件系统设置（重点）</h3><p>进入【安装位置】项目，选中硬盘，点击下方【我要配置分区】，点击【完成】</p><h4 id="BIOS-Boot"><a href="#BIOS-Boot" class="headerlink" title="BIOS Boot"></a>BIOS Boot</h4><p>点击【+】符号，挂载点选择【biosboot】，期望容量输入【2M】</p><h4 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h4><p>点击【+】符号，挂载点选择【/boot】，期望容量输入【1G】</p><h4 id=""><a href="#" class="headerlink" title="/"></a>/</h4><p>点击【+】符号，挂载点选择【/】，期望容量输入【10G】，设备类型改为【LVM】，点击【修改】</p><p>大小策略改为【大小固定】，输入【30G】</p><h4 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h4><p>点击【+】符号，挂载点选择【/home】，期望容量输入【5G】，设备类型改为【LVM】</p><h4 id="swap"><a href="#swap" class="headerlink" title="/swap"></a>/swap</h4><p>点击【+】符号，挂载点选择【/swap】，期望容量输入【1G】，设备类型改为【LVM】</p><p>全部修改完成后，左下方可用空间应为9209.97MiB，点击【完成】，点击【接受更改】</p><p><em>内存交换分区的功能为：党有数据被存放在物理内存里面，但是这些数据又不是常被CPU所使用时，那么这些不常被使用的数据将会被扔到硬盘的交换分区当中，而将速度较快的物理内存空间释放出来给真正需要的程序使用</em></p><h3 id="内核管理与网络设置"><a href="#内核管理与网络设置" class="headerlink" title="内核管理与网络设置"></a>内核管理与网络设置</h3><p>【KDUMP】是处理当Linux系统因为内核问题导致的宕机事件时会将宕机事件的内存中的数据保存的一项功能，主要偏向内核开发者除错用，可以开启可以不开</p><p>进入【网络和主机名】项目，右上角选择【开启】，点击【配置】选项，点击【常规】，选中【可用时自动链接到这个网络】，点击【IPV4设置】</p><p>方法改为【手动】，点击【添加】，输入地址与子网掩码，点击【保存】，修改主机名</p><p>未取得IP的情况下，可以套用如下的IP参数：</p><ul><li>是否使用DHCP：无</li><li>IP：192.168.1.100</li><li>子网掩码：255.255.255.0</li><li>主机名：study.centos.vbird</li></ul><h3 id="开始安装、设置root密码与新增可切换身份之一般用户"><a href="#开始安装、设置root密码与新增可切换身份之一般用户" class="headerlink" title="开始安装、设置root密码与新增可切换身份之一般用户"></a>开始安装、设置root密码与新增可切换身份之一般用户</h3><p>点击【开始安装】</p><p>点击【ROOT密码】，设置root密码</p><p>点击【创建用户】，创立一般用户，需要勾选【将此用户做为管理员】，可以使这个账号在需要时用自己的root密码来切换身份成为root，而不知道root的密码</p><h3 id="准备使用系统前的授权同意"><a href="#准备使用系统前的授权同意" class="headerlink" title="准备使用系统前的授权同意"></a>准备使用系统前的授权同意</h3><p>重启进入系统后，需要点击【许可信息】，勾选【同意许可协议】，即可进入CentOS 7系统</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸟哥私房菜学习（三）</title>
      <link href="/2021/08104346.html"/>
      <url>/2021/08104346.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux与硬件的搭配"><a href="#一、Linux与硬件的搭配" class="headerlink" title="一、Linux与硬件的搭配"></a>一、Linux与硬件的搭配</h1><p>各个组件或设备在Linux下面都是一个文件</p><h2 id="1、认识计算机的硬件设备"><a href="#1、认识计算机的硬件设备" class="headerlink" title="1、认识计算机的硬件设备"></a>1、认识计算机的硬件设备</h2><p>游戏机/工作机的考虑</p><p>性能/价格比与性能/消耗的瓦数比的考虑</p><p>支持度的考虑：当我们想要购买或是升级某些计算机组件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序</p><h2 id="2、选择与Linux搭配的主机设备"><a href="#2、选择与Linux搭配的主机设备" class="headerlink" title="2、选择与Linux搭配的主机设备"></a>2、选择与Linux搭配的主机设备</h2><p>桌面型Linux系统/含X-Window</p><p>用途：Linux的练习机或办公室工作机（一般我们会用到的环境）</p><p>CPU：最好等级高一点，例如Intel i5、i7以上的等级</p><p>内存：一定要大于1GB就比较好，否则容易有图形用户界面卡顿的现象</p><p>网卡：普通的以太网卡就好</p><p>显卡：使用256MB以上内存的显卡（入门级的都在这个容量以上了）</p><p>硬盘：越大越好，最好有60GB</p><h2 id="3、各硬件设备在Linux中的文件名"><a href="#3、各硬件设备在Linux中的文件名" class="headerlink" title="3、各硬件设备在Linux中的文件名"></a>3、各硬件设备在Linux中的文件名</h2><p><strong>重申：在Linux系统中，每个设备都被当成一个文件来对待</strong></p><table><thead><tr><th align="left">设备</th><th align="left">设备在Linux中的文件名</th></tr></thead><tbody><tr><td align="left">SCISI、SATA、USB驱动器</td><td align="left">/dev/sd[a-p]</td></tr><tr><td align="left">U盘</td><td align="left">/dev/sd[a-p]（与SATA相同）</td></tr><tr><td align="left">Virtio接口</td><td align="left">/dev/vd[a-p]（用于虚拟机内）</td></tr><tr><td align="left">软盘驱动器</td><td align="left">/dev/fd[0-7]</td></tr><tr><td align="left">打印机</td><td align="left">/dev/lp[0-2]（25针打印机）</td></tr><tr><td align="left"></td><td align="left">/dev/usb/lp[0-15]（USB接口）</td></tr><tr><td align="left">鼠标</td><td align="left">/dev/input/mouse[0-15]（通用）</td></tr><tr><td align="left"></td><td align="left">/dev/psaux（PS/2接口）</td></tr><tr><td align="left"></td><td align="left">/dev/mouse（当前鼠标）</td></tr><tr><td align="left">CD-ROM、DVD-ROM</td><td align="left">/dev/scd[0-1]（通用）</td></tr><tr><td align="left"></td><td align="left">/dev/sr[0-1]（通用，CentOS较常见）</td></tr><tr><td align="left"></td><td align="left">/dev/cdrom（当前CD-ROM）</td></tr><tr><td align="left">磁带机</td><td align="left">/dev/ht0（IDE接口）</td></tr><tr><td align="left"></td><td align="left">/dev/st0（SATA/SCSI接口）</td></tr><tr><td align="left"></td><td align="left">/dev/tape（当前磁带）</td></tr><tr><td align="left">IDE磁盘驱动器</td><td align="left">/dev/hd[a-d]（旧式系统才有）</td></tr></tbody></table><h2 id="4、使用虚拟机学习"><a href="#4、使用虚拟机学习" class="headerlink" title="4、使用虚拟机学习"></a>4、使用虚拟机学习</h2><p>如果用windows系统，建议使用VirtualBox这个软件，官网<a href="https://www.virtualbox.org/">https://www.virtualbox.org</a></p><p>教程<a href="http://www.virtualbox.org/manual/ch01.html">http://www.virtualbox.org/manual/ch01.html</a></p><p>如果原本用Linux系统，例如Fedora或Ubuntu等系列，建议使用原本系统内就有的虚拟系统管理器</p><h1 id="二、磁盘分区"><a href="#二、磁盘分区" class="headerlink" title="二、磁盘分区"></a>二、磁盘分区</h1><h2 id="1、磁盘连接方式与设备文件名的关系"><a href="#1、磁盘连接方式与设备文件名的关系" class="headerlink" title="1、磁盘连接方式与设备文件名的关系"></a>1、磁盘连接方式与设备文件名的关系</h2><p>设备文件名需要根据Linux内核检测到磁盘的顺序命名</p><p>我们知道磁盘主要由碟片，机械手臂，磁头与主轴马达所组成，而数据的读写其实是在碟片上面。碟片上面又可细分出扇区与磁道两种单位，其中扇区的物理大小设计有两种，分别是512字节与4k字节。</p><p>第一个扇区特别重要，因为它记录了整块磁盘的重要信息。早期磁盘第一个扇区里面含有的重要信息我们称为MBR格式，后来又多了一个新的磁盘分区格式，称为GPT</p><h2 id="2、MBR与GPT分区表"><a href="#2、MBR与GPT分区表" class="headerlink" title="2、MBR与GPT分区表"></a>2、MBR与GPT分区表</h2><h3 id="MBR分区表格式与限制"><a href="#MBR分区表格式与限制" class="headerlink" title="MBR分区表格式与限制"></a>MBR分区表格式与限制</h3><p>第一个扇区的512个字节通常有这两个东西：</p><p>主引导记录：可以安装启动引导程序的地方，有446字节</p><p>分区表：记录整块磁盘分区的状态，有64字节</p><p>由于分区表所在区块仅有64字节容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启动与结束的柱面号码</p><p>我们假设磁盘只有400个柱面，划分为四个分区，可如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/1figure1.jpeg">)</p><p>我们有几个重点信息：</p><ul><li>其实所谓的分区只是针对那个64字节的分区表进行设置而已</li><li>硬盘默认的分区表仅能写入四组分区信息</li><li>这四组划分信息我们称为主要或扩展分区</li><li>分区的最小单位为柱面</li></ul><p>分区由数据的安全性和系统的性能考虑来决定的</p><p>我们可以利用额外的扇区来记录更多的信息，即如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/1figure2.jpeg"></p><p>其中，P1为主要分区，P2为扩展分区。注意：扩展分区的目的是使用额外的扇区来记录分区信息，扩展分区本身并不能被拿来格式化</p><p>如图右下方那个区块继续划分出五个分区，这五个由扩展分区继续切出来的分区，被称为逻辑分区</p><p><em>因为前四个号码都是保留给主要或者扩展分区用的，所以逻辑分区的名称号码就从5号开始</em></p><p>MBR主要分区、扩展分区与逻辑分区的特性我们做个简单的定义</p><ul><li>主要分区与扩展分区最多可以有四个（磁盘的限制）</li><li>扩展分区最多只能有1个（操作系统的限制）</li><li>逻辑分区是由扩展分区持续划分出来的分区</li><li>能够被格式化后作为数据存取的分区是主要分区与逻辑分区，扩展分区无法格式化</li><li>逻辑分区的数量依操作系统的而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区</li></ul><h3 id="GPT磁盘分区表的出现"><a href="#GPT磁盘分区表的出现" class="headerlink" title="GPT磁盘分区表的出现"></a>GPT磁盘分区表的出现</h3><p>在过去MBR分区表的限制中经常可以发现如下的问题</p><ul><li>操作系统无法使用2.2TB以上的磁盘容量</li><li>MBR仅有一个区块，若被破坏后，经常无法或很难恢复</li><li>MBR内的存放启动引导程序的区块仅446字节，无法存储较多的程序代码</li></ul><p>因此出现了GPT磁盘分区表，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/1figure3.jpg"></p><p>GPT使用了34个LBA区块来记录分区信息，除了前面34个LBA外，整个磁盘的最后34个LBA也拿来作为另一个备份</p><p>解释如下：</p><p>LBA0（MBR兼容区块）：存储了第一阶段的启动引导程序，以及放入了一块特殊标志符，用来表示此磁盘为GPT格式</p><p>LBA1（GPT表头记录）：记录了分区表本身的位置与大小，记录了备份用的GPT分区放置的位置，同时放置了分区表的检验码（CRC32）</p><p>LBA2-33（实际记录分区信息化）：每个LBA都可以记录4组分区信息，所以在默认的情况下，总共可以有4*32=128组分区记录，GPT还在每组记录中提供了64位来记载开始/结束的扇区号码</p><p>现在GPT分区默认可以提供多达128组记录，而在Linux本身的Linux本身的内核设备记录中，针对单一磁盘来说，虽然过去最多只能到达15个分区，不过由于Linux内核通过udev等方式的处理，现在Linux也已经没有这个限制了。此外，GPT分区已经没有所谓的主、扩展、逻辑分区的概念，既然每组记录都可以独立存在，当然每个都可以视为是主要分区，每一个分区都可以拿来格式化使用。</p><h2 id="3、启动流程中的BIOS与UEFI启动检测程序"><a href="#3、启动流程中的BIOS与UEFI启动检测程序" class="headerlink" title="3、启动流程中的BIOS与UEFI启动检测程序"></a>3、启动流程中的BIOS与UEFI启动检测程序</h2><h3 id="BIOS搭配MBR-GPT的启动流程"><a href="#BIOS搭配MBR-GPT的启动流程" class="headerlink" title="BIOS搭配MBR/GPT的启动流程"></a>BIOS搭配MBR/GPT的启动流程</h3><ol><li>BIOS：启动主动执行的固件，会认识第一个可启动的设备</li><li>MBR：第一个可启动设备的第一个扇区内的主引导记录块，内含启动引导代码</li><li>启动引导程序：一个可读取内核文件来执行的软件</li><li>内核文件：开始启动操作系统</li></ol><p>如果启动引导程序支持GPT，那么使用BIOS同样可以读取到正确的操作系统内核；如果启动引导程序不懂GPT，如Windows XP的环境，就无法读取内核文件，就无法启动操作系统</p><p>Boot loader是操作系统安装在MBR上面的一个软件，主要任务有：</p><ul><li>提供选项：用户可以选择不同的启动选项，这也是多重引导的重要功能</li><li>加载内核文件：直接指向可使用的程序区段来启动操作系统</li><li>转交其他启动引导程序：将启动管理功能转交给其他启动引导程序负责</li></ul><p>启动引导程序除了可以安装在MBR之外，还可以安装在每个分区的启动扇区，这才造就了“<strong>多重引导</strong>”的功能，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/1figure4.png"></p><p>我们可以做个总结：</p><ul><li>每个分区都有自己的启动扇区</li><li>图中的系统分区为第一及第二分区</li><li>实际可启动的内核文件是放置到各分区中的</li><li>启动引导程序只会认识自己的系统分区内的可启动的内核文件，以及其他启动引导程序而已</li><li>启动引导程序可直接指向或是间接将管理权转交给另一个管理程序</li></ul><p>如果要安装多重引导，最好先安装Windows再安装Linux，否则原本在MBR内的Linux的启动程序就会被覆盖，使得MBR的启动引导程序就只会有Windows选项，而不会有Linux选项</p><h3 id="UEFI-BIOS搭配GPT启动的流程"><a href="#UEFI-BIOS搭配GPT启动的流程" class="headerlink" title="UEFI BIOS搭配GPT启动的流程"></a>UEFI BIOS搭配GPT启动的流程</h3><p>我们知道GPT可以提供64位的寻址，然后也能够使用较大的区块来处理启动引导程序，但是BIOS其实不懂GPT。还得要通过GPT提供兼容模式才能够读写这个磁盘设备，而且BIOS仅是16位的程序，在与现阶段的新的操作系统接轨方面有点弱。因此，就诞生了UEFI这个统一可扩展固件接口</p><p><em>UEFI也称UEFI BIOS，用C语言编写</em></p><p>传统BIOS与UEFI的差异：</p><table><thead><tr><th>比较项目</th><th>传统BIOS</th><th>UEFI</th></tr></thead><tbody><tr><td>使用程序语言</td><td>汇编语言</td><td>C语言</td></tr><tr><td>硬件资源控制</td><td>使用中断（IRQ）管理</td><td>使用驱动程序与协议</td></tr><tr><td></td><td>不可变的内存存取</td><td></td></tr><tr><td></td><td>不可变的输入/输出存取</td><td></td></tr><tr><td>处理器运行环境</td><td>16位</td><td>CPU保护模式</td></tr><tr><td>扩充方式</td><td>通过IRQ连接</td><td>直接加载驱动程序</td></tr><tr><td>第三方厂商支持</td><td>较差</td><td>较佳且可支持多平台</td></tr><tr><td>图形能力</td><td>较差</td><td>较佳</td></tr><tr><td>内置简化操作系统环境</td><td>不支持</td><td>支持</td></tr></tbody></table><p>UEFI当初在开发的时候，就制定了一些规则在里面，包括硬件资源使用轮询的方式来管理，与BIOS直接使用CPU以中断的方式来管理比较，这种轮询的效率稍微低一些</p><p>UEFI加入了一个所谓的安全启动功能，这个功能代表着即将启动的操作系统必须要被UEFI验证，否则就无法启动。在某些时刻，你可能要将secure boot功能关闭，才能够顺利进入Linux</p><p>虽然UEFI可以直接获取GPT的分区表，不过最好依旧拥有BIOS boot的分区支持</p><p>同时，为了与Windows兼容，并且提供其他第三方厂商所使用的UEFI应用程序存储的空间，你必须要格式化一个FAT格式的文件系统分区，大约提供512MB到1GB左右的大小，以让其他UEFI执行较为方便</p><h2 id="4、Linux安装模式下，磁盘分区的选择"><a href="#4、Linux安装模式下，磁盘分区的选择" class="headerlink" title="4、Linux安装模式下，磁盘分区的选择"></a>4、Linux安装模式下，磁盘分区的选择</h2><h3 id="目录树结构"><a href="#目录树结构" class="headerlink" title="目录树结构"></a>目录树结构</h3><p>目录树结构是以根目录为主，然后向下呈现为分支状的目录结构的一种文件结构，所以整个目录树架构最重要的就是那个根目录，这个根目录的表示方法为一条斜线“/”，所有的文件都与目录树有关</p><h3 id="文件系统与目录树的关系（挂载）"><a href="#文件系统与目录树的关系（挂载）" class="headerlink" title="文件系统与目录树的关系（挂载）"></a>文件系统与目录树的关系（挂载）</h3><p>所谓的“挂载”就是利用一个目录当成进入点，将磁盘分区的数据放置在该目录下；也就是说进入该目录就可以读取该分区的意思</p><h3 id="发行版安装时，挂载点与磁盘分区的规划"><a href="#发行版安装时，挂载点与磁盘分区的规划" class="headerlink" title="发行版安装时，挂载点与磁盘分区的规划"></a>发行版安装时，挂载点与磁盘分区的规划</h3><p>强烈建议使用“自定义安装”这个安装模式</p><p>A：初次接触Linux：只要划分“/“及”交换分区“即可</p><p>B：建议分区的方法：预备一个备用的剩余磁盘容量</p><h1 id="三、安装Linux前的规划"><a href="#三、安装Linux前的规划" class="headerlink" title="三、安装Linux前的规划"></a>三、安装Linux前的规划</h1><h2 id="1、选择合适的Linux的发行版"><a href="#1、选择合适的Linux的发行版" class="headerlink" title="1、选择合适的Linux的发行版"></a>1、选择合适的Linux的发行版</h2><p>CentOS官方网站：<a href="http://mirror.centos.org/centos/7/isos/">http://mirror.centos.org/centos/7/isos/</a></p><p>中科大镜像站：<a href="http://centos.ustc.edu.cn/centos/7/isos/">http://centos.ustc.edu.cn/centos/7/isos/</a></p><p>清华大学镜像站：<a href="http://mirrors.tuna.tsinghua.edu.cn/centos/7/isos">http://mirrors.tuna.tsinghua.edu.cn/centos/7/isos</a></p><p>必须将它以“镜像文件格式”刻录成CD或DVD才行</p><h2 id="2、主机的规划服务与硬件关系"><a href="#2、主机的规划服务与硬件关系" class="headerlink" title="2、主机的规划服务与硬件关系"></a>2、主机的规划服务与硬件关系</h2><ul><li>NAT（完成IP分享器的功能）</li><li>SAMBA（加入Windows网络邻居）</li><li>Mail（邮件服务器）</li><li>Web（WWW服务器）</li><li>DHCP（提供客户端自动获取IP的功能）</li><li>FTP</li></ul><h2 id="3、主机硬盘的主要规划"><a href="#3、主机硬盘的主要规划" class="headerlink" title="3、主机硬盘的主要规划"></a>3、主机硬盘的主要规划</h2><h3 id="最简单的分区方法"><a href="#最简单的分区方法" class="headerlink" title="最简单的分区方法"></a>最简单的分区方法</h3><p>仅划分出根目录与内存交换分区（/与swap），再预留一些剩余的磁盘空间以供后续的练习之用</p><h3 id="稍微麻烦的方法"><a href="#稍微麻烦的方法" class="headerlink" title="稍微麻烦的方法"></a>稍微麻烦的方法</h3><p>根据用途去分析，如：</p><ul><li>/boot</li><li>/</li><li>/home</li><li>/var</li><li>swap</li></ul><p>特别注意您的服务种类，然后才进行硬盘的规划</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux 电脑硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸟哥私房菜学习（二）</title>
      <link href="/2021/08087299.html"/>
      <url>/2021/08087299.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux是什么"><a href="#一、Linux是什么" class="headerlink" title="一、Linux是什么"></a>一、Linux是什么</h1><p>Linux是个<strong>操作系统</strong></p><p>如果能够参考硬件的功能函数并以此修改你的操作系统程序代码，那经过改版后的操作系统就能够在另一个硬件平台上运行，这个过程我们通常被称为“<strong>软件移植</strong>”</p><p>Linux提供了一个操作系统中最底层的硬件控制与资源管理的完整结构，这个架构是继承了UNIX良好的传统而来，所以相当的稳定且功能强大</p><h1 id="二、Linux的背景和历史"><a href="#二、Linux的背景和历史" class="headerlink" title="二、Linux的背景和历史"></a>二、Linux的背景和历史</h1><p>早期计算机输入设备只有读卡机，输出设备只有打印机，用户也无法与操作系统互动（<strong>批处理型操作系统</strong>）</p><p>20世纪60年代初期MIT发展了<strong>兼容分时系统</strong>，它可以让大型主机通过多个终端以连接进入主机，利用主机的资源进行运算工作</p><p>在1965前后，Bell实验室，MIT，通用电气公司（GE）共同发起了<strong>Multics计划</strong></p><p>1969年，Ken Thompson用汇编语言写了一组内核程序，同时包括一些内核工具程序，以及一个小小的文件系统，这个系统就是<strong>UNIX的原型</strong>，称为Unics</p><p>文件系统有两个重要概念：</p><p>1、所有的程序或系统设备都是文件</p><p>2、不管程序本身还是附属文件，所写的程序只有一个目标，且要有效的完成目标</p><p>1973年，Ritchie等人用c语言写出<strong>第一版正式UNIX内核</strong>，UNIX正式诞生</p><p>1977年，伯克利大学的Bill Joy在取得了UNIX的内源代码后，着手修改成适合自己机器的版本，并且同时增加了很多工具软件和编译器，最终命名为<strong>BSD</strong>（Berkeley Software Distribution），BSD是UNIX很重要的一个分支</p><p>由于操作系统的内核必须要跟硬件配合，与提供及控制硬件的资源进行良好的工作，所以早先每一个计算机公司都要为自己的硬件开发出合适的UNIX系统，早先的UNIX只能和服务器或是大型工作站划上等号。</p><p>1979年，AT&amp;T推出了<strong>System V架构和版权说明</strong>，情况有所改善</p><p>1984年，Tanenbaum教授编写了<strong>Minix</strong>这个UNIX-like的内核程序，完全没有参照UNIX的内核源代码，并且强调Minix必须能够与UNIX兼容，该程序可以移植到x86上面</p><p>1984年，斯托曼发起<strong>GNU计划</strong>，目的是：建立一个自由，开放的UNIX操作系统</p><p>同时，他借着<strong>Emacs</strong>（一种程序编辑器，可以在用户编写程序的过程中就进行语法的检验）以磁带的方式出售，赚的钱成立了自由软件基金会，借此最终完成了<strong>gcc</strong>编辑器，此外，还编写了<strong>C函数库</strong>，可以被用来运行操作系统的基本接口<strong>Bash shell</strong>,都在1990年左右完成</p><p>1985年，为了避免GNU所开发的自由软件被其他人利用成为专利软件，所以与律师草拟了有名的<strong>通用公共许可证</strong>（General Public License,<strong>GPL</strong>）</p><p>鉴于图形用户接口（GUI）的需求日益高涨，1984年MIT与第三方发表了<strong>X window System</strong>，在1988年成立了非营利性组织<strong>XFree86</strong>（X Window System +Free +x86）</p><h1 id="三、托瓦兹与LInux的发展"><a href="#三、托瓦兹与LInux的发展" class="headerlink" title="三、托瓦兹与LInux的发展"></a>三、托瓦兹与LInux的发展</h1><p>托瓦兹拿到Minux，安装到了386计算机上，通过GNU计划提供的bash以及gcc编译器等自由软件，顺利的编写了能与386紧紧结合在一起的内核程序，同时将内核程序发布到了网络上，希望得到更多人的建议与反馈</p><p>为了让所有的软件都可以在Linux上执行，托瓦兹参考了标准的<strong>POSIX规范</strong>，来修改Linux</p><p><em>POSIX是可移植操作系统接口的缩写，重点在于规范内核与应用程序之间的接口，这是美国电器与电子工程师学会（IEEE）所发布的一项标准</em></p><h2 id="Linux虚拟团队的产生和发展"><a href="#Linux虚拟团队的产生和发展" class="headerlink" title="Linux虚拟团队的产生和发展"></a>Linux虚拟团队的产生和发展</h2><p>1、单个人维护阶段</p><p>2、广大黑客志愿者加入阶段</p><p>3、内核功能详细分工与发展阶段</p><h2 id="Linux的内核版本"><a href="#Linux的内核版本" class="headerlink" title="Linux的内核版本"></a>Linux的内核版本</h2><p>3.10.0-123.e17.x86-64</p><p>主版本.次版本.发布版本-修改版本</p><p>2.6x版本以前：主次版本为<strong>奇数：开发中版本</strong>，主次版本为<strong>偶数：稳定版本</strong></p><p>3.0开始：主线版本，长期维护版本</p><h2 id="Linux发行版本"><a href="#Linux发行版本" class="headerlink" title="Linux发行版本"></a>Linux发行版本</h2><p>Linux是一个操作系统最底层的内核及其提供的内核工具，是GNU GPL授权模式</p><p>“<strong>Linux +各种软件</strong>”就是一个相当完整的操作系统</p><p>为了让用户能够接触到Linux，很多商业公司或非营利团体，就将Linux内核及其工具与可运行的软件整合起来，加上自己具有创意的工具程序，这个工具程序可以让用户以CD/DVD或通过网络直接安装、管理Linux系统。这个“<strong>内核+软件+工具+可完全安装程序</strong>“的东西，我们称之为Linux distribution，一般中文翻译为<strong>Linux发行版</strong>，或Linux发布商套件等。</p><p>各大Linux发行版的主要异同：支持标准</p><h1 id="四、Linux当前角色"><a href="#四、Linux当前角色" class="headerlink" title="四、Linux当前角色"></a>四、Linux当前角色</h1><h2 id="企业环境的使用"><a href="#企业环境的使用" class="headerlink" title="企业环境的使用"></a>企业环境的使用</h2><h2 id="个人环境的使用"><a href="#个人环境的使用" class="headerlink" title="个人环境的使用"></a>个人环境的使用</h2><p>桌面计算机</p><p>手持系统（PDA，手机）：Android就是Linux内核的分支，只是专门用来针对手机或者平板这类的ARM机器所设计的</p><p>嵌入式系统</p><h2 id="云端"><a href="#云端" class="headerlink" title="云端"></a>云端</h2><p>云程序</p><p><strong>虚拟化</strong>指的是：在一台物理主机上面模拟出多个逻辑上完全独立的硬件，这个假的虚拟出来的硬件主机，可以用来安装一台逻辑上完全独立的操作系统</p><p>终端设备</p><h1 id="五、Linux该如何学习"><a href="#五、Linux该如何学习" class="headerlink" title="五、Linux该如何学习"></a>五、Linux该如何学习</h1><p>1、计算机概论与硬件相关知识</p><p>2、先从Linux的安装与命令开始学起</p><p>3、Linux操作系统的基础技能</p><p>4、务必学会vi文本编辑器</p><p>5、shell（命令行模式）与shell脚本的学习</p><p>6、一定要学会软件管理</p><p>7、网络基础的建立</p><p>8、网站的建立</p><hr><p>参考网站：</p><p>鸟哥网站：<a href="http://linux.vbird.org/Searching.php">http://linux.vbird.org/Searching.php</a></p><p>酷学院讨论区：<a href="http://phorum.study-area.org/">http://phorum.study-area.org</a></p><p>鸟哥的私房菜馆讨论区：<a href="http://phorum.vbird.org/">http://phorum.vbird.org</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux 内核 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鸟哥私房菜学习（一）</title>
      <link href="/2021/080636089.html"/>
      <url>/2021/080636089.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、电脑综述"><a href="#一、电脑综述" class="headerlink" title="一、电脑综述"></a>一、电脑综述</h1><h2 id="1、电脑硬件的五大单元"><a href="#1、电脑硬件的五大单元" class="headerlink" title="1、电脑硬件的五大单元"></a>1、电脑硬件的五大单元</h2><p><strong>输入单元，输出单元，CPU内部的控制单元，算术逻辑单元，内存</strong></p><p>CPU：一个具有特定功能的芯片，里面含有指令集。</p><p>算术逻辑单元负责程序运算和逻辑判断，控制单元协调各周边组件与各单元之间的工作</p><p>CPU的数据都是从内存来，处理后先写回内存。</p><h2 id="2、CPU的架构"><a href="#2、CPU的架构" class="headerlink" title="2、CPU的架构"></a>2、CPU的架构</h2><p>​    <strong>精简指令集（RISC）</strong>：操作简单，指令性能较佳，如IBM公司的Power Architecture（包括PowerPC）系列与ARM公司的ARM CPU系列</p><p>​    <em>ARM架构是世界上使用范围最广的CPU</em></p><p>​    <strong>复杂指令集（CISC）</strong>：指令数目多且复杂，如AMD，Intel，VIA，等x86架构的CPU</p><p><em>为何个人电脑常被称为x86架构电脑？</em></p><p><em>因为最早的那块Intel研发出来的CPU代号称为8086，够来依此架构又开发出80286,80386等，因此这种架构的CPU就被称为x86架构了</em></p><p>后来AMD依此架构修改新一代的CPU为64位，为了区别两者的差异，因此64位的个人电脑CPU又被统称为x86-64架构</p><p><em>位（bit），指的是CPU一次读取数据的最大量，64位CPU一次读取64位的数据</em></p><p>新的x86的CPU大多含有很先进的指令集，这些指令集可以加速多媒体程序的运行，也能够增强虚拟化的性能，而且某些指令集更能够增加能源利用效率，让CPU耗电量降低</p><h2 id="3、其他单元的设备"><a href="#3、其他单元的设备" class="headerlink" title="3、其他单元的设备"></a>3、其他单元的设备</h2><p>系统单元：网卡，磁盘阵列卡，显卡等</p><p>存储单元：内存（RAM），辅助内存（硬盘，软盘，光盘，磁带）等</p><p>输入输出设备：键盘鼠标，体感设备；打印机，扬声器，投影仪</p><h1 id="二、个人电脑架构与相关设备组件"><a href="#二、个人电脑架构与相关设备组件" class="headerlink" title="二、个人电脑架构与相关设备组件"></a>二、个人电脑架构与相关设备组件</h1><p>早期芯片组通常分为两个网桥来控制各组件的通信，分别是：</p><p>（1）北桥，负责连接速度较快的CPU，内存与显卡等组件</p><p>（2）南桥，负责连接速度较慢的设备接口，包括硬盘，USB接口，网卡等</p><p>目前主流架构大多将北桥的内存控制器整合到了CPU当中</p><h2 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h2><p>目前主流的CPU大多都是双核以上的架构，，原本的单内核CPU仅有一个运算单元，所谓的多内核则是在一块CPU封装当中嵌入了两个以上的运算内核</p><p>不同的CPU大多具有不同型号的针脚，能够搭配的主板芯片组也不同</p><p>CPU的频率就是CPU每秒钟可以进行的工作次数</p><p>外频指的是CPU与外部组件进行数据传输时的速度，倍频则是CPU内部用来加速工作性能的一个倍数，两者相乘才是CPU的频率速度</p><p>超频是指将CPU的倍频或者外频通过主板提供的设置功能更改为较高频率的一种方式</p><p><strong>超线程技术</strong>（HT）：在每一个CPU内部将重要的寄存器分为两组，而让程序分别使用者两组寄存器。</p><h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>个人电脑的内存主要组件为动态随机存取内存（DRAM）/挥发性内存，分为SDRAM与DDR SDRAM两种，DDR是所谓的双倍数据传输速度，可以在一个工作周期中进行两次数据的传输</p><p><strong>多通道设计</strong>：传统的总线位宽一般大约仅有64位，为了加大这个位宽，芯片组厂商就将两个内存集合在一起，如果一根内存可以达到64位，两根内存就可以达到128位，这就是双通道的设计理念。</p><p><strong>静态随机存取内存（SRAM）</strong>：SRAM在设计上使用的晶体管数量较多，价格较高，不易做成大容量，因此可以做成<strong>二级缓存</strong>（L2 Cache）</p><p>主板上面如果有内置的网卡或显卡时，该功能是否要启动与该功能的各项参数，是被记录到主板上面的一个叫<strong>CMOS</strong>的芯片中</p><p>CMOS内的数据如何读取与更新呢，开机时按下DEL键可以进入BIOS界面</p><p><strong>BIOS</strong>是一个程序，这个程序是写死在主板上面的一个存储芯片中，这个存储芯片在没有通电时也能够记录数据，这就是<strong>只读存储器（ROM）</strong></p><h2 id="3、显卡"><a href="#3、显卡" class="headerlink" title="3、显卡"></a>3、显卡</h2><p>显卡上会有集成内存被称为显存，这个显存容量将会影响屏幕分辨率与颜色深度</p><p>显卡的规格从早期的PCI升级到AGP，近期AGP又被PCI-Eepress（PCLe）取代</p><p>PCle使用的是类似管道的概念来处理</p><h2 id="4、硬盘和存储设备"><a href="#4、硬盘和存储设备" class="headerlink" title="4、硬盘和存储设备"></a>4、硬盘和存储设备</h2><p>硬盘由许许多多的圆形碟片，机械手臂，磁头与主轴马达所组成</p><p>数据写在具有磁性物质的碟片上边，读写主要是通过在机械手臂上的磁头完成，实际运行时，主轴马达让碟片转动，然后机械手臂可伸展让磁头在碟片上面进行读写的操作。</p><p>在类似碟片同心圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的磁头去读写，这个小区块就是磁盘的最小物理存储单位，称之为<strong>扇区</strong>，同一个同心圆的扇区组合成的圆就是所谓的<strong>磁道</strong>，所有碟片上面的同一个磁道可以组合成所谓的<strong>柱面</strong>。</p><p>默认的读写方式是从外圈开始往内写</p><p><strong>传输接口</strong>：</p><p>SATA接口，SAS接口，USB接口</p><p>（版本越高，带宽越长，速度越快）</p><p>传统<strong>机械硬盘（HDD）</strong>有个很致命的问题，就是需要驱动马达去转动碟片，这会造成很严重的磁盘读取延迟。</p><p><strong>固态硬盘（SSD）</strong>：运用闪存可以直接读写的特性，没数据延迟，快速，省电</p><p><strong>每秒读写操作次数（IOPS）</strong>：数值越大，可操作次数越高，性能越好。</p><h2 id="5、扩展卡与接口"><a href="#5、扩展卡与接口" class="headerlink" title="5、扩展卡与接口"></a>5、扩展卡与接口</h2><p>几乎所有的卡都以PCle设计</p><p>多通道卡可以安装到少通道插槽</p><h2 id="6、主板"><a href="#6、主板" class="headerlink" title="6、主板"></a>6、主板</h2><p><strong>DMI2.0总线</strong>：CPU与南桥的通信管道</p><p><strong>I/O地址</strong>是各设备的门牌号码，<strong>IRQ</strong>是各个门牌连接到邮件中心（CPU）的专门路径</p><p>重提：</p><p><strong>CMOS</strong>主要功能为记录面板上的重要参数，包括系统时间，CPU电压与频率，各项设备的I/O地址与IRQ等，由于这些数据的记录要用电，因此主板上面才有电池</p><p><strong>BIOS</strong>是写入到主板上某一刻flash或EEPROM的程序，它可以在计算机启动的时候执行，以加载CMOS的参数，并尝试调用存储设备中的引导程序，进一步进入到操作系统中</p><p>连接外置设备的接口：</p><p>PS/2接口：原本常见额键盘和鼠标接口，越来越被USB取代</p><p>USB接口</p><p>声音输入，输出与麦克风</p><p>RJ-45网络口：有内置网络芯片会出现</p><p>HDMI：有内置显示芯片的话可能会提供，可以同时传输声音和影像</p><h2 id="7、主机电源"><a href="#7、主机电源" class="headerlink" title="7、主机电源"></a>7、主机电源</h2><p>能量转换率：输出功率/输入功率</p><h1 id="三、数据表示方式"><a href="#三、数据表示方式" class="headerlink" title="三、数据表示方式"></a>三、数据表示方式</h1><h2 id="1、数字系统"><a href="#1、数字系统" class="headerlink" title="1、数字系统"></a>1、数字系统</h2><p>二级制</p><h2 id="2、字符编码系统"><a href="#2、字符编码系统" class="headerlink" title="2、字符编码系统"></a>2、字符编码系统</h2><p>常见的英文编码表为ASCII系统</p><p>Unicode/UTF-8/万国码系统</p><h1 id="四、软件程序运行"><a href="#四、软件程序运行" class="headerlink" title="四、软件程序运行"></a>四、软件程序运行</h1><h2 id="1、机器语言程序与编译型程序"><a href="#1、机器语言程序与编译型程序" class="headerlink" title="1、机器语言程序与编译型程序"></a>1、机器语言程序与编译型程序</h2><p>需要了解机器语言</p><p>需要了解所有硬件的相关功能函数</p><p>程序不具有可移植性</p><p>程序具有专一性</p><h2 id="2、操作系统"><a href="#2、操作系统" class="headerlink" title="2、操作系统"></a>2、操作系统</h2><p>操作系统（OS）其实也是一组程序，这组程序的重点在于管理电脑的所有活动以及驱动系统中的所有硬件</p><p>内核主要在管理硬件与提供相关的功能</p><p>内核程序放置到内存当中的区块是受保护的，并且启动后就一直常驻在内存当中</p><p>操作系统会提供一套应用程序编程接口<strong>（API）（即系统调用层）</strong>给程序员来开发软件，工程师只要遵守API就很容易开发软件了</p><p>关系即：（应用程序（系统调用（内核（硬件））））<em>系统调用和内核统称为操作系统</em></p><p><strong>内核功能</strong>：系统调用接口、进程管理、内存管理、文件系统管理、设备驱动</p><p>驱动程序是操作系统中相当重要的一环</p><p>tips:</p><p>（1）操作系统必须能驱动硬件，如此应用程序才能够使用该硬件功能</p><p>（2）一般来说，操作系统会提供API，让开发商编写他们的驱动程序</p><p>（3）要使用新硬件功能，必须要安装厂商提供的驱动程序才行</p><p>（4）驱动程序由厂商提供，与操作系统无关，但是驱动程序仍是根据操作系统而开发</p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电脑硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu的优化和美化</title>
      <link href="/2021/073127307.html"/>
      <url>/2021/073127307.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、Ubuntu的优化"><a href="#一、Ubuntu的优化" class="headerlink" title="一、Ubuntu的优化"></a>一、Ubuntu的优化</h1><h2 id="1、软件的卸载"><a href="#1、软件的卸载" class="headerlink" title="1、软件的卸载"></a>1、软件的卸载</h2><h3 id="1-1、卸载亚马逊链接"><a href="#1-1、卸载亚马逊链接" class="headerlink" title="1.1、卸载亚马逊链接"></a>1.1、卸载亚马逊链接</h3><p><code>sudo apt-get remove unity-webapps-common</code></p><h3 id="1-2、卸载libreOffice更换为WPS"><a href="#1-2、卸载libreOffice更换为WPS" class="headerlink" title="1.2、卸载libreOffice更换为WPS"></a>1.2、卸载libreOffice更换为WPS</h3><p>libreoffice是ubuntu自带的开源office软件，体验效果不好，改为wps</p><p>卸载：<code>sudo apt-get remove libreoffice-common</code></p><p>wps的安装：</p><p>1、官网<a href="https://linux.wps.cn/">https://linux.wps.cn/</a>下载最新版本，选择deb for x64</p><p>2、输入<code>sudo dpkg -i wps-office_11.1.0.10161_amd64.deb</code>（根据版本不同命令不同）</p><p>3、启动wps后显示“系统缺失字体”</p><p>/1  进入C:\Windows\Fonts将所有字体压缩到Fonts压缩包中，将压缩包拷贝到ubuntu中，解压</p><p>（直接拷贝字体可能会出错）</p><p>/2 将Fonts文件夹在终端中打开，输入 <code>sudo cp * /usr/share/fonts/wps-office</code></p><p>/3 生成字体索引信息  <code>sudo mkfontscale</code>       <code> sudo mkfontdir</code></p><p>/4 更新字体缓存 <code>sudo fc-cache</code></p><p>/5 重启wps即可</p><h3 id="1-3、谷歌浏览器，搜狗拼音，vscode的安装"><a href="#1-3、谷歌浏览器，搜狗拼音，vscode的安装" class="headerlink" title="1.3、谷歌浏览器，搜狗拼音，vscode的安装"></a>1.3、谷歌浏览器，搜狗拼音，vscode的安装</h3><p>参照上一篇文章 《在虚拟机中安装Ubuntu与基本环境的配置》</p><h2 id="2、vim配置"><a href="#2、vim配置" class="headerlink" title="2、vim配置"></a>2、vim配置</h2><p>下载安装vim  <code>sudo apt-get install vim</code></p><p>打开vim配置文件  <code>sudo vim /etc/vim/vimrc</code></p><p>添加以下代码到文件尾：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">" 显示相关  "</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"set shortmess=atI   "</span> 启动的时候不显示那个援助乌干达儿童的提示  winpos <span class="token number">5</span> <span class="token number">5</span>         <span class="token string">" 设定窗口位置  set lines=30 columns=85    "</span> 设定窗口大小  <span class="token builtin class-name">set</span> nu              <span class="token string">" 显示行号  set go=             "</span> 不要图形按钮  <span class="token string">"color asmanian2     "</span> 设置背景主题  <span class="token builtin class-name">set</span> <span class="token assign-left variable">guifont</span><span class="token operator">=</span>Courier_New:h10:cANSI   <span class="token string">" 设置字体  syntax on           "</span> 语法高亮  autocmd InsertLeave * se nocul  <span class="token string">" 用浅色高亮当前行  autocmd InsertEnter * se cul    "</span> 用浅色高亮当前行  <span class="token builtin class-name">set</span> ruler           <span class="token string">" 显示标尺  set showcmd         "</span> 输入的命令显示出来，看的清楚些  <span class="token builtin class-name">set</span> <span class="token assign-left variable">cmdheight</span><span class="token operator">=</span><span class="token number">1</span>     <span class="token string">" 命令行（在状态行下）的高度，设置为1  "</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">whichwrap</span><span class="token operator">+=</span><span class="token operator">&lt;</span>,<span class="token operator">></span>,h,l   <span class="token string">" 允许backspace和光标键跨越行边界(不建议)  set scrolloff=3     "</span> 光标移动到buffer的顶部和底部时保持3行距离  <span class="token builtin class-name">set</span> novisualbell    <span class="token string">" 不要闪烁(不明白)  set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(<span class="token entity" title="\&quot;">\"</span>%d/%m/%y\ -\ %H:%M<span class="token entity" title="\&quot;">\"</span>)&#125;   "</span>状态行显示的内容  <span class="token builtin class-name">set</span> <span class="token assign-left variable">laststatus</span><span class="token operator">=</span><span class="token number">1</span>    <span class="token string">" 启动显示状态行(1),总是显示状态行(2)  set foldenable      "</span> 允许折叠  <span class="token builtin class-name">set</span> <span class="token assign-left variable">foldmethod</span><span class="token operator">=</span>manual   <span class="token string">" 手动折叠  set background=dark "</span>背景使用黑色 <span class="token builtin class-name">set</span> nocompatible  <span class="token string">"去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限  "</span> 显示中文帮助<span class="token keyword">if</span> version <span class="token operator">>=</span> <span class="token number">603</span>    <span class="token builtin class-name">set</span> <span class="token assign-left variable">helplang</span><span class="token operator">=</span>cn    <span class="token builtin class-name">set</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span>utf-8endif<span class="token string">" 设置配色方案"</span>colorscheme murphy<span class="token string">"字体 "</span><span class="token keyword">if</span> <span class="token punctuation">(</span>has<span class="token punctuation">(</span><span class="token string">"gui_running"</span><span class="token punctuation">))</span> <span class="token string">"   set guifont=Bitstream\ Vera\ Sans\ Mono\ 10 "</span>endif <span class="token builtin class-name">set</span> <span class="token assign-left variable">fencs</span><span class="token operator">=</span>utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936<span class="token builtin class-name">set</span> <span class="token assign-left variable">termencoding</span><span class="token operator">=</span>utf-8<span class="token builtin class-name">set</span> <span class="token assign-left variable">encoding</span><span class="token operator">=</span>utf-8<span class="token builtin class-name">set</span> <span class="token assign-left variable">fileencodings</span><span class="token operator">=</span>ucs-bom,utf-8,cp936<span class="token builtin class-name">set</span> <span class="token assign-left variable">fileencoding</span><span class="token operator">=</span>utf-8<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"新文件标题<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"新建.c,.h,.sh,.java文件，自动插入文件头 autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java exec "</span>:call SetTitle<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token string">" "</span>"定义函数SetTitle，自动插入文件头 func SetTitle<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token string">"如果文件类型为.sh文件     if &amp;filetype == 'sh'         call setline(1,"</span><span class="token punctuation">\</span>#<span class="token comment">########################################################################") </span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>, <span class="token string">"\# File Name     : "</span>.expand<span class="token punctuation">(</span><span class="token string">"%"</span><span class="token punctuation">))</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+1, <span class="token string">"\# Author        : enjoy5512"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+2, <span class="token string">"\# mail          : enjoy5512@163.com"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+3, <span class="token string">"\# Created Time  : "</span>.strftime<span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">))</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+4, <span class="token string">"\#########################################################################"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+5, <span class="token string">""</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+6, <span class="token string">"\#!/bin/bash"</span><span class="token punctuation">)</span>     call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+7, <span class="token string">""</span><span class="token punctuation">)</span>    call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+8, <span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">else</span>         call setline<span class="token punctuation">(</span><span class="token number">1</span>, <span class="token string">"/*************************************************************************"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>, <span class="token string">"    > File Name       : "</span>.expand<span class="token punctuation">(</span><span class="token string">"%"</span><span class="token punctuation">))</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+1, <span class="token string">"    > Author          : enjoy5512"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+2, <span class="token string">"    > Mail            : enjoy5512@163.com "</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+3, <span class="token string">"    > Created Time    : "</span>.strftime<span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">))</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+4, <span class="token string">" ************************************************************************/"</span><span class="token punctuation">)</span>         call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+5, <span class="token string">""</span><span class="token punctuation">)</span>    endif    <span class="token keyword">if</span> <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">'cpp'</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+6, <span class="token string">"#include&lt;iostream>"</span><span class="token punctuation">)</span>    call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+7, <span class="token string">""</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+8, <span class="token string">"using namespace std;"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+9, <span class="token string">""</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+10, <span class="token string">"int main(int argc,char *argv[])"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+11, <span class="token string">"&#123;"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+12, <span class="token string">"     "</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+13, <span class="token string">"    return 0;"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+14, <span class="token string">"&#125;"</span><span class="token punctuation">)</span>    endif    <span class="token keyword">if</span> <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">'c'</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+6, <span class="token string">"#include&lt;stdio.h>"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+7, <span class="token string">""</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+8, <span class="token string">"int main(int argc,char *argv[])"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+9, <span class="token string">"&#123;"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+10, <span class="token string">"     "</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+11, <span class="token string">"    return 0;"</span><span class="token punctuation">)</span>        call append<span class="token punctuation">(</span>line<span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span>+12, <span class="token string">"&#125;"</span><span class="token punctuation">)</span>    autocmd BufNewFile * <span class="token number">12</span> j    endifendfunc<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">"键盘命令"</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>C，C++ 按F5编译运行map <span class="token operator">&lt;</span>F<span class="token operator"><span class="token file-descriptor important">5</span>></span> :call CompileRunGcc<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>func<span class="token operator">!</span> CompileRunGcc<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token builtin class-name">exec</span> <span class="token string">"w"</span>    <span class="token keyword">if</span> <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">'c'</span>        <span class="token builtin class-name">exec</span> <span class="token string">"!gcc % -o %&lt;"</span>        <span class="token builtin class-name">exec</span> <span class="token string">"! ./%&lt;"</span>    elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">'cpp'</span>        <span class="token builtin class-name">exec</span> <span class="token string">"!g++ % -o %&lt;"</span>        <span class="token builtin class-name">exec</span> <span class="token string">"! ./%&lt;"</span>    elseif <span class="token operator">&amp;</span>filetype <span class="token operator">==</span> <span class="token string">'sh'</span>        :<span class="token operator">!</span>./%    endifendfunc<span class="token string">"C,C++的调试map &lt;C-F5> :call Rungdb()&lt;CR>func! Rungdb()    exec "</span>w<span class="token string">"    if &amp;filetype == 'c'        exec "</span><span class="token operator">!</span>gcc % -g -o %<span class="token operator">&lt;</span><span class="token string">"        exec "</span><span class="token operator">!</span>gdb -tui ./%<span class="token operator">&lt;</span><span class="token string">"    elseif &amp;filetype == 'cpp'        exec "</span><span class="token operator">!</span>g++ % -g -o %<span class="token operator">&lt;</span><span class="token string">"        exec "</span><span class="token operator">!</span>gdb -tui ./%<span class="token operator">&lt;</span><span class="token string">"    endifendfunc"</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"实用设置<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span>"<span class="token string">""</span><span class="token string">" 设置当文件被改动时自动载入set autoread"</span> quickfix模式autocmd FileType c,cpp map <span class="token operator">&lt;</span>buffer<span class="token operator">></span> <span class="token operator">&lt;</span>leader<span class="token operator">></span><span class="token operator">&lt;</span>space<span class="token operator">></span> :w<span class="token operator">&lt;</span>cr<span class="token operator">></span>:make<span class="token operator">&lt;</span>cr<span class="token operator">></span><span class="token string">"代码补全 set completeopt=preview,menu "</span>允许插件  filetype plugin on<span class="token string">"共享剪贴板  set clipboard+=unnamed "</span>从不备份  <span class="token builtin class-name">set</span> nobackup<span class="token string">"自动保存set autowriteset ruler                   "</span> 打开状态栏标尺<span class="token builtin class-name">set</span> cursorline              <span class="token string">" 突出显示当前行set magic                   "</span> 设置魔术<span class="token builtin class-name">set</span> guioptions-<span class="token operator">=</span>T           <span class="token string">" 隐藏工具栏set guioptions-=m           "</span> 隐藏菜单栏<span class="token builtin class-name">set</span> <span class="token assign-left variable">foldcolumn</span><span class="token operator">=</span><span class="token number">0</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">foldmethod</span><span class="token operator">=</span>indent <span class="token builtin class-name">set</span> <span class="token assign-left variable">foldlevel</span><span class="token operator">=</span><span class="token number">3</span> <span class="token builtin class-name">set</span> foldenable              <span class="token string">" 开始折叠"</span> 不要使用vi的键盘模式，而是vim自己的<span class="token builtin class-name">set</span> nocompatible<span class="token string">" 语法高亮set syntax=on"</span> 去掉输入错误的提示声音<span class="token builtin class-name">set</span> noeb<span class="token string">" 在处理未保存或只读文件的时候，弹出确认set confirm"</span> 自动缩进<span class="token builtin class-name">set</span> autoindent<span class="token builtin class-name">set</span> cindent<span class="token string">" Tab键的宽度set tabstop=4"</span> 统一缩进为4<span class="token builtin class-name">set</span> <span class="token assign-left variable">softtabstop</span><span class="token operator">=</span><span class="token number">4</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">shiftwidth</span><span class="token operator">=</span><span class="token number">4</span><span class="token string">"禁止生成临时文件set nobackupset noswapfile"</span>搜索忽略大小写<span class="token builtin class-name">set</span> ignorecase<span class="token string">"搜索逐字符高亮set hlsearchset incsearch"</span>行内替换<span class="token builtin class-name">set</span> gdefault<span class="token string">"编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936"</span>语言设置<span class="token builtin class-name">set</span> <span class="token assign-left variable">langmenu</span><span class="token operator">=</span>zh_CN.UTF-8<span class="token builtin class-name">set</span> <span class="token assign-left variable">helplang</span><span class="token operator">=</span>cn<span class="token string">" 我的状态行显示的内容（包括文件类型和解码）set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(<span class="token entity" title="\&quot;">\"</span>%d/%m/%y\ -\ %H:%M<span class="token entity" title="\&quot;">\"</span>)&#125;"</span><span class="token builtin class-name">set</span> <span class="token assign-left variable">statusline</span><span class="token operator">=</span><span class="token punctuation">[</span>%F<span class="token punctuation">]</span>%y%r%m%*%<span class="token operator">=</span><span class="token punctuation">[</span>Line:%l/%L,Column:%c<span class="token punctuation">]</span><span class="token punctuation">[</span>%p%%<span class="token punctuation">]</span><span class="token string">"set statusline=\ %&lt;%F[%1*%M%*%n%R%H]%=\ %y\ %0(%&#123;&amp;fileformat&#125;\ %&#123;&amp;encoding&#125;\ %c:%l/%L%)\"</span> 总是显示状态行<span class="token builtin class-name">set</span> <span class="token assign-left variable">laststatus</span><span class="token operator">=</span><span class="token number">2</span><span class="token string">" 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2"</span> 侦测文件类型filetype on<span class="token string">" 载入文件类型插件filetype plugin on"</span> 为特定文件类型载入相关缩进文件filetype indent on<span class="token string">" 保存全局变量set viminfo+=!"</span> 在被分割的窗口间显示空白，便于阅读<span class="token builtin class-name">set</span> <span class="token assign-left variable">fillchars</span><span class="token operator">=</span>vert:<span class="token punctuation">\</span> ,stl:<span class="token punctuation">\</span> ,stlnc:<span class="token punctuation">\</span><span class="token string">" 高亮显示匹配的括号set showmatch"</span> 匹配括号高亮的时间（单位是十分之一秒）<span class="token builtin class-name">set</span> <span class="token assign-left variable">matchtime</span><span class="token operator">=</span><span class="token number">1</span><span class="token string">" 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3"</span> 为C程序提供自动缩进<span class="token builtin class-name">set</span> smartindent<span class="token string">" 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile *  setfiletype txt"</span>自动补全<span class="token string">":inoremap ( ()&lt;ESC>i"</span>:inoremap <span class="token punctuation">)</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">')'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span>:inoremap <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token operator">&lt;</span>CR<span class="token operator">></span><span class="token punctuation">&#125;</span><span class="token operator">&lt;</span>ESC<span class="token operator">></span>O:inoremap <span class="token punctuation">&#125;</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">'&#125;'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span><span class="token string">":inoremap [ []&lt;ESC>i"</span>:inoremap <span class="token punctuation">]</span> <span class="token operator">&lt;</span>c-r<span class="token operator">>=</span>ClosePair<span class="token punctuation">(</span><span class="token string">']'</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>CR<span class="token operator">></span><span class="token string">":inoremap "</span> <span class="token string">""</span><span class="token operator">&lt;</span>ESC<span class="token operator">></span>i<span class="token string">":inoremap ' ''&lt;ESC>ifunction! ClosePair(char)    if getline('.')[col('.') - 1] == a:char        return "</span><span class="token punctuation">\</span><span class="token operator">&lt;</span>Right<span class="token operator">></span><span class="token string">"    else        return a:char    endifendfunctionfiletype plugin indent on "</span>打开文件类型检测, 加了这句才可以用智能补全<span class="token builtin class-name">set</span> <span class="token assign-left variable">completeopt</span><span class="token operator">=</span>longest,menu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3、菜单栏位置"><a href="#3、菜单栏位置" class="headerlink" title="3、菜单栏位置"></a>3、菜单栏位置</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">放到底部（终端输入以下）：gsettings <span class="token builtin class-name">set</span> com.canonical.Unity.Launcher launcher-position Bottom<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">放到左侧（终端输入以下）：gsettings <span class="token builtin class-name">set</span> com.canonical.Unity.Launcher launcher-position Left<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="二、美化Ubuntu"><a href="#二、美化Ubuntu" class="headerlink" title="二、美化Ubuntu"></a>二、美化Ubuntu</h1><h2 id="1、主题"><a href="#1、主题" class="headerlink" title="1、主题"></a>1、主题</h2><h3 id="1-1、安装unity-tweak-tool"><a href="#1-1、安装unity-tweak-tool" class="headerlink" title="1.1、安装unity-tweak-tool:"></a>1.1、安装unity-tweak-tool:</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> unity-tweak-tool<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调整 Unity 桌面环境，还是推荐使用Unity Tweak Tool，这是一个非常好用的 Unity 图形化管理工具，可以修改工作区数量、热区等。</p><p>在安装后，输入unity-tweak-tool，遇到一直报错打不开的问题，解决方法：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> unity-lens-applications <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> unity-lens-files<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-、Flatabulous主题"><a href="#1-2-、Flatabulous主题" class="headerlink" title="1.2 、Flatabulous主题"></a>1.2 、Flatabulous主题</h3><p>通过源码安装时，一直报错类似于仓库没有release文件，于是放弃源码安装</p><p><em>若遇到该问题，解决方法：</em></p><p><em>1、输入命令<code>cd /etc/apt/sources.list.d</code>进入到对应的ppa目录</em></p><p><em>2、ls看到对应无法下载的list</em></p><p><em>3、通过<code>sudo rm &lt;....list&gt;</code>删除命令删除</em></p><p><em>虽然问题解决了，但是主题仍未下载成功.</em></p><p>遂采用deb格式文件下载</p><p><code>wget https://github.com/anmoljagetia/Flatabulous/releases/download/16.04.1/Flatabulous-Theme.deb</code>下载flatabulous主题</p><p><code>sudo dpkg -i Flatabulous-Theme.deb</code>安装</p><p>安装完成后，打开unity-tweak-tool软件，进入主题 ，修改为Flatabulous </p><h2 id="2、终端"><a href="#2、终端" class="headerlink" title="2、终端"></a>2、终端</h2><h3 id="2-1、安装zsh"><a href="#2-1、安装zsh" class="headerlink" title="2.1、安装zsh"></a>2.1、安装zsh</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">zsh</span>  <span class="token comment">#安装zsh</span>chsh -s /bin/zsh      <span class="token comment">#将zsh设置默认为shell</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-2、安装oh-my-zsh"><a href="#2-2、安装oh-my-zsh" class="headerlink" title="2.2、安装oh my zsh"></a>2.2、安装oh my zsh</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">git</span> <span class="token comment">#git的安装</span><span class="token function">sh</span> -c <span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> -fsSL https://gitee.com/shmhlsy/oh-my-zsh-install.sh/raw/master/install.sh<span class="token variable">)</span></span> <span class="token comment">#oh my zsh的安装</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>重启即可</p><h3 id="2-3、更换主题"><a href="#2-3、更换主题" class="headerlink" title="2.3、更换主题"></a>2.3、更换主题</h3><p>进入theme官网 <a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a>选择你想要的主题，以avit为例</p><h3 id="2-4、安装插件"><a href="#2-4、安装插件" class="headerlink" title="2.4、安装插件"></a>2.4、安装插件</h3><h4 id="zsh-syntax-highlighting"><a href="#zsh-syntax-highlighting" class="headerlink" title="zsh-syntax-highlighting"></a>zsh-syntax-highlighting</h4><p>命令行高亮插件</p><p>执行以下命令</p><p><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</code></p><h4 id="zsh-autosuggestions"><a href="#zsh-autosuggestions" class="headerlink" title="zsh-autosuggestions"></a>zsh-autosuggestions</h4><p>命令行命令键入时的历史命令建议插件</p><p>执行以下命令</p><p><code>git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></p><h4 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h4><p><code>ls -a</code>   #查看文件</p><p><code>vim .zshrc</code> #编辑.zshrc配置文件</p><p>#输入i进入编辑模式</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用的zsh 主题</span><span class="token assign-left variable">ZSH_THEME</span><span class="token operator">=</span><span class="token string">"avit"</span><span class="token comment"># 启用已安装的插件</span><span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>  <span class="token function">git</span> zsh-autosuggestions zsh-syntax-highlighting<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>#esc退出编辑模式，:wq退出vim</p><p>即更换好主题和添加好插件</p><h3 id="2-5、更换背景"><a href="#2-5、更换背景" class="headerlink" title="2.5、更换背景"></a>2.5、更换背景</h3><p>/1、<code>sudo apt-get update</code>  更新系统资源</p><p>/2、<code>sudo apt-get  install  xfce4-terminal</code>   安装xfce4终端</p><p>/3、打开xfce4终端</p><p>/4、菜单栏编辑-&gt;首选项-&gt;外观-&gt;背景图片选择你想要的壁纸  样式改为拉伸</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在虚拟机中安装Ubuntu与基本环境的配置</title>
      <link href="/2021/073036866.html"/>
      <url>/2021/073036866.html</url>
      
        <content type="html"><![CDATA[<h1 id="一、安装前的准备和基本安装"><a href="#一、安装前的准备和基本安装" class="headerlink" title="一、安装前的准备和基本安装"></a>一、安装前的准备和基本安装</h1><h2 id="1-1-安装前的准备"><a href="#1-1-安装前的准备" class="headerlink" title="1.1 安装前的准备"></a>1.1 安装前的准备</h2><p>ubuntu官网 <a href="http://cn.ubuntu.com/download/">http://cn.ubuntu.com/download/</a>下载Ubuntu最新版本</p><p>VMWare官网<a href="https://www.vmware.com/go/getworkstation-win">https://www.vmware.com/go/getworkstation-win</a>安装VMWare虚拟机软件</p><h2 id="1-2-基本安装"><a href="#1-2-基本安装" class="headerlink" title="1.2 基本安装"></a>1.2 基本安装</h2><h3 id="1、创建新的虚拟机"><a href="#1、创建新的虚拟机" class="headerlink" title="1、创建新的虚拟机"></a>1、创建新的虚拟机</h3><p>典型安装-&gt;稍后安装操作系统-&gt;Linux  Ubuntu 64位-&gt;虚拟机名称无所谓 建议位置不要放在系统盘-&gt;最大磁盘大小建议大点（选择40）</p><h3 id="2、编辑虚拟机设置"><a href="#2、编辑虚拟机设置" class="headerlink" title="2、编辑虚拟机设置"></a>2、编辑虚拟机设置</h3><p>内存：2GB -&gt; 处理器：1 -&gt;移除打印机 -&gt; CD使用ISO镜像文件，选上下载的ubuntu</p><h3 id="3、安装Ubuntu"><a href="#3、安装Ubuntu" class="headerlink" title="3、安装Ubuntu"></a>3、安装Ubuntu</h3><p>中文（简体）-&gt;   English（US）  English（US) -&gt;时区选择shanghai-&gt;名字随便写  创立密码-&gt;安装</p><p><em>以上未提及的只管下一步即可</em></p><p>若遇到Please remove the installation medium,then press ENTER: 的问题，需要关闭客户机，编辑虚拟机设置，在CD中关闭启动时连接。</p><h2 id="1-3、VMware-Tools的安装"><a href="#1-3、VMware-Tools的安装" class="headerlink" title="1.3、VMware Tools的安装"></a>1.3、VMware Tools的安装</h2><p>标准安装步骤：</p><p>菜单栏中虚拟机选项 -&gt;安装VMware Tools-&gt;复制tar文件到桌面上-&gt;提取-&gt;文件夹在终端中打开-&gt;输入sudo ./vmware-install.pl   ，之后可能会输入yes，一直回车，重启虚拟机</p><p><em>其实在这里我遇到了虚拟机选项中重新安装VMware Tools为灰色的问题，我从网上找到了解决办法，如遇到同样问题的参考csdn@缱绻的西格玛  解决“重新安装vmware-tools”灰色而无法安装的问题</em></p><h1 id="二、安装常用软件"><a href="#二、安装常用软件" class="headerlink" title="二、安装常用软件"></a>二、安装常用软件</h1><h2 id="2-1、设置服务器镜像源"><a href="#2-1、设置服务器镜像源" class="headerlink" title="2.1、设置服务器镜像源"></a>2.1、设置服务器镜像源</h2><p>原服务器是在美国，更换服务器镜像源可以使安装更新速度更快</p><p>步骤：右上角齿轮-&gt;关于-&gt;软件更新-&gt;下载自中点击其他站点-&gt;选择最佳服务器-&gt;输入密码授权-&gt;关闭后会显示可用软件的列表信息已过时-&gt;重新载入</p><h2 id="2-2、在启动栏添加终端图标"><a href="#2-2、在启动栏添加终端图标" class="headerlink" title="2.2、在启动栏添加终端图标"></a>2.2、在启动栏添加终端图标</h2><p>打开终端，在桌面终端图标处右击添加到收藏夹</p><h2 id="2-3、apt终端命令"><a href="#2-3、apt终端命令" class="headerlink" title="2.3、apt终端命令"></a>2.3、apt终端命令</h2><p>apt全程Advanced Packaging Tool，是Ubuntu下的安装包管理工具</p><p>大部分软件安装、更新、卸载 都是利用apt命令实现</p><p><code>sudo apt install #安装软件</code></p><p><code>sudo apt remove #卸载软件</code></p><p><code>sudo apt update #更新可用软件包列表</code></p><p><code>sudo apt upgrade #更新已安装的包</code></p><h2 id="2-4、python的安装"><a href="#2-4、python的安装" class="headerlink" title="2.4、python的安装"></a>2.4、python的安装</h2><p><code>sudo apt install ipython3</code></p><p><code>sudo apt install python3-pip</code></p><h2 id="2-5、deb安装格式"><a href="#2-5、deb安装格式" class="headerlink" title="2.5、deb安装格式"></a>2.5、deb安装格式</h2><p>deb 是Debian Linux的安装格式，安装deb安装包需要使用dpkg的终端命令</p><p>格式：<code>sudo dpkg -i &lt;package.deb&gt;</code></p><h3 id="1-谷歌浏览器"><a href="#1-谷歌浏览器" class="headerlink" title="(1)谷歌浏览器"></a>(1)谷歌浏览器</h3><p>1、用ubuntu自带的火狐浏览器从<a href="http://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb">http://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb</a>下载最新版本安装文件</p><p>2、从下载目录在终端中打开执行以下命令</p><p><code>sudo apt install libappindicator1 libindicator7</code></p><p><code>sudo dpkg -i google-chrome-stable_current_amd64.deb</code></p><p><code>sudo apt -f install</code></p><p>3、把谷歌浏览器加入到收藏夹中</p><h3 id="2-搜狗输入法"><a href="#2-搜狗输入法" class="headerlink" title="(2)搜狗输入法"></a>(2)搜狗输入法</h3><p>1、安装Fcitx输入框架 </p><p>执行命令 <code>sudo apt install fcitx</code></p><p>2、用Ubuntu中的浏览器登录搜狗输入法官网下载Linux版本搜狗输入法<a href="https://pinyin.sogou.com/linux/?r=pinyin">https://pinyin.sogou.com/linux/?r=pinyin</a></p><p>3、进入相应的下载目录，在终端中打开，输入命令</p><p><code>sudo dpkg -i sogoupinyin_2.4.0.3469_amd64.deb</code></p><p>（命令会根据安装版本的不同而不同，注意更改）</p><p>（安装中若出错，输入<code>sudo apt --fix-broken install</code>）</p><p>4、进入设置，区域与语言-&gt;管理已安装的语言-&gt;键盘输入法系统改为fcitx-&gt;点击应用到整个系统，重启虚拟机</p><p>5、右上角出现一个键盘标志，点击进入，选择配置当前输入法，我们可以看到搜狗输入法个人版在第二行，这就说明了已将搜狗输入法配置好（不建议将搜狗输入法放在第一位，不然按shift切换中英文时，有时输入板会出现乱码，虽然多按两下shift可以切换回正常，但是太麻烦了）</p><p><em>ctrl+空格可以切换到搜狗输入法，可以通过shift键切换中英文</em></p><h3 id="3-vscode"><a href="#3-vscode" class="headerlink" title="(3)vscode"></a>(3)vscode</h3><p>1、登录vscode官网<a href="https://code.visualstudio.com/docs/?dv=linux64_deb">https://code.visualstudio.com/docs/?dv=linux64_deb</a>下载deb安装包</p><p>2、进入安装目录，在终端打开</p><p>3、执行命令 <code>sudo dpkg -i  code_1.58.2-1626302803_amd64.deb</code>（命令会根据安装版本的不同而不同，注意更改）</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu linux vmware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo-matery博客搭建</title>
      <link href="/2021/07293783.html"/>
      <url>/2021/07293783.html</url>
      
        <content type="html"><![CDATA[<h1 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h1><p>1、有自己的github账户</p><p>没有的移步 <a href="https://github.com/">https://github.com/</a></p><p>2、安装了git工具</p><p>没有的移步csdn教程@青云ing <a href="https://blog.csdn.net/shuikanshui/article/details/118295952">https://blog.csdn.net/shuikanshui/article/details/118295952</a></p><h1 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h1><h2 id="一、nodejs的安装"><a href="#一、nodejs的安装" class="headerlink" title="一、nodejs的安装"></a>一、nodejs的安装</h2><p>hexo需要nodejs的支持，因此我们需要先安装nodejs ，进入官网 <a href="https://nodejs.org/en/">https://nodejs.org/en/</a></p><p>安装LTS版本，一直点下一步即可</p><h2 id="二、hexo-博客的搭建"><a href="#二、hexo-博客的搭建" class="headerlink" title="二、hexo 博客的搭建"></a>二、hexo 博客的搭建</h2><p>windows+R输入cmd打开命令行解释器</p><h3 id="1、cnpm的下载"><a href="#1、cnpm的下载" class="headerlink" title="1、cnpm的下载"></a>1、cnpm的下载</h3><p>由于国内的npm下载速度堪忧，因此我们用淘宝镜像的cnpm下载，</p><p>即输入 <em>npm install -g cnpm –registry.npm.taobao.org</em></p><h3 id="2、hexo博客框架的安装"><a href="#2、hexo博客框架的安装" class="headerlink" title="2、hexo博客框架的安装"></a>2、hexo博客框架的安装</h3><p>输入  <em>cnpm install -g hexo-cli</em></p><p><em>hexo -v</em> 验证安装完成</p><h3 id="3、创建blog文件"><a href="#3、创建blog文件" class="headerlink" title="3、创建blog文件"></a>3、创建blog文件</h3><p>假如在D盘建立名为blog的文件夹    输入  <em>mkdir D:\blog</em>  后边的我们搭建的所有博客的内容都是存放于blog中，因此如果你有什么不满意难以修改的，完全可以删掉blog重来</p><h3 id="4、利用git工具进行blog的搭建"><a href="#4、利用git工具进行blog的搭建" class="headerlink" title="4、利用git工具进行blog的搭建"></a>4、利用git工具进行blog的搭建</h3><p>进入blog文件夹中，右键点击Git Bash Here进入git窗口   </p><p>输入<em>hexo init</em>初始化博客</p><p><em>如果遇到问题 fatal: unable to access ‘<a href="https://github.com/hexojs/hexo-starter.git/&#39;">https://github.com/hexojs/hexo-starter.git/&#39;</a>: OpenSSL SSL_read: Connection was reset, errno 10054是因为服务器的SSL整数没有经过第三方机构的签署，可输入git config –global http.sslVerify “false”解决</em></p><p>输入<em>dir -l</em>查看生成的文件</p><p>输入<em>hexo start(s)</em> 启动博客，一般是<em>localhost:4000</em>端口</p><p>输入hexo new(n) “文章的名字”创建文章，用vscode可以打开该文章进行编辑</p><p>输入<em>hexo clean</em>清理缓存</p><p>输入<em>hexo generate(g)</em> 生成文章，再重新<em>hexo start</em>即可看到文章</p><h3 id="5、github建立存储仓库"><a href="#5、github建立存储仓库" class="headerlink" title="5、github建立存储仓库"></a>5、github建立存储仓库</h3><p>github右上角”+”号处有个New repository新建仓库，Repository name必须为 <em>用户名.github.io</em>，Description可以随意写，之后Create repository</p><h3 id="6、部署推到远端"><a href="#6、部署推到远端" class="headerlink" title="6、部署推到远端"></a>6、部署推到远端</h3><p>输入<em>cnpm install –save hexo-deployer-git</em>安装git插件</p><p>用vscode打开_config.yml文件,最底部type: 后写git，下一行写repo: “仓库地址”,再下一行写main: master，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/deploy.png"></p><p>输入git config –global user.email “你的邮箱”<br>输入git config –global user.name “你的用户名”</p><p>输入*hexo deploy(d)*部署，可能会有无法连接到远端的情况，耐心多试几次即可</p><h3 id="7、访问"><a href="#7、访问" class="headerlink" title="7、访问"></a>7、访问</h3><p>https://你的用户名.github.io即是你的博客网址</p><h2 id="三、matery博客主题的修改"><a href="#三、matery博客主题的修改" class="headerlink" title="三、matery博客主题的修改"></a>三、matery博客主题的修改</h2><p>下载matery主题压缩包，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/rumor-sourse/cdn/theme.png"></p><p>将主题包解压到themes文件夹中重新部署即可</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo,github,git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周静I LOVE YOU</title>
      <link href="/2021/07241523.html"/>
      <url>/2021/07241523.html</url>
      
        <content type="html"><![CDATA[<p>这是搭建博客的测试页面，应npy要求置顶，嘻嘻~~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/072416107.html"/>
      <url>/2021/072416107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
